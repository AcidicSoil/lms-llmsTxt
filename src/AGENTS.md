<!-- Generated by Ruler -->


<!-- Source: .ruler/file-size_and_responsibility-rule.md -->

# file size and responsibility rules

## core rules

1. One primary unit per file
   - Each file owns **one main thing**:
     - Components: one main component (existing rule).
     - Hooks: one main hook (`useXxx`).
     - Server functions: one main server function or handler group for a single route.
     - Utilities: one cohesive utility topic (e.g. `dateFormat`, `sessionSearch`, `featureFlags`).
     - Schema: one logical schema group (e.g. `session.schema.ts`).
   - Any additional exports must be:
     - Small helpers directly supporting the main unit, or
     - Type-only exports.

2. File-size limits (non-component, general case)
   - Soft target: **150–300 LOC** per file (excluding imports and types).
   - Warning zone: **> 400 LOC** → required refactor before adding new behavior.
   - Hard cap: **600 LOC**. No exceptions; split into smaller files before merging.

3. Split by concern
   - **Stateful logic, effects, orchestration → hooks/logic files**:
     - `FeatureName/FeatureName.hooks.ts`
     - `FeatureName/FeatureName.logic.ts`
   - **Pure data shaping, parsing, formatting → utility files**:
     - `FeatureName/FeatureName.utils.ts`
     - `FeatureName/FeatureName.format.ts`
   - **Types/interfaces/enums shared across files → type files**:
     - `FeatureName/FeatureName.types.ts`
   - **Route/server concerns → route/server files only**:
     - Keep HTTP handling, validation, and side effects here.
     - Push domain logic into shared `*.logic.ts` or `*.utils.ts`.

4. When to split a file (hard triggers, any file type)
   - File > **400 LOC** or diff adds > **80 LOC** to a file already > **300 LOC**.
   - File mixes **two or more** of:
     - Network/server I/O (fetch, db, server functions)
     - Business/domain logic (calculations, rules)
     - UI / presentation (components, JSX, templates)
     - Cross-cutting concerns (logging, metrics, feature flags)
   - File exports **many unrelated things**:
     - More than **5–7 public exports** with different purposes.
     - Utilities that clearly belong to different topics (e.g. date helpers + string helpers).
   - Control flow / branching is hard to scan:
     - Deeply nested conditionals or long switch statements (`> ~100 LOC`) that can be moved into dedicated helpers.

5. Structure conventions by file kind
   - **Hooks**:
     - `FeatureName/FeatureName.hooks.ts` → owns `useFeatureNameXxx` hooks.
     - No JSX, no DOM; only state, effects, and derived data.
   - **Logic / services**:
     - `FeatureName/FeatureName.logic.ts` or `FeatureName/service.ts`.
     - Pure, testable functions; no React imports.
   - **Utilities / formatting**:
     - `FeatureName/FeatureName.utils.ts`, `FeatureName/FeatureName.format.ts`.
     - Pure, side-effect-free; reusable across features.
   - **Types**:
     - `FeatureName/FeatureName.types.ts`.
     - No runtime code.
   - **Server functions / routes**:
     - One route or server function group per file.
     - Validation + wiring here; heavy domain logic pushed into `*.logic.ts`.

6. Review checklist (for any file)
   - [ ] Does this file have **one clearly named primary responsibility**?
   - [ ] Is the file within the **150–300 LOC target** and **< 400 LOC** unless it’s about to be split?
   - [ ] Are stateful logic and side effects separated from pure helpers?
   - [ ] Are different concerns (I/O, domain logic, formatting, UI) split into distinct files?
   - [ ] Are exported functions/types cohesive, or should some move to a `*.utils.ts` / `*.logic.ts` / `*.types.ts` file?

---

Repository-wide, you want the same idea applied to any source file: one main responsibility, tight size bounds, and hard triggers that force you to split before the file becomes a gravity well. You already have the component-specific version in `src/components/AGENTS.md`.

Below is a generalized rule you can drop into a root `AGENTS.md` or a new `.ruler` rule, plus line-count thresholds as a rule of thumb.

---

### Repository-wide file-size and responsibility rule

Scope: all TypeScript/JavaScript files under `src` (routes, hooks, server functions, utilities, db, etc.), excluding config and test fixtures.

```md
# file size and responsibility rules

## core rules

1. One primary unit per file
   - Each file owns **one main thing**:
     - Components: one main component (existing rule).
     - Hooks: one main hook (`useXxx`).
     - Server functions: one main server function or handler group for a single route.
     - Utilities: one cohesive utility topic (e.g. `dateFormat`, `sessionSearch`, `featureFlags`).
     - Schema: one logical schema group (e.g. `session.schema.ts`).
   - Any additional exports must be:
     - Small helpers directly supporting the main unit, or
     - Type-only exports.

2. File-size limits (non-component, general case)
   - Soft target: **150–300 LOC** per file (excluding imports and types).
   - Warning zone: **> 400 LOC** → required refactor before adding new behavior.
   - Hard cap: **600 LOC**. No exceptions; split into smaller files before merging.

3. Split by concern
   - **Stateful logic, effects, orchestration → hooks/logic files**:
     - `FeatureName/FeatureName.hooks.ts`
     - `FeatureName/FeatureName.logic.ts`
   - **Pure data shaping, parsing, formatting → utility files**:
     - `FeatureName/FeatureName.utils.ts`
     - `FeatureName/FeatureName.format.ts`
   - **Types/interfaces/enums shared across files → type files**:
     - `FeatureName/FeatureName.types.ts`
   - **Route/server concerns → route/server files only**:
     - Keep HTTP handling, validation, and side effects here.
     - Push domain logic into shared `*.logic.ts` or `*.utils.ts`.

4. When to split a file (hard triggers, any file type)
   - File > **400 LOC** or diff adds > **80 LOC** to a file already > **300 LOC**.
   - File mixes **two or more** of:
     - Network/server I/O (fetch, db, server functions)
     - Business/domain logic (calculations, rules)
     - UI / presentation (components, JSX, templates)
     - Cross-cutting concerns (logging, metrics, feature flags)
   - File exports **many unrelated things**:
     - More than **5–7 public exports** with different purposes.
     - Utilities that clearly belong to different topics (e.g. date helpers + string helpers).
   - Control flow / branching is hard to scan:
     - Deeply nested conditionals or long switch statements (`> ~100 LOC`) that can be moved into dedicated helpers.

5. Structure conventions by file kind
   - **Hooks**:
     - `FeatureName/FeatureName.hooks.ts` → owns `useFeatureNameXxx` hooks.
     - No JSX, no DOM; only state, effects, and derived data.
   - **Logic / services**:
     - `FeatureName/FeatureName.logic.ts` or `FeatureName/service.ts`.
     - Pure, testable functions; no React imports.
   - **Utilities / formatting**:
     - `FeatureName/FeatureName.utils.ts`, `FeatureName/FeatureName.format.ts`.
     - Pure, side-effect-free; reusable across features.
   - **Types**:
     - `FeatureName/FeatureName.types.ts`.
     - No runtime code.
   - **Server functions / routes**:
     - One route or server function group per file.
     - Validation + wiring here; heavy domain logic pushed into `*.logic.ts`.

6. Review checklist (for any file)
   - [ ] Does this file have **one clearly named primary responsibility**?
   - [ ] Is the file within the **150–300 LOC target** and **< 400 LOC** unless it’s about to be split?
   - [ ] Are stateful logic and side effects separated from pure helpers?
   - [ ] Are different concerns (I/O, domain logic, formatting, UI) split into distinct files?
   - [ ] Are exported functions/types cohesive, or should some move to a `*.utils.ts` / `*.logic.ts` / `*.types.ts` file?
```

---

### Line-count thresholds as a rule of thumb

Use these as mental stop signs across the codebase:

- **Components (existing rule):**

  - Target: **150–250 LOC**
  - Refactor threshold: **> 400 LOC**
  - Hard cap: **600 LOC**

- **Hooks / logic modules:**

  - Target: **150–250 LOC**
  - Start considering a split: **> 300 LOC**
  - Must split before: **> 400 LOC**

- **Utility / formatting modules:**

  - Target: **150–300 LOC**
  - Start considering split: **> 350 LOC** or **> 8–10 exports**
  - Hard cap: **600 LOC**, but only if exports are tightly related.

- **Route / server function files:**

  - Target: **150–300 LOC** for the route file itself.
  - If adding behavior would push it **> 350–400 LOC**, push domain logic into a `*.logic.ts` or `*.service.ts` and keep the route thin.

Operational rule:

- Once any file crosses **~300 LOC** or starts handling **more than one major concern**, treat that as the point to factor logic into `*.hooks.ts`, `*.logic.ts`, `*.utils.ts`, and `*.types.ts` so the main file stays as a thin coordinator.



<!-- Source: .ruler/tanstack-environment-server-client-only-rules.md -->

# ClientOnly

Client-only render to avoid SSR hydration issues. Import from `@tanstack/react-router`:

```typescript
import { ClientOnly } from '@tanstack/react-router';

<ClientOnly fallback={<span>—</span>}>
  <ComponentThatUsesClientHooks />
</ClientOnly>
```

Alternative: Custom implementation using mounted pattern if needed (see hydration errors below).

# Environment functions

From `@tanstack/react-start`:

## createIsomorphicFn

Adapts to client/server:

```typescript
import { createIsomorphicFn } from '@tanstack/react-start';
const getEnv = createIsomorphicFn()
  .server(() => 'server')
  .client(() => 'client');
getEnv(); // 'server' on server, 'client' on client
```

Partial: `.server()` no-op on client, `.client()` no-op on server.

## createServerOnlyFn / createClientOnlyFn

RC1: `serverOnly` → `createServerOnlyFn`, `clientOnly` → `createClientOnlyFn`

Strict environment execution (throws if called wrong env):

```typescript
import { createServerOnlyFn, createClientOnlyFn } from '@tanstack/react-start';
const serverFn = createServerOnlyFn(() => 'bar'); // throws on client
const clientFn = createClientOnlyFn(() => 'bar'); // throws on server
```

Tree-shaken: client code removed from server bundle, server code removed from client bundle.

# Hydration errors

Mismatch: Server HTML differs from client render. Common causes: Intl (locale/timezone), Date.now(), random IDs, responsive logic, feature flags, user prefs.

Strategies:
1. Make server and client match: deterministic locale/timezone on server (cookie or Accept-Language header), compute once and hydrate as initial state.
2. Let client tell environment: set cookie with client timezone on first visit, SSR uses UTC until then.
3. Make it client-only: wrap unstable UI in `<ClientOnly>` to avoid SSR mismatches.
4. Disable/limit SSR: use selective SSR (`ssr: 'data-only'` or `false`) when server HTML cannot be stable.
5. Last resort: React's `suppressHydrationWarning` for small known-different nodes (use sparingly).

Checklist: Deterministic inputs (locale, timezone, feature flags). Prefer cookies for client context. Use `<ClientOnly>` for dynamic UI. Use selective SSR when server HTML unstable. Avoid blind suppression.

# TanStack Start basics

Depends: @tanstack/react-router, Vite. Router: getRouter() (was createRouter() in beta). routeTree.gen.ts auto-generated on first dev run. Optional: server handler via @tanstack/react-start/server; client hydrate via StartClient from @tanstack/react-start/client. RC1: Import StartClient from @tanstack/react-start/client (not @tanstack/react-start). StartClient no longer requires router prop. Root route head: utf-8, viewport, title; component wraps Outlet in RootDocument. Routes: createFileRoute() code-split + lazy-load; loader runs server/client. Navigation: Link (typed), useNavigate (imperative), useRouter (instance).

# Server functions

createServerFn({ method }) + zod .inputValidator + .handler(ctx). After mutations: router.invalidate(); queryClient.invalidateQueries(['entity', id]).

# Typed Links

Link to="/posts/$postId" with params; activeProps for styling.



<!-- Source: .ruler/tanstack-query-rules.md -->

# TanStack Query Rules

Server state via TanStack Query + server functions. Type-safe fetching and mutations.

## Query Pattern

Define in `lib/{resource}/queries.ts` using `queryOptions`:

```typescript
export const todosQueryOptions = () =>
  queryOptions({
    queryKey: ['todos'],
    queryFn: async ({ signal }) => await getTodos({ signal }),
    staleTime: 1000 * 60 * 5,
    gcTime: 1000 * 60 * 10,
  });
```

Use: `const { data, isLoading } = useQuery(todosQueryOptions())`. Prefer `useSuspenseQuery` with Suspense.

## Server Functions in Queries

Call server functions directly in `queryFn`. No `useServerFn` hook. TanStack Start proxies. Pass `signal` for cancellation.

## Mutation Pattern

```typescript
const mutation = useMutation({
  mutationFn: async (text: string) => await createTodo({ data: { text } }),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: todosQueryOptions().queryKey });
    toast.success('Success');
  },
  onError: (error) => toast.error(error.message || 'Failed'),
});
```

Call via `mutation.mutate(data)` or `mutateAsync` for promises.

## Query Invalidation

After mutations: `queryClient.invalidateQueries({ queryKey: ... })`. Use specific keys, not broad.

## Mutation States

Access: `isPending`, `isError`, `isSuccess`, `error`, `data`. Disable UI during `isPending`.

## Error Handling

Handle in `onError`. Toast messages. Access: `error.message || 'Default'`.

## Query Keys

Hierarchical: `['todos']`, `['todo', id]`, `['todos', 'completed']`. Include all affecting variables.

## Stale Time vs GC Time

`staleTime`: freshness duration (no refetch). Default 0. Set for stable data.
`gcTime`: unused cache duration (was `cacheTime`). Default 5min. Memory management.

## Infinite Queries

`useInfiniteQuery` for pagination. Required: `initialPageParam`, `getNextPageParam`, `fetchNextPage`. Access `data.pages`. Check `hasNextPage` before fetching.

## Optimistic Updates

`onMutate` for optimistic updates. Rollback in `onError`. Update cache via `queryClient.setQueryData`.

## Best Practices

1. Queries in `lib/{resource}/queries.ts` with `queryOptions`
2. Call server functions directly (no `useServerFn` in callbacks)
3. Invalidate after mutations
4. Toast for feedback
5. Handle loading/error states
6. Use TypeScript types from query options
7. Set `staleTime`/`gcTime` appropriately
8. Prefer `useSuspenseQuery` with Suspense

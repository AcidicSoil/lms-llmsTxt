# llms-full (private-aware)
> Built from GitHub files and website pages. Large files may be truncated.

--- examples/additive-creature/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Additive creature / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    #creature-wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      top: 0;
      left: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    #creature {
      font-size: .2vh;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 150em;
      height: 150em;
      flex-wrap: wrap;
    }
    #creature div {
      transform-style: preserve-3d;
      position: relative;
      width: 4em;
      height: 4em;
      margin: 3em;
      border-radius: 2em;
      will-change: transform;
      mix-blend-mode: plus-lighter;
      /*mix-blend-mode: screen;*/
      /*mix-blend-mode: lighten;*/
      background: var(--red);
    }
  </style>
</head>
<body>
  <div id="creature-wrapper">
    <div id="creature"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- examples/additive-fireflies/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Additive fireflies / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
      cursor: grab;
      user-select: none;
    }
    body:active {
      cursor: grabbing;
    }
    #animation-wrapper {
      /*font-size: .065vh;*/
      font-size: .2vh;
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      top: 0;
      left: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      color: var(--red);
    }
    #circle {
      opacity: .3;
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100em;
      height: 100em;
      margin: -50em 0 0 -50em;
      border-radius: 50%;
      will-change: transform, opacity
    }
    #circle:before,
    #circle:after {
      content: "";
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
    }
    #circle:before {
      z-index: 1;
      opacity: 1;
      box-shadow: inset 0px 0px 25em 0px currentColor,  0px 0px 10em 1px currentColor, 0px 0px 5em 1px currentColor;
    }
    #circle:after {
      z-index: 3;
      opacity: .75;
      box-shadow: inset 0 0 30em 0 currentColor;
      background-image: radial-gradient(circle at 50% 50%, currentColor 0%, transparent 100%);
    }
    .particle {
      opacity: .5;
      position: absolute;
      z-index: 2;
      top: 50%;
      left: 50%;
      width: 5em;
      height: 5em;
      margin: -2.5em 0 0 -2.5em;
      border-radius: 5em;
      will-change: transform;
      mix-blend-mode: plus-lighter;
      background: currentColor;
      box-shadow: 0px 0px 15em 0px currentColor, 0px 0px 5em 0px currentColor;
    }
  </style>
</head>
<body>
  <div id="animation-wrapper">
    <div id="circle"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- examples/advanced-grid-staggering/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Advanced grid staggering / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      --rows: 41;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .stagger-visualizer {
      position: relative;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      width: calc(var(--rows) * 1rem);
      height: calc(var(--rows) * 1rem);
    }

    .stagger-visualizer .dot {
      position: relative;
      width: .25rem;
      height: .25rem;
      margin: .375rem;
      background-color: currentColor;
      border-radius: 50%;
    }

    .stagger-visualizer .cursor {
      position: absolute;
      z-index: 1;
      top: 0;
      left: 0;
      width: 1rem;
      height: 1rem;
      background-color: currentColor;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div class="stagger-visualizer">
    <div class="cursor red"></div>
  </div>
</body>
<script type="module" src="./index.js"></script>
</html>


--- examples/animatable-follow-cursor/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Animatable follow cursor / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      top: 0;
      left: 0;
      overflow: hidden;
      width: 100%;
      height: 100vh;
    }

    .particles {
      --size: 21;
      --diameter: 1em;
      --margin: 0em;
      font-size: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      width: calc(var(--size) * 1em);
      height: calc(var(--size) * 1em);
    }

    .particles div {
      position: relative;
      width: calc(var(--diameter) - var(--margin) * 2);
      height: calc(var(--diameter) - var(--margin) * 2);
      margin: var(--margin);
      background: var(--red);
      mix-blend-mode: plus-lighter;
      box-shadow: 0 0 10px 0 var(--red);
      border-radius: .5rem;
      opacity: .75;
    }
  </style>
</head>
<body>
  <div class="particles"></div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- examples/animejs-v4-logo-animation/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Logo animation V4 / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
/*      background: black;*/
    }
    #animejs-v4-logo {
      overflow: hidden;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      width: 640px;
      height: 360px;
/*      background: #252423;*/
/*      box-shadow: 0 0 0 1px rgba(255,255,255,.1);*/
    }
    #logo {
      position: relative;
      overflow: visible;
      top: -15%;
      width: 72%;
      height: auto;
    }
    #logo * {
      transform-box: fill-box;
    }
    #animejs-v4-logo svg#effects {
      display: none;
    }
    #sub-text {
      position: absolute;
      z-index: 1;
      bottom: 20%;
      left: 0;
      right: 0;
      font-family: PPSupplyMono-Regular;
      font-size: 18px;
      color: #FFF;
      letter-spacing: 1px;
      text-align: center;
      line-height: 26px;
      white-space: pre;
    }

    #sub-text span {
      opacity: 0;
      display: inline-block;
    }
    #four {
      filter: url('#blur');
    }
  </style>
</head>
<body>
  <div id="animejs-v4-logo">
    <div id="sub-text">AVAILABLE NOW AT ANIMEJS.COM</div>
<svg id="effects" xmlns="http://www.w3.org/2000/svg" version="1.1" class="filters">
  <defs>
    <filter id="blur">
      <feGaussianBlur in="SourceGraphic" stdDeviation="10,0" />
    </filter>
  </defs>
</svg>
<?xml version="1.0" encoding="UTF-8"?>
<svg id="logo" width="640px" height="360px" viewBox="0 0 640 360" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>logo-anime-v4</title>
    <g id="logo-anime-v4" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <polygon id="dot-1" fill="#FF4B4B" fill-rule="nonzero" points="309.202438 224.68 309.293324 207 332.173324 207 332.212438 224.68"></polygon>
        <path d="M166.22864,296.48 C159.555307,296.48 154.222659,296.003333 150.230697,295.05 C146.238735,294.096667 143.222342,292.536667 141.18152,290.37 C139.140697,288.203333 137.855844,285.256667 137.326962,281.53 C137.09327,279.883333 136.989578,278.236667 137.015886,276.59 L137,273.73 C137.004557,268.876667 137.825158,265.193333 139.461803,262.68 C141.098449,260.166667 143.966307,258.39 148.065379,257.35 C152.164451,256.31 158.15732,255.79 166.043987,255.79 L168.643987,255.79 C174.79732,255.79 179.671893,256.245 183.267705,257.155 C186.863517,258.065 189.589018,259.56 191.444208,261.64 L191.834208,261.64 L191.617088,255.53 C191.569029,253.97 191.51425,252.973333 191.452752,252.54 C191.157562,250.46 190.508986,248.943333 189.507024,247.99 C188.505062,247.036667 187.094224,246.408333 185.274508,246.105 C183.454793,245.801667 180.811602,245.65 177.344936,245.65 L174.744936,245.65 C170.671602,245.65 167.600943,245.845 165.532958,246.235 C163.464973,246.625 162.077736,247.231667 161.371249,248.055 C160.664762,248.878333 160.286065,250.026667 160.235157,251.5 L160.160506,251.89 L138.580506,251.89 L138.563765,249.94 C138.556022,245 139.608807,241.273333 141.722119,238.76 C143.835431,236.246667 147.486365,234.491667 152.674919,233.495 C157.863474,232.498333 165.441085,232 175.407752,232 L178.527752,232 C186.761085,232 193.229624,232.541667 197.933369,233.625 C202.637114,234.708333 206.253596,236.68 208.782815,239.54 C211.312035,242.4 212.970231,246.603333 213.757404,252.15 C214.077193,254.403333 214.259693,257.826667 214.304905,262.42 L214.311045,295.44 L191.821045,295.44 L191.994779,288.42 L191.734779,288.42 C190.209969,290.5 188.660845,292.103333 187.087406,293.23 C185.513967,294.356667 183.334146,295.18 180.547944,295.7 C177.761741,296.22 173.89864,296.48 168.95864,296.48 L166.22864,296.48 Z M176.344557,282.57 C181.024557,282.57 184.46355,282.375 186.661535,281.985 C188.85952,281.595 190.327273,280.945 191.064795,280.035 C191.802316,279.125 192.171931,277.76 192.173639,275.94 L192.286044,274.9 C192.311213,274.466667 192.268449,273.86 192.157753,273.08 C191.985559,271.866667 191.463339,270.935 190.591092,270.285 C189.718845,269.635 188.202605,269.18 186.042373,268.92 C183.882141,268.66 180.722025,268.53 176.562025,268.53 L175.132025,268.53 C170.452025,268.53 166.994441,268.746667 164.759272,269.18 C162.524103,269.613333 161.037758,270.285 160.300237,271.195 C159.562716,272.105 159.193101,273.47 159.191392,275.29 L159.208987,276.33 L159.263481,277.63 C159.447975,278.93 160.069162,279.948333 161.127041,280.685 C162.184921,281.421667 163.793977,281.92 165.954209,282.18 C168.114441,282.44 171.144557,282.57 175.044557,282.57 L176.344557,282.57 Z" id="a-1" fill="#FFF" fill-rule="nonzero"></path>
        <path d="M221.545347,233.04 L244.425347,233.04 L244.249049,242.79 L244.509049,242.79 C246.034429,240.103333 247.834756,237.98 249.91003,236.42 C251.985304,234.86 254.55541,233.733333 257.620347,233.04 C260.685283,232.346667 264.514418,232 269.107752,232 L270.277752,232 C277.037752,232 282.546665,232.65 286.804492,233.95 C291.062319,235.25 294.387625,237.46 296.78041,240.58 C299.173195,243.7 300.750875,247.946667 301.513449,253.32 C301.833238,255.573333 302.040907,258.563333 302.136455,262.29 L302.031045,295.44 L279.151045,295.44 L279.107151,263.07 C279.10886,261.25 279.017468,259.69 278.832974,258.39 C278.476286,255.876667 277.732104,253.991667 276.600426,252.735 C275.468749,251.478333 273.875495,250.633333 271.820664,250.2 C269.765832,249.766667 266.96175,249.55 263.408417,249.55 L261.978417,249.55 C257.47175,249.55 253.948881,250.07 251.409809,251.11 C248.870738,252.15 247.080205,253.731667 246.038211,255.855 C244.996218,257.978333 244.467362,260.816667 244.451645,264.37 L244.441045,295.44 L221.561045,295.44 L221.545347,233.04 Z" id="n-1" fill="#FFF" fill-rule="nonzero"></path>
        <polygon id="i-1" fill="#FFF" fill-rule="nonzero" points="309.281045 295.44 309.265347 233.04 332.145347 233.04 332.161045 295.44"></polygon>
        <path d="M339.785347,233.04 L362.665347,233.04 L362.489049,242.79 L362.749049,242.79 C364.609366,239.41 367.310895,236.766667 370.853638,234.86 C374.39638,232.953333 379.157752,232 385.137752,232 L386.697752,232 C393.977752,232 399.610088,233.061667 403.594761,235.185 C407.579434,237.308333 410.473343,240.753333 412.276486,245.52 L412.406486,245.52 C414.193575,241.013333 417.115558,237.633333 421.172435,235.38 C425.229313,233.126667 430.637752,232 437.397752,232 L438.827752,232 C444.981085,232 449.942182,232.606667 453.711043,233.82 C457.479904,235.033333 460.39061,237.07 462.443163,239.93 C464.495716,242.79 465.87868,246.733333 466.592056,251.76 C466.924145,254.1 467.118945,257.61 467.176455,262.29 L467.201045,295.44 L444.321045,295.44 L444.388702,262.94 C444.390411,261.12 444.299018,259.56 444.114525,258.26 C443.782436,255.92 443.115553,254.121667 442.113876,252.865 C441.112199,251.608333 439.797536,250.741667 438.169888,250.265 C436.542241,249.788333 434.428417,249.55 431.828417,249.55 L430.528417,249.55 C426.108417,249.55 422.774398,250.026667 420.52636,250.98 C418.278322,251.933333 416.778823,253.428333 416.027863,255.465 C415.276903,257.501667 414.905864,260.383333 414.914746,264.11 L414.941045,295.44 L392.061045,295.44 L391.998702,262.94 C392.086508,261.726667 392.001265,260.21 391.742974,258.39 C391.398586,255.963333 390.722478,254.1 389.714651,252.8 C388.706824,251.5 387.413828,250.633333 385.835664,250.2 C384.257499,249.766667 382.21175,249.55 379.698417,249.55 L378.398417,249.55 C373.89175,249.55 370.536065,250.026667 368.33136,250.98 C366.126655,251.933333 364.624082,253.406667 363.823639,255.4 C363.023196,257.393333 362.639715,260.34 362.673196,264.24 L362.681045,295.44 L339.801045,295.44 L339.785347,233.04 Z" id="m-1" fill="#FFF" fill-rule="nonzero"></path>
        <path d="M511.73864,296.48 C503.15864,296.48 496.290876,295.873333 491.135349,294.66 C485.979821,293.446667 481.961182,291.236667 479.079431,288.03 C476.19768,284.823333 474.332469,280.23 473.483797,274.25 C473.004114,270.87 472.784145,267.793333 472.823892,265.02 L472.733177,262.55 C472.716729,253.883333 473.874261,247.383333 476.205948,243.05 C478.537636,238.716667 482.217525,235.791667 487.245616,234.275 C492.273706,232.758333 499.467752,232 508.827752,232 L512.857752,232 C520.917752,232 527.476032,232.563333 532.532593,233.69 C537.589155,234.816667 541.539861,236.853333 544.384714,239.8 C547.229566,242.746667 549.02713,246.863333 549.777404,252.15 C550.134092,254.663333 550.292847,257.003333 550.25367,259.17 L550.337373,268.92 L495.217373,268.92 L495.252563,271 C495.177057,272.3 495.200802,273.383333 495.323797,274.25 C495.643587,276.503333 496.42202,278.171667 497.659098,279.255 C498.896176,280.338333 500.557648,281.053333 502.643513,281.4 C504.729378,281.746667 507.72231,281.92 511.62231,281.92 L514.09231,281.92 C518.338977,281.92 521.533487,281.681667 523.675839,281.205 C525.818191,280.728333 527.273645,279.991667 528.0422,278.995 C528.810754,277.998333 529.195886,276.59 529.197595,274.77 L529.160696,274.51 L550.610696,274.51 L550.627437,276.46 C550.610011,281.833333 549.395908,285.95 546.985127,288.81 C544.574347,291.67 540.913904,293.663333 536.003798,294.79 C531.093693,295.916667 524.47864,296.48 516.15864,296.48 L511.73864,296.48 Z M528.76848,257.09 L528.696392,254.75 C528.783628,254.143333 528.747299,253.276667 528.587404,252.15 C528.341413,250.416667 527.720511,249.095 526.724698,248.185 C525.728886,247.275 524.228306,246.625 522.222958,246.235 C520.21761,245.845 517.438269,245.65 513.884936,245.65 L511.284936,245.65 C506.691602,245.65 503.252467,245.996667 500.967531,246.69 C498.682594,247.383333 497.130822,248.51 496.312214,250.07 C495.493607,251.63 495.089029,253.97 495.098319,257.09 L528.76848,257.09 Z" id="e-1" fill="#FFF" fill-rule="nonzero"></path>
        <g id="line" transform="translate(302.000000, 220.000000)" opacity="0.49878293" stroke-width="24">
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 18.5029597,56.4129153 18.5029597,51.3214156" id="line-0" stroke="#FF4B4B"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 16.7027142,64.322527 12.8291348,55.2014156" id="line-0-1" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 20.0805137,62.5805329 24.3906645,53.2014156" id="line-0-2" stroke="#4BFFFD"></path>
            <path d="M18.5029605,81.0814156 C18.5029605,66.8963175 17.682265,65.8816401 16.0496411,55.2014156" id="line-0-3" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 18.7131958,61.4525182 19.6580351,55.2014156" id="line-0-4" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 18.6880928,63.504343 17.8717813,55.7769881" id="line-0-5" stroke="#4BFFFD"></path>
            <path d="M18.5029601,81.0814156 C18.5029601,66.8963175 18.5029601,62.7412408 18.5029601,55.9905556" id="line-0-6" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 27.1232611,61.4408336 35.7435626,57.3214156" id="line-1" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 11.5633347,48.9981227 0,38.822786" id="line-2" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 24.1585737,32.9688645 31.8267924,25.3214156" id="line-3" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 14.5029597,25.3214156 10.5029597,14.0449261" id="line-4" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 18.5029597,9.08661174 18.5029597,0" id="line-5" stroke="#4BFFFD"></path>
        </g>
        <polygon id="dot-2" fill="#FFF" fill-rule="nonzero" opacity="0" points="585.36 224.68 587.96 207 610.84 207 608.37 224.68"></polygon>
        <path d="M94.78,296.44 C88.1066667,296.44 82.8416667,295.963333 78.985,295.01 C75.1283333,294.056667 72.3333333,292.496667 70.6,290.33 C68.8666667,288.163333 68,285.216667 68,281.49 C68,279.843333 68.13,278.196667 68.39,276.55 L68.78,273.69 C69.4733333,268.836667 70.8166667,265.153333 72.81,262.64 C74.8033333,260.126667 77.9233333,258.35 82.17,257.31 C86.4166667,256.27 92.4833333,255.75 100.37,255.75 L102.97,255.75 C109.123333,255.75 113.933333,256.205 117.4,257.115 C120.866667,258.025 123.38,259.52 124.94,261.6 L125.33,261.6 L125.98,255.49 C126.153333,253.93 126.24,252.933333 126.24,252.5 C126.24,250.42 125.806667,248.903333 124.94,247.95 C124.073333,246.996667 122.751667,246.368333 120.975,246.065 C119.198333,245.761667 116.576667,245.61 113.11,245.61 L110.51,245.61 C106.436667,245.61 103.338333,245.805 101.215,246.195 C99.0916667,246.585 97.6183333,247.191667 96.795,248.015 C95.9716667,248.838333 95.43,249.986667 95.17,251.46 L95.04,251.85 L73.46,251.85 L73.72,249.9 C74.4133333,244.96 75.995,241.233333 78.465,238.72 C80.935,236.206667 84.835,234.451667 90.165,233.455 C95.495,232.458333 103.143333,231.96 113.11,231.96 L116.23,231.96 C124.463333,231.96 130.855,232.501667 135.405,233.585 C139.955,234.668333 143.291667,236.64 145.415,239.5 C147.538333,242.36 148.6,246.563333 148.6,252.11 C148.6,254.363333 148.296667,257.786667 147.69,262.38 L143.01,295.4 L120.52,295.4 L121.69,288.38 L121.43,288.38 C119.61,290.46 117.833333,292.063333 116.1,293.19 C114.366667,294.316667 112.07,295.14 109.21,295.66 C106.35,296.18 102.45,296.44 97.51,296.44 L94.78,296.44 Z M106.87,282.53 C111.55,282.53 115.016667,282.335 117.27,281.945 C119.523333,281.555 121.083333,280.905 121.95,279.995 C122.816667,279.085 123.38,277.72 123.64,275.9 L123.9,274.86 C123.986667,274.426667 124.03,273.82 124.03,273.04 C124.03,271.826667 123.64,270.895 122.86,270.245 C122.08,269.595 120.628333,269.14 118.505,268.88 C116.381667,268.62 113.24,268.49 109.08,268.49 L107.65,268.49 C102.97,268.49 99.4816667,268.706667 97.185,269.14 C94.8883333,269.573333 93.3066667,270.245 92.44,271.155 C91.5733333,272.065 91.01,273.43 90.75,275.25 L90.62,276.29 L90.49,277.59 C90.49,278.89 90.9666667,279.908333 91.92,280.645 C92.8733333,281.381667 94.4116667,281.88 96.535,282.14 C98.6583333,282.4 101.67,282.53 105.57,282.53 L106.87,282.53 Z" id="a-2" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <path d="M159.1,233 L181.98,233 L180.42,242.75 L180.68,242.75 C182.586667,240.063333 184.688333,237.94 186.985,236.38 C189.281667,234.82 192.011667,233.693333 195.175,233 C198.338333,232.306667 202.216667,231.96 206.81,231.96 L207.98,231.96 C214.74,231.96 220.156667,232.61 224.23,233.91 C228.303333,235.21 231.315,237.42 233.265,240.54 C235.215,243.66 236.19,247.906667 236.19,253.28 C236.19,255.533333 235.973333,258.523333 235.54,262.25 L230.73,295.4 L207.85,295.4 L212.4,263.03 C212.66,261.21 212.79,259.65 212.79,258.35 C212.79,255.836667 212.313333,253.951667 211.36,252.695 C210.406667,251.438333 208.933333,250.593333 206.94,250.16 C204.946667,249.726667 202.173333,249.51 198.62,249.51 L197.19,249.51 C192.683333,249.51 189.086667,250.03 186.4,251.07 C183.713333,252.11 181.698333,253.691667 180.355,255.815 C179.011667,257.938333 178.08,260.776667 177.56,264.33 L173.14,295.4 L150.26,295.4 L159.1,233 Z" id="n-2" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <polygon id="i-2" fill="#FFF" fill-rule="nonzero" opacity="0" points="237.98 295.4 246.82 233 269.7 233 260.86 295.4"></polygon>
        <path d="M277.34,233 L300.22,233 L298.66,242.75 L298.92,242.75 C301.26,239.37 304.336667,236.726667 308.15,234.82 C311.963333,232.913333 316.86,231.96 322.84,231.96 L324.4,231.96 C331.68,231.96 337.161667,233.021667 340.845,235.145 C344.528333,237.268333 346.933333,240.713333 348.06,245.48 L348.19,245.48 C350.616667,240.973333 354.018333,237.593333 358.395,235.34 C362.771667,233.086667 368.34,231.96 375.1,231.96 L376.53,231.96 C382.683333,231.96 387.558333,232.566667 391.155,233.78 C394.751667,234.993333 397.373333,237.03 399.02,239.89 C400.666667,242.75 401.49,246.693333 401.49,251.72 C401.49,254.06 401.186667,257.57 400.58,262.25 L395.9,295.4 L373.02,295.4 L377.7,262.9 C377.96,261.08 378.09,259.52 378.09,258.22 C378.09,255.88 377.678333,254.081667 376.855,252.825 C376.031667,251.568333 374.84,250.701667 373.28,250.225 C371.72,249.748333 369.64,249.51 367.04,249.51 L365.74,249.51 C361.32,249.51 357.918333,249.986667 355.535,250.94 C353.151667,251.893333 351.44,253.388333 350.4,255.425 C349.36,257.461667 348.58,260.343333 348.06,264.07 L343.64,295.4 L320.76,295.4 L325.31,262.9 C325.57,261.686667 325.7,260.17 325.7,258.35 C325.7,255.923333 325.288333,254.06 324.465,252.76 C323.641667,251.46 322.471667,250.593333 320.955,250.16 C319.438333,249.726667 317.423333,249.51 314.91,249.51 L313.61,249.51 C309.103333,249.51 305.68,249.986667 303.34,250.94 C301,251.893333 299.288333,253.366667 298.205,255.36 C297.121667,257.353333 296.32,260.3 295.8,264.2 L291.38,295.4 L268.5,295.4 L277.34,233 Z" id="m-2" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <path d="M440.29,296.44 C431.71,296.44 424.928333,295.833333 419.945,294.62 C414.961667,293.406667 411.256667,291.196667 408.83,287.99 C406.403333,284.783333 405.19,280.19 405.19,274.21 C405.19,270.83 405.406667,267.753333 405.84,264.98 L406.1,262.51 C407.313333,253.843333 409.393333,247.343333 412.34,243.01 C415.286667,238.676667 419.381667,235.751667 424.625,234.235 C429.868333,232.718333 437.17,231.96 446.53,231.96 L450.56,231.96 C458.62,231.96 465.098333,232.523333 469.995,233.65 C474.891667,234.776667 478.553333,236.813333 480.98,239.76 C483.406667,242.706667 484.62,246.823333 484.62,252.11 C484.62,254.623333 484.446667,256.963333 484.1,259.13 L482.8,268.88 L427.68,268.88 L427.42,270.96 C427.16,272.26 427.03,273.343333 427.03,274.21 C427.03,276.463333 427.571667,278.131667 428.655,279.215 C429.738333,280.298333 431.298333,281.013333 433.335,281.36 C435.371667,281.706667 438.34,281.88 442.24,281.88 L444.71,281.88 C448.956667,281.88 452.185,281.641667 454.395,281.165 C456.605,280.688333 458.165,279.951667 459.075,278.955 C459.985,277.958333 460.57,276.55 460.83,274.73 L460.83,274.47 L482.28,274.47 L482.02,276.42 C481.24,281.793333 479.441667,285.91 476.625,288.77 C473.808333,291.63 469.865,293.623333 464.795,294.75 C459.725,295.876667 453.03,296.44 444.71,296.44 L440.29,296.44 Z M462.91,257.05 L463.17,254.71 C463.343333,254.103333 463.43,253.236667 463.43,252.11 C463.43,250.376667 462.996667,249.055 462.13,248.145 C461.263333,247.235 459.855,246.585 457.905,246.195 C455.955,245.805 453.203333,245.61 449.65,245.61 L447.05,245.61 C442.456667,245.61 438.968333,245.956667 436.585,246.65 C434.201667,247.343333 432.49,248.47 431.45,250.03 C430.41,251.59 429.673333,253.93 429.24,257.05 L462.91,257.05 Z" id="e-2" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <rect id="ground" fill="#252423" x="0" y="300" width="640" height="200"></rect>
        <path d="M477.57,317.5 C475.663333,317.5 474.103333,317.413333 472.89,317.24 L473.28,315.03 C474.666667,315.203333 476.183333,315.29 477.83,315.29 C479.91,315.29 481.535,314.878333 482.705,314.055 C483.875,313.231667 484.828333,311.78 485.565,309.7 C486.301667,307.62 486.973333,304.543333 487.58,300.47 L497.07,233 L499.8,233 L490.31,300.6 C489.703333,304.846667 488.923333,308.183333 487.97,310.61 C487.016667,313.036667 485.716667,314.791667 484.07,315.875 C482.423333,316.958333 480.256667,317.5 477.57,317.5 Z" id="j" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <path d="M534.26,296.31 C525.333333,296.31 518.616667,295.985 514.11,295.335 C509.603333,294.685 506.396667,293.45 504.49,291.63 C502.583333,289.81 501.63,286.993333 501.63,283.18 C501.63,281.966667 501.695,280.861667 501.825,279.865 C501.955,278.868333 502.106667,277.806667 502.28,276.68 L505.01,276.68 C504.576667,279.02 504.36,281.1 504.36,282.92 C504.36,286.04 505.205,288.358333 506.895,289.875 C508.585,291.391667 511.488333,292.431667 515.605,292.995 C519.721667,293.558333 525.94,293.84 534.26,293.84 L538.81,293.84 C546.436667,293.84 552.243333,293.363333 556.23,292.41 C560.216667,291.456667 563.033333,289.983333 564.68,287.99 C566.326667,285.996667 567.41,283.136667 567.93,279.41 C568.276667,277.243333 568.45,275.466667 568.45,274.08 C568.45,271.48 567.648333,269.508333 566.045,268.165 C564.441667,266.821667 561.581667,265.89 557.465,265.37 C553.348333,264.85 547.173333,264.546667 538.94,264.46 C530.533333,264.373333 524.141667,263.961667 519.765,263.225 C515.388333,262.488333 512.355,261.34 510.665,259.78 C508.975,258.22 508.13,256.01 508.13,253.15 C508.13,251.85 508.346667,249.856667 508.78,247.17 C509.3,243.183333 510.491667,240.128333 512.355,238.005 C514.218333,235.881667 517.316667,234.365 521.65,233.455 C525.983333,232.545 532.31,232.09 540.63,232.09 L543.88,232.09 C551.333333,232.09 557.096667,232.48 561.17,233.26 C565.243333,234.04 568.19,235.383333 570.01,237.29 C571.83,239.196667 572.74,241.926667 572.74,245.48 C572.74,246.866667 572.566667,248.903333 572.22,251.59 L569.62,251.59 C569.966667,249.163333 570.14,247.17 570.14,245.61 C570.14,242.663333 569.338333,240.41 567.735,238.85 C566.131667,237.29 563.466667,236.185 559.74,235.535 C556.013333,234.885 550.683333,234.56 543.75,234.56 L540.5,234.56 C532.7,234.56 526.828333,234.971667 522.885,235.795 C518.941667,236.618333 516.168333,237.918333 514.565,239.695 C512.961667,241.471667 511.9,244.136667 511.38,247.69 C511.033333,249.943333 510.86,251.633333 510.86,252.76 C510.86,255.186667 511.618333,257.028333 513.135,258.285 C514.651667,259.541667 517.403333,260.43 521.39,260.95 C525.376667,261.47 531.313333,261.773333 539.2,261.86 C547.866667,261.946667 554.431667,262.336667 558.895,263.03 C563.358333,263.723333 566.5,264.893333 568.32,266.54 C570.14,268.186667 571.05,270.613333 571.05,273.82 C571.05,275.206667 570.876667,277.156667 570.53,279.67 C569.923333,284.003333 568.645,287.34 566.695,289.68 C564.745,292.02 561.581667,293.71 557.205,294.75 C552.828333,295.79 546.653333,296.31 538.68,296.31 L534.26,296.31 Z" id="s" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <path d="M498.143,233.835 L488.870344,300.178569 L488.788109,300.741361 L488.617463,301.83314 C488.588338,302.011345 488.558871,302.187668 488.529064,302.362111 L488.346146,303.386172 C487.847513,306.056727 487.262239,308.244854 486.594348,309.944941 C485.7171,312.177933 484.698132,313.776334 483.252421,314.72746 C481.797469,315.684665 479.913737,316.185 477.423,316.185 L476.965305,316.183252 C476.064438,316.176263 475.250752,316.148336 474.525127,316.099815 L474,316.059" id="j-line" stroke="#FFF" stroke-width="2.5" stroke-linecap="square" fill-rule="nonzero"></path>
        <path d="M571.056,250.2 L571.096942,249.864827 L571.188848,249.040441 L571.266572,248.270344 L571.330128,247.5547 L571.379533,246.893678 C571.386589,246.788069 571.393056,246.684742 571.398934,246.583702 L571.427142,246.004923 L571.441239,245.48118 L571.443,245.24 C571.443,241.962222 570.627859,239.516799 569.031141,237.844047 C567.399823,236.135047 564.665034,234.888305 560.806717,234.149478 C559.004982,233.804465 556.854978,233.536636 554.358335,233.346643 L553.267127,233.269985 L552.133502,233.202869 C551.941031,233.192479 551.746795,233.182487 551.550792,233.172893 L550.353596,233.120112 L549.114053,233.076902 C548.903936,233.070499 548.692055,233.064495 548.478412,233.05889 L547.175405,233.030058 L545.830123,233.010825 C545.146919,233.00361 544.447873,233 543.733,233 L539.760455,233.001167 C539.521331,233.001945 539.28393,233.003112 539.048254,233.004668 L537.654893,233.018665 L536.302944,233.041979 L534.992436,233.0746 C534.777473,233.080812 534.564238,233.087411 534.352731,233.094397 L533.104434,233.140956 L531.897646,233.196793 L530.732393,233.261898 C530.541647,233.27352 530.352633,233.285528 530.165352,233.297922 L529.062455,233.376906 C528.882105,233.390841 528.703489,233.40516 528.526606,233.419864 L527.486127,233.512703 C525.27686,233.723849 523.360848,233.999936 521.739345,234.340452 C517.628698,235.203687 514.748415,236.613616 513.07237,238.523528 C511.375564,240.457098 510.266013,243.301581 509.768327,247.113117 C509.744752,247.259284 509.721835,247.40332 509.699577,247.545222 L509.573921,248.37099 L509.464041,249.145324 L509.369918,249.868009 L509.291531,250.538831 L509.228861,251.157577 L509.181888,251.724033 L509.150592,252.237985 C509.13886,252.4818 509.133,252.705845 509.133,252.91 C509.133,255.466423 509.85986,257.367442 511.298022,258.694976 C512.789477,260.071704 515.632529,261.148002 519.808879,261.850952 L520.194106,261.914083 L520.996187,262.035412 L521.840419,262.150158 C522.273069,262.205884 522.721518,262.259139 523.185753,262.30992 L524.135268,262.408179 C524.297028,262.424006 524.46054,262.439557 524.625806,262.454832 L525.638426,262.543179 L526.693089,262.62491 L527.789772,262.700018 L528.928455,262.768495 L530.109115,262.830336 L531.331731,262.885533 L532.596281,262.93408 L534.571684,262.994417 L535.940974,263.026308 L537.352121,263.051526 L540.2438,263.087698 L542.321694,263.12265 L544.303468,263.167815 L545.571282,263.203605 L546.796423,263.243945 L548.554167,263.312992 L550.216007,263.392298 L551.782007,263.481875 L552.772795,263.547306 L553.721037,263.617312 L554.62675,263.691898 C554.774159,263.70471 554.919797,263.717714 555.063665,263.730909 L556.31067,263.854822 C556.443916,263.869164 556.575393,263.883697 556.7051,263.898422 L557.462118,263.989066 C561.778158,264.53425 564.827086,265.527462 566.636553,267.043501 C568.518609,268.62036 569.453,270.918456 569.453,273.84 C569.453,275.295679 569.274065,277.129762 568.921966,279.328925 C568.374778,283.250439 567.217246,286.306323 565.419606,288.482414 C563.590867,290.69615 560.558909,292.282097 556.350459,293.288466 C554.367104,293.762746 551.961272,294.120693 549.130238,294.363622 L548.048663,294.449331 C547.681491,294.476105 547.307669,294.501085 546.927193,294.524273 L545.765797,294.588462 C545.568902,294.598265 545.370342,294.607621 545.170116,294.61653 L543.94877,294.66462 C543.74188,294.671742 543.533322,294.678418 543.323097,294.684647 L542.041729,294.716673 L540.720306,294.738008 C540.496729,294.740674 540.271482,294.742895 540.044564,294.744671 L538.663,294.75 L534.113,294.75 L532.699126,294.74722 L530.655553,294.732616 L528.7046,294.705476 L527.455386,294.680411 L525.65864,294.632343 L524.512164,294.593309 L523.406746,294.54868 L522.342365,294.49845 L521.318999,294.442614 L520.336627,294.381167 L519.395229,294.314104 L518.494782,294.241421 L517.635265,294.163112 L516.816658,294.079172 C516.550604,294.050253 516.291366,294.020395 516.038938,293.989597 L515.302085,293.894382 C510.978527,293.302737 507.873924,292.19064 505.979904,290.490879 C504.021984,288.733771 503.063,286.102713 503.063,282.68 C503.063,281.25837 503.188903,279.694292 503.439757,277.986433 L503.5,277.59" id="s-line" stroke="#FFF" stroke-width="2.5" stroke-linecap="square" fill-rule="nonzero"></path>
        <path d="M585.36,224.68 L587.96,207 L610.84,207 L608.37,224.68 L585.36,224.68 Z M94.78,296.44 C88.1066667,296.44 82.8416667,295.963333 78.985,295.01 C75.1283333,294.056667 72.3333333,292.496667 70.6,290.33 C68.8666667,288.163333 68,285.216667 68,281.49 C68,279.843333 68.13,278.196667 68.39,276.55 L68.78,273.69 C69.4733333,268.836667 70.8166667,265.153333 72.81,262.64 C74.8033333,260.126667 77.9233333,258.35 82.17,257.31 C86.4166667,256.27 92.4833333,255.75 100.37,255.75 L102.97,255.75 C109.123333,255.75 113.933333,256.205 117.4,257.115 C120.866667,258.025 123.38,259.52 124.94,261.6 L125.33,261.6 L125.98,255.49 C126.153333,253.93 126.24,252.933333 126.24,252.5 C126.24,250.42 125.806667,248.903333 124.94,247.95 C124.073333,246.996667 122.751667,246.368333 120.975,246.065 C119.198333,245.761667 116.576667,245.61 113.11,245.61 L110.51,245.61 C106.436667,245.61 103.338333,245.805 101.215,246.195 C99.0916667,246.585 97.6183333,247.191667 96.795,248.015 C95.9716667,248.838333 95.43,249.986667 95.17,251.46 L95.04,251.85 L73.46,251.85 L73.72,249.9 C74.4133333,244.96 75.995,241.233333 78.465,238.72 C80.935,236.206667 84.835,234.451667 90.165,233.455 C95.495,232.458333 103.143333,231.96 113.11,231.96 L116.23,231.96 C124.463333,231.96 130.855,232.501667 135.405,233.585 C139.955,234.668333 143.291667,236.64 145.415,239.5 C147.538333,242.36 148.6,246.563333 148.6,252.11 C148.6,254.363333 148.296667,257.786667 147.69,262.38 L143.01,295.4 L120.52,295.4 L121.69,288.38 L121.43,288.38 C119.61,290.46 117.833333,292.063333 116.1,293.19 C114.366667,294.316667 112.07,295.14 109.21,295.66 C106.35,296.18 102.45,296.44 97.51,296.44 L94.78,296.44 Z M106.87,282.53 C111.55,282.53 115.016667,282.335 117.27,281.945 C119.523333,281.555 121.083333,280.905 121.95,279.995 C122.816667,279.085 123.38,277.72 123.64,275.9 L123.9,274.86 C123.986667,274.426667 124.03,273.82 124.03,273.04 C124.03,271.826667 123.64,270.895 122.86,270.245 C122.08,269.595 120.628333,269.14 118.505,268.88 C116.381667,268.62 113.24,268.49 109.08,268.49 L107.65,268.49 C102.97,268.49 99.4816667,268.706667 97.185,269.14 C94.8883333,269.573333 93.3066667,270.245 92.44,271.155 C91.5733333,272.065 91.01,273.43 90.75,275.25 L90.62,276.29 L90.49,277.59 C90.49,278.89 90.9666667,279.908333 91.92,280.645 C92.8733333,281.381667 94.4116667,281.88 96.535,282.14 C98.6583333,282.4 101.67,282.53 105.57,282.53 L106.87,282.53 Z M159.1,233 L181.98,233 L180.42,242.75 L180.68,242.75 C182.586667,240.063333 184.688333,237.94 186.985,236.38 C189.281667,234.82 192.011667,233.693333 195.175,233 C198.338333,232.306667 202.216667,231.96 206.81,231.96 L207.98,231.96 C214.74,231.96 220.156667,232.61 224.23,233.91 C228.303333,235.21 231.315,237.42 233.265,240.54 C235.215,243.66 236.19,247.906667 236.19,253.28 C236.19,255.533333 235.973333,258.523333 235.54,262.25 L230.73,295.4 L207.85,295.4 L212.4,263.03 C212.66,261.21 212.79,259.65 212.79,258.35 C212.79,255.836667 212.313333,253.951667 211.36,252.695 C210.406667,251.438333 208.933333,250.593333 206.94,250.16 C204.946667,249.726667 202.173333,249.51 198.62,249.51 L197.19,249.51 C192.683333,249.51 189.086667,250.03 186.4,251.07 C183.713333,252.11 181.698333,253.691667 180.355,255.815 C179.011667,257.938333 178.08,260.776667 177.56,264.33 L173.14,295.4 L150.26,295.4 L159.1,233 Z M269.7,233 L260.86,295.4 L237.98,295.4 L246.82,233 L269.7,233 Z M324.4,231.96 C331.68,231.96 337.161667,233.021667 340.845,235.145 C344.528333,237.268333 346.933333,240.713333 348.06,245.48 L348.19,245.48 C350.616667,240.973333 354.018333,237.593333 358.395,235.34 C362.771667,233.086667 368.34,231.96 375.1,231.96 L376.53,231.96 C382.683333,231.96 387.558333,232.566667 391.155,233.78 C394.751667,234.993333 397.373333,237.03 399.02,239.89 C400.666667,242.75 401.49,246.693333 401.49,251.72 C401.49,254.06 401.186667,257.57 400.58,262.25 L395.9,295.4 L373.02,295.4 L377.7,262.9 C377.96,261.08 378.09,259.52 378.09,258.22 C378.09,255.88 377.678333,254.081667 376.855,252.825 C376.031667,251.568333 374.84,250.701667 373.28,250.225 C371.72,249.748333 369.64,249.51 367.04,249.51 L365.74,249.51 C361.32,249.51 357.918333,249.986667 355.535,250.94 C353.151667,251.893333 351.44,253.388333 350.4,255.425 C349.36,257.461667 348.58,260.343333 348.06,264.07 L343.64,295.4 L320.76,295.4 L325.31,262.9 C325.57,261.686667 325.7,260.17 325.7,258.35 C325.7,255.923333 325.288333,254.06 324.465,252.76 C323.641667,251.46 322.471667,250.593333 320.955,250.16 C319.438333,249.726667 317.423333,249.51 314.91,249.51 L313.61,249.51 C309.103333,249.51 305.68,249.986667 303.34,250.94 C301,251.893333 299.288333,253.366667 298.205,255.36 C297.121667,257.353333 296.32,260.3 295.8,264.2 L291.38,295.4 L268.5,295.4 L277.34,233 L300.22,233 L298.66,242.75 L298.92,242.75 C301.26,239.37 304.336667,236.726667 308.15,234.82 C311.963333,232.913333 316.86,231.96 322.84,231.96 L324.4,231.96 Z M499.8,233 L490.31,300.6 C489.703333,304.846667 488.923333,308.183333 487.97,310.61 C487.016667,313.036667 485.716667,314.791667 484.07,315.875 C482.423333,316.958333 480.256667,317.5 477.57,317.5 C475.663333,317.5 474.103333,317.413333 472.89,317.24 L473.28,315.03 C474.666667,315.203333 476.183333,315.29 477.83,315.29 C479.91,315.29 481.535,314.878333 482.705,314.055 C483.875,313.231667 484.828333,311.78 485.565,309.7 C486.301667,307.62 486.973333,304.543333 487.58,300.47 L497.07,233 L499.8,233 Z M450.56,231.96 C458.62,231.96 465.098333,232.523333 469.995,233.65 C474.891667,234.776667 478.553333,236.813333 480.98,239.76 C483.406667,242.706667 484.62,246.823333 484.62,252.11 C484.62,254.623333 484.446667,256.963333 484.1,259.13 L482.8,268.88 L427.68,268.88 L427.42,270.96 C427.16,272.26 427.03,273.343333 427.03,274.21 C427.03,276.463333 427.571667,278.131667 428.655,279.215 C429.738333,280.298333 431.298333,281.013333 433.335,281.36 C435.371667,281.706667 438.34,281.88 442.24,281.88 L444.71,281.88 C448.956667,281.88 452.185,281.641667 454.395,281.165 C456.605,280.688333 458.165,279.951667 459.075,278.955 C459.985,277.958333 460.57,276.55 460.83,274.73 L460.83,274.47 L482.28,274.47 L482.02,276.42 C481.24,281.793333 479.441667,285.91 476.625,288.77 C473.808333,291.63 469.865,293.623333 464.795,294.75 C459.725,295.876667 453.03,296.44 444.71,296.44 L440.29,296.44 C431.71,296.44 424.928333,295.833333 419.945,294.62 C414.961667,293.406667 411.256667,291.196667 408.83,287.99 C406.403333,284.783333 405.19,280.19 405.19,274.21 C405.19,270.83 405.406667,267.753333 405.84,264.98 L406.1,262.51 C407.313333,253.843333 409.393333,247.343333 412.34,243.01 C415.286667,238.676667 419.381667,235.751667 424.625,234.235 C429.868333,232.718333 437.17,231.96 446.53,231.96 L450.56,231.96 Z M449.65,245.61 L447.05,245.61 C442.456667,245.61 438.968333,245.956667 436.585,246.65 C434.201667,247.343333 432.49,248.47 431.45,250.03 C430.41,251.59 429.673333,253.93 429.24,257.05 L462.91,257.05 L463.17,254.71 C463.343333,254.103333 463.43,253.236667 463.43,252.11 C463.43,250.376667 462.996667,249.055 462.13,248.145 C461.263333,247.235 459.855,246.585 457.905,246.195 C455.955,245.805 453.203333,245.61 449.65,245.61 Z M534.26,296.31 C525.333333,296.31 518.616667,295.985 514.11,295.335 C509.603333,294.685 506.396667,293.45 504.49,291.63 C502.583333,289.81 501.63,286.993333 501.63,283.18 C501.63,281.966667 501.695,280.861667 501.825,279.865 C501.955,278.868333 502.106667,277.806667 502.28,276.68 L505.01,276.68 C504.576667,279.02 504.36,281.1 504.36,282.92 C504.36,286.04 505.205,288.358333 506.895,289.875 C508.585,291.391667 511.488333,292.431667 515.605,292.995 C519.721667,293.558333 525.94,293.84 534.26,293.84 L538.81,293.84 C546.436667,293.84 552.243333,293.363333 556.23,292.41 C560.216667,291.456667 563.033333,289.983333 564.68,287.99 C566.326667,285.996667 567.41,283.136667 567.93,279.41 C568.276667,277.243333 568.45,275.466667 568.45,274.08 C568.45,271.48 567.648333,269.508333 566.045,268.165 C564.441667,266.821667 561.581667,265.89 557.465,265.37 C553.348333,264.85 547.173333,264.546667 538.94,264.46 C530.533333,264.373333 524.141667,263.961667 519.765,263.225 C515.388333,262.488333 512.355,261.34 510.665,259.78 C508.975,258.22 508.13,256.01 508.13,253.15 C508.13,251.85 508.346667,249.856667 508.78,247.17 C509.3,243.183333 510.491667,240.128333 512.355,238.005 C514.218333,235.881667 517.316667,234.365 521.65,233.455 C525.983333,232.545 532.31,232.09 540.63,232.09 L543.88,232.09 C551.333333,232.09 557.096667,232.48 561.17,233.26 C565.243333,234.04 568.19,235.383333 570.01,237.29 C571.83,239.196667 572.74,241.926667 572.74,245.48 C572.74,246.866667 572.566667,248.903333 572.22,251.59 L569.62,251.59 C569.966667,249.163333 570.14,247.17 570.14,245.61 C570.14,242.663333 569.338333,240.41 567.735,238.85 C566.131667,237.29 563.466667,236.185 559.74,235.535 C556.013333,234.885 550.683333,234.56 543.75,234.56 L540.5,234.56 C532.7,234.56 526.828333,234.971667 522.885,235.795 C518.941667,236.618333 516.168333,237.918333 514.565,239.695 C512.961667,241.471667 511.9,244.136667 511.38,247.69 C511.033333,249.943333 510.86,251.633333 510.86,252.76 C510.86,255.186667 511.618333,257.028333 513.135,258.285 C514.651667,259.541667 517.403333,260.43 521.39,260.95 C525.376667,261.47 531.313333,261.773333 539.2,261.86 C547.866667,261.946667 554.431667,262.336667 558.895,263.03 C563.358333,263.723333 566.5,264.893333 568.32,266.54 C570.14,268.186667 571.05,270.613333 571.05,273.82 C571.05,275.206667 570.876667,277.156667 570.53,279.67 C569.923333,284.003333 568.645,287.34 566.695,289.68 C564.745,292.02 561.581667,293.71 557.205,294.75 C552.828333,295.79 546.653333,296.31 538.68,296.31 L534.26,296.31 Z" id="final-logo" fill="#00FF5D" fill-rule="nonzero" opacity="0"></path>
        <path d="M587.970588,316.9 L591.044118,294.738235 L510,294.738235 L514.691176,261.091176 L595.411765,206.9 L632.941176,206.9 L623.720588,272.091176 L639.735294,272.091176 L636.5,294.738235 L620.485294,294.738235 L617.411765,316.9 L587.970588,316.9 Z M538.632353,272.091176 L594.279412,272.091176 L600.102941,230.841176 L599.617647,230.841176 L538.632353,271.605882 L538.632353,272.091176 Z" id="four" fill="#FF4B4B" fill-rule="nonzero"></path>
    </g>
</svg>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- examples/canvas-2d/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Canvas 2d animation / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      width: 100%;
      height: 100%;
      background: #000;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }
  </style>
</head>
<body>
  <canvas></canvas>
</body>
<script type="module" src="./index.js"></script>
</html>


--- examples/clock-playback-controls/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Clock playback controls / anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      font-family: BerkeleyMono-Regular, monospace;
    }
    #clock {
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      width: 40ch;
      height: 20ch;
      padding: 4ch;
      border-radius: 4ch;
/*      background: #202020;*/
    }
    #digital {
      perspective: 1000px;
      display: flex;
      gap: 1ch;
      height: 4ch;
      margin-top: 4ch;
      margin-bottom: 4ch;
    }
    #digital::after {
      content: "";
      display: block;
      position: absolute;
      top: -150%;
      left: -50%;
      width: 200%;
      height: 400%;
      background-image: linear-gradient(180deg, #1a1a1a 10%, #1a1a1a66 30%, #1a1a1a00 40%, #1a1a1a00 60%,#1a1a1a66 70%, #1a1a1a 90%);
    }
    .slot {
      position: relative;
      width: 1ch;
      height: 2ch;
      color: #fff;
      display: flex;
      transform-style: preserve-3d;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 2em;
    }
    .colon {
      transform: translateZ(3ch);
    }
    .numbers > div {
      position: absolute;
      transform-style: preserve-3d;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      backface-visibility: hidden;
      transform-origin: center center 0px;
    }
    #parameters {
      position: fixed;
      right: 0;
      top: 0;
      width: 100%;
      padding: 3ch;
    }
    fieldset {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: .5ch;
      margin-bottom: 1ch;
    }
    fieldset > input {
      min-width: 0;
      border-radius: .1ch;
      accent-color: white;
      color: white;
      text-align: right;
      background: transparent;
    }
    fieldset > label {
      flex-shrink: 0;
      width: 10ch;
    }
    fieldset > .value {
      width: 16ch;
    }
    fieldset > .range {
      width: 100%;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      position: fixed;
      bottom: 0;
      width: 100%;
      padding: 3ch;
    }
    #controls button {
      width: 20%;
      flex-grow: 1;
      flex-shrink: 0;
      height: 4ch;
      min-width: 0;
      border-radius: 1ch;
      margin: .5ch;
      background-color: #2A2A2A;
      color: #FFF;
    }
    #controls button:hover {
      background-color: #3A3A3A;
    }
    #controls button:focus {
      background-color: #FFF;
      color: #2A2A2A;
    }
  </style>
</head>
<body>
  <div id="clock">
    <div id="digital"></div>
  </div>
  <div id="parameters">
    <fieldset id="currentTime">
      <label>currentTime</label>
      <input class="value" type="text" />
      <input class="range" type="range" min="0" max="86400000" step="1" />
    </fieldset>
    <fieldset id="speed">
      <label>speed</label>
      <input class="value" type="text" value="1" />
      <input class="range" type="range" min=".01" max="2" step=".01" value="1" />
    </fieldset>
  </div>
  <div id="controls">
    <button id="play">PLAY</button>
    <button id="pause">PAUSE</button>
    <button id="reverse">REVERSE</button>
    <button id="alternate">ALTERNATE</button>
    <button id="slowmo">SLOW MO</button>
    <button id="speedup">SPEED UP</button>
    <button id="normalspeed">NORMAL SPEED</button>
    <button id="reset">RESET</button>
    <button id="resume">RESUME</button>
    <button id="seek">SEEK</button>
    <button id="complete">COMPLETE</button>
    <button id="restart">RESTART</button>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- examples/draggable-infinite-auto-carousel/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Draggable infinite auto carousel / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    * {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      user-select: none;
    }
    body, html {
      overflow: hidden;
      background: #000;
    }
    #infinite-carousel {
      --spacing: 30px;
      display: hidden;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    .carousel {
      display: flex;
      height: 100%;
      padding: var(--spacing) 0;
      will-change: transform;
    }
    .carousel-item {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 25vw;
      flex-shrink: 0;
      width: 100%;
      height: 100%;
      margin-right: var(--spacing);
      background-color: var(--red);
      border-radius: var(--spacing);
      list-style: none;
    }
  </style>
</head>
<body>
  <div id="infinite-carousel">
    <ul class="carousel">
      <li class="draggable carousel-item" style="width: 35vw">1</li>
      <li class="draggable carousel-item" style="width: 60vw">2</li>
      <li class="draggable carousel-item" style="width: 85vw">3</li>
      <li class="draggable carousel-item" style="width: 60vw">4</li>
    </ul>
  </div>
  <script src="./index.js" type="module"></script>
</body>

</html>


--- examples/draggable-mouse-scroll-snap-carousel/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Draggable mouse scroll snap carousel / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    * {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      user-select: none;
    }
    body, html {
      overflow: hidden;
      background: #000;

    }
    #snap-carousel {
      --spacing: 30px;
      overflow: visible;
      position: absolute;
      top: 0;
      left: 100px;
      width: calc(100% - 200px);
      height: 100%;
    }
    .carousel {
      overflow: visible;
      display: flex;
      justify-content: flex-start;
      height: 100%;
      padding: var(--spacing) 0;
      will-change: transform;
    }
    .carousel-item {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 15vw;
      flex-shrink: 0;
      width: calc(50% - (var(--spacing) * 1.5));
      height: 100%;
      margin-left: var(--spacing);
      background-color: var(--red);
      border-radius: var(--spacing);
      list-style: none;
      will-change: transform;
    }
  </style>
</head>
<body>
  <div id="snap-carousel">
    <ul class="carousel">
      <li class="draggable carousel-item">1</li>
      <li class="draggable carousel-item">2</li>
      <li class="draggable carousel-item">3</li>
      <li class="draggable carousel-item">4</li>
      <li class="draggable carousel-item">5</li>
      <li class="draggable carousel-item">6</li>
      <li class="draggable carousel-item">7</li>
      <li class="draggable carousel-item">8</li>
    </ul>
  </div>
  <script src="./index.js" type="module"></script>
</body>

</html>


--- examples/draggable-playground/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Draggable playground / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>

    body {
      --one-cell: 100px;
      --border-color: rgba(255,255,255,.75);
    }

    .grid::before {
      content: "";
      pointer-events: none;
      position: absolute;
      z-index: 0;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(-90deg, rgba(255,255,255,.05) 1px, transparent 1px), linear-gradient(rgba(255,255,255,.05) 1px, transparent 1px), linear-gradient(-90deg, rgba(255,255,255,.04) 1px, transparent 1px), linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px), linear-gradient(transparent 3px, var(--black-1) 3px, var(--black-1) calc(var(--one-cell) - 2px), transparent calc(var(--one-cell) - 2px)), linear-gradient(-90deg, var(--white-1) 1px, transparent 1px), linear-gradient(-90deg, transparent 3px, var(--black-1) 3px, var(--black-1) calc(var(--one-cell) - 2px), transparent calc(var(--one-cell) - 2px)), linear-gradient(var(--white-1) 1px, transparent 1px), var(--black-1);
      background-size: calc(var(--one-cell) / 10) calc(var(--one-cell) / 10), calc(var(--one-cell) / 10) calc(var(--one-cell) / 10), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell);
      background-position: calc(var(--one-cell) * .25) -1px;
    }

    #draggables {
      overflow: hidden;
      position: relative;
      display: flex;
      flex-grow: 1;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: flex-start;
      padding: 0 0 var(--one-cell) 0;
      transform-origin: 50% 0% 0px;
      will-change: transform;
    }

    .example {
      position: relative;
      min-width: calc(var(--one-cell) * 1);
      margin: calc(var(--one-cell) * .25);
      margin-bottom: 0;
    }

    @media (min-width: 500px) {
      #draggables.grid {
        padding-bottom: calc(var(--one-cell) * 1);
      }
      #draggables.grid:before {
        width: calc(100% + calc(var(--one-cell) * .5));
        left: calc(var(--one-cell) * -.5);
        background-position: calc(var(--one-cell) * 1) -1px;
      }
      .example {
        margin: calc(var(--one-cell) * .5);
        margin-bottom: 0;
      }
    }

    .example h2 {
      font-family: Input Mono;
      height: calc(var(--one-cell) * .5);
      padding-top: 15px;
      padding-bottom: 15px;
    }

    .example-content {
      display: flex;
      justify-content: flex-start;
      width: 100%;
    }

    .example-content-vertical {
      flex-direction: column;
    }

    .draggable {
      display: flex;
      position: relative;
      z-index: 100;
    }

    .draggable::after {
      content: "";
      display: block;
      pointer-events: none;
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin-left: -10px;
      margin-top: -10px;
      background-size: 5px 5px;
      background-image:
        radial-gradient(circle at center, var(--black-1) 1px, transparent 0),
        radial-gradient(circle at center, var(--black-1) 1px, transparent 0);
    }

    .carousel .draggable {
      padding-top: 1rem;
      padding-left: 1rem;
      color: var(--black-1);
    }

    .rectangle {
      width: calc(var(--one-cell) * 2);
      height: calc(var(--one-cell) * 1);
      background-color: var(--red);
      border-radius: 20px;
    }

    .square {
      width: calc(var(--one-cell) * .8);
      height: calc(var(--one-cell) * .8);
      background-color: var(--red);
      border-radius: 20px;
    }

    .bar {
      overflow: hidden;
      width: calc(var(--one-cell) * .1);
      height: calc(var(--one-cell) * .8);
      background-color: var(--red);
      border-radius: 20px;
    }

    .margin {
      position: relative;
      z-index: 1;
      box-shadow: 0 0 0 1px var(--border-color);
      border-radius: 20px;
      padding: 10px;
    }

    .margin:before {
      content: "";
      pointer-events: none;
      display: block;
      position: absolute;
      z-index: 2;
      left: 10px;
      top: 10px;
      width: calc(100% - 20px);
      height: calc(100% - 20px);
      border: 1px dashed rgba(255,255,255,.25);
      border-radius: 10px;
    }

    .margin-overlay {
      position: absolute;
      pointer-events: none;
      z-index: 3;
      top: calc(var(--one-cell) * .5);
      left: 0;
      width: 100%;
      height: calc(100% - calc(var(--one-cell) * .5));
    }

    .margin-overlay + .margin:before {
      display: none;
    }

    .margin-overlay + .margin {
      box-shadow: none;
    }

    .margin .draggable {
      background-color: var(--red);
      border-radius: 10px;
    }

    .range-x {
      width: calc(var(--one-cell) * 3);
      height: calc(var(--one-cell) * 1);
    }

    .range-y {
      width: calc(var(--one-cell) * 1);
      height: calc(var(--one-cell) * 3);
    }

    .dynamic {
      width: calc(var(--one-cell) * 3);
      height: calc(var(--one-cell) * 1);
    }

    .dynamic .square,
    .dynamic .bar {
      position: absolute;
      left: 0;
      top: 0;
    }

    .dynamic .bar-left {
      left: 0;
      right: auto;
      border-radius: 10px 0 0 10px;
    }

    .dynamic .bar-right {
      left: auto;
      right: 0;
      border-radius: 0 10px 10px 0;
    }

    .container {
      overflow: hidden;
      width: calc((var(--one-cell) * 3));
      height: calc((var(--one-cell) * 3));
    }

    .container.overflow {
      overflow: auto;
      overscroll-behavior: contain;
    }

    #fixed-container {
      width: calc((var(--one-cell) * 2));
      height: calc((var(--one-cell) * 1));
      box-shadow: 0 0 0 1px var(--border-color);
      border-radius: 20px;
    }

    #fixed {
      position: fixed;
      top: calc((var(--one-cell) * .75));
      left: calc((var(--one-cell) * .25));
      box-shadow: 0 0 1rem 0 rgba(0,0,0,.2);
    }

    @media (min-width: 500px) {
      #fixed {
        position: fixed;
        top: calc((var(--one-cell) * 1));
        left: calc((var(--one-cell) * .5));
      }
    }

    #container-no-scroll {
      overflow: visible;
      z-index: 2;
    }

    .transformed-example {
      transform: scaleY(.75) scaleX(.75) rotate(-40deg) skew(15deg);
    }

    .transformed-example .margin-overlay {
      top: 0;
      width: calc((var(--one-cell) * 3));
      height: calc((var(--one-cell) * 3));
    }

    .scroller,
    .scroller:before {
      width: calc((var(--one-cell) * 8) - 20px);
      height: calc((var(--one-cell) * 8) - 20px);
    }

    .list {
      position: relative;
      overflow: visible;
      width: 100%;
      height: calc((var(--one-cell) * 3) - 20px);
    }

    .list-item {
      position: absolute;
      width: 100%;
      height: calc(var(--one-cell) * .5);
    }

    .carousel {
      display: flex;
      position: relative;
      overflow: visible;
      width: 100%;
      height: calc((var(--one-cell) * 3) - 20px);
    }

    .carousel-buttons {
      position: fixed;
      bottom: .5rem;
      left: 2rem;
      right: 2rem;
      z-index: 1;
      display: flex;
      justify-content: space-between;
    }

    .button {
      padding: .25em .5em;
      border-radius: 10px;
      cursor: pointer;
    }

    .carousel-item {
      width: calc((var(--one-cell) * 3) - 20px);
      height: calc((var(--one-cell) * 3) - 20px);
    }

    .carousel-item:nth-child(even),
    .list-item:nth-child(even) {
      background-color: var(--yellow);
    }

    .carousel-link {
      display: block;
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      bottom: 20px;
      border: 2px dotted var(--red);
    }

    #snap-carousel {
      display: flex;
      overflow: hidden;
    }

    #snap-carousel .carousel {
      display: flex;
      flex-shrink: 0;
      width: auto;
    }

    #snap-carousel .carousel-item {
      flex-shrink: 0;
      width: 100px;
    }

    #snap-carousel .carousel-item:nth-child(2n) {
      width: 200px;
    }

    #snap-carousel .carousel-item:nth-child(4n) {
      width: 280px;
    }

    .flicker .carousel-item:not(:last-child) {
      margin-right: 10px;
    }

    #map-props {
      overflow: initial;
      perspective: 1000px;
      touch-action: pan-x;
      width: 100%;
      height: calc((var(--one-cell) * 1));
      margin-top: 2rem;
      margin-bottom: 2rem;
    }

    #map-props .carousel {
      position: relative;
      transform-style: preserve-3d;
      height: 100%;
    }

    #map-props .carousel-item {
      pointer-events: none;
      position: absolute;
      transform-style: preserve-3d;
      left: 0;
      top: 0;
      width: min(25%, 105px);
      height: calc((var(--one-cell) * 1));
      border-radius: 10px;
      background: var(--yellow);
      backface-visibility: hidden;
    }

/*    #map-props .carousel-item:after {
      transform: scale(2.75);
    }*/

    .form {
      top: 62px;
      left: 60px;
      background: var(--black-1);
      padding: 20px;
      box-shadow: 0 0 0 1px var(--red);
    }

    .trigger {
      position: absolute;
      width: calc(var(--one-cell) * 3.2);
      height: calc(var(--one-cell) * 3.2);
      margin-left: calc(var(--one-cell) * -1.2);
      margin-top: calc(var(--one-cell) * -1.2);
      background: var(--yellow);
    }

    #onsnap-callback {
      z-index: 3;
    }

    /* Drawer */

    #toggle-drawer {
      position: absolute;
      z-index: 1;
      top: .5em;
      right: .5em;
      left: .5em;
      bottom: .5em;
      border-radius: .75em;
      width: auto;
      height: auto;
    }

    .drawer {
      overscroll-behavior: contain;
      position: fixed;
      z-index: 999;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      border-top-left-radius: .5rem;
      border-top-right-radius: .5rem;
      background-color: var(--red);
      will-change: transform;
      box-shadow: 0 500px 0 0 var(--red);
    }

    .drawer-content {
      overflow: auto;
      overscroll-behavior: contain;
      position: relative;
      z-index: 0;
      max-height: calc(100svh - 2rem);
      padding: 3rem 2rem;
    }

    .drawer-trigger {
      position: absolute;
      z-index: 1;
      width: 100%;
      height: 3rem;
      background-color: var(--red);
      border-top-left-radius: .5rem;
      border-top-right-radius: .5rem;
    }

    .drawer-trigger::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      display: block;
      width: 5rem;
      height: .25rem;
      border-radius: .25rem;
      background-color: #FFF;
      transform: translate3d(-50%,-50%, 0);
    }

    .drawer-content p,
    .drawer-content button {
      margin-bottom: 10px;
    }

    #nested-draggable {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: var(--yellow);
      margin-bottom: 10px;
      border-radius: .5rem;
    }

  </style>
</head>
<body>
  <div id="draggables" class="grid">
    <div class="example">
      <h2>Fixed (vel: <span id="log">0</span>)</h2>
      <div id="fixed-container" class="example-content">
        <div id="fixed" class="draggable rectangle">
          <button id="toggle-drawer" class="button"><span>Toggle Drawer</span></button>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Snap</h2>
      <div class="example-content example-content-vertical">
        <div id="body-snap" class="draggable rectangle"></div>
      </div>
    </div>
    <div class="example">
      <h2>Snap X</h2>
      <div class="example-content example-content-vertical">
        <div class="range margin range-x">
          <div class="draggable square"></div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Snap Y</h2>
      <div class="example-content">
        <div class="range margin range-y">
          <div class="draggable square"></div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Container</h2>
      <div class="example-content example-content-vertical">
        <div id="container-no-scroll" class="container margin">
          <div class="draggable square"></div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Container auto scroll</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="container-scroll" class="container margin overflow">
          <div class="scroller grid">
            <div class="draggable square"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Transformed container</h2>
      <div class="example-content example-content-vertical transformed-example">
        <div class="margin margin-overlay"></div>
        <div id="transformed-container" class="container overflow margin">
          <div class="scroller grid">
            <div class="draggable square"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Snap carousel</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="snap-carousel" class="flicker container margin">
          <ul class="carousel">
            <a href="https://animejs.com" target="_blank" class="draggable carousel-item"></a>
            <li class="draggable carousel-item"><a href="https://animejs.com" target="_blank" class="carousel-link"></a></li>
            <a href="https://animejs.com" target="_blank" class="draggable carousel-item"></a>
            <li class="draggable carousel-item"><a href="https://animejs.com" target="_blank" class="carousel-link"></a></li>
            <a href="https://animejs.com" target="_blank" class="draggable carousel-item"></a>
            <li class="draggable carousel-item"><a href="https://animejs.com" target="_blank" class="carousel-link"></a></li>
            <a href="https://animejs.com" target="_blank" class="draggable carousel-item"></a>
            <li class="draggable carousel-item"><a href="https://animejs.com" target="_blank" class="carousel-link"></a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Bounded flick</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="bounded-flick" class="flicker container margin">
          <ul class="carousel">
            <li class="draggable carousel-item"></li>
            <li class="draggable carousel-item"></li>
            <li class="draggable carousel-item"></li>
            <li class="draggable carousel-item"></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Object target</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="infinite-flick" class="flicker container margin">
          <ul class="carousel">
            <li class="draggable carousel-item">1</li>
            <li class="draggable carousel-item">2</li>
            <li class="draggable carousel-item">1</li>
            <li class="draggable carousel-item">2</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>onSnap() callback</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="onsnap-callback" class="container margin overflow">
          <ul class="list">
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="example">
      <h2>Array container</h2>
      <div class="example-content example-content-vertical">
        <div id="array-container" class="container margin">
          <div class="draggable square"></div>
        </div>
      </div>
    </div>

    <div class="example">
      <h2>Dynamic padding</h2>
      <div class="example-content example-content-vertical">
        <div class="range margin dynamic">
          <div class="draggable bar bar-left"></div>
          <div class="draggable bar bar-right"></div>
          <div class="draggable square"></div>
        </div>
      </div>
    </div>

  </div>

  <div class="drawer">
    <div id="nested-draggable" class="draggable square"></div>
    <div class="drawer-trigger"></div>
    <div class="drawer-content">
      <div id="map-props">
        <ul class="carousel">
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
        </ul>
      </div>
      <fieldset class="carousel-buttons">
        <button class="button carousel-prev">PREV</button>
        <button class="button carousel-next">NEXT</button>
      </fieldset>
      <p>
        This is the drawer content. <a href="https://animejs.com">This is a link with a <span>span</span>.</a> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar.
      </p>
      <p>
        This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar.
      </p>
      <p>
        This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar.
      </p>
      <p>
        This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar.
      </p>
    </div>
  </div>

  <script src="./index.js" type="module"></script>

</body>

</html>


## Links discovered
- [link](https://animejs.com)
- [This is a link with a <span>span</span>.](https://animejs.com)

--- tests/playground/waapi/composition/index.html ---
<!DOCTYPE html>
<html>
  <head>
    <title>WAAPI Composition tests / anime.js</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="../../assets/css/styles.css" rel="stylesheet">
    <style>
      body {
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
        flex-direction: row;
        width: 100%;
        height: 100vh;
      }
      .container {
        font-size: 2vw;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: row;
        flex-wrap: wrap;
        width: 10em;
        height: 10em;
      }
      .square {
        position: relative;
        width: 1em;
        height: 1em;
        border-radius: 0px;
        background-color: currentColor;
      }
      .container-A .square {
        color: var(--red);
      }
      .container-B .square {
        color: var(--orange-1);
      }
      .container-C .square {
        color: var(--yellow);
      }
    </style>
  </head>
  <body>
    <div class="container container-A">
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
    </div>
    <div class="container container-B">
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
    </div>
    <div class="container container-C">
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
    </div>
    <script type="module" src="./index.js"></script>
  </body>
</html>

--- tests/playground/waapi/eases/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>WAAPI eases tests / anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      width: 100%;
      height: 100vh;
    }
    #demo {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    .animation {
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      width: 100%;
      height: 100%;
    }
    .square {
      --border-radius: 10px;
      position: absolute;
      width: 5rem;
      height: 5rem;
      top: 50%;
      left: 50%;
      margin-top: -2.5rem;
      margin-left: -2.5rem;
      background-color: currentColor;
    }
  </style>
</head>
<body>
  <div id="demo">
    <div class="animation"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/waapi/playback/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>WAAPI tests / anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      width: 100%;
      height: 200vh;
    }
    #demo {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    #animation {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      width: 100%;
      margin-bottom: 10rem;
    }
    .square {
      --bg: var(--green-1);
      position: relative;
      width: 4rem;
      height: 4rem;
      margin: .5rem;
      background-color: currentColor;
    }
    #controls-panel {
      position: fixed;
      top: 2rem;
      right: 2rem;
    }
  </style>
</head>
<body>
  <div id="demo">
    <div id="controls-panel">
      <fieldset>
        <legend>Animation</legend>
        <label for="animation-playbackRate">Playback rate</label>
        <input type="range" id="animation-playbackRate" name="animation-playbackRate" value="1" min="0" max="2" step=".01">
        <input type="text" id="animation-speed" value="1">
        <br>
        <label for="animation-time-drift">Time drift</label>
        <input type="text" id="animation-time-drift" value="0">
        <br>
        <label for="animation-currentTime">Current time</label>
        <input type="range" id="animation-progress" name="animation-progress" value="0" min="0" max="1" step=".0001">
        <input type="text" id="animation-currentTime" value="0">
        <br>
        <input type="button" id="animation-play" value="play">
        <input type="button" id="animation-reverse" value="reverse">
        <input type="button" id="animation-pause" value="pause">
        <input type="button" id="animation-alternate" value="alternate">
        <input type="button" id="animation-resume" value="resume">
        <input type="button" id="animation-cancel" value="cancel">
        <input type="button" id="animation-revert" value="revert">
        <input type="button" id="animation-restart" value="restart">
      </fieldset>
    </div>
    <div id="animation">
      <div class="square red"></div>
      <div class="square red"></div>
      <div class="square red"></div>
      <div class="square red"></div>
      <div class="square red"></div>
      <div class="square red"></div>
      <div class="square red"></div>
      <div class="square red"></div>
      <div class="square red"></div>
      <div class="square red"></div>
      <div class="square red"></div>
    </div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/waapi/values/index.html ---
<!DOCTYPE html>
<html>
  <head>
    <title>WAAPI values stress test / anime.js</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="../../assets/css/styles.css" rel="stylesheet">
    <style>
      body {
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
        flex-direction: row;
        width: 100%;
        height: 100vh;
      }
      .container {
        font-size: 2vw;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: row;
        flex-wrap: wrap;
        width: 10em;
        height: 10em;
      }
      .square {
        position: relative;
        width: 1em;
        height: 1em;
        border-radius: 0px;
        background-color: currentColor;
        color: var(--red);
      }
    </style>
  </head>
  <body>
    <div class="container container-A">
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
    </div>
    <div class="container container-B">
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
    </div>
    <div class="container container-C">
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
      <div class="square"></div>
    </div>
    <script type="module" src="./index.js"></script>
  </body>
</html>

--- src/waapi/composition.js ---
import { addChild, removeChild } from "../core/helpers.js";

/**
 * @import {
 *   DOMTarget,
 * } from '../types/index.js'
*/

/**
 * @import {
 *   WAAPIAnimation,
 * } from '../waapi/waapi.js'
*/

const WAAPIAnimationsLookups = {
  _head: null,
  _tail: null,
}

/**
 * @param {DOMTarget} $el
 * @param {String} [property]
 * @param {WAAPIAnimation} [parent]
 * @return {globalThis.Animation}
 */
export const removeWAAPIAnimation = ($el, property, parent) => {
  let nextLookup = WAAPIAnimationsLookups._head;
  let anim;
  while (nextLookup) {
    const next = nextLookup._next;
    const matchTarget = nextLookup.$el === $el;
    const matchProperty = !property || nextLookup.property === property;
    const matchParent = !parent || nextLookup.parent === parent;
    if (matchTarget && matchProperty && matchParent) {
      anim = nextLookup.animation;
      try { anim.commitStyles(); } catch {};
      anim.cancel();
      removeChild(WAAPIAnimationsLookups, nextLookup);
      const lookupParent = nextLookup.parent;
      if (lookupParent) {
        lookupParent._completed++;
        if (lookupParent.animations.length === lookupParent._completed) {
          lookupParent.completed = true;
          lookupParent.paused = true;
          if (!lookupParent.muteCallbacks) {
            lookupParent.onComplete(lookupParent);
            lookupParent._resolve(lookupParent);
          }
        }
      }
    }
    nextLookup = next;
  }
  return anim;
}

/**
 * @param {WAAPIAnimation} parent
 * @param {DOMTarget} $el
 * @param {String} property
 * @param {PropertyIndexedKeyframes} keyframes
 * @param {KeyframeAnimationOptions} params
 * @retun {globalThis.Animation}
 */
export const addWAAPIAnimation = (parent, $el, property, keyframes, params) => {
  const animation = $el.animate(keyframes, params);
  const animTotalDuration = params.delay + (+params.duration * params.iterations);
  animation.playbackRate = parent._speed;
  if (parent.paused) animation.pause();
  if (parent.duration < animTotalDuration) {
    parent.duration = animTotalDuration;
    parent.controlAnimation = animation;
  }
  parent.animations.push(animation);
  removeWAAPIAnimation($el, property);
  addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });
  const handleRemove = () => { removeWAAPIAnimation($el, property, parent); };
  animation.oncancel = handleRemove;
  animation.onremove = handleRemove;
  if (!parent.persist) {
    animation.onfinish = handleRemove;
  }
  return animation;
}


--- dist/modules/index.js ---
/**
 * Anime.js - ESM
 * @version v4.3.0
 * @license MIT
 * @copyright 2026 - Julian Garnier
 */

export { Timer, createTimer } from './timer/timer.js';
export { JSAnimation, animate } from './animation/animation.js';
export { Timeline, createTimeline } from './timeline/timeline.js';
export { Animatable, createAnimatable } from './animatable/animatable.js';
export { Draggable, createDraggable } from './draggable/draggable.js';
export { Scope, createScope } from './scope/scope.js';
export { ScrollObserver, onScroll, scrollContainers } from './events/scroll.js';
export { engine } from './engine/engine.js';
import * as index from './easings/index.js';
export { index as easings };
export { AutoLayout, createLayout } from './layout/layout.js';
import * as index$1 from './utils/index.js';
export { index$1 as utils };
import * as index$2 from './svg/index.js';
export { index$2 as svg };
import * as index$3 from './text/index.js';
export { index$3 as text };
export { WAAPIAnimation, waapi } from './waapi/waapi.js';
export { cubicBezier } from './easings/cubic-bezier/index.js';
export { steps } from './easings/steps/index.js';
export { linear } from './easings/linear/index.js';
export { irregular } from './easings/irregular/index.js';
export { Spring, createSpring, spring } from './easings/spring/index.js';
export { eases } from './easings/eases/parser.js';
export { clamp, damp, degToRad, lerp, mapRange, padEnd, padStart, radToDeg, round, roundPad, snap, wrap } from './utils/chainable.js';
export { createSeededRandom, random, randomPick, shuffle } from './utils/random.js';
export { keepTime, sync } from './utils/time.js';
export { cleanInlineStyles } from './core/styles.js';
export { registerTargets as $ } from './core/targets.js';
export { get, remove, set } from './utils/target.js';
export { stagger } from './utils/stagger.js';
export { createMotionPath } from './svg/motionpath.js';
export { createDrawable } from './svg/drawable.js';
export { morphTo } from './svg/morphto.js';
export { TextSplitter, split, splitText } from './text/split.js';


--- src/waapi/index.js ---
export * from './waapi.js';

--- dist/modules/index.d.ts ---
export * from "./timer/index.js";
export * from "./animation/index.js";
export * from "./timeline/index.js";
export * from "./animatable/index.js";
export * from "./draggable/index.js";
export * from "./scope/index.js";
export * from "./events/index.js";
export * from "./engine/index.js";
export * from "./easings/index.js";
export * from "./layout/index.js";
export * from "./utils/index.js";
export * from "./svg/index.js";
export * from "./text/index.js";
export * from "./waapi/index.js";
export * from "./types/index.js";
export * as easings from "./easings/index.js";
export * as utils from "./utils/index.js";
export * as svg from "./svg/index.js";
export * as text from "./text/index.js";


--- src/waapi/waapi.js ---
import {
  isArr,
  isKey,
  isNum,
  isObj,
  isStr,
  isUnd,
  isFnc,
  stringStartsWith,
  toLowerCase,
  isNil,
  round,
} from '../core/helpers.js';

import {
  scope,
  globals,
} from '../core/globals.js';

import {
  registerTargets,
} from '../core/targets.js';

import {
  getFunctionValue,
  setValue,
} from '../core/values.js';

import {
  isBrowser,
  K,
  noop,
  emptyString,
  shortTransforms,
  transformsFragmentStrings,
  transformsSymbol,
  validTransforms,
} from '../core/consts.js';

import {
  none,
} from '../easings/none.js';

import {
  parseEaseString,
} from '../easings/eases/parser.js';

import {
  addWAAPIAnimation,
} from './composition.js';

/**
 * @import {
 *   Callback,
 *   EasingFunction,
 *   EasingParam,
 *   DOMTarget,
 *   DOMTargetsParam,
 *   DOMTargetsArray,
 *   WAAPIAnimationParams,
 *   WAAPITweenOptions,
 *   WAAPIKeyframeValue,
 *   WAAPITweenValue
 * } from '../types/index.js'
*/

/**
 * @import {
 *   Spring,
 * } from '../easings/spring/index.js'
*/

/**
 * @import {
 *   ScrollObserver,
 * } from '../events/scroll.js'
*/

/**
 * Converts an easing function into a valid CSS linear() timing function string
 * @param {EasingFunction} fn
 * @param {number} [samples=100]
 * @returns {string} CSS linear() timing function
 */
const easingToLinear = (fn, samples = 100) => {
  const points = [];
  for (let i = 0; i <= samples; i++) points.push(round(fn(i / samples), 4));
  return `linear(${points.join(', ')})`;
}

const WAAPIEasesLookups = {}

/**
 * @param  {EasingParam} ease
 * @return {String}
 */
const parseWAAPIEasing = (ease) => {
  let parsedEase = WAAPIEasesLookups[ease];
  if (parsedEase) return parsedEase;
  parsedEase = 'linear';
  if (isStr(ease)) {
    if (
      stringStartsWith(ease, 'linear') ||
      stringStartsWith(ease, 'cubic-') ||
      stringStartsWith(ease, 'steps') ||
      stringStartsWith(ease, 'ease')
    ) {
      parsedEase = ease;
    } else if (stringStartsWith(ease, 'cubicB')) {
      parsedEase = toLowerCase(ease);
    } else {
      const parsed = parseEaseString(ease);
      if (isFnc(parsed)) parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);
    }
    // Only cache string based easing name, otherwise function arguments get lost
    WAAPIEasesLookups[ease] = parsedEase;
  } else if (isFnc(ease)) {
    const easing = easingToLinear(ease);
    if (easing) parsedEase = easing;
  } else if (/** @type {Spring} */(ease).ease) {
    parsedEase = easingToLinear(/** @type {Spring} */(ease).ease);
  }
  return parsedEase;
}

const transformsShorthands = ['x', 'y', 'z'];
const commonDefaultPXProperties = [
  'perspective',
  'width',
  'height',
  'margin',
  'padding',
  'top',
  'right',
  'bottom',
  'left',
  'borderWidth',
  'fontSize',
  'borderRadius',
  ...transformsShorthands
]

const validIndividualTransforms = /*#__PURE__*/ (() => [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))])();

let transformsPropertiesRegistered = null;

/**
 * @param  {String} propName
 * @param  {WAAPIKeyframeValue} value
 * @param  {DOMTarget} $el
 * @param  {Number} i
 * @param  {Number} targetsLength
 * @return {String}
 */
const normalizeTweenValue = (propName, value, $el, i, targetsLength) => {
  // Do not try to compute strings with getFunctionValue otherwise it will convert CSS variables
  let v = isStr(value) ? value : getFunctionValue(/** @type {any} */(value), $el, i, targetsLength);
  if (!isNum(v)) return v;
  if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate')) return `${v}px`;
  if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew')) return `${v}deg`;
  return `${v}`;
}

/**
 * @param  {DOMTarget} $el
 * @param  {String} propName
 * @param  {WAAPIKeyframeValue} from
 * @param  {WAAPIKeyframeValue} to
 * @param  {Number} i
 * @param  {Number} targetsLength
 * @return {WAAPITweenValue}
 */
const parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {
  /** @type {WAAPITweenValue} */
  let tweenValue = '0';
  const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];
  if (!isUnd(from)) {
    const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);
    tweenValue = [computedFrom, computedTo];
  } else {
    tweenValue = isArr(to) ? to.map((/** @type {any} */v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;
  }
  return tweenValue;
}

export class WAAPIAnimation {
/**
 * @param {DOMTargetsParam} targets
 * @param {WAAPIAnimationParams} params
 */
  constructor(targets, params) {

    if (scope.current) scope.current.register(this);

    // Skip the registration and fallback to no animation in case CSS.registerProperty is not supported
    if (isNil(transformsPropertiesRegistered)) {
      if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'))) {
        transformsPropertiesRegistered = false;
      } else {
        validTransforms.forEach(t => {
          const isSkew = stringStartsWith(t, 'skew');
          const isScale = stringStartsWith(t, 'scale');
          const isRotate = stringStartsWith(t, 'rotate');
          const isTranslate = stringStartsWith(t, 'translate');
          const isAngle = isRotate || isSkew;
          const syntax = isAngle ? '<angle>' : isScale ? "<number>" : isTranslate ? "<length-percentage>" : "*";
          try {
            CSS.registerProperty({
              name: '--' + t,
              syntax,
              inherits: false,
              initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0',
            });
          } catch {};
        });
        transformsPropertiesRegistered = true;
      }
    }

    const parsedTargets = registerTargets(targets);
    const targetsLength = parsedTargets.length;

    if (!targetsLength) {
      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
    }

    const autoplay = setValue(params.autoplay, globals.defaults.autoplay);
    const scroll = autoplay && /** @type {ScrollObserver} */(autoplay).link ? autoplay : false;
    const alternate = params.alternate && /** @type {Boolean} */(params.alternate) === true;
    const reversed = params.reversed && /** @type {Boolean} */(params.reversed) === true;
    const loop = setValue(params.loop, globals.defaults.loop);
    const iterations = /** @type {Number} */((loop === true || loop === Infinity) ? Infinity : isNum(loop) ? loop + 1 : 1);
    /** @type {PlaybackDirection} */
    const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';
    /** @type {FillMode} */
    const fill = 'both'; // We use 'both' here because the animation can be reversed during playback
    const timeScale = (globals.timeScale === 1 ? 1 : K);

    /** @type {DOMTargetsArray}] */
    this.targets = parsedTargets;
    /** @type {Array<globalThis.Animation>}] */
    this.animations = [];
    /** @type {globalThis.Animation}] */
    this.controlAnimation = null;
    /** @type {Callback<this>} */
    this.onComplete = params.onComplete || /** @type {Callback<WAAPIAnimation>} */(/** @type {unknown} */(globals.defaults.onComplete));
    /** @type {Number} */
    this.duration = 0;
    /** @type {Boolean} */
    this.muteCallbacks = false;
    /** @type {Boolean} */
    this.completed = false;
    /** @type {Boolean} */
    this.paused = !autoplay || scroll !== false;
    /** @type {Boolean} */
    this.reversed = reversed;
    /** @type {Boolean} */
    this.persist = setValue(params.persist, globals.defaults.persist);
    /** @type {Boolean|ScrollObserver} */
    this.autoplay = autoplay;
    /** @type {Number} */
    this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);
    /** @type {Function} */
    this._resolve = noop; // Used by .then()
    /** @type {Number} */
    this._completed = 0;
    /** @type {Array.<Object>} */
    this._inlineStyles = [];

    parsedTargets.forEach(($el, i) => {

      const cachedTransforms = $el[transformsSymbol];
      const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));
      const elStyle = $el.style;
      const inlineStyles = this._inlineStyles[i] = {};

      const easeToParse = setValue(params.ease, globals.defaults.ease);

      const easeFunctionResult = getFunctionValue(easeToParse, $el, i, targetsLength);
      const keyEasing = isFnc(easeFunctionResult) || isStr(easeFunctionResult) ? easeFunctionResult : easeToParse;

      const spring = /** @type {Spring} */(easeToParse).ease && easeToParse;
      /** @type {String} */
      const easing = parseWAAPIEasing(keyEasing);

      /** @type {Number} */
      const duration = (spring ? /** @type {Spring} */(spring).settlingDuration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;
      /** @type {Number} */
      const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;
      /** @type {CompositeOperation} */
      const composite = /** @type {CompositeOperation} */(setValue(params.composition, 'replace'));

      for (let name in params) {
        if (!isKey(name)) continue;
        /** @type {PropertyIndexedKeyframes} */
        const keyframes = {};
        /** @type {KeyframeAnimationOptions} */
        const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };
        const propertyValue = params[name];
        const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;

        const styleName = individualTransformProperty ? 'transform' : name;
        if (!inlineStyles[styleName]) {
          inlineStyles[styleName] = elStyle[styleName];
        }

        let parsedPropertyValue;
        if (isObj(propertyValue)) {
          const tweenOptions = /** @type {WAAPITweenOptions} */(propertyValue);
          const tweenOptionsEase = setValue(tweenOptions.ease, easing);
          const tweenOptionsSpring = /** @type {Spring} */(tweenOptionsEase).ease && tweenOptionsEase;
          const to = /** @type {WAAPITweenOptions} */(tweenOptions).to;
          const from = /** @type {WAAPITweenOptions} */(tweenOptions).from;
          /** @type {Number} */
          tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */(tweenOptionsSpring).settlingDuration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;
          /** @type {Number} */
          tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;
          /** @type {CompositeOperation} */
          tweenParams.composite = /** @type {CompositeOperation} */(setValue(tweenOptions.composition, composite));
          /** @type {String} */
          tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);
          parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
          if (individualTransformProperty) {
            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
            cachedTransforms[individualTransformProperty] = parsedPropertyValue;
          } else {
            keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
          }
          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
          if (!isUnd(from)) {
            if (!individualTransformProperty) {
              elStyle[name] = keyframes[name][0];
            } else {
              const key = `--${individualTransformProperty}`;
              elStyle.setProperty(key, keyframes[key][0]);
            }
          }
        } else {
          parsedPropertyValue = isArr(propertyValue) ?
                                propertyValue.map((/** @type {any} */v) => normalizeTweenValue(name, v, $el, i, targetsLength)) :
                                normalizeTweenValue(name, /** @type {any} */(propertyValue), $el, i, targetsLength);
          if (individualTransformProperty) {
            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
            cachedTransforms[individualTransformProperty] = parsedPropertyValue;
          } else {
            keyframes[name] = parsedPropertyValue;
          }
          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
        }
      }
      if (hasIndividualTransforms) {
        let transforms = emptyString;
        for (let t in cachedTransforms) {
          transforms += `${transformsFragmentStrings[t]}var(--${t})) `;
        }
        elStyle.transform = transforms;
      }
    });

    if (scroll) {
      /** @type {ScrollObserver} */(this.autoplay).link(this);
    }
  }

  /**
   * @callback forEachCallback
   * @param {globalThis.Animation} animation
   */

  /**
   * @param  {forEachCallback|String} callback
   * @return {this}
   */
  forEach(callback) {
    try {
      const cb = isStr(callback) ? (/** @type {globalThis.Animation} */a) => a[callback]() : callback;
      this.animations.forEach(cb);
    } catch {};
    return this;
  }

  get speed() {
    return this._speed;
  }

  set speed(speed) {
    this._speed = +speed;
    this.forEach(anim => anim.playbackRate = speed);
  }

  get currentTime() {
    const controlAnimation = this.controlAnimation;
    const timeScale = globals.timeScale;
    return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;
  }

  set currentTime(time) {
    const t = time * (globals.timeScale === 1 ? 1 : K);
    this.forEach(anim => {
      // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.
      // The "paused" play state supersedes the "finished" play state; if the animation is both paused and finished, the "paused" state is the one that will be reported.
      // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event
      // This is not needed for persisting animations since they never finish.
      if (!this.persist && t >= this.duration) anim.play();
      anim.currentTime = t;
    });
  }

  get progress() {
    return this.currentTime / this.duration;
  }

  set progress(progress) {
    this.forEach(anim => anim.currentTime = progress * this.duration || 0);
  }

  resume() {
    if (!this.paused) return this;
    this.paused = false;
    // TODO: Store the current time, and seek back to the last position
    return this.forEach('play');
  }

  pause() {
    if (this.paused) return this;
    this.paused = true;
    return this.forEach('pause');
  }

  alternate() {
    this.reversed = !this.reversed;
    this.forEach('reverse');
    if (this.paused) this.forEach('pause');
    return this;
  }

  play() {
    if (this.reversed) this.alternate();
    return this.resume();
  }

  reverse() {
    if (!this.reversed) this.alternate();
    return this.resume();
  }

 /**
  * @param {Number} time
  * @param {Boolean} muteCallbacks
  */
  seek(time, muteCallbacks = false) {
    if (muteCallbacks) this.muteCallbacks = true;
    if (time < this.duration) this.completed = false;
    this.currentTime = time;
    this.muteCallbacks = false;
    if (this.paused) this.pause();
    return this;
  }

  restart() {
    this.completed = false;
    return this.seek(0, true).resume();
  }

  commitStyles() {
    return this.forEach('commitStyles');
  }

  complete() {
    return this.seek(this.duration);
  }

  cancel() {
    this.muteCallbacks = true; // This prevents triggering the onComplete callback and resolving the Promise
    this.commitStyles().forEach('cancel');
    this.animations.length = 0; // Needed to release all animations from memory
    requestAnimationFrame(() => {
      this.targets.forEach(($el) => { // Needed to avoid unecessary inline transorms
        if ($el.style.transform === 'none') $el.style.removeProperty('transform');
      });
    });
    return this;
  }

  revert() {
    // NOTE: We need a better way to revert the transforms, since right now the entire transform property value is reverted,
    // This means if you have multiple animations animating different transforms on the same target,
    // reverting one of them will also override the transform property of the other animations.
    // A better approach would be to store the original custom property values if they exist instead of the entire transform value,
    // and update the CSS variables with the orignal value
    this.cancel().targets.forEach(($el, i) => {
      const targetStyle = $el.style;
      const targetInlineStyles = this._inlineStyles[i];
      for (let name in targetInlineStyles) {
        const originalInlinedValue = targetInlineStyles[name];
        if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
          targetStyle.removeProperty(toLowerCase(name));
        } else {
          $el.style[name] = originalInlinedValue;
        }
      }
      // Remove style attribute if empty
      if ($el.getAttribute('style') === emptyString) $el.removeAttribute('style');
    });
    return this;
  }

  /**
   * @typedef {this & {then: null}} ResolvedWAAPIAnimation
   */

  /**
   * @param  {Callback<ResolvedWAAPIAnimation>} [callback]
   * @return Promise<this>
   */
  then(callback = noop) {
    const then = this.then;
    const onResolve = () => {
      this.then = null;
      callback(/** @type {ResolvedWAAPIAnimation} */(this));
      this.then = then;
      this._resolve = noop;
    }
    return new Promise(r => {
      this._resolve = () => r(onResolve());
      if (this.completed) this._resolve();
      return this;
    });
  }
}

export const waapi = {
/**
 * @param {DOMTargetsParam} targets
 * @param {WAAPIAnimationParams} params
 * @return {WAAPIAnimation}
 */
  animate: (targets, params) => new WAAPIAnimation(targets, params),
  convertEase: easingToLinear
}


--- tests/suites/waapi.test.js ---
import {
  expect,
} from '../utils.js';

import {
  waapi,
  utils,
  stagger,
  eases,
} from '../../dist/modules/index.js';

suite('WAAPI', () => {

  CSS.registerProperty({
    name: '--translateX',
    syntax: '<length-percentage>',
    inherits: false,
    initialValue: '0px'
  });

  test('Calling registerProperty on transforms should not conflict with the built-in one', resolve => {
    waapi.animate('#target-id', {
      scale: 1.5,
      duration: 10,
      onComplete: self => {
        expect(self.completed).to.equal(true);
        resolve();
      }
    })
  });

  test('Calling .complete() on an animation should trigger the .then() Promise', resolve => {
    const instance = waapi.animate('#target-id', {
      scale: 1.5,
      duration: 500,
      autoplay: false,
    });
    instance.then(self => {
      expect(self.completed).to.equal(true);
      resolve();
    });
    setTimeout(() => {
      instance.complete();
    }, 10);
  });

  test('Animate multiple elements', resolve => {
    const targets = utils.$('.target-class');
    waapi.animate(targets, {
      transform: `translateX(100px)`,
      duration: 10,
      onComplete: anim => {
        expect(anim.duration).to.equal(10);
        expect(utils.get(targets[0], 'x')).to.equal('100px');
        expect(utils.get(targets[1], 'x')).to.equal('100px');
        expect(utils.get(targets[2], 'x')).to.equal('100px');
        expect(utils.get(targets[3], 'x')).to.equal('100px');
        resolve();
      },
    });
  });

  test('Animate multiple elements with stagger', resolve => {
    const targets = utils.$('.target-class');
    waapi.animate(targets, {
      transform: `translateX(100px)`,
      duration: 10,
      delay: stagger(1),
      onComplete: anim => {
        expect(anim.duration).to.equal(13);
        expect(utils.get(targets[0], 'x')).to.equal('100px');
        expect(utils.get(targets[1], 'x')).to.equal('100px');
        expect(utils.get(targets[2], 'x')).to.equal('100px');
        expect(utils.get(targets[3], 'x')).to.equal('100px');
        resolve();
      },
    });
  });

  test('Animate with function based values', resolve => {
    const targets = utils.$('.target-class');
    waapi.animate(targets, {
      transform: (_, i) => `translateX(${i * 100}px)`,
      duration: 10,
      delay: stagger(1),
      onComplete: anim => {
        expect(utils.get(targets[0], 'x')).to.equal('0px');
        expect(utils.get(targets[1], 'x')).to.equal('100px');
        expect(utils.get(targets[2], 'x')).to.equal('200px');
        expect(utils.get(targets[3], 'x')).to.equal('300px');
        resolve();
      },
    });
  });

  test('Animate with function based properties', () => {
    const targets = utils.$('.target-class');
    const animation = waapi.animate(targets, {
      transform: `translateX(100px)`,
      duration: (_, i) => i * 20,
      delay: (_, i) => i * 5,
      ease: () => (t) => t,
      autoplay: false
    });
    animation.seek(20).commitStyles();
    expect(utils.get(targets[0], 'x')).to.equal('100px');
    expect(utils.get(targets[1], 'x')).to.equal('75px');
    expect(utils.get(targets[2], 'x')).to.equal('25px');
    expect(utils.get(targets[3], 'x')).to.equal('8.33333px');
  });

  test('Animate with function based keyframes value', resolve => {
    const targets = utils.$('.target-class');
    waapi.animate(targets, {
      transform: ['translateX(200px)', (_, i) => `translateX(${i * 100}px)`],
      duration: 10,
      delay: stagger(1),
      onComplete: anim => {
        expect(utils.get(targets[0], 'x')).to.equal('0px');
        expect(utils.get(targets[1], 'x')).to.equal('100px');
        expect(utils.get(targets[2], 'x')).to.equal('200px');
        expect(utils.get(targets[3], 'x')).to.equal('300px');
        resolve();
      },
    });
  });

  test('Seek an animation', () => {
    const targets = utils.$('.target-class');
    const animation = waapi.animate(targets, {
      translate: `100px`,
      duration: 10,
      autoplay: false,
      ease: 'linear',
    });
    expect(animation.currentTime).to.equal(0);
    animation.seek(5).commitStyles();
    expect(utils.get(targets[0], 'translate')).to.equal('50px');
    expect(animation.currentTime).to.equal(5);
    animation.seek(animation.duration).commitStyles();
    expect(animation.currentTime).to.equal(animation.duration);
    expect(utils.get(targets[0], 'translate')).to.equal('100px');
  });

  test('Set and get progress on an animation', () => {
    const targets = utils.$('.target-class');
    const animation = waapi.animate(targets, {
      translate: `100px`,
      duration: 10,
      autoplay: false,
      ease: 'linear',
    });
    expect(animation.progress).to.equal(0);
    animation.progress = .5;
    animation.commitStyles();
    expect(utils.get(targets[0], 'translate')).to.equal('50px');
    expect(animation.progress).to.equal(.5);
    animation.progress = 1;
    animation.commitStyles();
    expect(utils.get(targets[0], 'translate')).to.equal('100px');
  });

  test('Individual transforms', resolve => {
    const target = utils.$('#target-id');
    const animation = waapi.animate(target, {
      x: 100,
      y: 200,
      rotate: 45,
      scale: 2,
      duration: 10,
      ease: 'linear',
      onComplete: anim => {
        expect(anim.duration).to.equal(10);
        expect(utils.get(target, '--translateX')).to.equal('100px');
        expect(utils.get(target, '--translateY')).to.equal('200px');
        expect(utils.get(target, '--rotate')).to.equal('45deg');
        expect(utils.get(target, '--scale')).to.equal('2');
        resolve();
      },
    });
  });

  test('revert() an animation', resolve => {
    const targets = utils.$('.target-class');
    utils.set(targets, {
      backgroundColor: '#FF0000',
      opacity: .5,
    });
    const animation = waapi.animate(targets, {
      opacity: 1,
      backgroundColor: '#0000FF',
      x: 100,
      y: 200,
      rotate: 45,
      scale: 2,
      duration: 10,
      ease: 'linear',
      onComplete: () => {
        targets.forEach($el => {
          expect(utils.get($el, 'opacity')).to.equal('1');
          expect(utils.get($el, 'backgroundColor')).to.equal('rgb(0, 0, 255)');
        });
        animation.revert();
        targets.forEach($el => {
          expect(utils.get($el, 'opacity')).to.equal('0.5');
          expect(utils.get($el, 'backgroundColor')).to.equal('rgb(255, 0, 0)');
          expect(utils.get($el, 'transform')).to.equal('none');
          // expect(utils.get($el, '--translateX')).to.equal('0px');
          // expect(utils.get($el, '--translateY')).to.equal('0px');
          // expect(utils.get($el, '--rotate')).to.equal('0deg');
          // expect(utils.get($el, '--scale')).to.equal('1');
        });
        resolve();
      },
    });
  });

  test('utils.remove() a single target', resolve => {
    const targets = utils.$('.target-class');
    waapi.animate(targets, {
      opacity: .5,
      duration: 10,
      onComplete: () => {
        targets.forEach(($el, i) => {
          expect(utils.get($el, 'opacity')).to.equal(!i ? '1' : '0.5');
        });
        resolve();
      },
    });

    utils.remove(targets[0]);
  });

  test('utils.remove() on a specific animation', resolve => {
    const targets = utils.$('.target-class');
    const anim1 = waapi.animate(targets, {
      opacity: .5,
      duration: 10,
    });
    waapi.animate(targets, {
      width: ['0px', '100px'],
      duration: 10,
      onComplete: () => {
        targets.forEach(($el, i) => {
          expect(utils.get($el, 'opacity')).to.equal('1');
          expect(utils.get($el, 'width')).to.equal('100px');
        });
        resolve();
      },
    });

    utils.remove(targets, anim1);
  });

  test('utils.remove() on a specific property', resolve => {
    const targets = utils.$('.target-class');
    const anim1 = waapi.animate(targets, {
      opacity: .5,
      duration: 10,
    });
    waapi.animate(targets, {
      width: ['0px', '100px'],
      duration: 10,
      onComplete: () => {
        targets.forEach(($el, i) => {
          expect(utils.get($el, 'opacity')).to.equal('1');
          expect(utils.get($el, 'width')).to.equal('100px');
        });
        resolve();
      },
    });

    utils.remove(targets, null, 'opacity');
  });

  test('utils.remove() on a specific animation and property', resolve => {
    const targets = utils.$('.target-class');
    const anim1 = waapi.animate(targets, {
      opacity: .5,
      height: ['0px', '200px'],
      duration: 10,
    });
    waapi.animate(targets, {
      width: ['0px', '100px'],
      duration: 10,
      onComplete: () => {
        targets.forEach(($el, i) => {
          expect(utils.get($el, 'opacity')).to.equal('1');
          expect(utils.get($el, 'height')).to.equal('200px');
          expect(utils.get($el, 'width')).to.equal('100px');
        });
        resolve();
      },
    });

    utils.remove(targets, null, 'opacity');
  });

  test('WAAPI ease cache should not cache functions', () => {
    const [ $target1, $target2 ] = utils.$('.target-class');
    const animation1 = waapi.animate($target1, {
      opacity: 0,
      autoplay: false,
      duration: 10,
      ease: eases.out(1),
    });
    const animation2 = waapi.animate($target2, {
      opacity: 0,
      autoplay: false,
      duration: 10,
      ease: eases.out(4),
    });
    animation1.seek(5);
    animation2.seek(5);
    expect(utils.get($target1, 'opacity')).to.not.equal(utils.get($target2, 'opacity'));
  });

  test('WAAPI ease cache should cache strings', () => {
    const [ $target1, $target2 ] = utils.$('.target-class');
    const animation1 = waapi.animate($target1, {
      opacity: 0,
      autoplay: false,
      duration: 10,
      ease: 'out(1)',
    });
    const animation2 = waapi.animate($target2, {
      opacity: 0,
      autoplay: false,
      duration: 10,
      ease: 'out(4)',
    });
    animation1.seek(5);
    animation2.seek(5);
    expect(utils.get($target1, 'opacity')).to.not.equal(utils.get($target2, 'opacity'));
  });

});


--- tests/playground/benchmark/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Benchmark | anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body, html {
      background-color: black;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      width: 100%;
      height: 100%;
    }
    #stats {
      position: absolute;
      z-index: 2;
      right: 0;
      top: 0;
      background-color: rgba(0, 0, 0, .5);
      font-size: 12px;
      text-transform: uppercase;
      padding: 1em;
    }
    #stats fieldset {
      display: flex;
      padding: 0;
      margin: 0;
      flex-direction: column;
      font-family: monospace;
      min-width: 13em;
      border: none;
    }
    #stats legend {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      border-top: 1px solid currentColor;
      border-bottom: 1px solid currentColor;
      padding: 0;
      margin: 0;
    }
    #stats label {
      display: flex;
      justify-content: space-between;
    }
    #stats input {
      font-family: inherit;
      border: none;
      padding: 0;
      margin: 0;
      background: transparent;
      color: currentColor;
      text-align: right;
      font-size: inherit;
    }
    #stats button,
    #stats select {
      font-family: inherit;
      border: none;
      padding: 0;
      background: #FFF;
      color: #000;
      height: 1em;
      font-size: inherit;
      line-height: 1em;
    }
    #stats button:not(:last-child),
    #stats select:not(:last-child),
    #stats fieldset:not(:last-child) {
      margin-bottom: 1ch;
    }
    #particles-container {
      pointer-events: none;
      display: flex;
      position: relative;
      width: 100%;
      height: 100vh;
      max-width: 1440px;
      overflow: hidden;
    }
    .particle {
      position: absolute;
      z-index: 1;
      left: 50%;
      top: 50%;
      width: .5rem;
      height: .5rem;
      margin: -.25rem 0 0 -.25rem;
      background: currentColor;
/*      border-radius: 50%;*/
    }
    .color1 { color: #FF4B4B; }
    .color2 { color: #9F3A39; }
    .color3 { color: #CF4242; }
  </style>
</head>
<body>
  <div id="particles-container"></div>
  <div id="stats">
    <fieldset>
      <legend>MONITOR</legend>
      <label>FPS<input type="text" id="fps" value="00.00" size=6 /></label>
      <label>AVG FPS<input type="text" id="avg" value="0" size=6 /></label>
    </fieldset>
    <fieldset>
      <legend>RENDER MODE</legend>
      <label>Anime.js<input class="config-item" type="radio" name="mode" value="css-transform"></label>
      <label>Anime.js + WAAPI<input class="config-item" type="radio" name="mode" value="anime-waapi-css-transform"></label>
      <label>WAAPI<input class="config-item" type="radio" name="mode" value="wappi-css-transform"></label>
      <label>Anime.js + Three.js<input class="config-item" type="radio" name="mode" value="webgl-threejs"></label>
    </fieldset>
    <fieldset>
      <legend>ANIMATIONS<input class="config-item" type="text" name="count" value="0" size=6 /></label></legend>
      <label for="count-range">COUNT</label>
      <input id="count-range" class="config-item" type="range" name="count" min="0" max="4000" value="0" step="500" />
    </fieldset>
    <fieldset>
      <legend>TWEENS<span id="active-tweens"></span></legend>
      <label>x<input class="config-item" type="checkbox" name="tween" value="x"></label>
      <label>y<input class="config-item" type="checkbox" name="tween" value="y"></label>
      <label>rotation<input class="config-item" type="checkbox" name="tween" value="rotation"></label>
      <label>scale<input class="config-item" type="checkbox" name="tween" value="scale"></label>
    </fieldset>
    <fieldset>
      <button id="restart-button" class="restart-button">RESTART</button>
    </fieldset>
  </div>
</body>
<script type="module" src="index.js"></script>
</html>


--- CONTRIBUTING.md ---
# Contributing

> [!CAUTION]
> Issues and PRs created without following the guidelines listed below **will be closed** until they match the expected template.

## Bug report
Open a [bug report issue](https://github.com/juliangarnier/anime/issues/new?template=bug_report.md) by following the bug report template and attaching the "bug" label.

## New features proposal
Open a [feature proposal issue](https://github.com/juliangarnier/anime/issues/new?template=feature_request.md) by following the feature proposal template and attaching the "feature proposal" label.

## Question
If you have a question not related to a bug or a new feature, do not create an issue, but start a [Q&A discussion](https://github.com/juliangarnier/anime/discussions/new?category=q-a) instead.

## Documentation update
Open a [documentation update issue](https://github.com/juliangarnier/anime/issues/new?template=documentation-update.md) by following the documentation update template and attaching the "documentation" label.

## Development
Anime.js is written in JavaScript and the type definitions are generated from [JSDoc](https://jsdoc.app/) annotations.

JSDoc types used globally in the project are defined in the `src/types.js` file. Otherwise, JSDoc types should be defined directly in their corresponding file.

Before opening a PR, follow these steps to properly build and test the project:

1. Make sure your PR has a bug report or new feature proposal issue associated with it. If not, create one.
2. Clone your fork to your computer.
3. Install the NPM dependencies with `npm i`.
4. Modify or add `.js` files in `/src`, with valid JSDoc annotations.
5. Run `npm run dev-types` to build the `anime.esm.js` and `index.d.ts` files by watching changes in `/src`.
6. Add the necessary tests to the relevant file in `/test/suites/`.
7. Run `npm run test-browser` to make sure you haven't broken anything and all tests are passing.
8. Create a pull request on the **[`dev`](https://github.com/juliangarnier/anime/tree/dev)** branch.

## Consider supporting this project via GitHub Sponsors

I couldn't respond to issues and fix bugs without the support of my sponsors. If you find Anime.js valuable in your work, please consider becoming a sponsor via [GitHub Sponsors](https://github.com/sponsors/juliangarnier)! 


## Links discovered
- [bug report issue](https://github.com/juliangarnier/anime/issues/new?template=bug_report.md)
- [feature proposal issue](https://github.com/juliangarnier/anime/issues/new?template=feature_request.md)
- [Q&A discussion](https://github.com/juliangarnier/anime/discussions/new?category=q-a)
- [documentation update issue](https://github.com/juliangarnier/anime/issues/new?template=documentation-update.md)
- [JSDoc](https://jsdoc.app/)
- [`dev`](https://github.com/juliangarnier/anime/tree/dev)
- [GitHub Sponsors](https://github.com/sponsors/juliangarnier)

--- LICENSE.md ---
The MIT License

Copyright (c) 2025 Julian Garnier

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


--- tests/playground/benchmark/index.js ---
import { waapi, animate, createTimer, utils, engine } from '../../../dist/modules/index.js';

import {
  Object3D,
  Vector3,
  Color,
  PerspectiveCamera,
  BoxGeometry,
  MeshBasicMaterial,
  InstancedMesh,
  Scene,
  WebGLRenderer,
} from '../../../node_modules/three/build/three.module.min.js';

// engine.frameRate = 30;

// engine.suspendWhenHidden = false;

const noop = () => {};
const url = new URL(window.location.href);
const urlParams = url.searchParams;
const $particlesContainer = document.querySelector('#particles-container');
const $countRange = document.querySelector('#count-range');
const $restartButton = document.querySelector('#restart-button');
const $activeTweens = document.querySelector('#active-tweens');
const $configItems = document.querySelectorAll('.config-item');
const startedSymbol = Symbol();
const reversedSymbol = Symbol();
const duration = 4000;
const ease = 'linear';
const particleDiameter = 10;

const AnimeTransformMode = {
  minCount: 500,
  maxCount: 10000,
  defaultCount: 1500,
  step: 500,
};

const AnimeWAAPITransformMode = {
  minCount: 500,
  maxCount: 10000,
  defaultCount: 1500,
  step: 500,
};

const WAAPITransformMode = {
  minCount: 500,
  maxCount: 10000,
  defaultCount: 1500,
  step: 500,
};

const webglThreejsMode = {
  minCount: 5000,
  maxCount: 100000,
  defaultCount: 10000,
  step: 5000,
};

const renderModes = {
  'css-transform': AnimeTransformMode,
  'anime-waapi-css-transform': AnimeWAAPITransformMode,
  'wappi-css-transform': WAAPITransformMode,
  'webgl-threejs': webglThreejsMode,
};

const config = {
  mode: urlParams.get('mode') || 'css-transform',
  count: urlParams.get('count') !== null ? +urlParams.get('count') : 1500,
  x: urlParams.get('x') !== null ? urlParams.get('x') === 'true' : true,
  y: urlParams.get('y') !== null ? urlParams.get('y') === 'true' : true,
  rotation: urlParams.get('rotation') !== null ? urlParams.get('rotation') === 'true' : false,
  scale: urlParams.get('scale') !== null ? urlParams.get('scale') === 'true' : false,
}

let containerRect = $particlesContainer.getBoundingClientRect();
let containerW = containerRect.width;
let containerH = containerRect.height;
let W = containerW;
let H = containerH;
let halfW = W * .5;
let halfH = H * .5;
let maxScale = 1;

// Tweens values factories

function getRandomX(el) {
  return el[reversedSymbol] || el.reversed ? Math.random() > .5 ? -halfW : halfW : -halfW + Math.random() * W;
}

function getRandomY(el) {
  return el[reversedSymbol] || el.reversed ? -halfH + Math.random() * H : Math.random() > .5 ? -halfH : halfH;
}

function getRandomScale() {
  return (.25 + (Math.random() * .75)) * maxScale;
}

function getRandomRad() {
  return -Math.PI + (Math.random() * (2 * Math.PI));
}

function getRandomDeg() {
  return -180 + (Math.random() * 360);
}

function getBeginOffset(i) {
  return i * ((duration) / config.count);
}


// Anime.js CSS Transform mode

AnimeTransformMode.init = () => {

  if (AnimeTransformMode.isInitialized) return;

  AnimeTransformMode.isInitialized = true;

  function createParticule() {
    const $el = document.createElement('div');
    $el.classList.add('particle');
    $el.classList.add(`color${(1 + (Math.random() * 2)).toFixed()}`);
    $el[reversedSymbol] = !!utils.random(0, 1);
    return $el;
  }

  function animateParticle($el, i) {
    let delay = 0;
    $el[reversedSymbol] = !$el[reversedSymbol];
    if (!$el[startedSymbol]) {
      $el[startedSymbol] = true;
      delay = getBeginOffset(i);
    }
    const params = {
      delay,
      duration,
      ease,
      composition: 'none',
      onComplete: () => animateParticle($el, i),
    };
    if (config.x) params.x = getRandomX($el);
    if (config.y) params.y = getRandomY($el);
    if (config.rotation) params.rotate = getRandomDeg();
    if (config.scale) params.scale = getRandomScale();
    animate($el, params);
  }

  AnimeTransformMode.cancel = () => {
    const $particles = document.querySelectorAll('.particle');
    utils.remove($particles);
    $particlesContainer.innerHTML = '';
  }

  AnimeTransformMode.refresh = () => {
    maxScale = utils.clamp(AnimeTransformMode.maxCount / config.count, .125, 5);
    for (let i = 0; i < config.count; i++) {
      const $el = createParticule();
      $particlesContainer.appendChild($el);
      animateParticle($el, i);
    }
  }

  AnimeTransformMode.resize = () => {
    W = containerW;
    H = containerH;
    halfW = W * .5;
    halfH = H * .5;
  }
}

// Anime.js + WAAPI CSS Transform mode

AnimeWAAPITransformMode.init = () => {

  if (AnimeWAAPITransformMode.isInitialized) return;

  AnimeWAAPITransformMode.isInitialized = true;

  function createParticule() {
    const $el = document.createElement('div');
    $el.classList.add('particle');
    $el.classList.add(`color${(1 + (Math.random() * 2)).toFixed()}`);
    $el[reversedSymbol] = !!utils.random(0, 1);
    return $el;
  }

  function animateParticle($el, i) {
    let delay = 0;
    $el[reversedSymbol] = !$el[reversedSymbol];
    if (!$el[startedSymbol]) {
      $el[startedSymbol] = true;
      delay = getBeginOffset(i);
    }
    const params = {
      delay,
      duration,
      ease,
      onComplete: () => animateParticle($el, i),
    };
    let transform = ``;

    if (config.x) transform += `translateX(${getRandomX($el)}px) `;
    if (config.y) transform += `translateY(${getRandomY($el)}px) `;
    if (config.rotation) transform += `rotate(${getRandomDeg()}deg) `;
    if (config.scale) transform += `scale(${getRandomScale()}) `;

    params.transform = transform;

    waapi.animate($el, params);
  }

  AnimeWAAPITransformMode.cancel = () => {
    const animations = document.getAnimations();
    animations.forEach(animation => { animation.cancel() });
    $particlesContainer.innerHTML = '';
  }

  AnimeWAAPITransformMode.refresh = () => {
    maxScale = utils.clamp(AnimeWAAPITransformMode.maxCount / config.count, .125, 5);
    for (let i = 0; i < config.count; i++) {
      const $el = createParticule();
      $particlesContainer.appendChild($el);
      animateParticle($el, i);
    }
  }

  AnimeWAAPITransformMode.resize = () => {
    W = containerW;
    H = containerH;
    halfW = W * .5;
    halfH = H * .5;
  }
}

// WAAPI CSS Transform mode

WAAPITransformMode.init = () => {

  if (WAAPITransformMode.isInitialized) return;

  WAAPITransformMode.isInitialized = true;

  function createParticule() {
    const $el = document.createElement('div');
    $el.classList.add('particle');
    $el.classList.add(`color${(1 + (Math.random() * 2)).toFixed()}`);
    $el[reversedSymbol] = !!utils.random(0, 1);
    return $el;
  }

  function animateParticle($el, i) {
    let delay = 0;
    $el[reversedSymbol] = !$el[reversedSymbol];
    if (!$el[startedSymbol]) {
      $el[startedSymbol] = true;
      delay = getBeginOffset(i);
    }

    let transform = ``;

    if (config.x) transform += `translateX(${getRandomX($el)}px) `;
    if (config.y) transform += `translateY(${getRandomY($el)}px) `;
    if (config.rotation) transform += `rotate(${getRandomDeg()}deg) `;
    if (config.scale) transform += `scale(${getRandomScale()}) `;

    const anim = $el.animate({ transform }, {
      delay,
      duration,
      easing: ease,
      fill: 'forwards',
    });
    anim.onfinish = () => {
      // $el.style.transform = transform;

      // commitStyles() and cancel() have a huge impact on performance, but it simulates a real world usecase where you want to make sure the animations are properly removed
      anim.commitStyles();
      anim.cancel();
      animateParticle($el, i);
    }
  }

  WAAPITransformMode.cancel = () => {
    const animations = document.getAnimations();
    animations.forEach(animation => { animation.cancel() });
    $particlesContainer.innerHTML = '';
  }

  WAAPITransformMode.refresh = () => {
    maxScale = utils.clamp(WAAPITransformMode.maxCount / config.count, .125, 5);
    for (let i = 0; i < config.count; i++) {
      const $el = createParticule();
      $particlesContainer.appendChild($el);
      animateParticle($el, i);
    }
  }

  WAAPITransformMode.resize = () => {
    W = containerW;
    H = containerH;
    halfW = W * .5;
    halfH = H * .5;
  }
}

// WebGL Three.js mode

webglThreejsMode.init = () => {

  if (webglThreejsMode.isInitialized) return;

  webglThreejsMode.isInitialized = true;

  class InstancedMeshProxy {
    constructor(count) {
      this.index = 0;
      this._x = new Float32Array(count);
      this._y = new Float32Array(count);
      this._rotation = new Float32Array(count);
      this._scale = new Float32Array(count);
      this._started = new Int8Array(count);
      this._reversed = new Int8Array(count);
    }
    set x(v) { this._x[this.index] = v; }
    get x()  { return this._x[this.index]; }
    set y(v) { this._y[this.index] = v; }
    get y()  { return this._y[this.index]; }
    set rotation(v) { this._rotation[this.index] = v; }
    get rotation()  { return this._rotation[this.index]; }
    set scale(v) { this._scale[this.index] = v; }
    get scale()  { return this._scale[this.index]; }
    set started(v) { this._started[this.index] = v; }
    get started()  { return this._started[this.index]; }
    set reversed(v) { this._reversed[this.index] = v; }
    get reversed()  { return this._reversed[this.index]; }
  }

  const dummy = new Object3D();

  const camera = new PerspectiveCamera(60, containerW / containerH, 1, 150);
  camera.position.set(0, 0, -150);
  camera.lookAt(0, 0, 0);

  const geometry = new BoxGeometry(1, 1, 1);
  // const geometry = new SphereGeometry(1, 6, 3);
  const material = new MeshBasicMaterial();
  const mesh = new InstancedMesh(geometry, material, webglThreejsMode.maxCount);
  const meshProxy = new InstancedMeshProxy(webglThreejsMode.maxCount);

  const scene = new Scene();
  scene.add(mesh);

  const renderer = new WebGLRenderer({
    antialias: false,
    powerPreference: 'high-performance',
  });

  renderer.setPixelRatio(1);
  renderer.setSize(containerW, containerH);

  const renderLoop = createTimer({
    onUpdate: () => renderer.render(scene, camera),
    autoplay: false,
  });

  const screenCoords = new Vector3();
  const worldCoords = new Vector3();

  const colors = [new Color('#FF4B4B'), new Color('#9F3A39'), new Color('#CF4242')];

  function renderMesh(i) {
    meshProxy.index = i;
    dummy.position.set(meshProxy.x, meshProxy.y, 0);
    const r = meshProxy.rotation;
    dummy.rotation.set(r, r, r);
    const s = meshProxy.scale;
    dummy.scale.set(s, s, s);
    dummy.updateMatrix();
    mesh.setMatrixAt(i, dummy.matrix);
    mesh.instanceMatrix.needsUpdate = true;
  }

  function animateParticle(i, l) {
    meshProxy.index = i;
    meshProxy.reversed = ~~!meshProxy.reversed;
    let delay = 0;
    const started = meshProxy.started;
    if (!started) {
      meshProxy.started = 1;
      delay = getBeginOffset(i);
    }
    const params = {
      composition: 'none', // Needed to avoid overiding proxy tweens
      delay,
      duration,
      ease,
      onRender: () => renderMesh(i),
      onUpdate: () => meshProxy.index = i,
      onComplete: self => {
        animateParticle(i, l);
      },
    };
    if (config.x) params.x = getRandomX(meshProxy);
    if (config.y) params.y = getRandomY(meshProxy);
    if (config.rotation) params.rotation = getRandomRad();
    if (config.scale) params.scale = getRandomScale();
    animate(meshProxy, params);
  }

  webglThreejsMode.cancel = () => {
    for (let i = 0; i < webglThreejsMode.maxCount; i++) {
      meshProxy.index = i;
      meshProxy.x = 0;
      meshProxy.y = 0;
      meshProxy.rotation = 0;
      meshProxy.scale = 0;
      meshProxy.started = 0;
      meshProxy.reversed = 0;
      renderMesh(i);
    }
    utils.remove(meshProxy);
    renderLoop.pause();
  }

  webglThreejsMode.refresh = () => {
    if (!$particlesContainer.querySelector('canvas')) {
      $particlesContainer.appendChild(renderer.domElement);
    }
    maxScale = utils.clamp(webglThreejsMode.maxCount / config.count, .25, 2);
    for (let i = 0; i < config.count; i++) {
      meshProxy.index = i;
      meshProxy.scale = maxScale;
      meshProxy.rotation = Math.PI * .2;
      meshProxy.reversed = utils.random(0, 1);
      mesh.setColorAt(i, utils.randomPick(colors));
      animateParticle(i, config.count);
    }
    mesh.instanceColor.needsUpdate = true;
    renderLoop.play();
  }

  webglThreejsMode.resize = () => {
    camera.aspect = containerW / containerH;
    camera.updateProjectionMatrix();
    renderer.setSize(containerW, containerH);
    screenCoords.set(2, 2, .5);
    screenCoords.unproject(camera);
    screenCoords.sub(camera.position).normalize();
    worldCoords.copy(camera.position).add(screenCoords.multiplyScalar(-camera.position.z / screenCoords.z));
    W = worldCoords.x;
    H = worldCoords.y;
    halfW = W * .5;
    halfH = H * .5;
  }
}


// Init and controls

function updateTweensCount() {
  $activeTweens.textContent = `
    ${config.count * (~~config.x + ~~config.y + ~~config.rotation + ~~config.scale)}
  `;
}

function updateUI() {
  $configItems.forEach($item => {
    if ($item.name === 'mode') {
      $item.checked = $item.value === config[$item.name];
    }
    if ($item.name === 'count') {
      $item.value = config.count;
    }
    if ($item.name === 'tween') {
      $item.checked = config[$item.value];
    }
  });
  updateTweensCount();
}

function restartActiveDemo() {
  const activeMode = renderModes[config.mode];
  activeMode.init();
  activeMode.cancel();
  activeMode.resize();
  activeMode.refresh();
}

function activateMode(modeName) {
  const selectedMode = renderModes[config.mode];
  if (selectedMode && selectedMode.isInitialized) {
    selectedMode.cancel();
  }
  config.mode = modeName;
  const activeMode = renderModes[modeName];
  if (config.count > activeMode.maxCount || config.count < activeMode.minCount) {
    config.count = activeMode.defaultCount;
  }
  $countRange.setAttribute('min', activeMode.minCount);
  $countRange.setAttribute('max', activeMode.maxCount);
  $countRange.setAttribute('step', activeMode.step);
  restartActiveDemo();
  updateUI();
}

function updateUrl() {
  for (let name in config) {
    url.searchParams.set(name, config[name]);
  }
  window.history.replaceState(null, null, url);
}

function onLoad() {
  activateMode(config.mode);
  updateUI();
  updateUrl();
}

function onConfigItemChange() {
  if (this.name === 'mode') {
    activateMode(this.value);
  }
  if (this.name === 'count') {
    config.count = this.value;
    renderModes[config.mode].cancel();
    renderModes[config.mode].refresh();
    updateUI();
  }
  if (this.name === 'tween') {
    config[this.value] = this.checked;
    updateTweensCount();
  }
  updateUrl();
  resetAverageFps();
}

function onRangeInput() {
  config.count = $countRange.value;
  updateUrl();
  updateUI();
}

function onResize() {
  containerRect = $particlesContainer.getBoundingClientRect();
  containerW = containerRect.width;
  containerH = containerRect.height;
  renderModes[config.mode].resize();
}

$configItems.forEach($item => $item.onchange = onConfigItemChange);
$countRange.oninput = onRangeInput;
$restartButton.onclick = restartActiveDemo;
window.onload = onLoad;
window.onresize = onResize;


// MONITOR
// Calculating FPS past requestAnimationFrame limit with requestIdleCallback
// https://www.clicktorelease.com/blog/calculating-fps-with-requestIdleCallback/

const $fps = document.getElementById('fps');
const $avg = document.getElementById('avg');

let t = Date.now();
let hasrICBeenCalledForThisFrame = null;
let frames = 0;
let rICFPS = 0;
let fps = 0;
let activateAverage = false;
let averageFPS = null;
let mixedFPS = 0;
let previousMixedFPS = 0;
let maxScreenRefreshRate = 60;

function fpsCallback(d) {
  const goal = 1000 / maxScreenRefreshRate;
  const elapsed = goal - d.timeRemaining();
  rICFPS = goal * maxScreenRefreshRate / elapsed;
  hasrICBeenCalledForThisFrame = true;
}

function updateFpsMeter(fps) {
  $fps.value = fps.toFixed(2);
  if (!activateAverage) return;
  if (averageFPS === null) {
    averageFPS = mixedFPS;
  } else {
    averageFPS += (previousMixedFPS - averageFPS) * .1;
  }
  previousMixedFPS = mixedFPS;
}

function updateAverageFpsMeter(fps) {
  if (!activateAverage) return;
  $avg.value = averageFPS.toFixed(2);
}

const reqIdleCallback = window.requestIdleCallback ? requestIdleCallback : () => {};

function updateFps() {
  const dt = Date.now() - t;
  if (dt > 1000) {
    fps = frames * 1000 / dt;
    frames = 0;
    t = Date.now();
  }
  mixedFPS = hasrICBeenCalledForThisFrame ? rICFPS : fps;
  hasrICBeenCalledForThisFrame = false;
  requestAnimationFrame(updateFps);
  reqIdleCallback(fpsCallback);
  frames++;
}

updateFps();

setInterval(() => { updateFpsMeter(mixedFPS) }, 500);
setInterval(() => { updateAverageFpsMeter(mixedFPS) }, 2000);

function resetAverageFps() {
  averageFPS = null;
  activateAverage = false;
  $avg.value = '00.00';
  setTimeout(() => { activateAverage = true; }, 2000);
}

resetAverageFps();



--- README.md ---
# Anime.js

<p align="center">
  <picture align="center">
    <source media="(prefers-color-scheme: dark)" srcset="./assets/images/animejs-v4-logo-animation-dark.gif">
    <img align="center" alt="Anime.js V4 logo animation" src="./assets/images/animejs-v4-logo-animation.gif" width="560">
  </picture>
</p>

<p align="center">
  <strong>
  <em>Anime.js</em> is a fast, multipurpose and lightweight JavaScript animation library with a simple, yet powerful API.<br>
  It works with CSS properties, SVG, DOM attributes and JavaScript Objects.
  </strong>
</p>


<p align="center">
  <img alt="NPM Downloads" src="https://img.shields.io/npm/dm/animejs?style=flat-square&logo=npm">
  <img alt="jsDelivr hits (npm)" src="https://img.shields.io/jsdelivr/npm/hm/animejs?style=flat-square&logo=jsdeliver">
  <img alt="GitHub Sponsors" src="https://img.shields.io/github/sponsors/juliangarnier?style=flat-square&logo=github">
</p>

## Sponsors

Anime.js is 100% free and is only made possible with the help of our sponsors.
Help the project become sustainable by sponsoring us on <a target="_blank" href="https://github.com/sponsors/juliangarnier">GitHub Sponsors</a>.

### Platinum sponsors

<table>
  <tbody>
    <tr>
      <td>
        <a target="_blank" href="https://ice.io/?ref=animejs">
          <picture>
            <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/ice-open-network-logomark.png?v=200126">
            <img align="center" src="./assets/sponsors/ice-open-network-logomark-dark.png?v=200126" width="310">
          </picture>
        </a>
      </td>
      <td>
        <a target="_blank" href="https://hyperswitch.io/?utm_source=julian&utm_medium=github&utm_campaign=animejs_sponsorship">
          <picture>
            <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/juspay-logomark.png?v=200126">
            <img align="center" src="./assets/sponsors/juspay-logomark-dark.png?v=200126" width="310">
          </picture>
        </a>
      </td>
      <td>
        <a target="_blank" href="https://github.com/sponsors/juliangarnier">
          <picture>
            <img align="center" src="./assets/sponsors/placeholder-large.png?v=200126" width="310">
          </picture>
        </a>
      </td>
    </tr>
  </tbody>
</table>

### Silver sponsors

<table>
  <tbody>
    <tr>
      <td>
        <a target="_blank" href="https://www.testmu.ai?utm_source=animeJS&utm_medium=organic&utm_campaign=july_08&utm_term=sk&utm_content=opensource">
          <picture>
            <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/testmu-ai-logomark.png?v=200126">
            <img align="center" src="./assets/sponsors/testmu-ai-logomark-dark.png?v=200126" width="141">
          </picture>
        </a>
      </td>
      <td>
        <a target="_blank" href="https://inspatialapp.com/?ref=animejs">
          <picture>
            <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/inspatial-logomark.png?v=200126">
            <img align="center" src="./assets/sponsors/inspatial-logomark-dark.png?v=200126" width="141">
          </picture>
        </a>
      </td>
      <td>
        <a target="_blank" href="https://github.com/sponsors/juliangarnier">
          <picture>
            <img align="center" src="./assets/sponsors/placeholder-small.png?v=200126" width="141">
          </picture>
        </a>
      </td>
      <td>
        <a target="_blank" href="https://github.com/sponsors/juliangarnier">
          <picture>
            <img align="center" src="./assets/sponsors/placeholder-small.png?v=200126" width="141">
          </picture>
        </a>
      </td>
      <td>
        <a target="_blank" href="https://github.com/sponsors/juliangarnier">
          <picture>
            <img align="center" src="./assets/sponsors/placeholder-small.png?v=200126" width="141">
          </picture>
        </a>
      </td>
      <td>
        <a target="_blank" href="https://github.com/sponsors/juliangarnier">
          <picture>
            <img align="center" src="./assets/sponsors/placeholder-small.png?v=200126" width="141">
          </picture>
        </a>
      </td>
    </tr>
  </tbody>
</table>

Get featured here by becoming a <a target="_blank" href="https://github.com/sponsors/juliangarnier">GitHub Sponsor</a>.


## Usage

Anime.js V4 works by importing ES modules like so:


<table>
<tr>
  <td>

```javascript
import {
  animate,
  stagger,
} from 'animejs';

animate('.square', {
  x: 320,
  rotate: { from: -180 },
  duration: 1250,
  delay: stagger(65, { from: 'center' }),
  ease: 'inOutQuint',
  loop: true,
  alternate: true
});
```

  </td>
  <td>
    <img align="center" alt="Anime.js code example" src="./assets/images/usage-example-result.gif">
  </td>
</tr>
</table>

## V4 Documentation

The full documentation is available [here](https://animejs.com/documentation).

## V3 Migration guide

You can find the v3 to v4 migration guide [here](https://github.com/juliangarnier/anime/wiki/Migrating-from-v3-to-v4).

## NPM development scripts

First, run `npm i` to install all the necessary packages.
Then, execute the following scripts with `npm run <script>`.

| script | action |
| ------ | ------ |
| `dev` | Watches for changes in `src/**/*.js`, bundles the ESM version to `lib/` and creates type declarations in `types/` |
| `dev:test` | Runs `dev` and `test:browser` concurrently |
| `build` | Bundles ESM / UMD / CJS / IIFE versions to `lib/` and creates type declarations in `types/` |
| `test:browser` | Starts a local server and runs all browser-related tests |
| `test:node` | Starts Node-related tests |
| `open:examples` | Starts a local server to browse the examples locally |

 [Julian Garnier](http://juliangarnier.com) | [MIT License](LICENSE.md)


## Links discovered
- [here](https://animejs.com/documentation)
- [here](https://github.com/juliangarnier/anime/wiki/Migrating-from-v3-to-v4)
- [Julian Garnier](http://juliangarnier.com)
- [MIT License](https://github.com/juliangarnier/anime/blob/master/LICENSE.md)
- [GitHub Sponsors](https://github.com/sponsors/juliangarnier)
- [<picture> <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/ice-open-network-logomark.png?v=200126"> <img align="center" src="./assets/sponsors/ice-open-network-logomark-dark.png?v=200126" width="310"> </picture>](https://ice.io/?ref=animejs)
- [<picture> <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/juspay-logomark.png?v=200126"> <img align="center" src="./assets/sponsors/juspay-logomark-dark.png?v=200126" width="310"> </picture>](https://hyperswitch.io/?utm_source=julian&utm_medium=github&utm_campaign=animejs_sponsorship)
- [<picture> <img align="center" src="./assets/sponsors/placeholder-large.png?v=200126" width="310"> </picture>](https://github.com/sponsors/juliangarnier)
- [<picture> <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/testmu-ai-logomark.png?v=200126"> <img align="center" src="./assets/sponsors/testmu-ai-logomark-dark.png?v=200126" width="141"> </picture>](https://www.testmu.ai?utm_source=animeJS&utm_medium=organic&utm_campaign=july_08&utm_term=sk&utm_content=opensource)
- [<picture> <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/inspatial-logomark.png?v=200126"> <img align="center" src="./assets/sponsors/inspatial-logomark-dark.png?v=200126" width="141"> </picture>](https://inspatialapp.com/?ref=animejs)
- [<picture> <img align="center" src="./assets/sponsors/placeholder-small.png?v=200126" width="141"> </picture>](https://github.com/sponsors/juliangarnier)
- [GitHub Sponsor](https://github.com/sponsors/juliangarnier)

--- rollup.config.js ---
import terser from '@rollup/plugin-terser';
import fs from 'fs';

const pkg = JSON.parse(fs.readFileSync('./package.json', 'utf-8'));

const banner = (format, content = '') => chunk => {
  const date = new Date();
  const moduleName = chunk.fileName.split('/')[0] || '';
  return `/**
 * Anime.js${ moduleName.includes('.') ? '' : ' - ' + moduleName } - ${ format }
 * @version v${ pkg.version }
 * @license MIT
 * @copyright ${ date.getFullYear() } - Julian Garnier
 */${content}
`
}

const replace = (rgx, string = '') => {
  return {
    name: 'replace',
    generateBundle(_, bundle) {
      Object.keys(bundle).forEach((fileName) => {
        const file = bundle[fileName];
        let code = file.code;
        code = code.replace(rgx, string);
        file.code = code;
      });
    }
  }
}

const updatePackageVersion = replace(/__packageVersion__/g, pkg.version);

// Extracts module input paths from the package.json 'exports' field
const inputs = Object.keys(pkg.exports).filter(k => k !== './package.json').map(k => `src${k.replace('.', '')}/index.js`);

console.log(inputs);

const tasks = [{
  input: inputs,
  output: [
    {
      dir: 'dist/modules/',
      format: 'esm',
      preserveModules: true,
      preserveModulesRoot: 'src',
      banner: banner('ESM'),
    },
    {
      dir: 'dist/modules/',
      format: 'cjs',
      entryFileNames: '[name].cjs',
      preserveModules: true,
      preserveModulesRoot: 'src',
      banner: banner('CJS'),
    }
  ],
  plugins: [updatePackageVersion],
}];

if (process.env.build) {

  // Gets global JSDoc type definitions from src/types to be inserted in the banner of the bundles after tree shaking
  const JSDocTypes = fs.readFileSync('./src/types/index.js', 'utf-8').split('// Exported types')[1];

  // Removes comments containing JSDoc @import tags to avoid duplicated type definitions in bundles
  const cleanupJSDocImports = replace(/\/\*\*(?:(?!\*\/|\/\*\*)[\s\S])*?@import(?:(?!\*\/|\/\*\*)[\s\S])*?\*\//g);

  const minify = terser({
    compress: { passes: 10, module: false },
    mangle: true,
  });

  tasks.push({
    input: 'src/index.js',
    output: [
      { file: 'dist/bundles/anime.esm.js', format: 'esm', name: 'anime', banner: banner('ESM bundle', JSDocTypes) },
      { file: 'dist/bundles/anime.umd.js', format: 'umd', name: 'anime', banner: banner('UMD bundle', JSDocTypes) }
    ],
    plugins: [updatePackageVersion, cleanupJSDocImports]
  });

  tasks.push({
    input: 'src/index.js',
    output: [
      { file: 'dist/bundles/anime.esm.min.js', format: 'esm', name: 'anime', banner: banner('ESM minified bundle') },
      { file: 'dist/bundles/anime.umd.min.js', format: 'umd', name: 'anime', banner: banner('UMD minified bundle') }
    ],
    plugins: [updatePackageVersion, minify]
  });

}

export default tasks;


--- .github/ISSUE_TEMPLATE/bug_report.md ---
---
name: Bug report
about: Create a report to help us improve
title: "[BUG]"
labels: bug
assignees: ''

---

## Describe the bug

A clear and concise description of what the bug is.
If you're using an LLM to write the issue, please make sure that the text actually means something, and please, keep it short, LLMs tend to write longer texts than needed.
Do not post screenshots of your text editor. Quaote the code directly in the issue with [adequate code formatting](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code).

## Provide a minimal reproduction demo of the bug

Use this [CodePen template](https://codepen.io/pen?template=pvoGoxR) or use a similar service to provide a minimal reproduction demo so I can quickly follow the steps to reproduce your problem.

## Detail the steps to reproduce the issue

For example:
1. In Chrome 138
2. Open this [demo](https://codepen.io/pen?template=pvoGoxR)
2. Click on '....'
3. Scroll down to '....'
4. See error

You can also add a screen recording of the bug in action if it's too complicated to describe.


## Links discovered
- [adequate code formatting](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code)
- [CodePen template](https://codepen.io/pen?template=pvoGoxR)
- [demo](https://codepen.io/pen?template=pvoGoxR)

--- .github/ISSUE_TEMPLATE/documentation-update.md ---
---
name: Documentation update
about: Suggest a change to the documentation
title: "[DOCS]"
labels: documentation
assignees: ''

---

## Describe what the update does
A clear and concise description of what you want to change, improve or add.
Please don't post screenshots of text, instead paste the text directly in the issue with appropriate code formatting. Only uses screenshots for visual bug.

## Provide the suggested modification
Write your correction to the typo, suggested change, or addition to the documentation here.
If you're using an LLM to write this issue, please ensure the text is meaningful and keep it brief, as LLMs tend to produce unnecessarily long text.


--- .github/ISSUE_TEMPLATE/feature_request.md ---
---
name: Feature request
about: Suggest an idea for this project
title: "[FEATURE]"
labels: feature proposal
assignees: ''

---

## Describe what the feature does
A clear and concise description of what the feature request is trying to solve or improve.
If you're using an LLM to write the issue, please make sure that the text actually means something, and please, keep it short, LLMs tend to write longer texts than needed.

## Provide a code example of what the feature should look like
A clear and concise description of what you want to happen, with an example of how the API should look like.
Do not post screenshots of your text editor, paste the code directly in the issue with the adequate code formatting.

## Describe alternatives you've considered
A clear and concise description of any alternative solutions or features you've considered.

## Additional context
Add any other context or screen recording about the feature request here.


--- dist/bundles/anime.esm.js ---
/**
 * Anime.js - ESM bundle
 * @version v4.3.0
 * @license MIT
 * @copyright 2026 - Julian Garnier
 */

// Global types

/**
 * @typedef {Object} DefaultsParams
 * @property {Number|String} [id]
 * @property {PercentageKeyframes|DurationKeyframes} [keyframes]
 * @property {EasingParam} [playbackEase]
 * @property {Number} [playbackRate]
 * @property {Number} [frameRate]
 * @property {Number|Boolean} [loop]
 * @property {Boolean} [reversed]
 * @property {Boolean} [alternate]
 * @property {Boolean} [persist]
 * @property {Boolean|ScrollObserver} [autoplay]
 * @property {Number|FunctionValue} [duration]
 * @property {Number|FunctionValue} [delay]
 * @property {Number} [loopDelay]
 * @property {EasingParam|FunctionValue} [ease]
 * @property {'none'|'replace'|'blend'|compositionTypes} [composition]
 * @property {(v: any) => any} [modifier]
 * @property {Callback<Tickable>} [onBegin]
 * @property {Callback<Tickable>} [onBeforeUpdate]
 * @property {Callback<Tickable>} [onUpdate]
 * @property {Callback<Tickable>} [onLoop]
 * @property {Callback<Tickable>} [onPause]
 * @property {Callback<Tickable>} [onComplete]
 * @property {Callback<Renderable>} [onRender]
 */

/** @typedef {JSAnimation|Timeline} Renderable */
/** @typedef {Timer|Renderable} Tickable */
/** @typedef {Timer&JSAnimation&Timeline} CallbackArgument */
/** @typedef {Animatable|Tickable|WAAPIAnimation|Draggable|ScrollObserver|TextSplitter|Scope|AutoLayout} Revertible */

// Stagger types

/**
 * @template T
 * @callback StaggerFunction
 * @param {Target} [target]
 * @param {Number} [index]
 * @param {Number} [length]
 * @param {Timeline} [tl]
 * @return {T}
 */

/**
 * @typedef  {Object} StaggerParams
 * @property {Number|String} [start]
 * @property {Number|'first'|'center'|'last'|'random'} [from]
 * @property {Boolean} [reversed]
 * @property {Array.<Number>} [grid]
 * @property {('x'|'y')} [axis]
 * @property {String|((target: Target, i: Number, length: Number) => Number)} [use]
 * @property {Number} [total]
 * @property {EasingParam} [ease]
 * @property {TweenModifier} [modifier]
 */

// Targets types

/** @typedef {HTMLElement|SVGElement} DOMTarget */
/** @typedef {Record<String, any>} JSTarget */
/** @typedef {DOMTarget|JSTarget} Target */
/** @typedef {Target|NodeList|String} TargetSelector */
/** @typedef {DOMTarget|NodeList|String} DOMTargetSelector */
/** @typedef {Array.<DOMTargetSelector>|DOMTargetSelector} DOMTargetsParam */
/** @typedef {Array.<DOMTarget>} DOMTargetsArray */
/** @typedef {Array.<JSTarget>|JSTarget} JSTargetsParam */
/** @typedef {Array.<JSTarget>} JSTargetsArray */
/** @typedef {Array.<TargetSelector>|TargetSelector} TargetsParam */
/** @typedef {Array.<Target>} TargetsArray */

// Eases types

/**
 * @callback EasingFunction
 * @param {Number} time
 * @return {Number}
 */

/**
 * @typedef {('linear'|'none'|'in'|'out'|'inOut'|'inQuad'|'outQuad'|'inOutQuad'|'inCubic'|'outCubic'|'inOutCubic'|'inQuart'|'outQuart'|'inOutQuart'|'inQuint'|'outQuint'|'inOutQuint'|'inSine'|'outSine'|'inOutSine'|'inCirc'|'outCirc'|'inOutCirc'|'inExpo'|'outExpo'|'inOutExpo'|'inBounce'|'outBounce'|'inOutBounce'|'inBack'|'outBack'|'inOutBack'|'inElastic'|'outElastic'|'inOutElastic'|'out(p = 1.675)'|'inOut(p = 1.675)'|'inBack(overshoot = 1.7)'|'outBack(overshoot = 1.7)'|'inOutBack(overshoot = 1.7)'|'inElastic(amplitude = 1, period = .3)'|'outElastic(amplitude = 1, period = .3)'|'inOutElastic(amplitude = 1, period = .3)')} EaseStringParamNames
 */

/**
 * @typedef {('ease'|'ease-in'|'ease-out'|'ease-in-out'|'linear(0, 0.25, 1)'|'steps'|'steps(6, start)'|'step-start'|'step-end'|'cubic-bezier(0.42, 0, 1, 1)') } WAAPIEaseStringParamNames
 */

/**
 * @callback PowerEasing
 * @param {Number|String} [power=1.675]
 * @return {EasingFunction}
 */

/**
 * @callback BackEasing
 * @param {Number|String} [overshoot=1.7]
 * @return {EasingFunction}
 */

/**
 * @callback ElasticEasing
 * @param {Number|String} [amplitude=1]
 * @param {Number|String} [period=.3]
 * @return {EasingFunction}
 */

/** @typedef {PowerEasing|BackEasing|ElasticEasing} EasingFunctionWithParams */

// A hack to get both ease names suggestions AND allow any strings
// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421
/** @typedef {(String & {})|EaseStringParamNames|EasingFunction|Spring} EasingParam */
/** @typedef {(String & {})|EaseStringParamNames|WAAPIEaseStringParamNames|EasingFunction|Spring} WAAPIEasingParam */

// Spring types

/**
 * @typedef {Object} SpringParams
 * @property {Number} [mass=1] - Mass, default 1
 * @property {Number} [stiffness=100] - Stiffness, default 100
 * @property {Number} [damping=10] - Damping, default 10
 * @property {Number} [velocity=0] - Initial velocity, default 0
 * @property {Number} [bounce=0] - Initial bounce, default 0
 * @property {Number} [duration=0] - The perceived duration, default 0
 * @property {Callback<JSAnimation>} [onComplete] - Callback function called when the spring currentTime hits the perceived duration
 */

 // Callback types

/**
 * @template T
 * @callback Callback
 * @param {T} self - Returns itself
 * @param {PointerEvent} [e]
 * @return {*}
 */

/**
 * @template {object} T
 * @typedef {Object} TickableCallbacks
 * @property {Callback<T>} [onBegin]
 * @property {Callback<T>} [onBeforeUpdate]
 * @property {Callback<T>} [onUpdate]
 * @property {Callback<T>} [onLoop]
 * @property {Callback<T>} [onPause]
 * @property {Callback<T>} [onComplete]
 */

/**
 * @template {object} T
 * @typedef {Object} RenderableCallbacks
 * @property {Callback<T>} [onRender]
 */

// Timer types

/**
 * @typedef {Object} TimerOptions
 * @property {Number|String} [id]
 * @property {TweenParamValue} [duration]
 * @property {TweenParamValue} [delay]
 * @property {Number} [loopDelay]
 * @property {Boolean} [reversed]
 * @property {Boolean} [alternate]
 * @property {Boolean|Number} [loop]
 * @property {Boolean|ScrollObserver} [autoplay]
 * @property {Number} [frameRate]
 * @property {Number} [playbackRate]
 */

/**
 * @typedef {TimerOptions & TickableCallbacks<Timer>} TimerParams
 */

// Tween types

/**
 * @callback FunctionValue
 * @param {Target} target - The animated target
 * @param {Number} index - The target index
 * @param {Number} length - The total number of animated targets
 * @return {Number|String|TweenObjectValue|EasingParam|Array.<Number|String|TweenObjectValue>}
 */

/**
 * @callback TweenModifier
 * @param {Number} value - The animated value
 * @return {Number|String}
 */

/** @typedef {[Number, Number, Number, Number]} ColorArray */

/**
 * @typedef {Object} Tween
 * @property {Number} id
 * @property {JSAnimation} parent
 * @property {String} property
 * @property {Target} target
 * @property {String|Number} _value
 * @property {Function|null} _func
 * @property {EasingFunction} _ease
 * @property {Array.<Number>} _fromNumbers
 * @property {Array.<Number>} _toNumbers
 * @property {Array.<String>} _strings
 * @property {Number} _fromNumber
 * @property {Number} _toNumber
 * @property {Array.<Number>} _numbers
 * @property {Number} _number
 * @property {String} _unit
 * @property {TweenModifier} _modifier
 * @property {Number} _currentTime
 * @property {Number} _delay
 * @property {Number} _updateDuration
 * @property {Number} _startTime
 * @property {Number} _changeDuration
 * @property {Number} _absoluteStartTime
 * @property {tweenTypes} _tweenType
 * @property {valueTypes} _valueType
 * @property {Number} _composition
 * @property {Number} _isOverlapped
 * @property {Number} _isOverridden
 * @property {Number} _renderTransforms
 * @property {String} _inlineValue
 * @property {Tween} _prevRep
 * @property {Tween} _nextRep
 * @property {Tween} _prevAdd
 * @property {Tween} _nextAdd
 * @property {Tween} _prev
 * @property {Tween} _next
 */

/**
 * @typedef TweenDecomposedValue
 * @property {Number} t - Type
 * @property {Number} n - Single number value
 * @property {String} u - Value unit
 * @property {String} o - Value operator
 * @property {Array.<Number>} d - Array of Numbers (in case of complex value type)
 * @property {Array.<String>} s - Strings (in case of complex value type)
 */

/** @typedef {{_head: null|Tween, _tail: null|Tween}} TweenPropertySiblings */
/** @typedef {Record<String, TweenPropertySiblings>} TweenLookups */
/** @typedef {WeakMap.<Target, TweenLookups>} TweenReplaceLookups */
/** @typedef {Map.<Target, TweenLookups>} TweenAdditiveLookups */

// JSAnimation types

/**
 * @typedef {Number|String|FunctionValue|EasingParam} TweenParamValue
 */

/**
 * @typedef {TweenParamValue|[TweenParamValue, TweenParamValue]} TweenPropValue
 */

/**
 * @typedef {(String & {})|'none'|'replace'|'blend'|compositionTypes} TweenComposition
 */

/**
 * @typedef {Object} TweenParamsOptions
 * @property {TweenParamValue} [duration]
 * @property {TweenParamValue} [delay]
 * @property {EasingParam|FunctionValue} [ease]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 */

/**
 * @typedef {Object} TweenValues
 * @property {TweenParamValue} [from]
 * @property {TweenPropValue} [to]
 * @property {TweenPropValue} [fromTo]
 */

/**
 * @typedef {TweenParamsOptions & TweenValues} TweenKeyValue
 */

/**
 * @typedef {Array.<TweenKeyValue|TweenPropValue>} ArraySyntaxValue
 */

/**
 * @typedef {TweenParamValue|ArraySyntaxValue|TweenKeyValue} TweenOptions
 */

/**
 * @typedef {Partial<{to: TweenParamValue|Array.<TweenParamValue>; from: TweenParamValue|Array.<TweenParamValue>; fromTo: TweenParamValue|Array.<TweenParamValue>;}>} TweenObjectValue
 */

/**
 * @typedef {Object} PercentageKeyframeOptions
 * @property {EasingParam} [ease]
 */

/**
 * @typedef {Record<String, TweenParamValue>} PercentageKeyframeParams
 */

/**
 * @typedef {Record<String, PercentageKeyframeParams & PercentageKeyframeOptions>} PercentageKeyframes
 */

/**
 * @typedef {Array<Record<String, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>} DurationKeyframes
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {PercentageKeyframes|DurationKeyframes} [keyframes]
 * @property {EasingParam} [playbackEase]
 */

// TODO: Currently setting TweenModifier to the intersected Record<> makes the FunctionValue type target param any if only one parameter is set
/**
 * @typedef {Record<String, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | DurationKeyframes | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>} AnimationParams
 */

// Timeline types

/**
 * Accepts:<br>
 * - `Number` - Absolute position in milliseconds (e.g., `500` places element at exactly 500ms)<br>
 * - `'+=Number'` - Addition: Position element X ms after the last element (e.g., `'+=100'`)<br>
 * - `'-=Number'` - Subtraction: Position element X ms before the last element's end (e.g., `'-=100'`)<br>
 * - `'*=Number'` - Multiplier: Position element at a fraction of the total duration (e.g., `'*=.5'` for halfway)<br>
 * - `'<'` - Previous end: Position element at the end position of the previous element<br>
 * - `'<<'` - Previous start: Position element at the start position of the previous element<br>
 * - `'<<+=Number'` - Combined: Position element relative to previous element's start (e.g., `'<<+=250'`)<br>
 * - `'label'` - Label: Position element at a named label position (e.g., `'My Label'`)
 *
 * @typedef {Number|`+=${Number}`|`-=${Number}`|`*=${Number}`|'<'|'<<'|`<<+=${Number}`|`<<-=${Number}`|String} TimelinePosition
 */

/**
 * Accepts:<br>
 * - `Number` - Absolute position in milliseconds (e.g., `500` places animation at exactly 500ms)<br>
 * - `'+=Number'` - Addition: Position animation X ms after the last animation (e.g., `'+=100'`)<br>
 * - `'-=Number'` - Subtraction: Position animation X ms before the last animation's end (e.g., `'-=100'`)<br>
 * - `'*=Number'` - Multiplier: Position animation at a fraction of the total duration (e.g., `'*=.5'` for halfway)<br>
 * - `'<'` - Previous end: Position animation at the end position of the previous animation<br>
 * - `'<<'` - Previous start: Position animation at the start position of the previous animation<br>
 * - `'<<+=Number'` - Combined: Position animation relative to previous animation's start (e.g., `'<<+=250'`)<br>
 * - `'label'` - Label: Position animation at a named label position (e.g., `'My Label'`)<br>
 * - `stagger(String|Nummber)` - Stagger multi-elements animation positions (e.g., 10, 20, 30...)
 *
 * @typedef {TimelinePosition | StaggerFunction<Number|String>} TimelineAnimationPosition
 */

/**
 * @typedef {Object} TimelineOptions
 * @property {DefaultsParams} [defaults]
 * @property {EasingParam} [playbackEase]
 * @property {Boolean} [composition]
 */

/**
 * @typedef {TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} TimelineParams
 */

// WAAPIAnimation types

/**
 * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue
 */

/**
 * @callback WAAPIFunctionValue
 * @param {DOMTarget} target - The animated target
 * @param {Number} index - The target index
 * @param {Number} length - The total number of animated targets
 * @return {WAAPITweenValue|WAAPIEasingParam}
 */

/**
 * @typedef {WAAPITweenValue|WAAPIFunctionValue|Array<String|Number|WAAPIFunctionValue>} WAAPIKeyframeValue
 */

/**
 * @typedef {Object} WAAPITweenOptions
 * @property {WAAPIKeyframeValue} [to]
 * @property {WAAPIKeyframeValue} [from]
 * @property {Number|WAAPIFunctionValue} [duration]
 * @property {Number|WAAPIFunctionValue} [delay]
 * @property {WAAPIEasingParam} [ease]
 * @property {CompositeOperation} [composition]
 */

/**
 * @typedef {Object} WAAPIAnimationOptions
 * @property {Number|Boolean} [loop]
 * @property {Boolean} [Reversed]
 * @property {Boolean} [Alternate]
 * @property {Boolean|ScrollObserver} [autoplay]
 * @property {Number} [playbackRate]
 * @property {Number|WAAPIFunctionValue} [duration]
 * @property {Number|WAAPIFunctionValue} [delay]
 * @property {WAAPIEasingParam|WAAPIFunctionValue} [ease]
 * @property {CompositeOperation} [composition]
 * @property {Boolean} [persist]
 * @property {Callback<WAAPIAnimation>} [onComplete]
 */

/**
 * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | Callback<WAAPIAnimation> | WAAPIEasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams
 */

// Animatable types

/**
 * @callback AnimatablePropertySetter
 * @param  {Number|Array.<Number>} to
 * @param  {Number} [duration]
 * @param  {EasingParam} [ease]
 * @return {AnimatableObject}
 */

/**
 * @callback AnimatablePropertyGetter
 * @return {Number|Array.<Number>}
 */

/**
 * @typedef {AnimatablePropertySetter & AnimatablePropertyGetter} AnimatableProperty
 */

/**
 * @typedef {Animatable & Record<String, AnimatableProperty>} AnimatableObject
 */

/**
 * @typedef {Object} AnimatablePropertyParamsOptions
 * @property {String} [unit]
 * @property {TweenParamValue} [duration]
 * @property {EasingParam} [ease]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 */

/**
 * @typedef {Record<String, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions} AnimatableParams
 */

// Scope types

/**
 * @typedef {Object} ReactRef
 * @property {HTMLElement|SVGElement|null} [current]
 */

/**
 * @typedef {Object} AngularRef
 * @property {HTMLElement|SVGElement} [nativeElement]
 */

/**
 * @typedef {Object} ScopeParams
 * @property {DOMTargetSelector|ReactRef|AngularRef} [root]
 * @property {DefaultsParams} [defaults]
 * @property {Record<String, String>} [mediaQueries]
 */

/**
 * @template T
 * @callback ScopedCallback
 * @param {Scope} scope
 * @return {T}
 */

/**
 * @callback ScopeCleanupCallback
 * @param {Scope} [scope]
 */

/**
 * @callback ScopeConstructorCallback
 * @param {Scope} [scope]
 * @return {ScopeCleanupCallback|void}
 */

/**
 * @callback ScopeMethod
 * @param {...*} args
 * @return {ScopeCleanupCallback|void}
 */

// Scroll types

/**
 * @typedef {String|Number} ScrollThresholdValue
 */

/**
 * @typedef {Object} ScrollThresholdParam
 * @property {ScrollThresholdValue} [target]
 * @property {ScrollThresholdValue} [container]
 */

/**
 * @callback ScrollObserverAxisCallback
 * @param {ScrollObserver} self
 * @return {'x'|'y'}
 */

/**
 * @callback ScrollThresholdCallback
 * @param {ScrollObserver} self
 * @return {ScrollThresholdValue|ScrollThresholdParam}
 */

/**
 * @typedef {Object} ScrollObserverParams
 * @property {Number|String} [id]
 * @property {Boolean|Number|String|EasingParam} [sync]
 * @property {TargetsParam} [container]
 * @property {TargetsParam} [target]
 * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]
 * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]
 * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]
 * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]
 * @property {Boolean} [debug]
 * @property {Callback<ScrollObserver>} [onEnter]
 * @property {Callback<ScrollObserver>} [onLeave]
 * @property {Callback<ScrollObserver>} [onEnterForward]
 * @property {Callback<ScrollObserver>} [onLeaveForward]
 * @property {Callback<ScrollObserver>} [onEnterBackward]
 * @property {Callback<ScrollObserver>} [onLeaveBackward]
 * @property {Callback<ScrollObserver>} [onUpdate]
 * @property {Callback<ScrollObserver>} [onSyncComplete]
 */

// Draggable types

/**
 * @typedef {Object} DraggableAxisParam
 * @property {String} [mapTo]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]
 */

/**
 * @typedef {Object} DraggableCursorParams
 * @property {String} [onHover]
 * @property {String} [onGrab]
 */

/**
 * @typedef {Object} DraggableDragThresholdParams
 * @property {Number} [mouse]
 * @property {Number} [touch]
 */

/**
 * @typedef {Object} DraggableParams
 * @property {DOMTargetSelector} [trigger]
 * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]
 * @property {Boolean|DraggableAxisParam} [x]
 * @property {Boolean|DraggableAxisParam} [y]
 * @property {TweenModifier} [modifier]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]
 * @property {Number|((draggable: Draggable) => Number)} [containerFriction]
 * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]
 * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]
 * @property {Number|DraggableDragThresholdParams|((draggable: Draggable) => Number|DraggableDragThresholdParams)} [dragThreshold]
 * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]
 * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]
 * @property {Number|((draggable: Draggable) => Number)} [minVelocity]
 * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]
 * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]
 * @property {Number} [releaseMass]
 * @property {Number} [releaseStiffness]
 * @property {Number} [releaseDamping]
 * @property {Boolean} [releaseDamping]
 * @property {EasingParam} [releaseEase]
 * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]
 * @property {Callback<Draggable>} [onGrab]
 * @property {Callback<Draggable>} [onDrag]
 * @property {Callback<Draggable>} [onRelease]
 * @property {Callback<Draggable>} [onUpdate]
 * @property {Callback<Draggable>} [onSettle]
 * @property {Callback<Draggable>} [onSnap]
 * @property {Callback<Draggable>} [onResize]
 * @property {Callback<Draggable>} [onAfterResize]
 */

// Text types

/**
 * @typedef {Object} SplitTemplateParams
 * @property {false|String} [class]
 * @property {Boolean|'hidden'|'clip'|'visible'|'scroll'|'auto'} [wrap]
 * @property {Boolean|'top'|'right'|'bottom'|'left'|'center'} [clone]
 */

/**
 * @typedef {Boolean|String} SplitValue
 */

/**
 * @callback SplitFunctionValue
 * @param {Node|HTMLElement} [value]
 * @return String
 */

/**
 * @typedef {Object} TextSplitterParams
 * @property {SplitValue|SplitTemplateParams|SplitFunctionValue} [lines]
 * @property {SplitValue|SplitTemplateParams|SplitFunctionValue} [words]
 * @property {SplitValue|SplitTemplateParams|SplitFunctionValue} [chars]
 * @property {Boolean} [accessible]
 * @property {Boolean} [includeSpaces]
 * @property {Boolean} [debug]
 */

// SVG types

/**
 * @typedef {SVGGeometryElement & {
 *   setAttribute(name: 'draw', value: `${number} ${number}`): void;
 *   draw: `${number} ${number}`;
 * }} DrawableSVGGeometry
 */


// Environments

// TODO: Do we need to check if we're running inside a worker ?
const isBrowser = typeof window !== 'undefined';

/** @typedef {Window & {AnimeJS: Array} & {AnimeJSDevTools: any}|null} AnimeJSWindow

/** @type {AnimeJSWindow} */
const win = isBrowser ? /** @type {AnimeJSWindow} */(/** @type {unknown} */(window)) : null;

/** @type {Document|null} */
const doc = isBrowser ? document : null;

// Enums

/** @enum {Number} */
const tweenTypes = {
  OBJECT: 0,
  ATTRIBUTE: 1,
  CSS: 2,
  TRANSFORM: 3,
  CSS_VAR: 4,
};

/** @enum {Number} */
const valueTypes = {
  NUMBER: 0,
  UNIT: 1,
  COLOR: 2,
  COMPLEX: 3,
};

/** @enum {Number} */
const tickModes = {
  NONE: 0,
  AUTO: 1,
  FORCE: 2,
};

/** @enum {Number} */
const compositionTypes = {
  replace: 0,
  none: 1,
  blend: 2,
};

// Cache symbols

const isRegisteredTargetSymbol = Symbol();
const isDomSymbol = Symbol();
const isSvgSymbol = Symbol();
const transformsSymbol = Symbol();
const morphPointsSymbol = Symbol();
const proxyTargetSymbol = Symbol();

// Numbers

const minValue = 1e-11;
const maxValue = 1e12;
const K = 1e3;
const maxFps = 240;

// Strings

const emptyString = '';
const cssVarPrefix = 'var(';

const shortTransforms = /*#__PURE__*/ (() => {
  const map = new Map();
  map.set('x', 'translateX');
  map.set('y', 'translateY');
  map.set('z', 'translateZ');
  return map;
})();

const validTransforms = [
  'translateX',
  'translateY',
  'translateZ',
  'rotate',
  'rotateX',
  'rotateY',
  'rotateZ',
  'scale',
  'scaleX',
  'scaleY',
  'scaleZ',
  'skew',
  'skewX',
  'skewY',
  'matrix',
  'matrix3d',
  'perspective',
];

const transformsFragmentStrings = /*#__PURE__*/ validTransforms.reduce((a, v) => ({...a, [v]: v + '('}), {});

// Functions

/** @return {void} */
const noop = () => {};

// Regex

const hexTestRgx = /(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;
const rgbExecRgx = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;
const rgbaExecRgx = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
const hslExecRgx = /hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;
const hslaExecRgx = /hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
// export const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g;
const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi;
// export const unitsExecRgx = /^([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)+([a-z]+|%)$/i;
const unitsExecRgx = /^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i;
const lowerCaseRgx = /([a-z])([A-Z])/g;
const transformsExecRgx = /(\w+)(\([^)]+\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()
const relativeValuesExecRgx = /(\*=|\+=|-=)/;
const cssVariableMatchRgx = /var\(\s*(--[\w-]+)(?:\s*,\s*([^)]+))?\s*\)/;



/** @type {DefaultsParams} */
const defaults = {
  id: null,
  keyframes: null,
  playbackEase: null,
  playbackRate: 1,
  frameRate: maxFps,
  loop: 0,
  reversed: false,
  alternate: false,
  autoplay: true,
  persist: false,
  duration: K,
  delay: 0,
  loopDelay: 0,
  ease: 'out(2)',
  composition: compositionTypes.replace,
  modifier: v => v,
  onBegin: noop,
  onBeforeUpdate: noop,
  onUpdate: noop,
  onLoop: noop,
  onPause: noop,
  onComplete: noop,
  onRender: noop,
};

const scope = {
  /** @type {Scope} */
  current: null,
  /** @type {Document|DOMTarget} */
  root: doc,
};

const globals = {
  /** @type {DefaultsParams} */
  defaults,
  /** @type {Number} */
  precision: 4,
  /** @type {Number} equals 1 in ms mode, 0.001 in s mode */
  timeScale: 1,
  /** @type {Number} */
  tickThreshold: 200,
};

const devTools = isBrowser && win.AnimeJSDevTools;

const globalVersions = { version: '4.3.0', engine: null };

if (isBrowser) {
  if (!win.AnimeJS) win.AnimeJS = [];
  win.AnimeJS.push(globalVersions);
}



// Strings

/**
 * @param  {String} str
 * @return {String}
 */
const toLowerCase = str => str.replace(lowerCaseRgx, '$1-$2').toLowerCase();

/**
 * Prioritize this method instead of regex when possible
 * @param  {String} str
 * @param  {String} sub
 * @return {Boolean}
 */
const stringStartsWith = (str, sub) => str.indexOf(sub) === 0;

// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.
const now = Date.now;

// Types checkers

const isArr = Array.isArray;
/**@param {any} a @return {a is Record<String, any>} */
const isObj = a => a && a.constructor === Object;
/**@param {any} a @return {a is Number} */
const isNum = a => typeof a === 'number' && !isNaN(a);
/**@param {any} a @return {a is String} */
const isStr = a => typeof a === 'string';
/**@param {any} a @return {a is Function} */
const isFnc = a => typeof a === 'function';
/**@param {any} a @return {a is undefined} */
const isUnd = a => typeof a === 'undefined';
/**@param {any} a @return {a is null | undefined} */
const isNil = a => isUnd(a) || a === null;
/**@param {any} a @return {a is SVGElement} */
const isSvg = a => isBrowser && a instanceof SVGElement;
/**@param {any} a @return {Boolean} */
const isHex = a => hexTestRgx.test(a);
/**@param {any} a @return {Boolean} */
const isRgb = a => stringStartsWith(a, 'rgb') && a[a.length - 1] === ')';
/**@param {any} a @return {Boolean} */
const isHsl = a => stringStartsWith(a, 'hsl') && a[a.length - 1] === ')';
/**@param {any} a @return {Boolean} */
const isCol = a => isHex(a) || isRgb(a) || isHsl(a);
/**@param {any} a @return {Boolean} */
const isKey = a => !globals.defaults.hasOwnProperty(a);

// SVG

// Consider the following as CSS animation
// CSS opacity animation has better default values (opacity: 1 instead of 0))
// rotate is more commonly intended to be used as a transform
const svgCssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];

/**
 * @param  {Target} el
 * @param  {String} propertyName
 * @return {Boolean}
 */
const isValidSVGAttribute = (el, propertyName) => {
  if (svgCssReservedProperties.includes(propertyName)) return false;
  if (el.getAttribute(propertyName) || propertyName in el) {
    if (propertyName === 'scale') { // Scale
      const elParentNode = /** @type {SVGGeometryElement} */(/** @type {DOMTarget} */(el).parentNode);
      // Only consider scale as a valid SVG attribute on filter element
      return elParentNode && elParentNode.tagName === 'filter';
    }
    return true;
  }
};

// Number

/**
 * @param  {Number|String} str
 * @return {Number}
 */
const parseNumber = str => isStr(str) ?
  parseFloat(/** @type {String} */(str)) :
  /** @type {Number} */(str);

// Math

const pow = Math.pow;
const sqrt = Math.sqrt;
const sin = Math.sin;
const cos = Math.cos;
const abs = Math.abs;
const exp = Math.exp;
const ceil = Math.ceil;
const floor = Math.floor;
const asin = Math.asin;
const max = Math.max;
const atan2 = Math.atan2;
const PI = Math.PI;
const _round = Math.round;

/**
 * Clamps a value between min and max bounds
 *
 * @param  {Number} v - Value to clamp
 * @param  {Number} min - Minimum boundary
 * @param  {Number} max - Maximum boundary
 * @return {Number}
 */
const clamp$1 = (v, min, max) => v < min ? min : v > max ? max : v;

const powCache = {};

/**
 * Rounds a number to specified decimal places
 *
 * @param  {Number} v - Value to round
 * @param  {Number} decimalLength - Number of decimal places
 * @return {Number}
 */
const round$1 = (v, decimalLength) => {
  if (decimalLength < 0) return v;
  if (!decimalLength) return _round(v);
  let p = powCache[decimalLength];
  if (!p) p = powCache[decimalLength] = 10 ** decimalLength;
  return _round(v * p) / p;
};

/**
 * Snaps a value to nearest increment or array value
 *
 * @param  {Number} v - Value to snap
 * @param  {Number|Array<Number>} increment - Step size or array of snap points
 * @return {Number}
 */
const snap$1 = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => (abs(cv - v) < abs(closest - v) ? cv : closest)) : increment ? _round(v / increment) * increment : v;

/**
 * Linear interpolation between two values
 *
 * @param  {Number} start - Starting value
 * @param  {Number} end - Ending value
 * @param  {Number} factor - Interpolation factor in the range [0, 1]
 * @return {Number} The interpolated value
 */
const lerp$1 = (start, end, factor) => start + (end - start) * factor;

/**
 * Replaces infinity with maximum safe value
 *
 * @param  {Number} v - Value to check
 * @return {Number}
 */
const clampInfinity = v => v === Infinity ? maxValue : v === -Infinity ? -maxValue : v;

/**
 * Normalizes time value with minimum threshold
 *
 * @param  {Number} v - Time value to normalize
 * @return {Number}
 */
const normalizeTime = v => v <= minValue ? minValue : clampInfinity(round$1(v, 11));

// Arrays

/**
 * @template T
 * @param    {T[]} a
 * @return   {T[]}
 */
const cloneArray = a => isArr(a) ? [ ...a ] : a;

// Objects

/**
 * @template T
 * @template U
 * @param    {T} o1
 * @param    {U} o2
 * @return   {T & U}
 */
const mergeObjects = (o1, o2) => {
  const merged = /** @type {T & U} */({ ...o1 });
  for (let p in o2) {
    const o1p = /** @type {T & U} */(o1)[p];
    merged[p] = isUnd(o1p) ? /** @type {T & U} */(o2)[p] : o1p;
  }  return merged;
};

// Linked lists

/**
 * @param  {Object} parent
 * @param  {Function} callback
 * @param  {Boolean} [reverse]
 * @param  {String} [prevProp]
 * @param  {String} [nextProp]
 * @return {void}
 */
const forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {
  let next = parent._head;
  let adjustedNextProp = nextProp;
  if (reverse) {
    next = parent._tail;
    adjustedNextProp = prevProp;
  }
  while (next) {
    const currentNext = next[adjustedNextProp];
    callback(next);
    next = currentNext;
  }
};

/**
 * @param  {Object} parent
 * @param  {Object} child
 * @param  {String} [prevProp]
 * @param  {String} [nextProp]
 * @return {void}
 */
const removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {
  const prev = child[prevProp];
  const next = child[nextProp];
  prev ? prev[nextProp] = next : parent._head = next;
  next ? next[prevProp] = prev : parent._tail = prev;
  child[prevProp] = null;
  child[nextProp] = null;
};

/**
 * @param  {Object} parent
 * @param  {Object} child
 * @param  {Function} [sortMethod]
 * @param  {String} prevProp
 * @param  {String} nextProp
 * @return {void}
 */
const addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {
  let prev = parent._tail;
  while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];
  const next = prev ? prev[nextProp] : parent._head;
  prev ? prev[nextProp] = child : parent._head = child;
  next ? next[prevProp] = child : parent._tail = child;
  child[prevProp] = prev;
  child[nextProp] = next;
};



/**
 * @param  {DOMTarget} target
 * @param  {String} propName
 * @param  {Object} animationInlineStyles
 * @return {String}
 */
const parseInlineTransforms = (target, propName, animationInlineStyles) => {
  const inlineTransforms = target.style.transform;
  let inlinedStylesPropertyValue;
  if (inlineTransforms) {
    const cachedTransforms = target[transformsSymbol];
    let t; while (t = transformsExecRgx.exec(inlineTransforms)) {
      const inlinePropertyName = t[1];
      // const inlinePropertyValue = t[2];
      const inlinePropertyValue = t[2].slice(1, -1);
      cachedTransforms[inlinePropertyName] = inlinePropertyValue;
      if (inlinePropertyName === propName) {
        inlinedStylesPropertyValue = inlinePropertyValue;
        // Store the new parsed inline styles if animationInlineStyles is provided
        if (animationInlineStyles) {
          animationInlineStyles[propName] = inlinePropertyValue;
        }
      }
    }
  }
  return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue :
    stringStartsWith(propName, 'scale') ? '1' :
    stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew') ? '0deg' : '0px';
};



/**
 * RGB / RGBA Color value string -> RGBA values array
 * @param  {String} rgbValue
 * @return {ColorArray}
 */
const rgbToRgba = rgbValue => {
  const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);
  const a = !isUnd(rgba[4]) ? +rgba[4] : 1;
  return [
    +rgba[1],
    +rgba[2],
    +rgba[3],
    a
  ]
};

/**
 * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array
 * @param  {String} hexValue
 * @return {ColorArray}
 */
const hexToRgba = hexValue => {
  const hexLength = hexValue.length;
  const isShort = hexLength === 4 || hexLength === 5;
  return [
    +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),
    +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),
    +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),
    ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)
  ]
};

/**
 * @param  {Number} p
 * @param  {Number} q
 * @param  {Number} t
 * @return {Number}
 */
const hue2rgb = (p, q, t) => {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  return t < 1 / 6 ? p + (q - p) * 6 * t :
         t < 1 / 2 ? q :
         t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :
         p;
};

/**
 * HSL / HSLA Color value string -> RGBA values array
 * @param  {String} hslValue
 * @return {ColorArray}
 */
const hslToRgba = hslValue => {
  const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);
  const h = +hsla[1] / 360;
  const s = +hsla[2] / 100;
  const l = +hsla[3] / 100;
  const a = !isUnd(hsla[4]) ? +hsla[4] : 1;
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const q = l < .5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = round$1(hue2rgb(p, q, h + 1 / 3) * 255, 0);
    g = round$1(hue2rgb(p, q, h) * 255, 0);
    b = round$1(hue2rgb(p, q, h - 1 / 3) * 255, 0);
  }
  return [r, g, b, a];
};

/**
 * All in one color converter that converts a color string value into an array of RGBA values
 * @param  {String} colorString
 * @return {ColorArray}
 */
const convertColorStringValuesToRgbaArray = colorString => {
  return isRgb(colorString) ? rgbToRgba(colorString) :
         isHex(colorString) ? hexToRgba(colorString) :
         isHsl(colorString) ? hslToRgba(colorString) :
         [0, 0, 0, 1];
};



/**
 * @template T, D
 * @param {T|undefined} targetValue
 * @param {D} defaultValue
 * @return {T|D}
 */
const setValue = (targetValue, defaultValue) => {
  return isUnd(targetValue) ? defaultValue : targetValue;
};

/**
 * @param  {TweenPropValue} value
 * @param  {Target} target
 * @param  {Number} index
 * @param  {Number} total
 * @param  {Object} [store]
 * @return {any}
 */
const getFunctionValue = (value, target, index, total, store) => {
  let func;
  if (isFnc(value)) {
    func = () => {
      const computed = /** @type {Function} */(value)(target, index, total);
      // Fallback to 0 if the function returns undefined / NaN / null / false / 0
      return !isNaN(+computed) ? +computed : computed || 0;
    };
  } else if (isStr(value) && stringStartsWith(value, cssVarPrefix)) {
    func = () => {
      const match = value.match(cssVariableMatchRgx);
      const cssVarName = match[1];
      const fallbackValue = match[2];
      let computed = getComputedStyle(/** @type {HTMLElement} */(target))?.getPropertyValue(cssVarName);
      // Use fallback if CSS variable is not set or empty
      if ((!computed || computed.trim() === emptyString) && fallbackValue) {
        computed = fallbackValue.trim();
      }
      return computed || 0;
    };
  } else {
    return value;
  }
  if (store) store.func = func;
  return func();
};

/**
 * @param  {Target} target
 * @param  {String} prop
 * @return {tweenTypes}
 */
const getTweenType = (target, prop) => {
  return !target[isDomSymbol] ? tweenTypes.OBJECT :
    // Handle SVG attributes
    target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE :
    // Handle CSS Transform properties differently than CSS to allow individual animations
    validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM :
    // CSS variables
    stringStartsWith(prop, '--') ? tweenTypes.CSS_VAR :
    // All other CSS properties
    prop in /** @type {DOMTarget} */(target).style ? tweenTypes.CSS :
    // Handle other DOM Attributes
    prop in target ? tweenTypes.OBJECT :
    tweenTypes.ATTRIBUTE;
};

/**
 * @param  {DOMTarget} target
 * @param  {String} propName
 * @param  {Object} animationInlineStyles
 * @return {String}
 */
const getCSSValue = (target, propName, animationInlineStyles) => {
  const inlineStyles = target.style[propName];
  if (inlineStyles && animationInlineStyles) {
    animationInlineStyles[propName] = inlineStyles;
  }
  const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);
  return value === 'auto' ? '0' : value;
};

/**
 * @param {Target} target
 * @param {String} propName
 * @param {tweenTypes} [tweenType]
 * @param {Object|void} [animationInlineStyles]
 * @return {String|Number}
 */
const getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {
  const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);
  return type === tweenTypes.OBJECT ? target[propName] || 0 :
         type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */(target).getAttribute(propName) :
         type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */(target), propName, animationInlineStyles) :
         type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles).trimStart() :
         getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles);
};

/**
 * @param  {Number} x
 * @param  {Number} y
 * @param  {String} operator
 * @return {Number}
 */
const getRelativeValue = (x, y, operator) => {
  return operator === '-' ? x - y :
         operator === '+' ? x + y :
         x * y;
};

/** @return {TweenDecomposedValue} */
const createDecomposedValueTargetObject = () => {
  return {
    /** @type {valueTypes} */
    t: valueTypes.NUMBER,
    n: 0,
    u: null,
    o: null,
    d: null,
    s: null,
  }
};

/**
 * @param  {String|Number} rawValue
 * @param  {TweenDecomposedValue} targetObject
 * @return {TweenDecomposedValue}
 */
const decomposeRawValue = (rawValue, targetObject) => {
  /** @type {valueTypes} */
  targetObject.t = valueTypes.NUMBER;
  targetObject.n = 0;
  targetObject.u = null;
  targetObject.o = null;
  targetObject.d = null;
  targetObject.s = null;
  if (!rawValue) return targetObject;
  const num = +rawValue;
  if (!isNaN(num)) {
    // It's a number
    targetObject.n = num;
    return targetObject;
  } else {
    // let str = /** @type {String} */(rawValue).trim();
    let str = /** @type {String} */(rawValue);
    // Parsing operators (+=, -=, *=) manually is much faster than using regex here
    if (str[1] === '=') {
      targetObject.o = str[0];
      str = str.slice(2);
    }
    // Skip exec regex if the value type is complex or color to avoid long regex backtracking
    const unitMatch = str.includes(' ') ? false : unitsExecRgx.exec(str);
    if (unitMatch) {
      // Has a number and a unit
      targetObject.t = valueTypes.UNIT;
      targetObject.n = +unitMatch[1];
      targetObject.u = unitMatch[2];
      return targetObject;
    } else if (targetObject.o) {
      // Has an operator (+=, -=, *=)
      targetObject.n = +str;
      return targetObject;
    } else if (isCol(str)) {
      // Is a color
      targetObject.t = valueTypes.COLOR;
      targetObject.d = convertColorStringValuesToRgbaArray(str);
      return targetObject;
    } else {
      // Is a more complex string (generally svg coords, calc() or filters CSS values)
      const matchedNumbers = str.match(digitWithExponentRgx);
      targetObject.t = valueTypes.COMPLEX;
      targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];
      targetObject.s = str.split(digitWithExponentRgx) || [];
      return targetObject;
    }
  }
};

/**
 * @param  {Tween} tween
 * @param  {TweenDecomposedValue} targetObject
 * @return {TweenDecomposedValue}
 */
const decomposeTweenValue = (tween, targetObject) => {
  targetObject.t = tween._valueType;
  targetObject.n = tween._toNumber;
  targetObject.u = tween._unit;
  targetObject.o = null;
  targetObject.d = cloneArray(tween._toNumbers);
  targetObject.s = cloneArray(tween._strings);
  return targetObject;
};

const decomposedOriginalValue = createDecomposedValueTargetObject();







/**
 * @param  {Tickable} tickable
 * @param  {Number} time
 * @param  {Number} muteCallbacks
 * @param  {Number} internalRender
 * @param  {tickModes} tickMode
 * @return {Number}
 */
const render = (tickable, time, muteCallbacks, internalRender, tickMode) => {

  const parent = tickable.parent;
  const duration = tickable.duration;
  const completed = tickable.completed;
  const iterationDuration = tickable.iterationDuration;
  const iterationCount = tickable.iterationCount;
  const _currentIteration = tickable._currentIteration;
  const _loopDelay = tickable._loopDelay;
  const _reversed = tickable._reversed;
  const _alternate = tickable._alternate;
  const _hasChildren = tickable._hasChildren;
  const tickableDelay = tickable._delay;
  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime

  const tickableEndTime = tickableDelay + iterationDuration;
  const tickableAbsoluteTime = time - tickableDelay;
  const tickablePrevTime = clamp$1(tickablePrevAbsoluteTime, -tickableDelay, duration);
  const tickableCurrentTime = clamp$1(tickableAbsoluteTime, -tickableDelay, duration);
  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;
  const isCurrentTimeAboveZero = tickableCurrentTime > 0;
  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;
  const isSetter = duration <= minValue;
  const forcedTick = tickMode === tickModes.FORCE;

  let isOdd = 0;
  let iterationElapsedTime = tickableAbsoluteTime;
  // Render checks
  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer
  let hasRendered = 0;

  // Execute the "expensive" iterations calculations only when necessary
  if (iterationCount > 1) {
    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers
    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));
    tickable._currentIteration = clamp$1(currentIteration, 0, iterationCount);
    // Prevent the iteration count to go above the max iterations when reaching the end of the animation
    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;
    isOdd = tickable._currentIteration % 2;
    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;
  }

  // Checks if exactly one of _reversed and (_alternate && isOdd) is true
  const isReversed = _reversed ^ (_alternate && isOdd);
  const _ease = /** @type {Renderable} */(tickable)._ease;
  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;
  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;
  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;

  tickable._currentTime = tickableAbsoluteTime;
  tickable._iterationTime = iterationTime;
  tickable.backwards = isRunningBackwards;

  if (isCurrentTimeAboveZero && !tickable.began) {
    tickable.began = true;
    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
      tickable.onBegin(/** @type {CallbackArgument} */(tickable));
    }
  } else if (tickableAbsoluteTime <= 0) {
    tickable.began = false;
  }

  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function
  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values
  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {
    tickable.onLoop(/** @type {CallbackArgument} */(tickable));
  }

  if (
    forcedTick ||
    tickMode === tickModes.AUTO && (
      time >= tickableDelay && time <= tickableEndTime || // Normal render
      time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state
      time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state
    ) ||
    iterationTime >= tickableEndTime && tickablePrevTime !== duration ||
    iterationTime <= tickableDelay && tickablePrevTime > 0 ||
    time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation
    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped
  ) {

    if (isCurrentTimeAboveZero) {
      // Trigger onUpdate callback before rendering
      tickable.computeDeltaTime(tickablePrevTime);
      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */(tickable));
    }

    // Start tweens rendering
    if (!_hasChildren) {

      // Time has jumped more than globals.tickThreshold so consider this tick manual
      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;
      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;

      // Only Animation can have tweens, Timer returns undefined
      let tween = /** @type {Tween} */(/** @type {JSAnimation} */(tickable)._head);
      let tweenTarget;
      let tweenStyle;
      let tweenTargetTransforms;
      let tweenTargetTransformsProperties;
      let tweenTransformsNeedUpdate = 0;

      while (tween) {

        const tweenComposition = tween._composition;
        const tweenCurrentTime = tween._currentTime;
        const tweenChangeDuration = tween._changeDuration;
        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;
        const tweenNextRep = tween._nextRep;
        const tweenPrevRep = tween._prevRep;
        const tweenHasComposition = tweenComposition !== compositionTypes.none;

        if ((forcedRender || (
            (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&
            (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)
          )) && (!tweenHasComposition || (
            !tween._isOverridden &&
            (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&
            (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&
            (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))
          ))
        ) {

          const tweenNewTime = tween._currentTime = clamp$1(iterationTime - tween._startTime, 0, tweenChangeDuration);
          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);
          const tweenModifier = tween._modifier;
          const tweenValueType = tween._valueType;
          const tweenType = tween._tweenType;
          const tweenIsObject = tweenType === tweenTypes.OBJECT;
          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;
          // Only round the in-between frames values if the final value is a string
          const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;

          // Recompose tween value
          /** @type {String|Number} */
          let value;
          /** @type {Number} */
          let number;

          if (tweenIsNumber) {
            value = number = /** @type {Number} */(tweenModifier(round$1(lerp$1(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision )));
          } else if (tweenValueType === valueTypes.UNIT) {
            // Rounding the values speed up string composition
            number = /** @type {Number} */(tweenModifier(round$1(lerp$1(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision)));
            value = `${number}${tween._unit}`;
          } else if (tweenValueType === valueTypes.COLOR) {
            const fn = tween._fromNumbers;
            const tn = tween._toNumbers;
            const r = round$1(clamp$1(/** @type {Number} */(tweenModifier(lerp$1(fn[0], tn[0], tweenProgress))), 0, 255), 0);
            const g = round$1(clamp$1(/** @type {Number} */(tweenModifier(lerp$1(fn[1], tn[1], tweenProgress))), 0, 255), 0);
            const b = round$1(clamp$1(/** @type {Number} */(tweenModifier(lerp$1(fn[2], tn[2], tweenProgress))), 0, 255), 0);
            const a = clamp$1(/** @type {Number} */(tweenModifier(round$1(lerp$1(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);
            value = `rgba(${r},${g},${b},${a})`;
            if (tweenHasComposition) {
              const ns = tween._numbers;
              ns[0] = r;
              ns[1] = g;
              ns[2] = b;
              ns[3] = a;
            }
          } else if (tweenValueType === valueTypes.COMPLEX) {
            value = tween._strings[0];
            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {
              const n = /** @type {Number} */(tweenModifier(round$1(lerp$1(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));
              const s = tween._strings[j + 1];
              value += `${s ? n + s : n}`;
              if (tweenHasComposition) {
                tween._numbers[j] = n;
              }
            }
          }

          // For additive tweens and Animatables
          if (tweenHasComposition) {
            tween._number = number;
          }

          if (!internalRender && tweenComposition !== compositionTypes.blend) {

            const tweenProperty = tween.property;
            tweenTarget = tween.target;

            if (tweenIsObject) {
              tweenTarget[tweenProperty] = value;
            } else if (tweenType === tweenTypes.ATTRIBUTE) {
              /** @type {DOMTarget} */(tweenTarget).setAttribute(tweenProperty, /** @type {String} */(value));
            } else {
              tweenStyle = /** @type {DOMTarget} */(tweenTarget).style;
              if (tweenType === tweenTypes.TRANSFORM) {
                if (tweenTarget !== tweenTargetTransforms) {
                  tweenTargetTransforms = tweenTarget;
                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.
                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];
                }
                tweenTargetTransformsProperties[tweenProperty] = value;
                tweenTransformsNeedUpdate = 1;
              } else if (tweenType === tweenTypes.CSS) {
                tweenStyle[tweenProperty] = value;
              } else if (tweenType === tweenTypes.CSS_VAR) {
                tweenStyle.setProperty(tweenProperty,/** @type {String} */(value));
              }
            }

            if (isCurrentTimeAboveZero) hasRendered = 1;

          } else {
            // Used for composing timeline tweens without having to do a real render
            tween._value = value;
          }

        }

        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax
        // to reduce memory usage on string composition
        if (tweenTransformsNeedUpdate && tween._renderTransforms) {
          let str = emptyString;
          for (let key in tweenTargetTransformsProperties) {
            str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;
          }
          tweenStyle.transform = str;
          tweenTransformsNeedUpdate = 0;
        }

        tween = tween._next;
      }

      if (!muteCallbacks && hasRendered) {
        /** @type {JSAnimation} */(tickable).onRender(/** @type {JSAnimation} */(tickable));
      }
    }

    if (!muteCallbacks && isCurrentTimeAboveZero) {
      tickable.onUpdate(/** @type {CallbackArgument} */(tickable));
    }

  }

  // End tweens rendering

  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards
  if (parent && isSetter) {
    if (!muteCallbacks && (
      // (tickableAbsoluteTime > 0 instead) of (tickableAbsoluteTime >= duration) to prevent floating point precision issues
      // see: https://github.com/juliangarnier/anime/issues/1088
      (parent.began && !isRunningBackwards && tickableAbsoluteTime > 0 && !completed) ||
      (isRunningBackwards && tickableAbsoluteTime <= minValue && completed)
    )) {
      tickable.onComplete(/** @type {CallbackArgument} */(tickable));
      tickable.completed = !isRunningBackwards;
    }
  // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops
  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {
    if (iterationCount === Infinity) {
      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer
      tickable._startTime += tickable.duration;
    } else if (tickable._currentIteration >= iterationCount - 1) {
      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick
      tickable.paused = true;
      if (!completed && !_hasChildren) {
        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function
        tickable.completed = true;
        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
          tickable.onComplete(/** @type {CallbackArgument} */(tickable));
          tickable._resolve(/** @type {CallbackArgument} */(tickable));
        }
      }
    }
  // Otherwise set the completed flag to false
  } else {
    tickable.completed = false;
  }

  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?
  return hasRendered;
};

/**
 * @param  {Tickable} tickable
 * @param  {Number} time
 * @param  {Number} muteCallbacks
 * @param  {Number} internalRender
 * @param  {Number} tickMode
 * @return {void}
 */
const tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {
  const _currentIteration = tickable._currentIteration;
  render(tickable, time, muteCallbacks, internalRender, tickMode);
  if (tickable._hasChildren) {
    const tl = /** @type {Timeline} */(tickable);
    const tlIsRunningBackwards = tl.backwards;
    const tlChildrenTime = internalRender ? time : tl._iterationTime;
    const tlCildrenTickTime = now();

    let tlChildrenHasRendered = 0;
    let tlChildrenHaveCompleted = true;

    // If the timeline has looped forward, we need to manually triggers children skipped callbacks
    if (!internalRender && tl._currentIteration !== _currentIteration) {
      const tlIterationDuration = tl.iterationDuration;
      forEachChildren(tl, (/** @type {JSAnimation} */child) => {
        if (!tlIsRunningBackwards) {
          // Force an internal render to trigger the callbacks if the child has not completed on loop
          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {
            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);
          }
          // Reset their began and completed flags to allow retrigering callbacks on the next iteration
          child.began = false;
          child.completed = false;
        } else {
          const childDuration = child.duration;
          const childStartTime = child._offset + child._delay;
          const childEndTime = childStartTime + childDuration;
          // Triggers the onComplete callback on reverse for children on the edges of the timeline
          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {
            child.onComplete(child);
          }
        }
      });
      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */(tl));
    }

    forEachChildren(tl, (/** @type {JSAnimation} */child) => {
      const childTime = round$1((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds
      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;
      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);
      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;
    }, tlIsRunningBackwards);

    // Renders on timeline are triggered by its children so it needs to be set after rendering the children
    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */(tl));

    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end
    if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {
      // Make sure the paused flag is false in case it has been skipped in the render function
      tl.paused = true;
      if (!tl.completed) {
        tl.completed = true;
        if (!muteCallbacks) {
          tl.onComplete(/** @type {CallbackArgument} */(tl));
          tl._resolve(/** @type {CallbackArgument} */(tl));
        }
      }
    }
  }
};





const propertyNamesCache = {};

/**
 * @param  {String} propertyName
 * @param  {Target} target
 * @param  {tweenTypes} tweenType
 * @return {String}
 */
const sanitizePropertyName = (propertyName, target, tweenType) => {
  if (tweenType === tweenTypes.TRANSFORM) {
    const t = shortTransforms.get(propertyName);
    return t ? t : propertyName;
  } else if (
    tweenType === tweenTypes.CSS ||
    // Handle special cases where properties like "strokeDashoffset" needs to be set as "stroke-dashoffset"
    // but properties like "baseFrequency" should stay in lowerCamelCase
    (tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */(target).style))
  ) {
    const cachedPropertyName = propertyNamesCache[propertyName];
    if (cachedPropertyName) {
      return cachedPropertyName;
    } else {
      const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;
      propertyNamesCache[propertyName] = lowerCaseName;
      return lowerCaseName;
    }
  } else {
    return propertyName;
  }
};

/**
 * @template {Renderable} T
 * @param {T} renderable
 * @return {T}
 */
const cleanInlineStyles = renderable => {
  // Allow cleanInlineStyles() to be called on timelines
  if (renderable._hasChildren) {
    forEachChildren(renderable, cleanInlineStyles, true);
  } else {
    const animation = /** @type {JSAnimation} */(renderable);
    animation.pause();
    forEachChildren(animation, (/** @type {Tween} */tween) => {
      const tweenProperty = tween.property;
      const tweenTarget = tween.target;
      if (tweenTarget[isDomSymbol]) {
        const targetStyle = /** @type {DOMTarget} */(tweenTarget).style;
        const originalInlinedValue = tween._inlineValue;
        const tweenHadNoInlineValue = isNil(originalInlinedValue) || originalInlinedValue === emptyString;
        if (tween._tweenType === tweenTypes.TRANSFORM) {
          const cachedTransforms = tweenTarget[transformsSymbol];
          if (tweenHadNoInlineValue) {
            delete cachedTransforms[tweenProperty];
          } else {
            cachedTransforms[tweenProperty] = originalInlinedValue;
          }
          if (tween._renderTransforms) {
            if (!Object.keys(cachedTransforms).length) {
              targetStyle.removeProperty('transform');
            } else {
              let str = emptyString;
              for (let key in cachedTransforms) {
                str += transformsFragmentStrings[key] + cachedTransforms[key] + ') ';
              }
              targetStyle.transform = str;
            }
          }
        } else {
          if (tweenHadNoInlineValue) {
            targetStyle.removeProperty(toLowerCase(tweenProperty));
          } else {
            targetStyle[tweenProperty] = originalInlinedValue;
          }
        }
        if (animation._tail === tween) {
          animation.targets.forEach(t => {
            if (t.getAttribute && t.getAttribute('style') === emptyString) {
              t.removeAttribute('style');
            }          });
        }
      }
    });
  }
  return renderable;
};



/*
 * Base class to control framerate and playback rate.
 * Inherited by Engine, Timer, Animation and Timeline.
 */
class Clock {

  /** @param {Number} [initTime] */
  constructor(initTime = 0) {
    /** @type {Number} */
    this.deltaTime = 0;
    /** @type {Number} */
    this._currentTime = initTime;
    /** @type {Number} */
    this._lastTickTime = initTime;
    /** @type {Number} */
    this._startTime = initTime;
    /** @type {Number} */
    this._lastTime = initTime;
    /** @type {Number} */
    this._scheduledTime = 0;
    /** @type {Number} */
    this._frameDuration = K / maxFps;
    /** @type {Number} */
    this._fps = maxFps;
    /** @type {Number} */
    this._speed = 1;
    /** @type {Boolean} */
    this._hasChildren = false;
    /** @type {Tickable|Tween} */
    this._head = null;
    /** @type {Tickable|Tween} */
    this._tail = null;
  }

  get fps() {
    return this._fps;
  }

  set fps(frameRate) {
    const previousFrameDuration = this._frameDuration;
    const fr = +frameRate;
    const fps = fr < minValue ? minValue : fr;
    const frameDuration = K / fps;
    if (fps > defaults.frameRate) defaults.frameRate = fps;
    this._fps = fps;
    this._frameDuration = frameDuration;
    this._scheduledTime += frameDuration - previousFrameDuration;
  }

  get speed() {
    return this._speed;
  }

  set speed(playbackRate) {
    const pbr = +playbackRate;
    this._speed = pbr < minValue ? minValue : pbr;
  }

  /**
   * @param  {Number} time
   * @return {tickModes}
   */
  requestTick(time) {
    const scheduledTime = this._scheduledTime;
    this._lastTickTime = time;
    // If the current time is lower than the scheduled time
    // this means not enough time has passed to hit one frameDuration
    // so skip that frame
    if (time < scheduledTime) return tickModes.NONE;
    const frameDuration = this._frameDuration;
    const frameDelta = time - scheduledTime;
    // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.
    // Skips ahead if the actual elapsed time is higher.
    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;
    return tickModes.AUTO;
  }

  /**
   * @param  {Number} time
   * @return {Number}
   */
  computeDeltaTime(time) {
    const delta = time - this._lastTime;
    this.deltaTime = delta;
    this._lastTime = time;
    return delta;
  }

}

const additive = {
  animation: null,
  update: noop,
};



/**
 * @typedef AdditiveAnimation
 * @property {Number} duration
 * @property {Number} _offset
 * @property {Number} _delay
 * @property {Tween} _head
 * @property {Tween} _tail
 */

/**
 * @param  {TweenAdditiveLookups} lookups
 * @return {AdditiveAnimation}
 */
const addAdditiveAnimation = lookups => {
  let animation = additive.animation;
  if (!animation) {
    animation = {
      duration: minValue,
      computeDeltaTime: noop,
      _offset: 0,
      _delay: 0,
      _head: null,
      _tail: null,
    };
    additive.animation = animation;
    additive.update = () => {
      lookups.forEach(propertyAnimation => {
        for (let propertyName in propertyAnimation) {
          const tweens = propertyAnimation[propertyName];
          const lookupTween = tweens._head;
          if (lookupTween) {
            const valueType = lookupTween._valueType;
            const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;
            let additiveValue = lookupTween._fromNumber;
            let tween = tweens._tail;
            while (tween && tween !== lookupTween) {
              if (additiveValues) {
                for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];
              } else {
                additiveValue += tween._number;
              }
              tween = tween._prevAdd;
            }
            lookupTween._toNumber = additiveValue;
            lookupTween._toNumbers = additiveValues;
          }
        }
      });
      // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop
      render(animation, 1, 1, 0, tickModes.FORCE);
    };
  }
  return animation;
};





const engineTickMethod = /*#__PURE__*/ (() => isBrowser ? requestAnimationFrame : setImmediate)();
const engineCancelMethod = /*#__PURE__*/ (() => isBrowser ? cancelAnimationFrame : clearImmediate)();

class Engine extends Clock {

  /** @param {Number} [initTime] */
  constructor(initTime) {
    super(initTime);
    this.useDefaultMainLoop = true;
    this.pauseOnDocumentHidden = true;
    /** @type {DefaultsParams} */
    this.defaults = defaults;
    // this.paused = isBrowser && doc.hidden ? true  : false;
    this.paused = true;
    /** @type {Number|NodeJS.Immediate} */
    this.reqId = 0;
  }

  update() {
    const time = this._currentTime = now();
    if (this.requestTick(time)) {
      this.computeDeltaTime(time);
      const engineSpeed = this._speed;
      const engineFps = this._fps;
      let activeTickable = /** @type {Tickable} */(this._head);
      while (activeTickable) {
        const nextTickable = activeTickable._next;
        if (!activeTickable.paused) {
          tick(
            activeTickable,
            (time - activeTickable._startTime) * activeTickable._speed * engineSpeed,
            0, // !muteCallbacks
            0, // !internalRender
            activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO
          );
        } else {
          removeChild(this, activeTickable);
          this._hasChildren = !!this._tail;
          activeTickable._running = false;
          if (activeTickable.completed && !activeTickable._cancelled) {
            activeTickable.cancel();
          }
        }
        activeTickable = nextTickable;
      }
      additive.update();
    }
  }

  wake() {
    if (this.useDefaultMainLoop && !this.reqId) {
      // Imediatly request a tick to update engine._lastTickTime and get accurate offsetPosition calculation in timer.js
      this.requestTick(now());
      this.reqId = engineTickMethod(tickEngine);
    }
    return this;
  }

  pause() {
    if (!this.reqId) return;
    this.paused = true;
    return killEngine();
  }

  resume() {
    if (!this.paused) return;
    this.paused = false;
    forEachChildren(this, (/** @type {Tickable} */child) => child.resetTime());
    return this.wake();
  }

  // Getter and setter for speed
  get speed() {
    return this._speed * (globals.timeScale === 1 ? 1 : K);
  }

  set speed(playbackRate) {
    this._speed = playbackRate * globals.timeScale;
    forEachChildren(this, (/** @type {Tickable} */child) => child.speed = child._speed);
  }

  // Getter and setter for timeUnit
  get timeUnit() {
    return globals.timeScale === 1 ? 'ms' : 's';
  }

  set timeUnit(unit) {
    const secondsScale = 0.001;
    const isSecond = unit === 's';
    const newScale = isSecond ? secondsScale : 1;
    if (globals.timeScale !== newScale) {
      globals.timeScale = newScale;
      globals.tickThreshold = 200 * newScale;
      const scaleFactor = isSecond ? secondsScale : K;
      /** @type {Number} */
      (this.defaults.duration) *= scaleFactor;
      this._speed *= scaleFactor;
    }
  }

  // Getter and setter for precision
  get precision() {
    return globals.precision;
  }

  set precision(precision) {
    globals.precision = precision;
  }

}

const engine = /*#__PURE__*/(() => {
  const engine = new Engine(now());
  if (isBrowser) {
    globalVersions.engine = engine;
    doc.addEventListener('visibilitychange', () => {
      if (!engine.pauseOnDocumentHidden) return;
      doc.hidden ? engine.pause() : engine.resume();
    });
  }
  return engine;
})();


const tickEngine = () => {
  if (engine._head) {
    engine.reqId = engineTickMethod(tickEngine);
    engine.update();
  } else {
    engine.reqId = 0;
  }
};

const killEngine = () => {
  engineCancelMethod(/** @type {NodeJS.Immediate & Number} */(engine.reqId));
  engine.reqId = 0;
  return engine;
};



const lookups = {
  /** @type {TweenReplaceLookups} */
  _rep: new WeakMap(),
  /** @type {TweenAdditiveLookups} */
  _add: new Map(),
};

/**
 * @param  {Target} target
 * @param  {String} property
 * @param  {String} lookup
 * @return {TweenPropertySiblings}
 */
const getTweenSiblings = (target, property, lookup = '_rep') => {
  const lookupMap = lookups[lookup];
  let targetLookup = lookupMap.get(target);
  if (!targetLookup) {
    targetLookup = {};
    lookupMap.set(target, targetLookup);
  }
  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {
    _head: null,
    _tail: null,
  }
};

/**
 * @param  {Tween} p
 * @param  {Tween} c
 * @return {Number|Boolean}
 */
const addTweenSortMethod = (p, c) => {
  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;
};

/**
 * @param {Tween} tween
 */
const overrideTween = tween => {
  tween._isOverlapped = 1;
  tween._isOverridden = 1;
  tween._changeDuration = minValue;
  tween._currentTime = minValue;
};

/**
 * @param  {Tween} tween
 * @param  {TweenPropertySiblings} siblings
 * @return {Tween}
 */
const composeTween = (tween, siblings) => {

  const tweenCompositionType = tween._composition;

  // Handle replaced tweens

  if (tweenCompositionType === compositionTypes.replace) {

    const tweenAbsStartTime = tween._absoluteStartTime;

    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');

    const prevSibling = tween._prevRep;

    // Update the previous siblings for composition replace tweens

    if (prevSibling) {

      const prevParent = prevSibling.parent;
      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;

      // Handle looped animations tween

      if (
        // Check if the previous tween is from a different animation
        tween.parent.id !== prevParent.id &&
        // Check if the animation has loops
        prevParent.iterationCount> 1 &&
        // Check if _absoluteChangeEndTime of last loop overlaps the current tween
        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime
      ) {

        // TODO: Find a way to only override the iterations overlapping with the tween
        overrideTween(prevSibling);

        let prevPrevSibling = prevSibling._prevRep;

        // If the tween was part of a set of keyframes, override its siblings
        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {
          overrideTween(prevPrevSibling);
          prevPrevSibling = prevPrevSibling._prevRep;
        }

      }

      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;

      if (prevAbsEndTime > absoluteUpdateStartTime) {

        const prevChangeStartTime = prevSibling._startTime;
        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);
        // Rounding is necessary here to minimize floating point errors when working in seconds
        const updatedPrevChangeDuration = round$1(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);

        prevSibling._changeDuration = updatedPrevChangeDuration;
        prevSibling._currentTime = updatedPrevChangeDuration;
        prevSibling._isOverlapped = 1;

        // Override the previous tween if its new _changeDuration is lower than minValue
        // TODO: See if it's even neceseeary to test against minValue, checking for 0 might be enough
        if (updatedPrevChangeDuration < minValue) {
          overrideTween(prevSibling);
        }
      }

      // Pause (and cancel) the parent if it only contains overlapped tweens

      let pausePrevParentAnimation = true;

      forEachChildren(prevParent, (/** @type Tween */t) => {
        if (!t._isOverlapped) pausePrevParentAnimation = false;
      });

      if (pausePrevParentAnimation) {
        const prevParentTL = prevParent.parent;
        if (prevParentTL) {
          let pausePrevParentTL = true;
          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {
            if (a !== prevParent) {
              forEachChildren(a, (/** @type Tween */t) => {
                if (!t._isOverlapped) pausePrevParentTL = false;
              });
            }
          });
          if (pausePrevParentTL) {
            prevParentTL.cancel();
          }
        } else {
          prevParent.cancel();
          // Previously, calling .cancel() on a timeline child would affect the render order of other children
          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop
          // This is no longer needed since timeline tween composition is now handled separately
          // Keeping this here for reference
          // prevParent.completed = true;
          // prevParent.pause();
        }
      }

    }

    // let nextSibling = tween._nextRep;

    // // All the next siblings are automatically overridden

    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {
    //   while (nextSibling) {
    //     overrideTween(nextSibling);
    //     nextSibling = nextSibling._nextRep;
    //   }
    // }

    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {
    //   while (nextSibling) {
    //     overrideTween(nextSibling);
    //     console.log(tween.id, nextSibling.id);
    //     nextSibling = nextSibling._nextRep;
    //   }
    // }

  // Handle additive tweens composition

  } else if (tweenCompositionType === compositionTypes.blend) {

    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');
    const additiveAnimation = addAdditiveAnimation(lookups._add);

    let lookupTween = additiveTweenSiblings._head;

    if (!lookupTween) {
      lookupTween = { ...tween };
      lookupTween._composition = compositionTypes.replace;
      lookupTween._updateDuration = minValue;
      lookupTween._startTime = 0;
      lookupTween._numbers = cloneArray(tween._fromNumbers);
      lookupTween._number = 0;
      lookupTween._next = null;
      lookupTween._prev = null;
      addChild(additiveTweenSiblings, lookupTween);
      addChild(additiveAnimation, lookupTween);
    }

    // Convert the values of TO to FROM and set TO to 0

    const toNumber = tween._toNumber;
    tween._fromNumber = lookupTween._fromNumber - toNumber;
    tween._toNumber = 0;
    tween._numbers = cloneArray(tween._fromNumbers);
    tween._number = 0;
    lookupTween._fromNumber = toNumber;

    if (tween._toNumbers) {
      const toNumbers = cloneArray(tween._toNumbers);
      if (toNumbers) {
        toNumbers.forEach((value, i) => {
          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;
          tween._toNumbers[i] = 0;
        });
      }
      lookupTween._fromNumbers = toNumbers;
    }

    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');

  }

  return tween;

};

/**
 * @param  {Tween} tween
 * @return {Tween}
 */
const removeTweenSliblings = tween => {
  const tweenComposition = tween._composition;
  if (tweenComposition !== compositionTypes.none) {
    const tweenTarget = tween.target;
    const tweenProperty = tween.property;
    const replaceTweensLookup = lookups._rep;
    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);
    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];
    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');
    if (tweenComposition === compositionTypes.blend) {
      const addTweensLookup = lookups._add;
      const addTargetProps = addTweensLookup.get(tweenTarget);
      if (!addTargetProps) return;
      const additiveTweenSiblings = addTargetProps[tweenProperty];
      const additiveAnimation = additive.animation;
      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');
      // If only one tween is left in the additive lookup, it's the tween lookup
      const lookupTween = additiveTweenSiblings._head;
      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {
        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');
        removeChild(additiveAnimation, lookupTween);
        let shouldClean = true;
        for (let prop in addTargetProps) {
          if (addTargetProps[prop]._head) {
            shouldClean = false;
            break;
          }
        }
        if (shouldClean) {
          addTweensLookup.delete(tweenTarget);
        }
      }
    }
  }
  return tween;
};

/**
 * @param  {TargetsArray} targetsArray
 * @param  {JSAnimation} animation
 * @param  {String} [propertyName]
 * @return {Boolean}
 */
const removeTargetsFromJSAnimation = (targetsArray, animation, propertyName) => {
  let tweensMatchesTargets = false;
  forEachChildren(animation, (/**@type {Tween} */tween) => {
    const tweenTarget = tween.target;
    if (targetsArray.includes(tweenTarget)) {
      const tweenName = tween.property;
      const tweenType = tween._tweenType;
      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);
      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {
        // Make sure to flag the previous CSS transform tween to renderTransform
        if (tween.parent._tail === tween &&
            tween._tweenType === tweenTypes.TRANSFORM &&
            tween._prev &&
            tween._prev._tweenType === tweenTypes.TRANSFORM
        ) {
          tween._prev._renderTransforms = 1;
        }
        // Removes the tween from the selected animation
        removeChild(animation, tween);
        // Detach the tween from its siblings to make sure blended tweens are correctlly removed
        removeTweenSliblings(tween);
        tweensMatchesTargets = true;
      }
    }
  }, true);
  return tweensMatchesTargets;
};

/**
 * @param  {TargetsArray} targetsArray
 * @param  {Renderable} [renderable]
 * @param  {String} [propertyName]
 */
const removeTargetsFromRenderable = (targetsArray, renderable, propertyName) => {
  const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : engine);
  let removeMatches;
  if (parent._hasChildren) {
    let iterationDuration = 0;
    forEachChildren(parent, (/** @type {Renderable} */child) => {
      if (!child._hasChildren) {
        removeMatches = removeTargetsFromJSAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);
        // Remove the child from its parent if no tweens and no children left after the removal
        if (removeMatches && !child._head) {
          child.cancel();
          removeChild(parent, child);
        } else {
          // Calculate the new iterationDuration value to handle onComplete with last child in render()
          const childTLOffset = child._offset + child._delay;
          const childDur = childTLOffset + child.duration;
          if (childDur > iterationDuration) {
            iterationDuration = childDur;
          }
        }
      }
      // Make sure to also remove engine's children targets
      // NOTE: Avoid recursion?
      if (child._head) {
        removeTargetsFromRenderable(targetsArray, child, propertyName);
      } else {
        child._hasChildren = false;
      }
    }, true);
    // Update iterationDuration value to handle onComplete with last child in render()
    if (!isUnd(/** @type {Renderable} */(parent).iterationDuration)) {
      /** @type {Renderable} */(parent).iterationDuration = iterationDuration;
    }
  } else {
    removeMatches = removeTargetsFromJSAnimation(
      targetsArray,
      /** @type {JSAnimation} */(parent),
      propertyName
    );
  }
  if (removeMatches && !parent._head) {
    parent._hasChildren = false;
    // Cancel the parent if there are no tweens and no children left after the removal
    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself
    if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();
  }
};







/**
 * @param  {Timer} timer
 * @return {Timer}
 */
const resetTimerProperties = timer => {
  timer.paused = true;
  timer.began = false;
  timer.completed = false;
  return timer;
};

/**
 * @param  {Timer} timer
 * @return {Timer}
 */
const reviveTimer = timer => {
  if (!timer._cancelled) return timer;
  if (timer._hasChildren) {
    forEachChildren(timer, reviveTimer);
  } else {
    forEachChildren(timer, (/** @type {Tween} tween */tween) => {
      if (tween._composition !== compositionTypes.none) {
        composeTween(tween, getTweenSiblings(tween.target, tween.property));
      }
    });
  }
  timer._cancelled = 0;
  return timer;
};

let timerId = 0;

/**
 * Base class used to create Timers, Animations and Timelines
 */
class Timer extends Clock {
  /**
   * @param {TimerParams} [parameters]
   * @param {Timeline} [parent]
   * @param {Number} [parentPosition]
   */
  constructor(parameters = {}, parent = null, parentPosition = 0) {

    super(0);

    ++timerId;

    const {
      id,
      delay,
      duration,
      reversed,
      alternate,
      loop,
      loopDelay,
      autoplay,
      frameRate,
      playbackRate,
      onComplete,
      onLoop,
      onPause,
      onBegin,
      onBeforeUpdate,
      onUpdate,
    } = parameters;

    if (scope.current) scope.current.register(this);

    const timerInitTime = parent ? 0 : engine._lastTickTime;
    const timerDefaults = parent ? parent.defaults : globals.defaults;
    const timerDelay = /** @type {Number} */(isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay);
    const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;
    const timerLoop = setValue(loop, timerDefaults.loop);
    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);
    let timerIterationCount = timerLoop === true ||
                              timerLoop === Infinity ||
                              /** @type {Number} */(timerLoop) < 0 ? Infinity :
                              /** @type {Number} */(timerLoop) + 1;

    if (devTools) {
      const isInfinite = timerIterationCount === Infinity;
      const registered = devTools.register(this, parameters, isInfinite);
      if (registered && isInfinite) {
        const minIterations = alternate ? 2 : 1;
        const iterations = parent ? devTools.maxNestedInfiniteLoops : devTools.maxInfiniteLoops;
        timerIterationCount = Math.max(iterations, minIterations);
      }
    }

    let offsetPosition = 0;

    if (parent) {
      offsetPosition = parentPosition;
    } else {
      // Make sure to tick the engine once if not currently running to get up to date engine._lastTickTime
      // to avoid big gaps with the following offsetPosition calculation
      if (!engine.reqId) engine.requestTick(now());
      // Make sure to scale the offset position with globals.timeScale to properly handle seconds unit
      offsetPosition = (engine._lastTickTime - engine._startTime) * globals.timeScale;
    }

    // Timer's parameters
    /** @type {String|Number} */
    this.id = !isUnd(id) ? id : timerId;
    /** @type {Timeline} */
    this.parent = parent;
    // Total duration of the timer
    this.duration = clampInfinity(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || minValue;
    /** @type {Boolean} */
    this.backwards = false;
    /** @type {Boolean} */
    this.paused = true;
    /** @type {Boolean} */
    this.began = false;
    /** @type {Boolean} */
    this.completed = false;
    /** @type {Callback<this>} */
    this.onBegin = onBegin || timerDefaults.onBegin;
    /** @type {Callback<this>} */
    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;
    /** @type {Callback<this>} */
    this.onUpdate = onUpdate || timerDefaults.onUpdate;
    /** @type {Callback<this>} */
    this.onLoop = onLoop || timerDefaults.onLoop;
    /** @type {Callback<this>} */
    this.onPause = onPause || timerDefaults.onPause;
    /** @type {Callback<this>} */
    this.onComplete = onComplete || timerDefaults.onComplete;
    /** @type {Number} */
    this.iterationDuration = timerDuration; // Duration of one loop
    /** @type {Number} */
    this.iterationCount = timerIterationCount; // Number of loops
    /** @type {Boolean|ScrollObserver} */
    this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);
    /** @type {Number} */
    this._offset = offsetPosition;
    /** @type {Number} */
    this._delay = timerDelay;
    /** @type {Number} */
    this._loopDelay = timerLoopDelay;
    /** @type {Number} */
    this._iterationTime = 0;
    /** @type {Number} */
    this._currentIteration = 0; // Current loop index
    /** @type {Function} */
    this._resolve = noop; // Used by .then()
    /** @type {Boolean} */
    this._running = false;
    /** @type {Number} */
    this._reversed = +setValue(reversed, timerDefaults.reversed);
    /** @type {Number} */
    this._reverse = this._reversed;
    /** @type {Number} */
    this._cancelled = 0;
    /** @type {Boolean} */
    this._alternate = setValue(alternate, timerDefaults.alternate);
    /** @type {Renderable} */
    this._prev = null;
    /** @type {Renderable} */
    this._next = null;

    // Clock's parameters
    /** @type {Number} */
    this._lastTickTime = timerInitTime;
    /** @type {Number} */
    this._startTime = timerInitTime;
    /** @type {Number} */
    this._lastTime = timerInitTime;
    /** @type {Number} */
    this._fps = setValue(frameRate, timerDefaults.frameRate);
    /** @type {Number} */
    this._speed = setValue(playbackRate, timerDefaults.playbackRate);
  }

  get cancelled() {
    return !!this._cancelled;
  }

  set cancelled(cancelled) {
    cancelled ? this.cancel() : this.reset(true).play();
  }

  get currentTime() {
    return clamp$1(round$1(this._currentTime, globals.precision), -this._delay, this.duration);
  }

  set currentTime(time) {
    const paused = this.paused;
    // Pausing the timer is necessary to avoid time jumps on a running instance
    this.pause().seek(+time);
    if (!paused) this.resume();
  }

  get iterationCurrentTime() {
    return clamp$1(round$1(this._iterationTime, globals.precision), 0, this.iterationDuration);
  }

  set iterationCurrentTime(time) {
    this.currentTime = (this.iterationDuration * this._currentIteration) + time;
  }

  get progress() {
    return clamp$1(round$1(this._currentTime / this.duration, 10), 0, 1);
  }

  set progress(progress) {
    this.currentTime = this.duration * progress;
  }

  get iterationProgress() {
    return clamp$1(round$1(this._iterationTime / this.iterationDuration, 10), 0, 1);
  }

  set iterationProgress(progress) {
    const iterationDuration = this.iterationDuration;
    this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);
  }

  get currentIteration() {
    return this._currentIteration;
  }

  set currentIteration(iterationCount) {
    this.currentTime = (this.iterationDuration * clamp$1(+iterationCount, 0, this.iterationCount - 1));
  }

  get reversed() {
    return !!this._reversed;
  }

  set reversed(reverse) {
    reverse ? this.reverse() : this.play();
  }

  get speed() {
    return super.speed;
  }

  set speed(playbackRate) {
    super.speed = playbackRate;
    this.resetTime();
  }

  /**
   * @param  {Boolean} [softReset]
   * @return {this}
   */
  reset(softReset = false) {
    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings
    reviveTimer(this);
    if (this._reversed && !this._reverse) this.reversed = false;
    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden
    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order
    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?
    this._iterationTime = this.iterationDuration;
    // Set tickMode to tickModes.FORCE to force rendering
    tick(this, 0, 1, ~~softReset, tickModes.FORCE);
    // Reset timer properties after revive / render to make sure the props are not updated again
    resetTimerProperties(this);
    // Also reset children properties
    if (this._hasChildren) {
      forEachChildren(this, resetTimerProperties);
    }
    return this;
  }

  /**
   * @param  {Boolean} internalRender
   * @return {this}
   */
  init(internalRender = false) {
    this.fps = this._fps;
    this.speed = this._speed;
    // Manually calling .init() on timelines should render all children intial state
    // Forces all children to render once then render to 0 when reseted
    if (!internalRender && this._hasChildren) {
      tick(this, this.duration, 1, ~~internalRender, tickModes.FORCE);
    }
    this.reset(internalRender);
    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link
    const autoplay = this._autoplay;
    if (autoplay === true) {
      this.resume();
    } else if (autoplay && !isUnd(/** @type {ScrollObserver} */(autoplay).linked)) {
      /** @type {ScrollObserver} */(autoplay).link(this);
    }
    return this;
  }

  /** @return {this} */
  resetTime() {
    const timeScale = 1 / (this._speed * engine._speed);
    // TODO: See if we can safely use engine._lastTickTime here
    // if (!engine.reqId) engine.requestTick(now())
    // this._startTime = engine._lastTickTime - (this._currentTime + this._delay) * timeScale;
    this._startTime = now() - (this._currentTime + this._delay) * timeScale;
    return this;
  }

  /** @return {this} */
  pause() {
    if (this.paused) return this;
    this.paused = true;
    this.onPause(this);
    return this;
  }

  /** @return {this} */
  resume() {
    if (!this.paused) return this;
    this.paused = false;
    // We can safely imediatly render a timer that has no duration and no children
    if (this.duration <= minValue && !this._hasChildren) {
      tick(this, minValue, 0, 0, tickModes.FORCE);
    } else {
      if (!this._running) {
        addChild(engine, this);
        engine._hasChildren = true;
        this._running = true;
      }
      this.resetTime();
      // Forces the timer to advance by at least one frame when the next tick occurs
      this._startTime -= 12;
      engine.wake();
    }
    return this;
  }

  /** @return {this} */
  restart() {
    return this.reset().resume();
  }

  /**
   * @param  {Number} time
   * @param  {Boolean|Number} [muteCallbacks]
   * @param  {Boolean|Number} [internalRender]
   * @return {this}
   */
  seek(time, muteCallbacks = 0, internalRender = 0) {
    // Recompose the tween siblings in case the timer has been cancelled
    reviveTimer(this);
    // If you seek a completed animation, otherwise the next play will starts at 0
    this.completed = false;
    const isPaused = this.paused;
    this.paused = true;
    // timer, time, muteCallbacks, internalRender, tickMode
    tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);
    return isPaused ? this : this.resume();
  }

  /** @return {this} */
  alternate() {
    const reversed = this._reversed;
    const count = this.iterationCount;
    const duration = this.iterationDuration;
    // Calculate the maximum iterations possible given the iteration duration
    const iterations = count === Infinity ? floor(maxValue / duration) : count;
    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);
    if (count === Infinity) {
      // Handle infinite loops to loop on themself
      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;
    } else {
      this.seek((duration * iterations) - this._currentTime);
    }
    this.resetTime();
    return this;
  }

  /** @return {this} */
  play() {
    if (this._reversed) this.alternate();
    return this.resume();
  }

  /** @return {this} */
  reverse() {
    if (!this._reversed) this.alternate();
    return this.resume();
  }

  // TODO: Move all the animation / tweens / children related code to Animation / Timeline

  /** @return {this} */
  cancel() {
    if (this._hasChildren) {
      forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);
    } else {
      forEachChildren(this, removeTweenSliblings);
    }
    this._cancelled = 1;
    // Pausing the timer removes it from the engine
    return this.pause();
  }

  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    const normlizedDuration = normalizeTime(newDuration);
    if (currentDuration === normlizedDuration) return this;
    const timeScale = newDuration / currentDuration;
    const isSetter = newDuration <= minValue;
    this.duration = isSetter ? minValue : normlizedDuration;
    this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);
    this._offset *= timeScale;
    this._delay *= timeScale;
    this._loopDelay *= timeScale;
    return this;
  }

 /**
   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary
   * @return {this}
   */
  revert() {
    tick(this, 0, 1, 0, tickModes.AUTO);
    const ap = /** @type {ScrollObserver} */(this._autoplay);
    if (ap && ap.linked && ap.linked === this) ap.revert();
    return this.cancel();
  }

 /**
   * Imediatly completes the timer, cancels it and triggers the onComplete callback
   * @param  {Boolean|Number} [muteCallbacks]
   * @return {this}
   */
  complete(muteCallbacks = 0) {
    return this.seek(this.duration, muteCallbacks).cancel();
  }

  /**
   * @typedef {this & {then: null}} ResolvedTimer
   */

  /**
   * @param  {Callback<ResolvedTimer>} [callback]
   * @return Promise<this>
   */
  then(callback = noop) {
    const then = this.then;
    const onResolve = () => {
      // this.then = null prevents infinite recursion if returned by an async function
      // https://github.com/juliangarnierorg/anime-beta/issues/26
      this.then = null;
      callback(/** @type {ResolvedTimer} */(this));
      this.then = then;
      this._resolve = noop;
    };
    return new Promise(r => {
      this._resolve = () => r(onResolve());
      // Make sure to resolve imediatly if the timer has already completed
      if (this.completed) this._resolve();
      return this;
    });
  }

}

/**
 * @param {TimerParams} [parameters]
 * @return {Timer}
 */
const createTimer = parameters => new Timer(parameters, null, 0).init();



/**
 * @param  {DOMTargetsParam|TargetsParam} v
 * @return {NodeList|HTMLCollection}
 */
function getNodeList(v) {
  const n = isStr(v) ? scope.root.querySelectorAll(v) : v;
  if (n instanceof NodeList || n instanceof HTMLCollection) return n;
}

/**
 * @overload
 * @param  {DOMTargetsParam} targets
 * @return {DOMTargetsArray}
 *
 * @overload
 * @param  {JSTargetsParam} targets
 * @return {JSTargetsArray}
 *
 * @overload
 * @param  {TargetsParam} targets
 * @return {TargetsArray}
 *
 * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
 */
function parseTargets(targets) {
  if (isNil(targets)) return /** @type {TargetsArray} */([]);
  if (!isBrowser) return /** @type {JSTargetsArray} */(isArr(targets) && targets.flat(Infinity) || [targets]);
  if (isArr(targets)) {
    const flattened = targets.flat(Infinity);
    /** @type {TargetsArray} */
    const parsed = [];
    for (let i = 0, l = flattened.length; i < l; i++) {
      const item = flattened[i];
      if (!isNil(item)) {
        const nodeList = getNodeList(item);
        if (nodeList) {
          for (let j = 0, jl = nodeList.length; j < jl; j++) {
            const subItem = nodeList[j];
            if (!isNil(subItem)) {
              let isDuplicate = false;
              for (let k = 0, kl = parsed.length; k < kl; k++) {
                if (parsed[k] === subItem) {
                  isDuplicate = true;
                  break;
                }
              }
              if (!isDuplicate) {
                parsed.push(subItem);
              }
            }
          }
        } else {
          let isDuplicate = false;
          for (let j = 0, jl = parsed.length; j < jl; j++) {
            if (parsed[j] === item) {
              isDuplicate = true;
              break;
            }
          }
          if (!isDuplicate) {
            parsed.push(item);
          }
        }
      }
    }
    return parsed;
  }
  const nodeList = getNodeList(targets);
  if (nodeList) return /** @type {DOMTargetsArray} */(Array.from(nodeList));
  return /** @type {TargetsArray} */([targets]);
}

/**
 * @overload
 * @param  {DOMTargetsParam} targets
 * @return {DOMTargetsArray}
 *
 * @overload
 * @param  {JSTargetsParam} targets
 * @return {JSTargetsArray}
 *
 * @overload
 * @param  {TargetsParam} targets
 * @return {TargetsArray}
 *
 * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
 */
function registerTargets(targets) {
  const parsedTargetsArray = parseTargets(targets);
  const parsedTargetsLength = parsedTargetsArray.length;
  if (parsedTargetsLength) {
    for (let i = 0; i < parsedTargetsLength; i++) {
      const target = parsedTargetsArray[i];
      if (!target[isRegisteredTargetSymbol]) {
        target[isRegisteredTargetSymbol] = true;
        const isSvgType = isSvg(target);
        const isDom = /** @type {DOMTarget} */(target).nodeType || isSvgType;
        if (isDom) {
          target[isDomSymbol] = true;
          target[isSvgSymbol] = isSvgType;
          target[transformsSymbol] = {};
        }
      }
    }
  }
  return parsedTargetsArray;
}

const angleUnitsMap = { 'deg': 1, 'rad': 180 / PI, 'turn': 360 };
const convertedValuesCache = {};



/**
 * @param  {DOMTarget} el
 * @param  {TweenDecomposedValue} decomposedValue
 * @param  {String} unit
 * @param  {Boolean} [force]
 * @return {TweenDecomposedValue}
 */
const convertValueUnit = (el, decomposedValue, unit, force = false) => {
  const currentUnit = decomposedValue.u;
  const currentNumber = decomposedValue.n;
  if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) { // TODO: Check if checking against the same unit string is necessary
    return decomposedValue;
  }
  const cachedKey = currentNumber + currentUnit + unit;
  const cached = convertedValuesCache[cachedKey];
  if (!isUnd(cached) && !force) {
    decomposedValue.n = cached;
  } else {
    let convertedValue;
    if (currentUnit in angleUnitsMap) {
      convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];
    } else {
      const baseline = 100;
      const tempEl = /** @type {DOMTarget} */(el.cloneNode());
      const parentNode = el.parentNode;
      const parentEl = (parentNode && (parentNode !== doc)) ? parentNode : doc.body;
      parentEl.appendChild(tempEl);
      const elStyle = tempEl.style;
      elStyle.width = baseline + currentUnit;
      const currentUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;
      elStyle.width = baseline + unit;
      const newUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;
      const factor = currentUnitWidth / newUnitWidth;
      parentEl.removeChild(tempEl);
      convertedValue = factor * currentNumber;
    }
    decomposedValue.n = convertedValue;
    convertedValuesCache[cachedKey] = convertedValue;
  }
  decomposedValue.t === valueTypes.UNIT;
  decomposedValue.u = unit;
  return decomposedValue;
};



/** @type {EasingFunction} */
const none = t => t;




/** @type {PowerEasing} */
const easeInPower = (p = 1.68) => t => pow(t, +p);

/**
 * @callback EaseType
 * @param {EasingFunction} Ease
 * @return {EasingFunction}
 */

/** @type {Record<String, EaseType>} */
const easeTypes = {
  in: easeIn => t => easeIn(t),
  out: easeIn => t => 1 - easeIn(1 - t),
  inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,
  outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2,
};

/**
 * Easing functions adapted and simplified from https://robertpenner.com/easing/
 * (c) 2001 Robert Penner
 */

const halfPI = PI / 2;
const doublePI = PI * 2;

/** @type {Record<String, EasingFunctionWithParams|EasingFunction>} */
const easeInFunctions = {
  [emptyString]: easeInPower,
  Quad: easeInPower(2),
  Cubic: easeInPower(3),
  Quart: easeInPower(4),
  Quint: easeInPower(5),
  /** @type {EasingFunction} */
  Sine: t => 1 - cos(t * halfPI),
  /** @type {EasingFunction} */
  Circ: t => 1 - sqrt(1 - t * t),
  /** @type {EasingFunction} */
  Expo: t => t ? pow(2, 10 * t - 10) : 0,
  /** @type {EasingFunction} */
  Bounce: t => {
    let pow2, b = 4;
    while (t < ((pow2 = pow(2, --b)) - 1) / 11);
    return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);
  },
  /** @type {BackEasing} */
  Back: (overshoot = 1.7) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,
  /** @type {ElasticEasing} */
  Elastic: (amplitude = 1, period = .3) => {
    const a = clamp$1(+amplitude, 1, 10);
    const p = clamp$1(+period, minValue, 2);
    const s = (p / doublePI) * asin(1 / a);
    const e = doublePI / p;
    return t => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin(((1 - t) - s) * e);
  }
};

/**
 * @typedef  {Object} EasesFunctions
 * @property {typeof none} linear
 * @property {typeof none} none
 * @property {PowerEasing} in
 * @property {PowerEasing} out
 * @property {PowerEasing} inOut
 * @property {PowerEasing} outIn
 * @property {EasingFunction} inQuad
 * @property {EasingFunction} outQuad
 * @property {EasingFunction} inOutQuad
 * @property {EasingFunction} outInQuad
 * @property {EasingFunction} inCubic
 * @property {EasingFunction} outCubic
 * @property {EasingFunction} inOutCubic
 * @property {EasingFunction} outInCubic
 * @property {EasingFunction} inQuart
 * @property {EasingFunction} outQuart
 * @property {EasingFunction} inOutQuart
 * @property {EasingFunction} outInQuart
 * @property {EasingFunction} inQuint
 * @property {EasingFunction} outQuint
 * @property {EasingFunction} inOutQuint
 * @property {EasingFunction} outInQuint
 * @property {EasingFunction} inSine
 * @property {EasingFunction} outSine
 * @property {EasingFunction} inOutSine
 * @property {EasingFunction} outInSine
 * @property {EasingFunction} inCirc
 * @property {EasingFunction} outCirc
 * @property {EasingFunction} inOutCirc
 * @property {EasingFunction} outInCirc
 * @property {EasingFunction} inExpo
 * @property {EasingFunction} outExpo
 * @property {EasingFunction} inOutExpo
 * @property {EasingFunction} outInExpo
 * @property {EasingFunction} inBounce
 * @property {EasingFunction} outBounce
 * @property {EasingFunction} inOutBounce
 * @property {EasingFunction} outInBounce
 * @property {BackEasing} inBack
 * @property {BackEasing} outBack
 * @property {BackEasing} inOutBack
 * @property {BackEasing} outInBack
 * @property {ElasticEasing} inElastic
 * @property {ElasticEasing} outElastic
 * @property {ElasticEasing} inOutElastic
 * @property {ElasticEasing} outInElastic
 */

const eases = (/*#__PURE__ */ (() => {
  const list = { linear: none, none: none };
  for (let type in easeTypes) {
    for (let name in easeInFunctions) {
      const easeIn = easeInFunctions[name];
      const easeType = easeTypes[type];
      list[type + name] = /** @type {EasingFunctionWithParams|EasingFunction} */(
        name === emptyString || name === 'Back' || name === 'Elastic' ?
        (a, b) => easeType(/** @type {EasingFunctionWithParams} */(easeIn)(a, b)) :
        easeType(/** @type {EasingFunction} */(easeIn))
      );
    }
  }
  return /** @type {EasesFunctions} */(list);
})());

/** @type {Record<String, EasingFunction>} */
const easesLookups = { linear: none, none: none };

/**
 * @param  {String} string
 * @return {EasingFunction}
 */
const parseEaseString = (string) => {
  if (easesLookups[string]) return easesLookups[string];
  if (string.indexOf('(') <= -1) {
    const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');
    const parsedFn = /** @type {EasingFunction} */(hasParams ? /** @type {EasingFunctionWithParams} */(eases[string])() : eases[string]);
    return parsedFn ? easesLookups[string] = parsedFn : none;
  } else {
    const split = string.slice(0, -1).split('(');
    const parsedFn = /** @type {EasingFunctionWithParams} */(eases[split[0]]);
    return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : none;
  }
};

const deprecated = ['steps(', 'irregular(', 'linear(', 'cubicBezier('];

/**
 * @param  {EasingParam} ease
 * @return {EasingFunction}
 */
const parseEase = ease => {
  if (isStr(ease)) {
    for (let i = 0, l = deprecated.length; i < l; i++) {
      if (stringStartsWith(ease, deprecated[i])) {
        console.warn(`String syntax for \`ease: "${ease}"\` has been removed from the core and replaced by importing and passing the easing function directly: \`ease: ${ease}\``);
        return none;
      }
    }
  }
  const easeFunc = isFnc(ease) ? ease : isStr(ease) ? parseEaseString(/** @type {String} */(ease)) : none;
  return easeFunc;
};



// Defines decomposed values target objects only once and mutate their properties later to avoid GC
// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object
const fromTargetObject = createDecomposedValueTargetObject();
const toTargetObject = createDecomposedValueTargetObject();
const inlineStylesStore = {};
const toFunctionStore = { func: null };
const keyframesTargetArray = [null];
const fastSetValuesArray = [null, null];
/** @type {TweenKeyValue} */
const keyObjectTarget = { to: null };

let tweenId = 0;
let JSAnimationId = 0;
let keyframes;
/** @type {TweenParamsOptions & TweenValues} */
let key;

/**
 * @param {DurationKeyframes | PercentageKeyframes} keyframes
 * @param {AnimationParams} parameters
 * @return {AnimationParams}
 */
const generateKeyframes = (keyframes, parameters) => {
  /** @type {AnimationParams} */
  const properties = {};
  if (isArr(keyframes)) {
    const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);
    for (let i = 0, l = propertyNames.length; i < l; i++) {
      const propName = propertyNames[i];
      const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {
        /** @type {TweenKeyValue} */
        const newKey = {};
        for (let p in key) {
          const keyValue = /** @type {TweenPropValue} */(key[p]);
          if (isKey(p)) {
            if (p === propName) {
              newKey.to = keyValue;
            }
          } else {
            newKey[p] = keyValue;
          }
        }
        return newKey;
      });
      properties[propName] = /** @type {ArraySyntaxValue} */(propArray);
    }

  } else {
    const totalDuration = /** @type {Number} */(setValue(parameters.duration, globals.defaults.duration));
    const keys = Object.keys(keyframes)
    .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })
    .sort((a, b) => a.o - b.o);
    keys.forEach(key => {
      const offset = key.o;
      const prop = key.p;
      for (let name in prop) {
        if (isKey(name)) {
          let propArray = /** @type {Array} */(properties[name]);
          if (!propArray) propArray = properties[name] = [];
          const duration = offset * totalDuration;
          let length = propArray.length;
          let prevKey = propArray[length - 1];
          const keyObj = { to: prop[name] };
          let durProgress = 0;
          for (let i = 0; i < length; i++) {
            durProgress += propArray[i].duration;
          }
          if (length === 1) {
            keyObj.from = prevKey.to;
          }
          if (prop.ease) {
            keyObj.ease = prop.ease;
          }
          keyObj.duration = duration - (length ? durProgress : 0);
          propArray.push(keyObj);
        }
      }
      return key;
    });

    for (let name in properties) {
      const propArray = /** @type {Array} */(properties[name]);
      let prevEase;
      // let durProgress = 0
      for (let i = 0, l = propArray.length; i < l; i++) {
        const prop = propArray[i];
        // Emulate WAPPI easing parameter position
        const currentEase = prop.ease;
        prop.ease = prevEase ? prevEase : undefined;
        prevEase = currentEase;
        // durProgress += prop.duration;
        // if (i === l - 1 && durProgress !== totalDuration) {
        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })
        // }
      }
      if (!propArray[0].duration) {
        propArray.shift();
      }
    }

  }

  return properties;
};

class JSAnimation extends Timer {
  /**
   * @param {TargetsParam} targets
   * @param {AnimationParams} parameters
   * @param {Timeline} [parent]
   * @param {Number} [parentPosition]
   * @param {Boolean} [fastSet=false]
   * @param {Number} [index=0]
   * @param {Number} [length=0]
   */
  constructor(
    targets,
    parameters,
    parent,
    parentPosition,
    fastSet = false,
    index = 0,
    length = 0
  ) {

    super(/** @type {TimerParams & AnimationParams} */(parameters), parent, parentPosition);

    ++JSAnimationId;

    const parsedTargets = registerTargets(targets);
    const targetsLength = parsedTargets.length;

    // If the parameters object contains a "keyframes" property, convert all the keyframes values to regular properties

    const kfParams = /** @type {AnimationParams} */(parameters).keyframes;
    const params = /** @type {AnimationParams} */(kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);

    const {
      id,
      delay,
      duration,
      ease,
      playbackEase,
      modifier,
      composition,
      onRender,
    } = params;

    const animDefaults = parent ? parent.defaults : globals.defaults;
    const animEase = setValue(ease, animDefaults.ease);
    const animPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);
    const parsedAnimPlaybackEase = animPlaybackEase ? parseEase(animPlaybackEase) : null;
    const hasSpring = !isUnd(/** @type {Spring} */(animEase).ease);
    const tEasing = hasSpring ? /** @type {Spring} */(animEase).ease : setValue(ease, parsedAnimPlaybackEase ? 'linear' : animDefaults.ease);
    const tDuration = hasSpring ? /** @type {Spring} */(animEase).settlingDuration : setValue(duration, animDefaults.duration);
    const tDelay = setValue(delay, animDefaults.delay);
    const tModifier = modifier || animDefaults.modifier;
    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation
    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;
    // const absoluteOffsetTime = this._offset;
    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);
    // This allows targeting the current animation in the spring onComplete callback
    if (hasSpring) /** @type {Spring} */(animEase).parent = this;

    let iterationDuration = NaN;
    let iterationDelay = NaN;
    let animationAnimationLength = 0;
    let shouldTriggerRender = 0;

    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {

      const target = parsedTargets[targetIndex];
      const ti = index || targetIndex;
      const tl = length || targetsLength;

      let lastTransformGroupIndex = NaN;
      let lastTransformGroupLength = NaN;

      for (let p in params) {

        if (isKey(p)) {

          const tweenType = getTweenType(target, p);

          const propName = sanitizePropertyName(p, target, tweenType);

          let propValue = params[p];

          const isPropValueArray = isArr(propValue);

          if (fastSet && !isPropValueArray) {
            fastSetValuesArray[0] = propValue;
            fastSetValuesArray[1] = propValue;
            propValue = fastSetValuesArray;
          }

          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })
          // Normalize property values to valid keyframe syntax:
          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]
          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];
          if (isPropValueArray) {
            const arrayLength = /** @type {Array} */(propValue).length;
            const isNotObjectValue = !isObj(propValue[0]);
            // Convert [x, y] to [{to: [x, y]}]
            if (arrayLength === 2 && isNotObjectValue) {
              keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));
              keyframesTargetArray[0] = keyObjectTarget;
              keyframes = keyframesTargetArray;
            // Convert [x, y, z] to [[x, y], z]
            } else if (arrayLength > 2 && isNotObjectValue) {
              keyframes = [];
              /** @type {Array.<Number>} */(propValue).forEach((v, i) => {
                if (!i) {
                  fastSetValuesArray[0] = v;
                } else if (i === 1) {
                  fastSetValuesArray[1] = v;
                  keyframes.push(fastSetValuesArray);
                } else {
                  keyframes.push(v);
                }
              });
            } else {
              keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);
            }
          } else {
            keyframesTargetArray[0] = propValue;
            keyframes = keyframesTargetArray;
          }

          let siblings = null;
          let prevTween = null;
          let firstTweenChangeStartTime = NaN;
          let lastTweenChangeEndTime = 0;
          let tweenIndex = 0;

          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {

            const keyframe = keyframes[tweenIndex];

            if (isObj(keyframe)) {
              key = keyframe;
            } else {
              keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);
              key = keyObjectTarget;
            }

            toFunctionStore.func = null;

            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);

            let tweenToValue;
            // Allows function based values to return an object syntax value ({to: v})
            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {
              key = computedToValue;
              tweenToValue = computedToValue.to;
            } else {
              tweenToValue = computedToValue;
            }
            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);
            const easeToParse = key.ease || tEasing;

            const easeFunctionResult = getFunctionValue(easeToParse, target, ti, tl);
            const keyEasing = isFnc(easeFunctionResult) || isStr(easeFunctionResult) ? easeFunctionResult : easeToParse;

            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);
            const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing;
            // Calculate default individual keyframe duration by dividing the tl of keyframes
            const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).settlingDuration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);
            // Default delay value should only be applied to the first tween
            const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);
            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);
            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];
            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper
            const tweenModifier = key.modifier || tModifier;
            const hasFromvalue = !isUnd(tweenFromValue);
            const hasToValue = !isUnd(tweenToValue);
            const isFromToArray = isArr(tweenToValue);
            const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);
            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;
            // Rounding is necessary here to minimize floating point errors when working in seconds
            const absoluteStartTime = round$1(absoluteOffsetTime + tweenStartTime, 12);

            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false
            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;

            let prevSibling = prevTween;

            if (tweenComposition !== compositionTypes.none) {
              if (!siblings) siblings = getTweenSiblings(target, propName);
              let nextSibling = siblings._head;
              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time
              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {
                prevSibling = nextSibling;
                nextSibling = nextSibling._nextRep;
                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time
                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {
                  while (nextSibling) {
                    overrideTween(nextSibling);
                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden
                    nextSibling = nextSibling._nextRep;
                  }
                }
              }
            }

            // Decompose values
            if (isFromToValue) {
              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);
              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);
              // Needed to force an inline style registration
              const originalValue = getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore);
              if (fromTargetObject.t === valueTypes.NUMBER) {
                if (prevSibling) {
                  if (prevSibling._valueType === valueTypes.UNIT) {
                    fromTargetObject.t = valueTypes.UNIT;
                    fromTargetObject.u = prevSibling._unit;
                  }
                } else {
                  decomposeRawValue(
                    originalValue,
                    decomposedOriginalValue
                  );
                  if (decomposedOriginalValue.t === valueTypes.UNIT) {
                    fromTargetObject.t = valueTypes.UNIT;
                    fromTargetObject.u = decomposedOriginalValue.u;
                  }
                }
              }
            } else {
              if (hasToValue) {
                decomposeRawValue(tweenToValue, toTargetObject);
              } else {
                if (prevTween) {
                  decomposeTweenValue(prevTween, toTargetObject);
                } else {
                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), toTargetObject);
                }
              }
              if (hasFromvalue) {
                decomposeRawValue(tweenFromValue, fromTargetObject);
              } else {
                if (prevTween) {
                  decomposeTweenValue(prevTween, fromTargetObject);
                } else {
                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), fromTargetObject);
                }
              }
            }

            // Apply operators
            if (fromTargetObject.o) {
              fromTargetObject.n = getRelativeValue(
                !prevSibling ? decomposeRawValue(
                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore),
                  decomposedOriginalValue
                ).n : prevSibling._toNumber,
                fromTargetObject.n,
                fromTargetObject.o
              );
            }

            if (toTargetObject.o) {
              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);
            }

            // Values omogenisation in cases of type difference between "from" and "to"
            if (fromTargetObject.t !== toTargetObject.t) {
              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {
                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;
                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;
                notComplexValue.t = valueTypes.COMPLEX;
                notComplexValue.s = cloneArray(complexValue.s);
                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);
              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {
                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;
                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;
                notUnitValue.t = valueTypes.UNIT;
                notUnitValue.u = unitValue.u;
              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {
                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;
                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;
                notColorValue.t = valueTypes.COLOR;
                notColorValue.s = colorValue.s;
                notColorValue.d = [0, 0, 0, 1];
              }
            }

            // Unit conversion
            if (fromTargetObject.u !== toTargetObject.u) {
              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;
              valueToConvert = convertValueUnit(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);
              // TODO:
              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);
            }

            // Fill in non existing complex values
            if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {
              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;
              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;
              // TODO: Check if n should be used instead of 0 for default complex values
              shortestValue.d = longestValue.d.map((/** @type {Number} */_, /** @type {Number} */i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);
              shortestValue.s = cloneArray(longestValue.s);
            }

            // Tween factory

            // Rounding is necessary here to minimize floating point errors when working in seconds
            const tweenUpdateDuration = round$1(+tweenDuration || minValue, 12);

            // Copy the value of the iniline style if it exist and imediatly nullify it to prevents false positive on other targets
            let inlineValue = inlineStylesStore[propName];
            if (!isNil(inlineValue)) inlineStylesStore[propName] = null;

            /** @type {Tween} */
            const tween = {
              parent: this,
              id: tweenId++,
              property: propName,
              target: target,
              _value: null,
              _func: toFunctionStore.func,
              _ease: parseEase(tweenEasing),
              _fromNumbers: cloneArray(fromTargetObject.d),
              _toNumbers: cloneArray(toTargetObject.d),
              _strings: cloneArray(toTargetObject.s),
              _fromNumber: fromTargetObject.n,
              _toNumber: toTargetObject.n,
              _numbers: cloneArray(fromTargetObject.d), // For additive tween and animatables
              _number: fromTargetObject.n, // For additive tween and animatables
              _unit: toTargetObject.u,
              _modifier: tweenModifier,
              _currentTime: 0,
              _startTime: tweenStartTime,
              _delay: +tweenDelay,
              _updateDuration: tweenUpdateDuration,
              _changeDuration: tweenUpdateDuration,
              _absoluteStartTime: absoluteStartTime,
              // NOTE: Investigate bit packing to stores ENUM / BOOL
              _tweenType: tweenType,
              _valueType: toTargetObject.t,
              _composition: tweenComposition,
              _isOverlapped: 0,
              _isOverridden: 0,
              _renderTransforms: 0,
              _inlineValue: inlineValue,
              _prevRep: null, // For replaced tween
              _nextRep: null, // For replaced tween
              _prevAdd: null, // For additive tween
              _nextAdd: null, // For additive tween
              _prev: null,
              _next: null,
            };

            if (tweenComposition !== compositionTypes.none) {
              composeTween(tween, siblings);
            }

            if (isNaN(firstTweenChangeStartTime)) {
              firstTweenChangeStartTime = tween._startTime;
            }
            // Rounding is necessary here to minimize floating point errors when working in seconds
            lastTweenChangeEndTime = round$1(tweenStartTime + tweenUpdateDuration, 12);
            prevTween = tween;
            animationAnimationLength++;

            addChild(this, tween);

          }

          // Update animation timings with the added tweens properties

          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {
            iterationDelay = firstTweenChangeStartTime;
          }

          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {
            iterationDuration = lastTweenChangeEndTime;
          }

          // TODO: Find a way to inline tween._renderTransforms = 1 here
          if (tweenType === tweenTypes.TRANSFORM) {
            lastTransformGroupIndex = animationAnimationLength - tweenIndex;
            lastTransformGroupLength = animationAnimationLength;
          }

        }

      }

      // Set _renderTransforms to last transform property to correctly render the transforms list
      if (!isNaN(lastTransformGroupIndex)) {
        let i = 0;
        forEachChildren(this, (/** @type {Tween} */tween) => {
          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {
            tween._renderTransforms = 1;
            if (tween._composition === compositionTypes.blend) {
              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {
                if (additiveTween.id === tween.id) {
                  additiveTween._renderTransforms = 1;
                }
              });
            }
          }
          i++;
        });
      }

    }

    if (!targetsLength) {
      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
    }

    if (iterationDelay) {
      forEachChildren(this, (/** @type {Tween} */tween) => {
        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too
        if (!(tween._startTime - tween._delay)) {
          tween._delay -= iterationDelay;
        }
        tween._startTime -= iterationDelay;
      });
      iterationDuration -= iterationDelay;
    } else {
      iterationDelay = 0;
    }

    // Prevents iterationDuration to be NaN if no valid animatable props have been provided
    // Prevents _iterationCount to be NaN if no valid animatable props have been provided
    if (!iterationDuration) {
      iterationDuration = minValue;
      this.iterationCount = 0;
    }
    /** @type {TargetsArray} */
    this.targets = parsedTargets;
    /** @type {String|Number} */
    this.id = !isUnd(id) ? id : JSAnimationId;
    /** @type {Number} */
    this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;
    /** @type {Callback<this>} */
    this.onRender = onRender || animDefaults.onRender;
    /** @type {EasingFunction} */
    this._ease = parsedAnimPlaybackEase;
    /** @type {Number} */
    this._delay = iterationDelay;
    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.
    // this._delay = parent ? 0 : iterationDelay;
    // this._offset += parent ? iterationDelay : 0;
    /** @type {Number} */
    this.iterationDuration = iterationDuration;

    if (!this._autoplay && shouldTriggerRender) this.onRender(this);
  }

  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    if (currentDuration === normalizeTime(newDuration)) return this;
    const timeScale = newDuration / currentDuration;
    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0
    forEachChildren(this, (/** @type {Tween} */tween) => {
      // Rounding is necessary here to minimize floating point errors
      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);
      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);
      tween._currentTime *= timeScale;
      tween._startTime *= timeScale;
      tween._absoluteStartTime *= timeScale;
    });
    return super.stretch(newDuration);
  }

  /**
   * @return {this}
   */
  refresh() {
    forEachChildren(this, (/** @type {Tween} */tween) => {
      const tweenFunc = tween._func;
      if (tweenFunc) {
        const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);
        decomposeRawValue(ogValue, decomposedOriginalValue);
        // TODO: Check for from / to Array based values here,
        decomposeRawValue(tweenFunc(), toTargetObject);
        tween._fromNumbers = cloneArray(decomposedOriginalValue.d);
        tween._fromNumber = decomposedOriginalValue.n;
        tween._toNumbers = cloneArray(toTargetObject.d);
        tween._strings = cloneArray(toTargetObject.s);
        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025
        tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;
      }
    });
    // This forces setter animations to render once
    if (this.duration === minValue) this.restart();
    return this;
  }

  /**
   * Cancel the animation and revert all the values affected by this animation to their original state
   * @return {this}
   */
  revert() {
    super.revert();
    return cleanInlineStyles(this);
  }

  /**
   * @typedef {this & {then: null}} ResolvedJSAnimation
   */

  /**
   * @param  {Callback<ResolvedJSAnimation>} [callback]
   * @return Promise<this>
   */
  then(callback) {
    return super.then(callback);
  }

}

/**
 * @param {TargetsParam} targets
 * @param {AnimationParams} parameters
 * @return {JSAnimation}
 */
const animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();





const WAAPIAnimationsLookups = {
  _head: null,
  _tail: null,
};

/**
 * @param {DOMTarget} $el
 * @param {String} [property]
 * @param {WAAPIAnimation} [parent]
 * @return {globalThis.Animation}
 */
const removeWAAPIAnimation = ($el, property, parent) => {
  let nextLookup = WAAPIAnimationsLookups._head;
  let anim;
  while (nextLookup) {
    const next = nextLookup._next;
    const matchTarget = nextLookup.$el === $el;
    const matchProperty = !property || nextLookup.property === property;
    const matchParent = !parent || nextLookup.parent === parent;
    if (matchTarget && matchProperty && matchParent) {
      anim = nextLookup.animation;
      try { anim.commitStyles(); } catch {}      anim.cancel();
      removeChild(WAAPIAnimationsLookups, nextLookup);
      const lookupParent = nextLookup.parent;
      if (lookupParent) {
        lookupParent._completed++;
        if (lookupParent.animations.length === lookupParent._completed) {
          lookupParent.completed = true;
          lookupParent.paused = true;
          if (!lookupParent.muteCallbacks) {
            lookupParent.onComplete(lookupParent);
            lookupParent._resolve(lookupParent);
          }
        }
      }
    }
    nextLookup = next;
  }
  return anim;
};

/**
 * @param {WAAPIAnimation} parent
 * @param {DOMTarget} $el
 * @param {String} property
 * @param {PropertyIndexedKeyframes} keyframes
 * @param {KeyframeAnimationOptions} params
 * @retun {globalThis.Animation}
 */
const addWAAPIAnimation = (parent, $el, property, keyframes, params) => {
  const animation = $el.animate(keyframes, params);
  const animTotalDuration = params.delay + (+params.duration * params.iterations);
  animation.playbackRate = parent._speed;
  if (parent.paused) animation.pause();
  if (parent.duration < animTotalDuration) {
    parent.duration = animTotalDuration;
    parent.controlAnimation = animation;
  }
  parent.animations.push(animation);
  removeWAAPIAnimation($el, property);
  addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });
  const handleRemove = () => { removeWAAPIAnimation($el, property, parent); };
  animation.oncancel = handleRemove;
  animation.onremove = handleRemove;
  if (!parent.persist) {
    animation.onfinish = handleRemove;
  }
  return animation;
};





/**
 * @overload
 * @param  {DOMTargetSelector} targetSelector
 * @param  {String} propName
 * @return {String}
 *
 * @overload
 * @param  {JSTargetsParam} targetSelector
 * @param  {String} propName
 * @return {Number|String}
 *
 * @overload
 * @param  {DOMTargetsParam} targetSelector
 * @param  {String} propName
 * @param  {String} unit
 * @return {String}
 *
 * @overload
 * @param  {TargetsParam} targetSelector
 * @param  {String} propName
 * @param  {Boolean} unit
 * @return {Number}
 *
 * @param  {TargetsParam} targetSelector
 * @param  {String} propName
 * @param  {String|Boolean} [unit]
 */
function get(targetSelector, propName, unit) {
  const targets = registerTargets(targetSelector);
  if (!targets.length) return;
  const [ target ] = targets;
  const tweenType = getTweenType(target, propName);
  const normalizePropName = sanitizePropertyName(propName, target, tweenType);
  let originalValue = getOriginalAnimatableValue(target, normalizePropName);
  if (isUnd(unit)) {
    return originalValue;
  } else {
    decomposeRawValue(originalValue, decomposedOriginalValue);
    if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {
      if (unit === false) {
        return decomposedOriginalValue.n;
      } else {
        const convertedValue = convertValueUnit(/** @type {DOMTarget} */(target), decomposedOriginalValue, /** @type {String} */(unit), false);
        return `${round$1(convertedValue.n, globals.precision)}${convertedValue.u}`;
      }
    }
  }
}

/**
 * @param  {TargetsParam} targets
 * @param  {AnimationParams} parameters
 * @return {JSAnimation}
 */
const set = (targets, parameters) => {
  if (isUnd(parameters)) return;
  parameters.duration = minValue;
  // Do not overrides currently active tweens by default
  parameters.composition = setValue(parameters.composition, compositionTypes.none);
  // Skip init() and force rendering by playing the animation
  return new JSAnimation(targets, parameters, null, 0, true).resume();
};

/**
 * @param  {TargetsParam} targets
 * @param  {Renderable|WAAPIAnimation} [renderable]
 * @param  {String} [propertyName]
 * @return {TargetsArray}
 */
const remove = (targets, renderable, propertyName) => {
  const targetsArray = parseTargets(targets);
  for (let i = 0, l = targetsArray.length; i < l; i++) {
    removeWAAPIAnimation(
      /** @type {DOMTarget}  */(targetsArray[i]),
      propertyName,
      renderable && /** @type {WAAPIAnimation} */(renderable).controlAnimation && /** @type {WAAPIAnimation} */(renderable),
    );
  }
  removeTargetsFromRenderable(
    targetsArray,
    /** @type {Renderable} */(renderable),
    propertyName
  );
  return targetsArray;
};





/**
 * Timeline's children offsets positions parser
 * @param  {Timeline} timeline
 * @param  {String} timePosition
 * @return {Number}
 */
const getPrevChildOffset = (timeline, timePosition) => {
  if (stringStartsWith(timePosition, '<')) {
    const goToPrevAnimationOffset = timePosition[1] === '<';
    const prevAnimation = /** @type {Tickable} */(timeline._tail);
    const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;
    return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;
  }
};

/**
 * @param  {Timeline} timeline
 * @param  {TimelinePosition} [timePosition]
 * @return {Number}
 */
const parseTimelinePosition = (timeline, timePosition) => {
  let tlDuration = timeline.iterationDuration;
  if (tlDuration === minValue) tlDuration = 0;
  if (isUnd(timePosition)) return tlDuration;
  if (isNum(+timePosition)) return +timePosition;
  const timePosStr = /** @type {String} */(timePosition);
  const tlLabels = timeline ? timeline.labels : null;
  const hasLabels = !isNil(tlLabels);
  const prevOffset = getPrevChildOffset(timeline, timePosStr);
  const hasSibling = !isUnd(prevOffset);
  const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);
  if (matchedRelativeOperator) {
    const fullOperator = matchedRelativeOperator[0];
    const split = timePosStr.split(fullOperator);
    const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;
    const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;
    const parsedNumericalOffset = +split[1];
    return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);
  } else {
    return hasSibling ? prevOffset :
           hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] :
           tlDuration : tlDuration;
  }
};





/**
 * @param {Timeline} tl
 * @return {Number}
 */
function getTimelineTotalDuration(tl) {
  return clampInfinity(((tl.iterationDuration + tl._loopDelay) * tl.iterationCount) - tl._loopDelay) || minValue;
}

/**
 * @overload
 * @param  {TimerParams} childParams
 * @param  {Timeline} tl
 * @param  {Number} timePosition
 * @return {Timeline}
 *
 * @overload
 * @param  {AnimationParams} childParams
 * @param  {Timeline} tl
 * @param  {Number} timePosition
 * @param  {TargetsParam} targets
 * @param  {Number} [index]
 * @param  {Number} [length]
 * @return {Timeline}
 *
 * @param  {TimerParams|AnimationParams} childParams
 * @param  {Timeline} tl
 * @param  {Number} timePosition
 * @param  {TargetsParam} [targets]
 * @param  {Number} [index]
 * @param  {Number} [length]
 */
function addTlChild(childParams, tl, timePosition, targets, index, length) {
  const isSetter = isNum(childParams.duration) && /** @type {Number} */(childParams.duration) <= minValue;
  // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position
  const adjustedPosition = isSetter ? timePosition - minValue : timePosition;
  if (tl.composition) tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);
  const tlChild = targets ?
    new JSAnimation(targets,/** @type {AnimationParams} */(childParams), tl, adjustedPosition, false, index, length) :
    new Timer(/** @type {TimerParams} */(childParams), tl, adjustedPosition);
  if (tl.composition) tlChild.init(true);
  // TODO: Might be better to insert at a position relative to startTime?
  addChild(tl, tlChild);
  forEachChildren(tl, (/** @type {Renderable} */child) => {
    const childTLOffset = child._offset + child._delay;
    const childDur = childTLOffset + child.duration;
    if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;
  });
  tl.duration = getTimelineTotalDuration(tl);
  return tl;
}

let TLId = 0;

class Timeline extends Timer {

  /**
   * @param {TimelineParams} [parameters]
   */
  constructor(parameters = {}) {
    super(/** @type {TimerParams&TimelineParams} */(parameters), null, 0);
    ++TLId;
    /** @type {String|Number} */
    this.id = !isUnd(parameters.id) ? parameters.id : TLId;
    /** @type {Number} */
    this.duration = 0; // TL duration starts at 0 and grows when adding children
    /** @type {Record<String, Number>} */
    this.labels = {};
    const defaultsParams = parameters.defaults;
    const globalDefaults = globals.defaults;
    /** @type {DefaultsParams} */
    this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;
    /** @type {Boolean} */
    this.composition = setValue(parameters.composition, true);
    /** @type {Callback<this>} */
    this.onRender = parameters.onRender || globalDefaults.onRender;
    const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);
    this._ease = tlPlaybackEase ? parseEase(tlPlaybackEase) : null;
    /** @type {Number} */
    this.iterationDuration = 0;
  }

  /**
   * @overload
   * @param {TargetsParam} a1
   * @param {AnimationParams} a2
   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]
   * @return {this}
   *
   * @overload
   * @param {TimerParams} a1
   * @param {TimelinePosition} [a2]
   * @return {this}
   *
   * @param {TargetsParam|TimerParams} a1
   * @param {TimelinePosition|AnimationParams} a2
   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]
   */
  add(a1, a2, a3) {
    const isAnim = isObj(a2);
    const isTimer = isObj(a1);
    if (isAnim || isTimer) {
      this._hasChildren = true;
      if (isAnim) {
        const childParams = /** @type {AnimationParams} */(a2);
        // Check for function for children stagger positions
        if (isFnc(a3)) {
          const staggeredPosition = a3;
          const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */(a1));
          // Store initial duration before adding new children that will change the duration
          const tlDuration = this.duration;
          // Store initial _iterationDuration before adding new children that will change the duration
          const tlIterationDuration = this.iterationDuration;
          // Store the original id in order to add specific indexes to the new animations ids
          const id = childParams.id;
          let i = 0;
          /** @type {Number} */
          const parsedLength = (parsedTargetsArray.length);
          parsedTargetsArray.forEach((/** @type {Target} */target) => {
            // Create a new parameter object for each staggered children
            const staggeredChildParams = { ...childParams };
            // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation
            this.duration = tlDuration;
            this.iterationDuration = tlIterationDuration;
            if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;
            addTlChild(
              staggeredChildParams,
              this,
              parseTimelinePosition(this, staggeredPosition(target, i, parsedLength, this)),
              target,
              i,
              parsedLength
            );
            i++;
          });
        } else {
          addTlChild(
            childParams,
            this,
            parseTimelinePosition(this, a3),
            /** @type {TargetsParam} */(a1),
          );
        }
      } else {
        // It's a Timer
        addTlChild(
          /** @type TimerParams */(a1),
          this,
          parseTimelinePosition(this,a2),
        );
      }
      if (this.composition) this.init(true);
      return this;
    }
  }

  /**
   * @overload
   * @param {Tickable} [synced]
   * @param {TimelinePosition} [position]
   * @return {this}
   *
   * @overload
   * @param {globalThis.Animation} [synced]
   * @param {TimelinePosition} [position]
   * @return {this}
   *
   * @overload
   * @param {WAAPIAnimation} [synced]
   * @param {TimelinePosition} [position]
   * @return {this}
   *
   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]
   * @param {TimelinePosition} [position]
   */
  sync(synced, position) {
    if (isUnd(synced) || synced && isUnd(synced.pause)) return this;
    synced.pause();
    const duration = +(/** @type {globalThis.Animation} */(synced).effect ? /** @type {globalThis.Animation} */(synced).effect.getTiming().duration : /** @type {Tickable} */(synced).duration);
    return this.add(synced, { currentTime: [0, duration], duration, delay: 0, ease: 'linear', playbackEase: 'linear' }, position);
  }

  /**
   * @param  {TargetsParam} targets
   * @param  {AnimationParams} parameters
   * @param  {TimelinePosition} [position]
   * @return {this}
   */
  set(targets, parameters, position) {
    if (isUnd(parameters)) return this;
    parameters.duration = minValue;
    parameters.composition = compositionTypes.replace;
    return this.add(targets, parameters, position);
  }

  /**
   * @param {Callback<Timer>} callback
   * @param {TimelinePosition} [position]
   * @return {this}
   */
  call(callback, position) {
    if (isUnd(callback) || callback && !isFnc(callback)) return this;
    return this.add({ duration: 0, delay: 0, onComplete: () => callback(this) }, position);
  }

  /**
   * @param {String} labelName
   * @param {TimelinePosition} [position]
   * @return {this}
   *
   */
  label(labelName, position) {
    if (isUnd(labelName) || labelName && !isStr(labelName)) return this;
    this.labels[labelName] = parseTimelinePosition(this, position);
    return this;
  }

  /**
   * @param  {TargetsParam} targets
   * @param  {String} [propertyName]
   * @return {this}
   */
  remove(targets, propertyName) {
    removeTargetsFromRenderable(parseTargets(targets), this, propertyName);
    return this;
  }

  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    if (currentDuration === normalizeTime(newDuration)) return this;
    const timeScale = newDuration / currentDuration;
    const labels = this.labels;
    forEachChildren(this, (/** @type {JSAnimation} */child) => child.stretch(child.duration * timeScale));
    for (let labelName in labels) labels[labelName] *= timeScale;
    return super.stretch(newDuration);
  }

  /**
   * @return {this}
   */
  refresh() {
    forEachChildren(this, (/** @type {JSAnimation} */child) => {
      if (child.refresh) child.refresh();
    });
    return this;
  }

  /**
   * @return {this}
   */
  revert() {
    super.revert();
    forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);
    return cleanInlineStyles(this);
  }

  /**
   * @typedef {this & {then: null}} ResolvedTimeline
   */

  /**
   * @param  {Callback<ResolvedTimeline>} [callback]
   * @return Promise<this>
   */
  then(callback) {
    return super.then(callback);
  }
}

/**
 * @param {TimelineParams} [parameters]
 * @return {Timeline}
 */
const createTimeline = parameters => new Timeline(parameters).init();



class Animatable {
  /**
   * @param {TargetsParam} targets
   * @param {AnimatableParams} parameters
   */
  constructor(targets, parameters) {
    if (scope.current) scope.current.register(this);
    const beginHandler = () => {
      if (this.callbacks.completed) this.callbacks.reset();
      this.callbacks.play();
    };
    const pauseHandler = () => {
      if (this.callbacks.completed) return;
      let paused = true;
      for (let name in this.animations) {
        const anim = this.animations[name];
        if (!anim.paused && paused) {
          paused = false;
          break;
        }
      }
      if (paused) {
        this.callbacks.complete();
      }
    };
    /** @type {AnimationParams} */
    const globalParams = {
      onBegin: beginHandler,
      onComplete: pauseHandler,
      onPause: pauseHandler,
    };
    /** @type {AnimationParams} */
    const callbacksAnimationParams = { v: 1, autoplay: false };
    const properties = {};
    this.targets = [];
    this.animations = {};
    /** @type {JSAnimation|null} */
    this.callbacks = null;
    if (isUnd(targets) || isUnd(parameters)) return;
    for (let propName in parameters) {
      const paramValue = parameters[propName];
      if (isKey(propName)) {
        properties[propName] = paramValue;
      } else if (stringStartsWith(propName, 'on')) {
        callbacksAnimationParams[propName] = paramValue;
      } else {
        globalParams[propName] = paramValue;
      }
    }
    this.callbacks = new JSAnimation({ v: 0 }, callbacksAnimationParams);
    for (let propName in properties) {
      const propValue = properties[propName];
      const isObjValue = isObj(propValue);
      /** @type {TweenParamsOptions} */
      let propParams = {};
      let to = '+=0';
      if (isObjValue) {
        const unit = propValue.unit;
        if (isStr(unit)) to += unit;
      } else {
        propParams.duration = propValue;
      }
      propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;
      const animParams = mergeObjects(globalParams, propParams);
      animParams.composition = compositionTypes.replace;
      animParams.autoplay = false;
      const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();
      if (!this.targets.length) this.targets.push(...animation.targets);
      /** @type {AnimatableProperty} */
      this[propName] = (to, duration, ease) => {
        const tween = /** @type {Tween} */(animation._head);
        if (isUnd(to) && tween) {
          const numbers = tween._numbers;
          if (numbers && numbers.length) {
            return numbers;
          } else {
            return tween._modifier(tween._number);
          }
        } else {
          forEachChildren(animation, (/** @type {Tween} */tween) => {
            if (isArr(to)) {
              for (let i = 0, l = /** @type {Array} */(to).length; i < l; i++) {
                if (!isUnd(tween._numbers[i])) {
                  tween._fromNumbers[i] = /** @type {Number} */(tween._modifier(tween._numbers[i]));
                  tween._toNumbers[i] = to[i];
                }
              }
            } else {
              tween._fromNumber = /** @type {Number} */(tween._modifier(tween._number));
              tween._toNumber = /** @type {Number} */(to);
            }
            if (!isUnd(ease)) tween._ease = parseEase(ease);
            tween._currentTime = 0;
          });
          if (!isUnd(duration)) animation.stretch(duration);
          animation.reset(true).resume();
          return this;
        }
      };
    }
  }

  revert() {
    for (let propName in this.animations) {
      this[propName] = noop;
      this.animations[propName].revert();
    }
    this.animations = {};
    this.targets.length = 0;
    if (this.callbacks) this.callbacks.revert();
    return this;
  }
}

/**
 * @param {TargetsParam} targets
 * @param {AnimatableParams} parameters
 * @return {AnimatableObject}
 */
const createAnimatable = (targets, parameters) => /** @type {AnimatableObject} */ (new Animatable(targets, parameters));

/**
 * Rounds a number to fixed decimal places
 * @param  {Number|String} v - Value to round
 * @param  {Number} decimalLength - Number of decimal places
 * @return {String}
 */
const roundPad$1 = (v, decimalLength) => (+v).toFixed(decimalLength);

/**
 * Pads the start of a value with a string
 * @param  {Number} v - Value to pad
 * @param  {Number} totalLength - Target length
 * @param  {String} padString - String to pad with
 * @return {String}
 */
const padStart$1 = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);

/**
 * Pads the end of a value with a string
 * @param  {Number} v - Value to pad
 * @param  {Number} totalLength - Target length
 * @param  {String} padString - String to pad with
 * @return {String}
 */
const padEnd$1 = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);

/**
 * Wraps a value within a range
 * @param  {Number} v - Value to wrap
 * @param  {Number} min - Minimum boundary
 * @param  {Number} max - Maximum boundary
 * @return {Number}
 */
const wrap$1 = (v, min, max) => (((v - min) % (max - min) + (max - min)) % (max - min)) + min;

/**
 * Maps a value from one range to another
 * @param  {Number} value - Input value
 * @param  {Number} inLow - Input range minimum
 * @param  {Number} inHigh - Input range maximum
 * @param  {Number} outLow - Output range minimum
 * @param  {Number} outHigh - Output range maximum
 * @return {Number}
 */
const mapRange$1 = (value, inLow, inHigh, outLow, outHigh) => outLow + ((value - inLow) / (inHigh - inLow)) * (outHigh - outLow);

/**
 * Converts degrees to radians
 * @param  {Number} degrees - Angle in degrees
 * @return {Number}
 */
const degToRad$1 = degrees => degrees * Math.PI / 180;

/**
 * Converts radians to degrees
 * @param  {Number} radians - Angle in radians
 * @return {Number}
 */
const radToDeg$1 = radians => radians * 180 / Math.PI;

/**
 * Frame rate independent damped lerp
 * Based on: https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
 *
 * @param  {Number} start - Starting value
 * @param  {Number} end - Target value
 * @param  {Number} deltaTime - Delta time in ms
 * @param  {Number} factor - Interpolation factor in the range [0, 1]
 * @return {Number} The interpolated value
 */
const damp$1 = (start, end, deltaTime, factor) => {
  return !factor ? start : factor === 1 ? end : lerp$1(start, end, 1 - Math.exp(-factor * deltaTime * .1));
};

var numberImports = /*#__PURE__*/Object.freeze({
  __proto__: null,
  clamp: clamp$1,
  damp: damp$1,
  degToRad: degToRad$1,
  lerp: lerp$1,
  mapRange: mapRange$1,
  padEnd: padEnd$1,
  padStart: padStart$1,
  radToDeg: radToDeg$1,
  round: round$1,
  roundPad: roundPad$1,
  snap: snap$1,
  wrap: wrap$1
});





/*
 * Spring easing solver adapted from https://webkit.org/demos/spring/spring.js
 * (c) 2016 Webkit - Apple Inc
 */

const maxSpringParamValue = K * 10;

class Spring {
  /**
   * @param {SpringParams} [parameters]
   */
  constructor(parameters = {}) {
    const hasBounceOrDuration = !isUnd(parameters.bounce) || !isUnd(parameters.duration);
    this.timeStep = .02; // Interval fed to the solver to calculate duration
    this.restThreshold = .0005; // Values below this threshold are considered resting position
    this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold
    this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)
    this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation
    this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration
    this.bn = clamp$1(setValue(parameters.bounce, .5), -1, 1); // The bounce percentage between -1 and 1.
    this.pd = clamp$1(setValue(parameters.duration, 628), 10 * globals.timeScale, maxSpringParamValue * globals.timeScale); // The perceived duration
    this.m = clamp$1(setValue(parameters.mass, 1), 1, maxSpringParamValue);
    this.s = clamp$1(setValue(parameters.stiffness, 100), minValue, maxSpringParamValue);
    this.d = clamp$1(setValue(parameters.damping, 10), minValue, maxSpringParamValue);
    this.v = clamp$1(setValue(parameters.velocity, 0), -maxSpringParamValue, maxSpringParamValue);
    this.w0 = 0;
    this.zeta = 0;
    this.wd = 0;
    this.b = 0;
    this.completed = false;
    this.solverDuration = 0;
    this.settlingDuration = 0;
    /** @type {JSAnimation} */
    this.parent = null;
    /** @type {Callback<JSAnimation>} */
    this.onComplete = parameters.onComplete || noop;
    if (hasBounceOrDuration) this.calculateSDFromBD();
    this.compute();
    /** @type {EasingFunction} */
    this.ease = t => {
      const currentTime = t * this.settlingDuration;
      const completed = this.completed;
      const perceivedTime = this.pd;
      if (currentTime >= perceivedTime && !completed) {
        this.completed = true;
        this.onComplete(this.parent);
      }
      if (currentTime < perceivedTime && completed) {
        this.completed = false;
      }
      return t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);
    };
  }

  /** @type {EasingFunction} */
  solve(time) {
    const { zeta, w0, wd, b } = this;
    let t = time;
    if (zeta < 1) {
      // Underdamped
      t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));
    } else if (zeta === 1) {
      // Critically damped
      t = (1 + b * t) * exp(-t * w0);
    } else {
      // Overdamped
      // Using exponential instead of cosh and sinh functions to prevent Infinity
      // Original exp(-zeta * w0 * t) * (cosh(wd * t) + b * sinh(wd * t))
      t = ((1 + b) * exp((-zeta * w0 + wd) * t) + (1 - b) * exp((-zeta * w0 - wd) * t)) / 2;
    }
    return 1 - t;
  }

  calculateSDFromBD() {
    // Apple's SwiftUI perceived spring duration implementation https://developer.apple.com/videos/play/wwdc2023/10158/?time=1010
    // Equations taken from Kevin Grajeda's article https://www.kvin.me/posts/effortless-ui-spring-animations
    const pds = globals.timeScale === 1 ? this.pd / K : this.pd;
    // Mass and velocity should be set to their default values
    this.m = 1;
    this.v = 0;
    // Stiffness = (2  perceptualDuration)
    this.s = pow((2 * PI) / pds, 2);
    if (this.bn >= 0) {
      // For bounce  0 (critically damped to underdamped)
      // damping = ((1 - bounce)  4)  perceptualDuration
      this.d = ((1 - this.bn) * 4 * PI) / pds;
    } else {
      // For bounce < 0 (overdamped)
      // damping = 4  (perceptualDuration  (1 + bounce))
      // Note: (1 + bounce) is positive since bounce is negative
      this.d = (4 * PI) / (pds * (1 + this.bn));
    }
    this.s = round$1(clamp$1(this.s, minValue, maxSpringParamValue), 3);
    this.d = round$1(clamp$1(this.d, minValue, 300), 3); // Clamping to 300 is needed to prevent insane values in the solver
  }

  calculateBDFromSD() {
    // Calculate perceived duration and bounce from stiffness and damping
    // Note: We assumes m = 1 and v = 0 for these calculations
    const pds = (2 * PI) / sqrt(this.s);
    this.pd = pds * (globals.timeScale === 1 ? K : 1);
    const zeta = this.d / (2 * sqrt(this.s));
    if (zeta <= 1) {
      // Critically damped to underdamped
      this.bn = 1 - (this.d * pds) / (4 * PI);
    } else {
      // Overdamped
      this.bn = (4 * PI) / (this.d * pds) - 1;
    }
    this.bn = round$1(clamp$1(this.bn, -1, 1), 3);
    this.pd = round$1(clamp$1(this.pd, 10 * globals.timeScale, maxSpringParamValue * globals.timeScale), 3);
  }

  compute() {
    const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;
    const w0 = this.w0 = clamp$1(sqrt(s / m), minValue, K);
    const bouncedZeta = this.zeta = d / (2 * sqrt(s * m));
    // Calculate wd based on damping type
    if (bouncedZeta < 1) {
      // Underdamped
      this.wd = w0 * sqrt(1 - bouncedZeta * bouncedZeta);
      this.b = (bouncedZeta * w0 + -v) / this.wd;
    } else if (bouncedZeta === 1) {
      // Critically damped
      this.wd = 0;
      this.b = -v + w0;
    } else {
      // Overdamped
      this.wd = w0 * sqrt(bouncedZeta * bouncedZeta - 1);
      this.b = (bouncedZeta * w0 + -v) / this.wd;
    }

    let solverTime = 0;
    let restSteps = 0;
    let iterations = 0;
    while (restSteps <= maxRestSteps && iterations <= maxIterations) {
      if (abs(1 - this.solve(solverTime)) < restThreshold) {
        restSteps++;
      } else {
        restSteps = 0;
      }
      this.solverDuration = solverTime;
      solverTime += timeStep;
      iterations++;
    }
    this.settlingDuration = round$1(this.solverDuration * K, 0) * globals.timeScale;
  }

  get bounce() {
    return this.bn;
  }

  set bounce(v) {
    this.bn = clamp$1(setValue(v, 1), -1, 1);
    this.calculateSDFromBD();
    this.compute();
  }

  get duration() {
    return this.pd;
  }

  set duration(v) {
    this.pd = clamp$1(setValue(v, 1), 10 * globals.timeScale, maxSpringParamValue * globals.timeScale);
    this.calculateSDFromBD();
    this.compute();
  }

  get stiffness() {
    return this.s;
  }

  set stiffness(v) {
    this.s = clamp$1(setValue(v, 100), minValue, maxSpringParamValue);
    this.calculateBDFromSD();
    this.compute();
  }

  get damping() {
    return this.d;
  }

  set damping(v) {
    this.d = clamp$1(setValue(v, 10), minValue, maxSpringParamValue);
    this.calculateBDFromSD();
    this.compute();
  }

  get mass() {
    return this.m;
  }

  set mass(v) {
    this.m = clamp$1(setValue(v, 1), 1, maxSpringParamValue);
    this.compute();
  }

  get velocity() {
    return this.v;
  }

  set velocity(v) {
    this.v = clamp$1(setValue(v, 0), -maxSpringParamValue, maxSpringParamValue);
    this.compute();
  }
}

/**
 * @param {SpringParams} [parameters]
 * @returns {Spring}
 */
const spring = (parameters) => new Spring(parameters);

/**
 * @deprecated createSpring() is deprecated use spring() instead
 *
 * @param {SpringParams} [parameters]
 * @returns {Spring}
 */
const createSpring = (parameters) => {
  console.warn('createSpring() is deprecated use spring() instead');
  return new Spring(parameters);
};





/**
 * @param {Event} e
 */
const preventDefault = e => {
  if (e.cancelable) e.preventDefault();
};

class DOMProxy {
  /** @param {Object} el */
  constructor(el) {
    this.el = el;
    this.zIndex = 0;
    this.parentElement = null;
    this.classList = {
      add: noop,
      remove: noop,
    };
  }

  get x() { return this.el.x || 0 };
  set x(v) { this.el.x = v; };

  get y() { return this.el.y || 0 };
  set y(v) { this.el.y = v; };

  get width() { return this.el.width || 0 };
  set width(v) { this.el.width = v; };

  get height() { return this.el.height || 0 };
  set height(v) { this.el.height = v; };

  getBoundingClientRect() {
    return {
      top: this.y,
      right: this.x,
      bottom: this.y + this.height,
      left: this.x + this.width,
    }
  }
}

class Transforms {
  /**
   * @param {DOMTarget|DOMProxy} $el
   */
  constructor($el) {
    this.$el = $el;
    this.inlineTransforms = [];
    this.point = new DOMPoint();
    this.inversedMatrix = this.getMatrix().inverse();
  }

  /**
   * @param {Number} x
   * @param {Number} y
   * @return {DOMPoint}
   */
  normalizePoint(x, y) {
    this.point.x = x;
    this.point.y = y;
    return this.point.matrixTransform(this.inversedMatrix);
  }

  /**
   * @callback TraverseParentsCallback
   * @param {DOMTarget} $el
   * @param {Number} i
   */

  /**
   * @param {TraverseParentsCallback} cb
   */
  traverseUp(cb) {
    let $el = /** @type {DOMTarget|Document} */(this.$el.parentElement), i = 0;
    while ($el && $el !== doc) {
      cb(/** @type {DOMTarget} */($el), i);
      $el = /** @type {DOMTarget} */($el.parentElement);
      i++;
    }
  }

  getMatrix() {
    const matrix = new DOMMatrix();
    this.traverseUp($el => {
      const transformValue = getComputedStyle($el).transform;
      if (transformValue) {
        const elMatrix = new DOMMatrix(transformValue);
        matrix.preMultiplySelf(elMatrix);
      }
    });
    return matrix;
  }

  remove() {
    this.traverseUp(($el, i) => {
      this.inlineTransforms[i] = $el.style.transform;
      $el.style.transform = 'none';
    });
  }

  revert() {
    this.traverseUp(($el, i) => {
      const ct = this.inlineTransforms[i];
      if (ct === '') {
        $el.style.removeProperty('transform');
      } else {
        $el.style.transform = ct;
      }
    });
  }
}

/**
 * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams|DraggableDragThresholdParams} T
 * @param {T | ((draggable: Draggable) => T)} value
 * @param {Draggable} draggable
 * @return {T}
 */
const parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */(value)(draggable) : /** @type {T} */(value);

let zIndex = 0;

class Draggable {
  /**
   * @param {TargetsParam} target
   * @param {DraggableParams} [parameters]
   */
  constructor(target, parameters = {}) {
    if (!target) return;
    if (scope.current) scope.current.register(this);
    const paramX = parameters.x;
    const paramY = parameters.y;
    const trigger = parameters.trigger;
    const modifier = parameters.modifier;
    const ease = parameters.releaseEase;
    const customEase = ease && parseEase(ease);
    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);
    const xProp = /** @type {String} */(isObj(paramX) && !isUnd(/** @type {Object} */(paramX).mapTo) ? /** @type {Object} */(paramX).mapTo : 'translateX');
    const yProp = /** @type {String} */(isObj(paramY) && !isUnd(/** @type {Object} */(paramY).mapTo) ? /** @type {Object} */(paramY).mapTo : 'translateY');
    const container = parseDraggableFunctionParameter(parameters.container, this);
    this.containerArray = isArr(container) ? container : null;
    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);
    this.useWin = this.$container === doc.body;
    /** @type {Window | HTMLElement} */
    this.$scrollContainer = this.useWin ? win : this.$container;
    this.$target = /** @type {HTMLElement} */(isObj(target) ? new DOMProxy(target) : parseTargets(target)[0]);
    this.$trigger = /** @type {HTMLElement} */(parseTargets(trigger ? trigger : target)[0]);
    this.fixed = get(this.$target, 'position') === 'fixed';
    // Refreshable parameters
    this.isFinePointer = true;
    /** @type {[Number, Number, Number, Number]} */
    this.containerPadding = [0, 0, 0, 0];
    /** @type {Number} */
    this.containerFriction = 0;
    /** @type {Number} */
    this.releaseContainerFriction = 0;
    /** @type {Number|Array<Number>} */
    this.snapX = 0;
    /** @type {Number|Array<Number>} */
    this.snapY = 0;
    /** @type {Number} */
    this.scrollSpeed = 0;
    /** @type {Number} */
    this.scrollThreshold = 0;
    /** @type {Number} */
    this.dragSpeed = 0;
    /** @type {Number} */
    this.dragThreshold = 3;
    /** @type {Number} */
    this.maxVelocity = 0;
    /** @type {Number} */
    this.minVelocity = 0;
    /** @type {Number} */
    this.velocityMultiplier = 0;
    /** @type {Boolean|DraggableCursorParams} */
    this.cursor = false;
    /** @type {Spring} */
    this.releaseXSpring = hasSpring ? /** @type {Spring} */(ease) : spring({
      mass: setValue(parameters.releaseMass, 1),
      stiffness: setValue(parameters.releaseStiffness, 80),
      damping: setValue(parameters.releaseDamping, 20),
    });
    /** @type {Spring} */
    this.releaseYSpring = hasSpring ? /** @type {Spring} */(ease) : spring({
      mass: setValue(parameters.releaseMass, 1),
      stiffness: setValue(parameters.releaseStiffness, 80),
      damping: setValue(parameters.releaseDamping, 20),
    });
    /** @type {EasingFunction} */
    this.releaseEase = customEase || eases.outQuint;
    /** @type {Boolean} */
    this.hasReleaseSpring = hasSpring;
    /** @type {Callback<this>} */
    this.onGrab = parameters.onGrab || noop;
    /** @type {Callback<this>} */
    this.onDrag = parameters.onDrag || noop;
    /** @type {Callback<this>} */
    this.onRelease = parameters.onRelease || noop;
    /** @type {Callback<this>} */
    this.onUpdate = parameters.onUpdate || noop;
    /** @type {Callback<this>} */
    this.onSettle = parameters.onSettle || noop;
    /** @type {Callback<this>} */
    this.onSnap = parameters.onSnap || noop;
    /** @type {Callback<this>} */
    this.onResize = parameters.onResize || noop;
    /** @type {Callback<this>} */
    this.onAfterResize = parameters.onAfterResize || noop;
    /** @type {[Number, Number]} */
    this.disabled = [0, 0];
    /** @type {AnimatableParams} */
    const animatableParams = {};
    if (modifier) animatableParams.modifier = modifier;
    if (isUnd(paramX) || paramX === true) {
      animatableParams[xProp] = 0;
    } else if (isObj(paramX)) {
      const paramXObject = /** @type {DraggableAxisParam} */(paramX);
      const animatableXParams = {};
      if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;
      if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;
      animatableParams[xProp] = animatableXParams;
    } else if (paramX === false) {
      animatableParams[xProp] = 0;
      this.disabled[0] = 1;
    }
    if (isUnd(paramY) || paramY === true) {
      animatableParams[yProp] = 0;
    } else if (isObj(paramY)) {
      const paramYObject = /** @type {DraggableAxisParam} */(paramY);
      const animatableYParams = {};
      if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;
      if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;
      animatableParams[yProp] = animatableYParams;
    } else if (paramY === false) {
      animatableParams[yProp] = 0;
      this.disabled[1] = 1;
    }
    /** @type {AnimatableObject} */
    this.animate = /** @type {AnimatableObject} */(new Animatable(this.$target, animatableParams));
    // Internal props
    this.xProp = xProp;
    this.yProp = yProp;
    this.destX = 0;
    this.destY = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.scroll = {x: 0, y: 0};
    /** @type {[Number, Number, Number, Number]} */
    this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y
    /** @type {[Number, Number]} */
    this.snapped = [0, 0]; // x, y
    /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */
    this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2
    /** @type {[Number, Number]} */
    this.scrollView = [0, 0]; // w, h
    /** @type {[Number, Number, Number, Number]} */
    this.dragArea = [0, 0, 0, 0]; // x, y, w, h
    /** @type {[Number, Number, Number, Number]} */
    this.containerBounds = [-maxValue, maxValue, maxValue, -maxValue]; // t, r, b, l
    /** @type {[Number, Number, Number, Number]} */
    this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l
    /** @type {[Number, Number, Number, Number]} */
    this.targetBounds = [0, 0, 0, 0]; // t, r, b, l
    /** @type {[Number, Number]} */
    this.window = [0, 0]; // w, h
    /** @type {[Number, Number, Number]} */
    this.velocityStack = [0, 0, 0];
    /** @type {Number} */
    this.velocityStackIndex = 0;
    /** @type {Number} */
    this.velocityTime = now();
    /** @type {Number} */
    this.velocity = 0;
    /** @type {Number} */
    this.angle = 0;
    /** @type {JSAnimation} */
    this.cursorStyles = null;
    /** @type {JSAnimation} */
    this.triggerStyles = null;
    /** @type {JSAnimation} */
    this.bodyStyles = null;
    /** @type {JSAnimation} */
    this.targetStyles = null;
    /** @type {JSAnimation} */
    this.touchActionStyles = null;
    this.transforms = new Transforms(this.$target);
    this.overshootCoords = { x: 0, y: 0 };
    this.overshootTicker = new Timer({
      autoplay: false,
      onUpdate: () => {
        this.updated = true;
        this.manual = true;
        // Use a duration of 1 to prevent the animatable from completing immediately to prevent issues with onSettle()
        // https://github.com/juliangarnier/anime/issues/1045
        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 1);
        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 1);
      },
      onComplete: () => {
        this.manual = false;
        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 0);
        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 0);
      },
    }, null, 0).init();
    this.updateTicker = new Timer({ autoplay: false, onUpdate: () => this.update() }, null,0,).init();
    this.contained = !isUnd(container);
    this.manual = false;
    this.grabbed = false;
    this.dragged = false;
    this.updated = false;
    this.released = false;
    this.canScroll = false;
    this.enabled = false;
    this.initialized = false;
    this.activeProp = this.disabled[1] ? xProp : yProp;
    this.animate.callbacks.onRender = () => {
      const hasUpdated = this.updated;
      const hasMoved = this.grabbed && hasUpdated;
      const hasReleased = !hasMoved && this.released;
      const x = this.x;
      const y = this.y;
      const dx = x - this.coords[2];
      const dy = y - this.coords[3];
      this.deltaX = dx;
      this.deltaY = dy;
      this.coords[2] = x;
      this.coords[3] = y;
      // Check if dx or dy are not 0 to check if the draggable has actually moved
      // https://github.com/juliangarnier/anime/issues/1032
      if (hasUpdated && (dx || dy)) {
        this.onUpdate(this);
      }
      if (!hasReleased) {
        this.updated = false;
      } else {
        this.computeVelocity(dx, dy);
        this.angle = atan2(dy, dx);
      }
    };
    this.animate.callbacks.onComplete = () => {
      if ((!this.grabbed && this.released)) {
        // Set released to false before calling onSettle to avoid recursion
        this.released = false;
      }
      if (!this.manual) {
        this.deltaX = 0;
        this.deltaY = 0;
        this.velocity = 0;
        this.velocityStack[0] = 0;
        this.velocityStack[1] = 0;
        this.velocityStack[2] = 0;
        this.velocityStackIndex = 0;
        this.onSettle(this);
      }
    };
    this.resizeTicker = new Timer({
      autoplay: false,
      duration: 150 * globals.timeScale,
      onComplete: () => {
        this.onResize(this);
        this.refresh();
        this.onAfterResize(this);
      },
    }).init();
    this.parameters = parameters;
    this.resizeObserver = new ResizeObserver(() => {
      if (this.initialized) {
        this.resizeTicker.restart();
      } else {
        this.initialized = true;
      }
    });
    this.enable();
    this.refresh();
    this.resizeObserver.observe(this.$container);
    if (!isObj(target)) this.resizeObserver.observe(this.$target);
  }

  /**
   * @param  {Number} dx
   * @param  {Number} dy
   * @return {Number}
   */
  computeVelocity(dx, dy) {
    const prevTime = this.velocityTime;
    const curTime = now();
    const elapsed = curTime - prevTime;
    if (elapsed < 17) return this.velocity;
    this.velocityTime = curTime;
    const velocityStack = this.velocityStack;
    const vMul = this.velocityMultiplier;
    const minV = this.minVelocity;
    const maxV = this.maxVelocity;
    const vi = this.velocityStackIndex;
    velocityStack[vi] = round$1(clamp$1((sqrt(dx * dx + dy * dy) / elapsed) * vMul, minV, maxV), 5);
    const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);
    this.velocity = velocity;
    this.velocityStackIndex = (vi + 1) % 3;
    return velocity;
  }

  /**
   * @param {Number}  x
   * @param {Boolean} [muteUpdateCallback]
   * @return {this}
   */
  setX(x, muteUpdateCallback = false) {
    if (this.disabled[0]) return;
    const v = round$1(x, 5);
    this.overshootTicker.pause();
    this.manual = true;
    this.updated = !muteUpdateCallback;
    this.destX = v;
    this.snapped[0] = snap$1(v, this.snapX);
    this.animate[this.xProp](v, 0);
    this.manual = false;
    return this;
  }

  /**
   * @param {Number}  y
   * @param {Boolean} [muteUpdateCallback]
   * @return {this}
   */
  setY(y, muteUpdateCallback = false) {
    if (this.disabled[1]) return;
    const v = round$1(y, 5);
    this.overshootTicker.pause();
    this.manual = true;
    this.updated = !muteUpdateCallback;
    this.destY = v;
    this.snapped[1] = snap$1(v, this.snapY);
    this.animate[this.yProp](v, 0);
    this.manual = false;
    return this;
  }

  get x() {
    return round$1(/** @type {Number} */(this.animate[this.xProp]()), globals.precision);
  }

  set x(x) {
    this.setX(x, false);
  }

  get y() {
    return round$1(/** @type {Number} */(this.animate[this.yProp]()), globals.precision);
  }

  set y(y) {
    this.setY(y, false);
  }

  get progressX() {
    return mapRange$1(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);
  }

  set progressX(x) {
    this.setX(mapRange$1(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);
  }

  get progressY() {
    return mapRange$1(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);
  }

  set progressY(y) {
    this.setY(mapRange$1(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);
  }

  updateScrollCoords() {
    const sx = round$1(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);
    const sy = round$1(this.useWin ? win.scrollY : this.$container.scrollTop, 0);
    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
    const threshold = this.scrollThreshold;
    this.scroll.x = sx;
    this.scroll.y = sy;
    this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;
    this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;
    this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;
    this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;
  }

  updateBoundingValues() {
    const $container = this.$container;
    // Return early if no $container defined to prevents error when reading scrollWidth / scrollHeight
    // https://github.com/juliangarnier/anime/issues/1064
    if (!$container) return;
    const cx = this.x;
    const cy = this.y;
    const cx2 = this.coords[2];
    const cy2 =  this.coords[3];
    // Prevents interfering with the scroll area in cases the target is outside of the container
    // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates
    this.coords[2] = 0;
    this.coords[3] = 0;
    this.setX(0, true);
    this.setY(0, true);
    this.transforms.remove();
    const iw = this.window[0] = win.innerWidth;
    const ih = this.window[1] = win.innerHeight;
    const uw = this.useWin;
    const sw = $container.scrollWidth;
    const sh = $container.scrollHeight;
    const fx = this.fixed;
    const transformContainerRect = $container.getBoundingClientRect();
    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
    this.dragArea[0] = uw ? 0 : transformContainerRect.left;
    this.dragArea[1] = uw ? 0 : transformContainerRect.top;
    this.scrollView[0] = uw ? clamp$1(sw, iw, sw) : sw;
    this.scrollView[1] = uw ? clamp$1(sh, ih, sh) : sh;
    this.updateScrollCoords();
    const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();
    this.dragArea[2] = round$1(uw ? clamp$1(width, iw, iw) : width, 0);
    this.dragArea[3] = round$1(uw ? clamp$1(height, ih, ih) : height, 0);
    const containerOverflow = get($container, 'overflow');
    const visibleOverflow = containerOverflow === 'visible';
    const hiddenOverflow = containerOverflow === 'hidden';
    this.canScroll = fx ? false :
      this.contained &&
      (($container === doc.body && visibleOverflow) || (!hiddenOverflow && !visibleOverflow)) &&
      (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) &&
      (!this.containerArray || (this.containerArray && !isArr(this.containerArray)));
    if (this.contained) {
      const sx = this.scroll.x;
      const sy = this.scroll.y;
      const canScroll = this.canScroll;
      const targetRect = this.$target.getBoundingClientRect();
      const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;
      const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;
      const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;
      const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;
      this.targetBounds[0] = round$1((targetRect.top + sy) - (uw ? 0 : top), 0);
      this.targetBounds[1] = round$1((targetRect.right + sx) - (uw ? iw : right), 0);
      this.targetBounds[2] = round$1((targetRect.bottom + sy) - (uw ? ih : bottom), 0);
      this.targetBounds[3] = round$1((targetRect.left + sx) - (uw ? 0 : left), 0);
      if (this.containerArray) {
        this.containerBounds[0] = this.containerArray[0] + cpt;
        this.containerBounds[1] = this.containerArray[1] - cpr;
        this.containerBounds[2] = this.containerArray[2] - cpb;
        this.containerBounds[3] = this.containerArray[3] + cpl;
      } else {
        this.containerBounds[0] = -round$1(targetRect.top - (fx ? clamp$1(top, 0, ih) : top) + hiddenTop - cpt, 0);
        this.containerBounds[1] = -round$1(targetRect.right - (fx ? clamp$1(right, 0, iw) : right) - hiddenRight + cpr, 0);
        this.containerBounds[2] = -round$1(targetRect.bottom - (fx ? clamp$1(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);
        this.containerBounds[3] = -round$1(targetRect.left - (fx ? clamp$1(left, 0, iw) : left) + hiddenLeft - cpl, 0);
      }
    }
    this.transforms.revert();
    // Restore coordinates
    this.coords[2] = cx2;
    this.coords[3] = cy2;
    this.setX(cx, true);
    this.setY(cy, true);
  }

  /**
   * @param  {Array} bounds
   * @param  {Number} x
   * @param  {Number} y
   * @return {Number}
   */
  isOutOfBounds(bounds, x, y) {
    // Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB
    if (!this.contained) return 0;
    const [ bt, br, bb, bl ] = bounds;
    const [ dx, dy ] = this.disabled;
    const obx = !dx && x < bl || !dx && x > br;
    const oby = !dy && y < bt || !dy && y > bb;
    return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;
  }

  refresh() {
    const params = this.parameters;
    const paramX = params.x;
    const paramY = params.y;
    const container = parseDraggableFunctionParameter(params.container, this);
    const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;
    const containerPadding = /** @type {[Number, Number, Number, Number]} */(isArr(cp) ? cp : [cp, cp, cp, cp]);
    const cx = this.x;
    const cy = this.y;
    const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);
    const cursorStyles = { onHover: 'grab', onGrab: 'grabbing' };
    if (parsedCursorStyles) {
      const { onHover, onGrab } = /** @type {DraggableCursorParams} */(parsedCursorStyles);
      if (onHover) cursorStyles.onHover = onHover;
      if (onGrab) cursorStyles.onGrab = onGrab;
    }
    const parsedDragThreshold = parseDraggableFunctionParameter(params.dragThreshold, this);
    const dragThreshold = { mouse: 3, touch: 7 };
    if (isNum(parsedDragThreshold)) {
      dragThreshold.mouse = parsedDragThreshold;
      dragThreshold.touch = parsedDragThreshold;
    } else if (parsedDragThreshold) {
      const { mouse, touch } = parsedDragThreshold;
      if (!isUnd(mouse)) dragThreshold.mouse = mouse;
      if (!isUnd(touch)) dragThreshold.touch = touch;
    }
    this.containerArray = isArr(container) ? container : null;
    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);
    this.useWin = this.$container === doc.body;
    /** @type {Window | HTMLElement} */
    this.$scrollContainer = this.useWin ? win : this.$container;
    this.isFinePointer = matchMedia('(pointer:fine)').matches;
    this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);
    this.containerFriction = clamp$1(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);
    this.releaseContainerFriction = clamp$1(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);
    this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);
    this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);
    this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);
    this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);
    this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);
    this.dragThreshold = this.isFinePointer ? dragThreshold.mouse : dragThreshold.touch;
    this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);
    this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);
    this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);
    this.cursor = parsedCursorStyles === false ? false : cursorStyles;
    this.updateBoundingValues();

    // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);
    // if (ob === 1 || ob === 3) this.progressX = px;
    // if (ob === 2 || ob === 3) this.progressY = py;

    // if (this.initialized && this.contained) {
    //   if (this.progressX !== px) this.progressX = px;
    //   if (this.progressY !== py) this.progressY = py;
    // }

    const [ bt, br, bb, bl ] = this.containerBounds;
    this.setX(clamp$1(cx, bl, br), true);
    this.setY(clamp$1(cy, bt, bb), true);
  }

  update() {
    this.updateScrollCoords();
    if (this.canScroll) {
      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
      const [ sw, sh ] = this.scrollView;
      const daw = this.dragArea[2];
      const dah = this.dragArea[3];
      const csx = this.scroll.x;
      const csy = this.scroll.y;
      const nsw = this.$container.scrollWidth;
      const nsh = this.$container.scrollHeight;
      const csw = this.useWin ? clamp$1(nsw, this.window[0], nsw) : nsw;
      const csh = this.useWin ? clamp$1(nsh, this.window[1], nsh) : nsh;
      const swd = sw - csw;
      const shd = sh - csh;
      // Handle cases where the scrollarea dimensions changes during drag
      if (this.dragged && swd > 0) {
        this.coords[0] -= swd;
        this.scrollView[0] = csw;
      }
      if (this.dragged && shd > 0) {
        this.coords[1] -= shd;
        this.scrollView[1] = csh;
      }
      // Handle autoscroll when target is at the edges of the scroll bounds
      const s = this.scrollSpeed * 10;
      const threshold = this.scrollThreshold;
      const [ x, y ] = this.coords;
      const [ st, sr, sb, sl ] = this.scrollBounds;
      const t = round$1(clamp$1((y - st + cpt) / threshold, -1, 0) * s, 0);
      const r = round$1(clamp$1((x - sr - cpr) / threshold, 0, 1) * s, 0);
      const b = round$1(clamp$1((y - sb - cpb) / threshold, 0, 1) * s, 0);
      const l = round$1(clamp$1((x - sl + cpl) / threshold, -1, 0) * s, 0);
      if (t || b || l || r) {
        const [nx, ny] = this.disabled;
        let scrollX = csx;
        let scrollY = csy;
        if (!nx) {
          scrollX = round$1(clamp$1(csx + (l || r), 0, sw - daw), 0);
          this.coords[0] -= csx - scrollX;
        }
        if (!ny) {
          scrollY = round$1(clamp$1(csy + (t || b), 0, sh - dah), 0);
          this.coords[1] -= csy - scrollY;
        }
        // Note: Safari mobile requires to use different scroll methods depending if using the window or not
        if (this.useWin) {
          this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));
        } else {
          this.$scrollContainer.scrollTo(scrollX, scrollY);
        }
      }
    }
    const [ ct, cr, cb, cl ] = this.containerBounds;
    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;
    this.coords[0] += (px1 - px3) * this.dragSpeed;
    this.coords[1] += (py1 - py3) * this.dragSpeed;
    this.pointer[4] = px1;
    this.pointer[5] = py1;
    const [ cx, cy ] = this.coords;
    const [ sx, sy ] = this.snapped;
    const cf = (1 - this.containerFriction) * this.dragSpeed;
    this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);
    this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);
    this.computeVelocity(px1 - px3, py1 - py3);
    this.angle = atan2(py1 - py2, px1 - px2);
    const [ nsx, nsy ] = this.snapped;
    if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {
      this.onSnap(this);
    }
  }

  stop() {
    this.updateTicker.pause();
    this.overshootTicker.pause();
    // Pauses the in bounds onRelease animations
    for (let prop in this.animate.animations) this.animate.animations[prop].pause();
    removeTargetsFromRenderable([this], null, 'x');
    removeTargetsFromRenderable([this], null, 'y');
    removeTargetsFromRenderable([this], null, 'progressX');
    removeTargetsFromRenderable([this], null, 'progressY');
    removeTargetsFromRenderable([this.scroll]); // Removes any active animations on the container scroll
    removeTargetsFromRenderable([this.overshootCoords]); // Removes active overshoot animations
    return this;
  }

  /**
   * @param {Number} [duration]
   * @param {Number} [gap]
   * @param {EasingParam} [ease]
   * @return {this}
   */
  scrollInView(duration, gap = 0, ease = eases.inOutQuad) {
    this.updateScrollCoords();
    const x = this.destX;
    const y = this.destY;
    const scroll = this.scroll;
    const scrollBounds = this.scrollBounds;
    const canScroll = this.canScroll;
    if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {
      const [ st, sr, sb, sl ] = scrollBounds;
      const t = round$1(clamp$1(y - st, -maxValue, 0), 0);
      const r = round$1(clamp$1(x - sr, 0, maxValue), 0);
      const b = round$1(clamp$1(y - sb, 0, maxValue), 0);
      const l = round$1(clamp$1(x - sl, -maxValue, 0), 0);
      new JSAnimation(scroll, {
        x: round$1(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),
        y: round$1(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),
        duration: isUnd(duration) ? 350 * globals.timeScale : duration,
        ease,
        onUpdate: () => {
          this.canScroll = false;
          this.$scrollContainer.scrollTo(scroll.x, scroll.y);
        }
      }).init().then(() => {
        this.canScroll = canScroll;
      });
    }
    return this;
  }

  handleHover() {
    if (this.isFinePointer && this.cursor && !this.cursorStyles) {
      this.cursorStyles = set(this.$trigger, {
        cursor: /** @type {DraggableCursorParams} */(this.cursor).onHover
      });
    }
  }

  /**
   * @param  {Number} [duration]
   * @param  {Number} [gap]
   * @param  {EasingParam} [ease]
   * @return {this}
   */
  animateInView(duration, gap = 0, ease = eases.inOutQuad) {
    this.stop();
    this.updateBoundingValues();
    const x = this.x;
    const y = this.y;
    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
    const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;
    const br = this.scroll.x - this.targetBounds[1] - cpr - gap;
    const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;
    const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;
    const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);
    if (ob) {
      const [ disabledX, disabledY ] = this.disabled;
      const destX = clamp$1(snap$1(x, this.snapX), bl, br);
      const destY = clamp$1(snap$1(y, this.snapY), bt, bb);
      const dur = isUnd(duration) ? 350 * globals.timeScale : duration;
      if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);
      if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);
    }
    return this;
  }

  /**
   * @param {MouseEvent|TouchEvent} e
   */
  handleDown(e) {
    const $eTarget = /** @type {HTMLElement} */(e.target);
    if (this.grabbed || /** @type {HTMLInputElement} */($eTarget).type === 'range') return;

    e.stopPropagation();

    this.grabbed = true;
    this.released = false;
    this.stop();
    this.updateBoundingValues();
    const touches = /** @type {TouchEvent} */(e).changedTouches;
    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;
    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;
    const { x, y } = this.transforms.normalizePoint(eventX, eventY);
    const [ ct, cr, cb, cl ] = this.containerBounds;
    const cf = (1 - this.containerFriction) * this.dragSpeed;
    const cx = this.x;
    const cy = this.y;
    this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;
    this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;
    this.pointer[0] = x;
    this.pointer[1] = y;
    this.pointer[2] = x;
    this.pointer[3] = y;
    this.pointer[4] = x;
    this.pointer[5] = y;
    this.pointer[6] = x;
    this.pointer[7] = y;
    this.deltaX = 0;
    this.deltaY = 0;
    this.velocity = 0;
    this.velocityStack[0] = 0;
    this.velocityStack[1] = 0;
    this.velocityStack[2] = 0;
    this.velocityStackIndex = 0;
    this.angle = 0;
    if (this.targetStyles) {
      this.targetStyles.revert();
      this.targetStyles = null;
    }
    const z = /** @type {Number} */(get(this.$target, 'zIndex', false));
    zIndex = (z > zIndex ? z : zIndex) + 1;
    this.targetStyles = set(this.$target, { zIndex });
    if (this.triggerStyles) {
      this.triggerStyles.revert();
      this.triggerStyles = null;
    }
    if (this.cursorStyles) {
      this.cursorStyles.revert();
      this.cursorStyles = null;
    }
    if (this.isFinePointer && this.cursor) {
      this.bodyStyles = set(doc.body, {
        cursor: /** @type {DraggableCursorParams} */(this.cursor).onGrab
      });
    }
    this.scrollInView(100, 0, eases.out(3));
    this.onGrab(this);

    doc.addEventListener('touchmove', this);
    doc.addEventListener('touchend', this);
    doc.addEventListener('touchcancel', this);
    doc.addEventListener('mousemove', this);
    doc.addEventListener('mouseup', this);
    doc.addEventListener('selectstart', this);
  }

  /**
   * @param {MouseEvent|TouchEvent} e
   */
  handleMove(e) {
    if (!this.grabbed) return;
    const touches = /** @type {TouchEvent} */(e).changedTouches;
    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;
    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;
    const { x, y } = this.transforms.normalizePoint(eventX, eventY);
    const movedX = x - this.pointer[6];
    const movedY = y - this.pointer[7];

    let $parent = /** @type {HTMLElement} */(e.target);
    let isAtTop = false;
    let isAtBottom = false;
    let canTouchScroll = false;

    while (touches && $parent && $parent !== this.$trigger) {
      const overflowY = get($parent, 'overflow-y');
      if (overflowY !== 'hidden' && overflowY !== 'visible') {
        const { scrollTop, scrollHeight, clientHeight } = $parent;
        if (scrollHeight > clientHeight) {
          canTouchScroll = true;
          isAtTop = scrollTop <= 3;
          isAtBottom = scrollTop >= (scrollHeight - clientHeight) - 3;
          break;
        }
      }
      $parent = $parent.parentElement;
    }

    if (canTouchScroll && ((!isAtTop && !isAtBottom) || (isAtTop && movedY < 0) || (isAtBottom && movedY > 0))) {

      this.pointer[0] = x;
      this.pointer[1] = y;
      this.pointer[2] = x;
      this.pointer[3] = y;
      this.pointer[4] = x;
      this.pointer[5] = y;
      this.pointer[6] = x;
      this.pointer[7] = y;

    } else {

      preventDefault(e);

      // Needed to prevents click on handleUp
      if (!this.triggerStyles) this.triggerStyles = set(this.$trigger, { pointerEvents: 'none' });
      // Needed to prevent page scroll while dragging on touch devvice
      this.$trigger.addEventListener('touchstart', preventDefault, { passive: false });
      this.$trigger.addEventListener('touchmove', preventDefault, { passive: false });
      this.$trigger.addEventListener('touchend', preventDefault);

      // Don't check for a miminim distance move if already dragging
      if (this.dragged || (!this.disabled[0] && abs(movedX) > this.dragThreshold) || (!this.disabled[1] && abs(movedY) > this.dragThreshold)) {
        this.updateTicker.resume();
        this.pointer[2] = this.pointer[0];
        this.pointer[3] = this.pointer[1];
        this.pointer[0] = x;
        this.pointer[1] = y;
        this.dragged = true;
        this.released = false;
        this.onDrag(this);
      }
    }
  }

  handleUp() {

    if (!this.grabbed) return;

    this.updateTicker.pause();

    if (this.triggerStyles) {
      this.triggerStyles.revert();
      this.triggerStyles = null;
    }

    if (this.bodyStyles) {
      this.bodyStyles.revert();
      this.bodyStyles = null;
    }

    const [ disabledX, disabledY ] = this.disabled;
    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;
    const [ ct, cr, cb, cl ] = this.containerBounds;
    const [ sx, sy ] = this.snapped;
    const springX = this.releaseXSpring;
    const springY = this.releaseYSpring;
    const releaseEase = this.releaseEase;
    const hasReleaseSpring = this.hasReleaseSpring;
    const overshootCoords = this.overshootCoords;
    const cx = this.x;
    const cy = this.y;
    const pv = this.computeVelocity(px1 - px3, py1 - py3);
    const pa = this.angle = atan2(py1 - py2, px1 - px2);
    const ds = pv * 150;
    const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;
    const nx = cx + (cos(pa) * ds);
    const ny = cy + (sin(pa) * ds);
    const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;
    const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;
    const dx = this.destX = clamp$1(round$1(snap$1(bx, this.snapX), 5), cl, cr);
    const dy = this.destY = clamp$1(round$1(snap$1(by, this.snapY), 5), ct, cb);
    const ob = this.isOutOfBounds(this.containerBounds, nx, ny);

    let durationX = 0;
    let durationY = 0;
    let easeX = releaseEase;
    let easeY = releaseEase;
    let longestReleaseDuration = 0;

    overshootCoords.x = cx;
    overshootCoords.y = cy;

    if (!disabledX) {
      const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;
      const distanceX = round$1(cx - dx, 0);
      springX.velocity = disabledY && hasReleaseSpring ? distanceX ? (ds * directionX) / abs(distanceX) : 0 : pv;
      const { ease, settlingDuration, restDuration } = springX;
      durationX = cx === dx ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - (restDuration * globals.timeScale);
      if (hasReleaseSpring) easeX = ease;
      if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;
    }

    if (!disabledY) {
      const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;
      const distanceY = round$1(cy - dy, 0);
      springY.velocity = disabledX && hasReleaseSpring ? distanceY ? (ds * directionY) / abs(distanceY) : 0 : pv;
      const { ease, settlingDuration, restDuration } = springY;
      durationY = cy === dy ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - (restDuration * globals.timeScale);
      if (hasReleaseSpring) easeY = ease;
      if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;
    }

    if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {

        const composition = compositionTypes.blend;

        new JSAnimation(overshootCoords, {
          x: { to: bx, duration: durationX * .65 },
          y: { to: by, duration: durationY * .65 },
          ease: releaseEase,
          composition,
        }).init();

        new JSAnimation(overshootCoords, {
          x: { to: dx, duration: durationX },
          y: { to: dy, duration: durationY },
          ease: releaseEase,
          composition,
        }).init();

        this.overshootTicker.stretch(max(durationX, durationY)).restart();

    } else {

      if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);
      if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);

    }

    this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);

    let hasSnapped = false;

    if (dx !== sx) {
      this.snapped[0] = dx;
      if (this.snapX) hasSnapped = true;
    }

    if (dy !== sy && this.snapY) {
      this.snapped[1] = dy;
      if (this.snapY) hasSnapped = true;
    }

    if (hasSnapped) this.onSnap(this);

    this.grabbed = false;
    this.dragged = false;
    this.updated = true;
    this.released = true;

    // It's important to trigger the callback after the release animations to be able to cancel them
    this.onRelease(this);

    this.$trigger.removeEventListener('touchstart', preventDefault);
    this.$trigger.removeEventListener('touchmove', preventDefault);
    this.$trigger.removeEventListener('touchend', preventDefault);

    doc.removeEventListener('touchmove', this);
    doc.removeEventListener('touchend', this);
    doc.removeEventListener('touchcancel', this);
    doc.removeEventListener('mousemove', this);
    doc.removeEventListener('mouseup', this);
    doc.removeEventListener('selectstart', this);
  }

  reset() {
    this.stop();
    this.resizeTicker.pause();
    this.grabbed = false;
    this.dragged = false;
    this.updated = false;
    this.released = false;
    this.canScroll = false;
    this.setX(0, true);
    this.setY(0, true);
    this.coords[0] = 0;
    this.coords[1] = 0;
    this.pointer[0] = 0;
    this.pointer[1] = 0;
    this.pointer[2] = 0;
    this.pointer[3] = 0;
    this.pointer[4] = 0;
    this.pointer[5] = 0;
    this.pointer[6] = 0;
    this.pointer[7] = 0;
    this.velocity = 0;
    this.velocityStack[0] = 0;
    this.velocityStack[1] = 0;
    this.velocityStack[2] = 0;
    this.velocityStackIndex = 0;
    this.angle = 0;
    return this;
  }

  enable() {
    if (!this.enabled) {
      this.enabled = true;
      this.$target.classList.remove('is-disabled');
      this.touchActionStyles = set(this.$trigger, {
        touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'
      });
      this.$trigger.addEventListener('touchstart', this, { passive: true });
      this.$trigger.addEventListener('mousedown', this, { passive: true });
      this.$trigger.addEventListener('mouseenter', this);
    }
    return this;
  }

  disable() {
    this.enabled = false;
    this.grabbed = false;
    this.dragged = false;
    this.updated = false;
    this.released = false;
    this.canScroll = false;
    this.touchActionStyles.revert();
    if (this.cursorStyles) {
      this.cursorStyles.revert();
      this.cursorStyles = null;
    }
    if (this.triggerStyles) {
      this.triggerStyles.revert();
      this.triggerStyles = null;
    }
    if (this.bodyStyles) {
      this.bodyStyles.revert();
      this.bodyStyles = null;
    }
    if (this.targetStyles) {
      this.targetStyles.revert();
      this.targetStyles = null;
    }
    this.$target.classList.add('is-disabled');
    this.$trigger.removeEventListener('touchstart', this);
    this.$trigger.removeEventListener('mousedown', this);
    this.$trigger.removeEventListener('mouseenter', this);
    doc.removeEventListener('touchmove', this);
    doc.removeEventListener('touchend', this);
    doc.removeEventListener('touchcancel', this);
    doc.removeEventListener('mousemove', this);
    doc.removeEventListener('mouseup', this);
    doc.removeEventListener('selectstart', this);
    return this;
  }

  revert() {
    this.reset();
    this.disable();
    this.$target.classList.remove('is-disabled');
    this.updateTicker.revert();
    this.overshootTicker.revert();
    this.resizeTicker.revert();
    this.animate.revert();
    this.resizeObserver.disconnect();
    return this;
  }

  /**
   * @param {Event} e
   */
  handleEvent(e) {
    switch (e.type) {
      case 'mousedown':
        this.handleDown(/** @type {MouseEvent} */(e));
        break;
      case 'touchstart':
        this.handleDown(/** @type {TouchEvent} */(e));
        break;
      case 'mousemove':
        this.handleMove(/** @type {MouseEvent} */(e));
        break;
      case 'touchmove':
        this.handleMove(/** @type {TouchEvent} */(e));
        break;
      case 'mouseup':
        this.handleUp();
        break;
      case 'touchend':
        this.handleUp();
        break;
      case 'touchcancel':
        this.handleUp();
        break;
      case 'mouseenter':
        this.handleHover();
        break;
      case 'selectstart':
        preventDefault(e);
        break;
    }
  }
}

/**
 * @param {TargetsParam} target
 * @param {DraggableParams} [parameters]
 * @return {Draggable}
 */
const createDraggable = (target, parameters) => new Draggable(target, parameters);



/**
 * @param  {Callback<Timer>} [callback]
 * @return {Timer}
 */
const sync = (callback = noop) => {
  return new Timer({ duration: 1 * globals.timeScale, onComplete: callback }, null, 0).resume();
};

/**
 * @param  {(...args: any[]) => Tickable | ((...args: any[]) => void)} constructor
 * @return {(...args: any[]) => Tickable | ((...args: any[]) => void)}
 */
const keepTime = constructor => {
  /** @type {Tickable} */
  let tracked;
  return (...args) => {
    let currentIteration, currentIterationProgress, reversed, alternate;
    if (tracked) {
      currentIteration = tracked.currentIteration;
      currentIterationProgress = tracked.iterationProgress;
      reversed = tracked.reversed;
      alternate = tracked._alternate;
      tracked.revert();
    }
    const cleanup = constructor(...args);
    if (cleanup && !isFnc(cleanup) && cleanup.revert) tracked = cleanup;
    if (!isUnd(currentIterationProgress)) {
      /** @type {Tickable} */(tracked).currentIteration = currentIteration;
      /** @type {Tickable} */(tracked).iterationProgress = (alternate ? !(currentIteration % 2) ? reversed : !reversed : reversed) ? 1 - currentIterationProgress : currentIterationProgress;
    }
    return cleanup || noop;
  }
};



class Scope {
  /** @param {ScopeParams} [parameters] */
  constructor(parameters = {}) {
    if (scope.current) scope.current.register(this);
    const rootParam = parameters.root;
    /** @type {Document|DOMTarget} */
    let root = doc;
    if (rootParam) {
      root = /** @type {ReactRef} */(rootParam).current ||
             /** @type {AngularRef} */(rootParam).nativeElement ||
             parseTargets(/** @type {DOMTargetSelector} */(rootParam))[0] ||
             doc;
    }
    const scopeDefaults = parameters.defaults;
    const globalDefault = globals.defaults;
    const mediaQueries = parameters.mediaQueries;
    /** @type {DefaultsParams} */
    this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;
    /** @type {Document|DOMTarget} */
    this.root = root;
    /** @type {Array<ScopeConstructorCallback>} */
    this.constructors = [];
    /** @type {Array<ScopeCleanupCallback>} */
    this.revertConstructors = [];
    /** @type {Array<Revertible>} */
    this.revertibles = [];
    /** @type {Array<ScopeConstructorCallback | ((scope: this) => Tickable)>} */
    this.constructorsOnce = [];
    /** @type {Array<ScopeCleanupCallback>} */
    this.revertConstructorsOnce = [];
    /** @type {Array<Revertible>} */
    this.revertiblesOnce = [];
    /** @type {Boolean} */
    this.once = false;
    /** @type {Number} */
    this.onceIndex = 0;
    /** @type {Record<String, ScopeMethod>} */
    this.methods = {};
    /** @type {Record<String, Boolean>} */
    this.matches = {};
    /** @type {Record<String, MediaQueryList>} */
    this.mediaQueryLists = {};
    /** @type {Record<String, any>} */
    this.data = {};
    if (mediaQueries) {
      for (let mq in mediaQueries) {
        const _mq = win.matchMedia(mediaQueries[mq]);
        this.mediaQueryLists[mq] = _mq;
        _mq.addEventListener('change', this);
      }
    }
  }

  /**
   * @param {Revertible} revertible
   */
  register(revertible) {
    const store = this.once ? this.revertiblesOnce : this.revertibles;
    store.push(revertible);
  }

  /**
   * @template T
   * @param {ScopedCallback<T>} cb
   * @return {T}
   */
  execute(cb) {
    let activeScope = scope.current;
    let activeRoot = scope.root;
    let activeDefaults = globals.defaults;
    scope.current = this;
    scope.root = this.root;
    globals.defaults = this.defaults;
    const mqs = this.mediaQueryLists;
    for (let mq in mqs) this.matches[mq] = mqs[mq].matches;
    const returned = cb(this);
    scope.current = activeScope;
    scope.root = activeRoot;
    globals.defaults = activeDefaults;
    return returned;
  }

  /**
   * @return {this}
   */
  refresh() {
    this.onceIndex = 0;
    this.execute(() => {
      let i = this.revertibles.length;
      let y = this.revertConstructors.length;
      while (i--) this.revertibles[i].revert();
      while (y--) this.revertConstructors[y](this);
      this.revertibles.length = 0;
      this.revertConstructors.length = 0;
      this.constructors.forEach((/** @type {ScopeConstructorCallback} */constructor) => {
        const revertConstructor = constructor(this);
        if (isFnc(revertConstructor)) {
          this.revertConstructors.push(revertConstructor);
        }
      });
    });
    return this;
  }

  /**
   * @overload
   * @param {String} a1
   * @param {ScopeMethod} a2
   * @return {this}
   *
   * @overload
   * @param {ScopeConstructorCallback} a1
   * @return {this}
   *
   * @param {String|ScopeConstructorCallback} a1
   * @param {ScopeMethod} [a2]
   */
  add(a1, a2) {
    this.once = false;
    if (isFnc(a1)) {
      const constructor = /** @type {ScopeConstructorCallback} */(a1);
      this.constructors.push(constructor);
      this.execute(() => {
        const revertConstructor = constructor(this);
        if (isFnc(revertConstructor)) {
          this.revertConstructors.push(revertConstructor);
        }
      });
    } else {
      this.methods[/** @type {String} */(a1)] = (/** @type {any} */...args) => this.execute(() => a2(...args));
    }
    return this;
  }

  /**
   * @param {ScopeConstructorCallback} scopeConstructorCallback
   * @return {this}
   */
  addOnce(scopeConstructorCallback) {
    this.once = true;
    if (isFnc(scopeConstructorCallback)) {
      const currentIndex = this.onceIndex++;
      const tracked = this.constructorsOnce[currentIndex];
      if (tracked) return this;
      const constructor = /** @type {ScopeConstructorCallback} */(scopeConstructorCallback);
      this.constructorsOnce[currentIndex] = constructor;
      this.execute(() => {
        const revertConstructor = constructor(this);
        if (isFnc(revertConstructor)) {
          this.revertConstructorsOnce.push(revertConstructor);
        }
      });
    }
    return this;
  }

  /**
   * @param  {(scope: this) => Tickable} cb
   * @return {Tickable}
   */
  keepTime(cb) {
    this.once = true;
    const currentIndex = this.onceIndex++;
    const tracked = /** @type {(scope: this) => Tickable} */(this.constructorsOnce[currentIndex]);
    if (isFnc(tracked)) return tracked(this);
    const constructor = /** @type {(scope: this) => Tickable} */(keepTime(cb));
    this.constructorsOnce[currentIndex] = constructor;
    let trackedTickable;
    this.execute(() => {
      trackedTickable = constructor(this);
    });
    return trackedTickable;
  }

  /**
   * @param {Event} e
   */
  handleEvent(e) {
    switch (e.type) {
      case 'change':
        this.refresh();
        break;
    }
  }

  revert() {
    const revertibles = this.revertibles;
    const revertConstructors = this.revertConstructors;
    const revertiblesOnce = this.revertiblesOnce;
    const revertConstructorsOnce = this.revertConstructorsOnce;
    const mqs = this.mediaQueryLists;
    let i = revertibles.length;
    let j = revertConstructors.length;
    let k = revertiblesOnce.length;
    let l = revertConstructorsOnce.length;
    while (i--) revertibles[i].revert();
    while (j--) revertConstructors[j](this);
    while (k--) revertiblesOnce[k].revert();
    while (l--) revertConstructorsOnce[l](this);
    for (let mq in mqs) mqs[mq].removeEventListener('change', this);
    revertibles.length = 0;
    revertConstructors.length = 0;
    this.constructors.length = 0;
    revertiblesOnce.length = 0;
    revertConstructorsOnce.length = 0;
    this.constructorsOnce.length = 0;
    this.onceIndex = 0;
    this.matches = {};
    this.methods = {};
    this.mediaQueryLists = {};
    this.data = {};
  }
}

/**
 * @param {ScopeParams} [params]
 * @return {Scope}
 */
const createScope = params => new Scope(params);









/**
 * @return {Number}
 */
const getMaxViewHeight = () => {
  const $el = doc.createElement('div');
  doc.body.appendChild($el);
  $el.style.height = '100lvh';
  const height = $el.offsetHeight;
  doc.body.removeChild($el);
  return height;
};

/**
 * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T
 * @param {T | ((observer: ScrollObserver) => T)} value
 * @param {ScrollObserver} scroller
 * @return {T}
 */
const parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */(value)(scroller) : /** @type {T} */(value);

const scrollContainers = new Map();

class ScrollContainer {
  /**
   * @param {HTMLElement} $el
   */
  constructor($el) {
    /** @type {HTMLElement} */
    this.element = $el;
    /** @type {Boolean} */
    this.useWin = this.element === doc.body;
    /** @type {Number} */
    this.winWidth = 0;
    /** @type {Number} */
    this.winHeight = 0;
    /** @type {Number} */
    this.width = 0;
    /** @type {Number} */
    this.height = 0;
    /** @type {Number} */
    this.left = 0;
    /** @type {Number} */
    this.top = 0;
    /** @type {Number} */
    this.scale = 1;
    /** @type {Number} */
    this.zIndex = 0;
    /** @type {Number} */
    this.scrollX = 0;
    /** @type {Number} */
    this.scrollY = 0;
    /** @type {Number} */
    this.prevScrollX = 0;
    /** @type {Number} */
    this.prevScrollY = 0;
    /** @type {Number} */
    this.scrollWidth = 0;
    /** @type {Number} */
    this.scrollHeight = 0;
    /** @type {Number} */
    this.velocity = 0;
    /** @type {Boolean} */
    this.backwardX = false;
    /** @type {Boolean} */
    this.backwardY = false;
    /** @type {Timer} */
    this.scrollTicker = new Timer({
      autoplay: false,
      onBegin: () => this.dataTimer.resume(),
      onUpdate: () => {
        const backwards = this.backwardX || this.backwardY;
        forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);
      },
      onComplete: () => this.dataTimer.pause()
    }).init();
    /** @type {Timer} */
    this.dataTimer = new Timer({
      autoplay: false,
      frameRate: 30,
      onUpdate: (/** @type {Timer} */self) => {
        const dt = self.deltaTime;
        const px = this.prevScrollX;
        const py = this.prevScrollY;
        const nx = this.scrollX;
        const ny = this.scrollY;
        const dx = px - nx;
        const dy = py - ny;
        this.prevScrollX = nx;
        this.prevScrollY = ny;
        if (dx) this.backwardX = px > nx;
        if (dy) this.backwardY = py > ny;
        this.velocity = round$1(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);
      }
    }).init();
    /** @type {Timer} */
    this.resizeTicker = new Timer({
      autoplay: false,
      duration: 250 * globals.timeScale,
      onComplete: () => {
        this.updateWindowBounds();
        this.refreshScrollObservers();
        this.handleScroll();
      }
    }).init();
    /** @type {Timer} */
    this.wakeTicker = new Timer({
      autoplay: false,
      duration: 500 * globals.timeScale,
      onBegin: () => {
        this.scrollTicker.resume();
      },
      onComplete: () => {
        this.scrollTicker.pause();
      }
    }).init();
    /** @type {ScrollObserver} */
    this._head = null;
    /** @type {ScrollObserver} */
    this._tail = null;
    this.updateScrollCoords();
    this.updateWindowBounds();
    this.updateBounds();
    this.refreshScrollObservers();
    this.handleScroll();
    this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());
    this.resizeObserver.observe(this.element);
    (this.useWin ? win : this.element).addEventListener('scroll', this, false);
  }

  updateScrollCoords() {
    const useWin = this.useWin;
    const $el = this.element;
    this.scrollX = round$1(useWin ? win.scrollX : $el.scrollLeft, 0);
    this.scrollY = round$1(useWin ? win.scrollY : $el.scrollTop, 0);
  }

  updateWindowBounds() {
    this.winWidth = win.innerWidth;
    this.winHeight = getMaxViewHeight();
  }

  updateBounds() {
    const style = getComputedStyle(this.element);
    const $el = this.element;
    this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
    this.updateWindowBounds();
    let width, height;
    if (this.useWin) {
      width = this.winWidth;
      height = this.winHeight;
    } else {
      const elRect = $el.getBoundingClientRect();
      width = $el.clientWidth;
      height = $el.clientHeight;
      this.top = elRect.top;
      this.left = elRect.left;
      this.scale = elRect.width ? width / elRect.width : (elRect.height ? height / elRect.height : 1);
    }
    this.width = width;
    this.height = height;
  }

  refreshScrollObservers() {
    forEachChildren(this, (/** @type {ScrollObserver} */child) => {
      if (child._debug) {
        child.removeDebug();
      }
    });
    this.updateBounds();
    forEachChildren(this, (/** @type {ScrollObserver} */child) => {
      child.refresh();
      if (child._debug) {
        child.debug();
      }
    });
  }

  refresh() {
    this.updateWindowBounds();
    this.updateBounds();
    this.refreshScrollObservers();
    this.handleScroll();
  }

  handleScroll() {
    this.updateScrollCoords();
    this.wakeTicker.restart();
  }

  /**
   * @param {Event} e
   */
  handleEvent(e) {
    switch (e.type) {
      case 'scroll':
        this.handleScroll();
        break;
    }
  }

  revert() {
    this.scrollTicker.cancel();
    this.dataTimer.cancel();
    this.resizeTicker.cancel();
    this.wakeTicker.cancel();
    this.resizeObserver.disconnect();
    (this.useWin ? win : this.element).removeEventListener('scroll', this);
    scrollContainers.delete(this.element);
  }
}

/**
 * @param {TargetsParam} target
 * @return {ScrollContainer}
 */
const registerAndGetScrollContainer = target => {
  const $el = /** @type {HTMLElement} */(target ? parseTargets(target)[0] || doc.body : doc.body);
  let scrollContainer = scrollContainers.get($el);
  if (!scrollContainer) {
    scrollContainer = new ScrollContainer($el);
    scrollContainers.set($el, scrollContainer);
  }
  return scrollContainer;
};

/**
 * @param {HTMLElement} $el
 * @param {Number|string} v
 * @param {Number} size
 * @param {Number} [under]
 * @param {Number} [over]
 * @return {Number}
 */
const convertValueToPx = ($el, v, size, under, over) => {
  const clampMin = v === 'min';
  const clampMax = v === 'max';
  const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 :
                v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' :
                v === 'center' ? '50%' :
                v;
  const { n, u } = decomposeRawValue(value, decomposedOriginalValue);
  let px = n;
  if (u === '%') {
    px = (n / 100) * size;
  } else if (u) {
    px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;
  }
  if (clampMax && under < 0) px += under;
  if (clampMin && over > 0) px += over;
  return px;
};

/**
 * @param {HTMLElement} $el
 * @param {ScrollThresholdValue} v
 * @param {Number} size
 * @param {Number} [under]
 * @param {Number} [over]
 * @return {Number}
 */
const parseBoundValue = ($el, v, size, under, over) => {
  /** @type {Number} */
  let value;
  if (isStr(v)) {
    const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */(v));
    if (matchedOperator) {
      const splitter = matchedOperator[0];
      const operator = splitter[0];
      const splitted = /** @type {String} */(v).split(splitter);
      const clampMin = splitted[0] === 'min';
      const clampMax = splitted[0] === 'max';
      const valueAPx = convertValueToPx($el, splitted[0], size, under, over);
      const valueBPx = convertValueToPx($el, splitted[1], size, under, over);
      if (clampMin) {
        const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);
        value = min < valueAPx ? valueAPx : min;
      } else if (clampMax) {
        const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);
        value = max > valueAPx ? valueAPx : max;
      } else {
        value = getRelativeValue(valueAPx, valueBPx, operator);
      }
    } else {
      value = convertValueToPx($el, v, size, under, over);
    }
  } else {
    value = /** @type {Number} */(v);
  }
  return round$1(value, 0);
};

/**
 * @param {JSAnimation} linked
 * @return {HTMLElement}
 */
const getAnimationDomTarget = linked => {
  let $linkedTarget;
  const linkedTargets = linked.targets;
  for (let i = 0, l = linkedTargets.length; i < l; i++) {
    const target = linkedTargets[i];
    if (target[isDomSymbol]) {
      $linkedTarget = /** @type {HTMLElement} */(target);
      break;
    }
  }
  return $linkedTarget;
};

let scrollerIndex = 0;

const debugColors$1 = ['#FF4B4B','#FF971B','#FFC730','#F9F640','#7AFF5A','#18FF74','#17E09B','#3CFFEC','#05DBE9','#33B3F1','#638CF9','#C563FE','#FF4FCF','#F93F8A'];

class ScrollObserver {
  /**
   * @param {ScrollObserverParams} parameters
   */
  constructor(parameters = {}) {
    if (scope.current) scope.current.register(this);
    const syncMode = setValue(parameters.sync, 'play pause');
    const ease = syncMode ? parseEase(/** @type {EasingParam} */(syncMode)) : null;
    const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);
    const isEase = syncMode && !(ease === none && !isLinear);
    const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);
    const isMethods = syncMode && (isStr(syncMode) && !isEase && !isSmooth);
    const syncMethods = isMethods ? /** @type {String} */(syncMode).split(' ').map(
      (/** @type {String} */m) => () => {
        const linked = this.linked;
        return linked && linked[m] ? linked[m]() : null;
      }
    ) : null;
    const biDirSync = isMethods && syncMethods.length > 2;
    /** @type {Number} */
    this.index = scrollerIndex++;
    /** @type {String|Number} */
    this.id = !isUnd(parameters.id) ? parameters.id : this.index;
    /** @type {ScrollContainer} */
    this.container = registerAndGetScrollContainer(parameters.container);
    /** @type {HTMLElement} */
    this.target = null;
    /** @type {Tickable|WAAPIAnimation} */
    this.linked = null;
    /** @type {Boolean} */
    this.repeat = null;
    /** @type {Boolean} */
    this.horizontal = null;
    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
    this.enter = null;
    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
    this.leave = null;
    /** @type {Boolean} */
    this.sync = isEase || isSmooth || !!syncMethods;
    /** @type {EasingFunction} */
    this.syncEase = isEase ? ease : null;
    /** @type {Number} */
    this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */(syncMode) : null;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onEnter = parameters.onEnter || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onLeave = parameters.onLeave || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onEnterForward = parameters.onEnterForward || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onLeaveForward = parameters.onLeaveForward || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onEnterBackward = parameters.onEnterBackward || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onLeaveBackward = parameters.onLeaveBackward || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onUpdate = parameters.onUpdate || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncComplete = parameters.onSyncComplete || noop;
    /** @type {Boolean} */
    this.reverted = false;
    /** @type {Boolean} */
    this.ready = false;
    /** @type {Boolean} */
    this.completed = false;
    /** @type {Boolean} */
    this.began = false;
    /** @type {Boolean} */
    this.isInView = false;
    /** @type {Boolean} */
    this.forceEnter = false;
    /** @type {Boolean} */
    this.hasEntered = false;
    /** @type {Number} */
    this.offset = 0;
    /** @type {Number} */
    this.offsetStart = 0;
    /** @type {Number} */
    this.offsetEnd = 0;
    /** @type {Number} */
    this.distance = 0;
    /** @type {Number} */
    this.prevProgress = 0;
    /** @type {Array} */
    this.thresholds = ['start', 'end', 'end', 'start'];
    /** @type {[Number, Number, Number, Number]} */
    this.coords = [0, 0, 0, 0];
    /** @type {JSAnimation} */
    this.debugStyles = null;
    /** @type {HTMLElement} */
    this.$debug = null;
    /** @type {ScrollObserverParams} */
    this._params = parameters;
    /** @type {Boolean} */
    this._debug = setValue(parameters.debug, false);
    /** @type {ScrollObserver} */
    this._next = null;
    /** @type {ScrollObserver} */
    this._prev = null;
    addChild(this.container, this);
    // Wait for the next frame to add to the container in order to handle calls to link()
    sync(() => {
      if (this.reverted) return;
      if (!this.target) {
        const target = /** @type {HTMLElement} */(parseTargets(parameters.target)[0]);
        this.target = target || doc.body;
        this.refresh();
      }
      if (this._debug) this.debug();
    });
  }

  /**
   * @param {Tickable|WAAPIAnimation} linked
   */
  link(linked) {
    if (linked) {
      // Make sure to pause the linked object in case it's added later
      linked.pause();
      this.linked = linked;
      // Forces WAAPI Animation to persist; otherwise, they will stop syncing on finish.
      if (!isUnd(/** @type {WAAPIAnimation} */(linked))) /** @type {WAAPIAnimation} */(linked).persist = true;
      // Try to use a target of the linked object if no target parameters specified
      if (!this._params.target) {
        /** @type {HTMLElement} */
        let $linkedTarget;
        if (!isUnd(/** @type {JSAnimation} */(linked).targets)) {
          $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(linked));
        } else {
          forEachChildren(/** @type {Timeline} */(linked), (/** @type {JSAnimation} */child) => {
            if (child.targets && !$linkedTarget) {
              $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(child));
            }
          });
        }
        // Fallback to body if no target found
        this.target = $linkedTarget || doc.body;
        this.refresh();
      }
    }
    return this;
  }

  get velocity() {
    return this.container.velocity;
  }

  get backward() {
    return this.horizontal ? this.container.backwardX : this.container.backwardY;
  }

  get scroll() {
    return this.horizontal ? this.container.scrollX : this.container.scrollY;
  }

  get progress() {
    const p = (this.scroll - this.offsetStart) / this.distance;
    return p === Infinity || isNaN(p) ? 0 : round$1(clamp$1(p, 0, 1), 6);
  }

  refresh() {
    // This flag is used to prevent running handleScroll() outside of this.refresh() with values not yet calculated
    this.ready = true;
    this.reverted = false;
    const params = this._params;
    this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);
    this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';
    this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');
    this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');
    this.updateBounds();
    this.handleScroll();
    return this;
  }

  removeDebug() {
    if (this.$debug) {
      this.$debug.parentNode.removeChild(this.$debug);
      this.$debug = null;
    }
    if (this.debugStyles) {
      this.debugStyles.revert();
      this.$debug = null;
    }
    return this;
  }

  debug() {
    this.removeDebug();
    const container = this.container;
    const isHori = this.horizontal;
    const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');
    const $debug = doc.createElement('div');
    const $thresholds = doc.createElement('div');
    const $triggers = doc.createElement('div');
    const color = debugColors$1[this.index % debugColors$1.length];
    const useWin = container.useWin;
    const containerWidth = useWin ? container.winWidth : container.width;
    const containerHeight = useWin ? container.winHeight : container.height;
    const scrollWidth = container.scrollWidth;
    const scrollHeight = container.scrollHeight;
    const size = this.container.width > 360 ? 320 : 260;
    const offLeft = isHori ? 0 : 10;
    const offTop = isHori ? 10 : 0;
    const half = isHori ? 24 : size / 2;
    const labelHeight = isHori ? half : 15;
    const labelWidth = isHori ? 60 : half;
    const labelSize = isHori ? labelWidth : labelHeight;
    const repeat = isHori ? 'repeat-x' : 'repeat-y';
    /**
     * @param {Number} v
     * @return {String}
     */
    const gradientOffset = v => isHori ? '0px '+(v)+'px' : (v)+'px'+' 2px';
    /**
     * @param {String} c
     * @return {String}
     */
    const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;
    /**
     * @param {String} p
     * @param {Number} l
     * @param {Number} t
     * @param {Number} w
     * @param {Number} h
     * @return {String}
     */
    const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;
    $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}
      pointer-events: none;
      z-index: ${this.container.zIndex++};
      display: flex;
      flex-direction: ${isHori ? 'column' : 'row'};
      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));
    `;
    $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;
    if (!$existingDebug) {
      $thresholds.style.cssText += `background:
        ${lineCSS('#FFFF')}${gradientOffset(half-10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},
        ${lineCSS('#FFF8')}${gradientOffset(half-10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};
      `;
    }
    $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;
    if (!$existingDebug) {
      $triggers.style.cssText += `background:
        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},
        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};
      `;
    }
    const labels = [' enter: ', ' leave: '];
    this.coords.forEach((v, i) => {
      const isView = i > 1;
      const value = (isView ? 0 : this.offset) + v;
      const isTail = i % 2;
      const isFirst = value < labelSize;
      const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;
      const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;
      const $label = doc.createElement('div');
      const $text = doc.createElement('div');
      const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';
      const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;
      // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;
      $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;
      $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}
        display: flex;
        flex-direction: ${isHori ? 'column' : 'row'};
        justify-content: flex-${isView ? 'start' : 'end'};
        align-items: flex-${isFlip ? 'end' : 'start'};
        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};
      `;
      $text.style.cssText = `
        overflow: hidden;
        max-width: ${(size / 2) - 10}px;
        height: ${labelHeight};
        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;
        padding: 1px;
        font-family: ui-monospace, monospace;
        font-size: 10px;
        letter-spacing: -.025em;
        line-height: 9px;
        font-weight: 600;
        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};
        white-space: pre;
        text-overflow: ellipsis;
        color: ${isTail ? color : 'rgba(0,0,0,.75)'};
        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};
        border: 2px solid ${isTail ? color : 'transparent'};
        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;
        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;
      `;
      $label.appendChild($text);
      let position = value - flipOffset + (isHori ? 1 : 0);
      $label.style[isHori ? 'left' : 'top'] = `${position}px`;
      // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';
      (isView ? $thresholds : $triggers).appendChild($label);
    });

    $debug.appendChild($thresholds);
    $debug.appendChild($triggers);
    container.element.appendChild($debug);

    if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');
    this.$debug = $debug;
    const containerPosition = get(container.element, 'position');
    if (containerPosition === 'static') {
      this.debugStyles = set(container.element, { position: 'relative '});
    }

  }

  updateBounds() {
    if (this._debug) {
      this.removeDebug();
    }
    let stickys;
    const $target = this.target;
    const container = this.container;
    const isHori = this.horizontal;
    const linked = this.linked;
    let linkedTime;
    let $el = $target;
    // let offsetX = 0;
    // let offsetY = 0;
    // let $offsetParent = $el;
    /** @type {Element} */
    if (linked) {
      linkedTime = linked.currentTime;
      linked.seek(0, true);
    }
    /* Old implementation to get offset and targetSize before fixing https://github.com/juliangarnier/anime/issues/1021
    // const isContainerStatic = get(container.element, 'position') === 'static' ? set(container.element, { position: 'relative '}) : false;
    // while ($el && $el !== container.element && $el !== doc.body) {
    //   const isSticky = get($el, 'position') === 'sticky' ?
    //                    set($el, { position: 'static' }) :
    //                    false;
    //   if ($el === $offsetParent) {
    //     offsetX += $el.offsetLeft || 0;
    //     offsetY += $el.offsetTop || 0;
    //     $offsetParent = $el.offsetParent;
    //   }
    //   $el = /** @type {HTMLElement} */($el.parentElement);
    //   if (isSticky) {
    //     if (!stickys) stickys = [];
    //     stickys.push(isSticky);
    //   }
    // }
    // if (isContainerStatic) isContainerStatic.revert();
    // const offset = isHori ? offsetX : offsetY;
    // const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;

    while ($el && $el !== container.element && $el !== doc.body) {
      const isSticky = get($el, 'position') === 'sticky' ? set($el, { position: 'static' }) : false;
      $el = $el.parentElement;
      if (isSticky) {
        if (!stickys) stickys = [];
        stickys.push(isSticky);
      }
    }
    const rect = $target.getBoundingClientRect();
    const scale = container.scale;
    const offset = (isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top) * scale;
    const targetSize = (isHori ? rect.width : rect.height) * scale;
    const containerSize = isHori ? container.width : container.height;
    const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;
    const maxScroll = scrollSize - containerSize;
    const enter = this.enter;
    const leave = this.leave;

    /** @type {ScrollThresholdValue} */
    let enterTarget = 'start';
    /** @type {ScrollThresholdValue} */
    let leaveTarget = 'end';
    /** @type {ScrollThresholdValue} */
    let enterContainer = 'end';
    /** @type {ScrollThresholdValue} */
    let leaveContainer = 'start';

    if (isStr(enter)) {
      const splitted = /** @type {String} */(enter).split(' ');
      enterContainer = splitted[0];
      enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;
    } else if (isObj(enter)) {
      const e = /** @type {ScrollThresholdParam} */(enter);
      if (!isUnd(e.container)) enterContainer = e.container;
      if (!isUnd(e.target)) enterTarget = e.target;
    } else if (isNum(enter)) {
      enterContainer = /** @type {Number} */(enter);
    }

    if (isStr(leave)) {
      const splitted = /** @type {String} */(leave).split(' ');
      leaveContainer = splitted[0];
      leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;
    } else if (isObj(leave)) {
      const t = /** @type {ScrollThresholdParam} */(leave);
      if (!isUnd(t.container)) leaveContainer = t.container;
      if (!isUnd(t.target)) leaveTarget = t.target;
    } else if (isNum(leave)) {
      leaveContainer = /** @type {Number} */(leave);
    }

    const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);
    const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);
    const under = (parsedEnterTarget + offset) - containerSize;
    const over = (parsedLeaveTarget + offset) - maxScroll;
    const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);
    const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);
    const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;
    const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;
    const scrollDelta = offsetEnd - offsetStart;
    this.offset = offset;
    this.offsetStart = offsetStart;
    this.offsetEnd = offsetEnd;
    this.distance = scrollDelta <= 0 ? 0 : scrollDelta;
    this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];
    this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];
    if (stickys) {
      stickys.forEach(sticky => sticky.revert());
    }
    if (linked) {
      linked.seek(linkedTime, true);
    }
    if (this._debug) {
      this.debug();
    }
  }

  handleScroll() {
    if (!this.ready) return;
    const linked = this.linked;
    const sync = this.sync;
    const syncEase = this.syncEase;
    const syncSmooth = this.syncSmooth;
    const shouldSeek = linked && (syncEase || syncSmooth);
    const isHori = this.horizontal;
    const container = this.container;
    const scroll = this.scroll;
    const isBefore = scroll <= this.offsetStart;
    const isAfter = scroll >= this.offsetEnd;
    const isInView = !isBefore && !isAfter;
    const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;
    const forceEnter = !this.hasEntered && isOnTheEdge;
    const $debug = this._debug && this.$debug;
    let hasUpdated = false;
    let syncCompleted = false;
    let p = this.progress;

    if (isBefore && this.began) {
      this.began = false;
    }

    if (p > 0 && !this.began) {
      this.began = true;
    }

    if (shouldSeek) {
      const lp = linked.progress;
      if (syncSmooth && isNum(syncSmooth)) {
        if (/** @type {Number} */(syncSmooth) < 1) {
          const step = 0.0001;
          const snap = lp < p && p === 1 ? step : lp > p && !p ? -step : 0;
          p = round$1(lerp$1(lp, p, lerp$1(.01, .2, /** @type {Number} */(syncSmooth))) + snap, 6);
        }
      } else if (syncEase) {
        p = syncEase(p);
      }
      hasUpdated = p !== this.prevProgress;
      syncCompleted = lp === 1;
      if (hasUpdated && !syncCompleted && (syncSmooth && lp)) {
        container.wakeTicker.restart();
      }
    }

    if ($debug) {
      const sticky = isHori ? container.scrollY : container.scrollX;
      $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';
    }

    // Trigger enter callbacks if already in view or when entering the view
    if ((isInView && !this.isInView) || (forceEnter && !this.forceEnter && !this.hasEntered)) {
      if (isInView) this.isInView = true;
      if (!this.forceEnter || !this.hasEntered) {
        if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;
        this.onSyncEnter(this);
        this.onEnter(this);
        if (this.backward) {
          this.onSyncEnterBackward(this);
          this.onEnterBackward(this);
        } else {
          this.onSyncEnterForward(this);
          this.onEnterForward(this);
        }
        this.hasEntered = true;
        if (forceEnter) this.forceEnter = true;
      } else if (isInView) {
        this.forceEnter = false;
      }
    }

    if (isInView || !isInView && this.isInView) {
      hasUpdated = true;
    }

    if (hasUpdated) {
      if (shouldSeek) linked.seek(linked.duration * p);
      this.onUpdate(this);
    }

    if (!isInView && this.isInView) {
      this.isInView = false;
      this.onSyncLeave(this);
      this.onLeave(this);
      if (this.backward) {
        this.onSyncLeaveBackward(this);
        this.onLeaveBackward(this);
      } else {
        this.onSyncLeaveForward(this);
        this.onLeaveForward(this);
      }
      if (sync && !syncSmooth) {
        syncCompleted = true;
      }
    }

    if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {
      if (sync) {
        this.onSyncComplete(this);
      }
      this.completed = true;
      if ((!this.repeat && !linked) || (!this.repeat && linked && linked.completed)) {
        this.revert();
      }
    }

    if (p < 1 && this.completed) {
      this.completed = false;
    }

    this.prevProgress = p;
  }

  revert() {
    if (this.reverted) return;
    const container = this.container;
    removeChild(container, this);
    if (!container._head) {
      container.revert();
    }
    if (this._debug) {
      this.removeDebug();
    }
    this.reverted = true;
    this.ready = false;
    return this;
  }

}

/**
 * @param {ScrollObserverParams} [parameters={}]
 * @return {ScrollObserver}
 */
const onScroll = (parameters = {}) => new ScrollObserver(parameters);



/**
 * Cubic Bezier solver adapted from https://github.com/gre/bezier-easing
 * (c) 2014 Gatan Renaudeau
 */

/**
 * @param  {Number} aT
 * @param  {Number} aA1
 * @param  {Number} aA2
 * @return {Number}
 */
const calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + (3 * aA1)) * aT;

/**
 * @param  {Number} aX
 * @param  {Number} mX1
 * @param  {Number} mX2
 * @return {Number}
 */
const binarySubdivide = (aX, mX1, mX2) => {
  let aA = 0, aB = 1, currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (abs(currentX) > .0000001 && ++i < 100);
  return currentT;
};

/**
 * @param  {Number} [mX1] The x coordinate of the first point
 * @param  {Number} [mY1] The y coordinate of the first point
 * @param  {Number} [mX2] The x coordinate of the second point
 * @param  {Number} [mY2] The y coordinate of the second point
 * @return {EasingFunction}
 */

const cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0) => (mX1 === mY1 && mX2 === mY2) ? none :
  t => t === 0 || t === 1 ? t :
  calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);



/**
 * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function
 * Only covers 'end' and 'start' jumpterms
 * @param  {Number} steps
 * @param  {Boolean} [fromStart]
 * @return {EasingFunction}
 */
const steps = (steps = 10, fromStart) => {
  const roundMethod = fromStart ? ceil : floor;
  return t => roundMethod(clamp$1(t, 0, 1) * steps) * (1 / steps);
};



/**
 * Without parameters, the linear function creates a non-eased transition.
 * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.
 *
 * @param  {...(String|Number)} args - Points
 * @return {EasingFunction}
 */
const linear = (...args) => {
  const argsLength = args.length;
  if (!argsLength) return none;
  const totalPoints = argsLength - 1;
  const firstArg = args[0];
  const lastArg = args[totalPoints];
  const xPoints = [0];
  const yPoints = [parseNumber(firstArg)];
  for (let i = 1; i < totalPoints; i++) {
    const arg = args[i];
    const splitValue = isStr(arg) ?
    /** @type {String} */(arg).trim().split(' ') :
    [arg];
    const value = splitValue[0];
    const percent = splitValue[1];
    xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);
    yPoints.push(parseNumber(value));
  }
  yPoints.push(parseNumber(lastArg));
  xPoints.push(1);
  return function easeLinear(t) {
    for (let i = 1, l = xPoints.length; i < l; i++) {
      const currentX = xPoints[i];
      if (t <= currentX) {
        const prevX = xPoints[i - 1];
        const prevY = yPoints[i - 1];
        return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);
      }
    }
    return yPoints[yPoints.length - 1];
  }
};



/**
 * Generate random steps
 * @param  {Number} [length] - The number of steps
 * @param  {Number} [randomness] - How strong the randomness is
 * @return {EasingFunction}
 */
const irregular = (length = 10, randomness = 1) => {
  const values = [0];
  const total = length - 1;
  for (let i = 1; i < total; i++) {
    const previousValue = values[i - 1];
    const spacing = i / total;
    const segmentEnd = (i + 1) / total;
    const randomVariation = spacing + (segmentEnd - spacing) * Math.random();
    // Mix the even spacing and random variation based on the randomness parameter
    const randomValue = spacing * (1 - randomness) + randomVariation * randomness;
    values.push(clamp$1(randomValue, previousValue, 1));
  }
  values.push(1);
  return linear(...values);
};

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Spring: Spring,
  createSpring: createSpring,
  cubicBezier: cubicBezier,
  eases: eases,
  irregular: irregular,
  linear: linear,
  spring: spring,
  steps: steps
});







/**
 * Converts an easing function into a valid CSS linear() timing function string
 * @param {EasingFunction} fn
 * @param {number} [samples=100]
 * @returns {string} CSS linear() timing function
 */
const easingToLinear = (fn, samples = 100) => {
  const points = [];
  for (let i = 0; i <= samples; i++) points.push(round$1(fn(i / samples), 4));
  return `linear(${points.join(', ')})`;
};

const WAAPIEasesLookups = {};

/**
 * @param  {EasingParam} ease
 * @return {String}
 */
const parseWAAPIEasing = (ease) => {
  let parsedEase = WAAPIEasesLookups[ease];
  if (parsedEase) return parsedEase;
  parsedEase = 'linear';
  if (isStr(ease)) {
    if (
      stringStartsWith(ease, 'linear') ||
      stringStartsWith(ease, 'cubic-') ||
      stringStartsWith(ease, 'steps') ||
      stringStartsWith(ease, 'ease')
    ) {
      parsedEase = ease;
    } else if (stringStartsWith(ease, 'cubicB')) {
      parsedEase = toLowerCase(ease);
    } else {
      const parsed = parseEaseString(ease);
      if (isFnc(parsed)) parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);
    }
    // Only cache string based easing name, otherwise function arguments get lost
    WAAPIEasesLookups[ease] = parsedEase;
  } else if (isFnc(ease)) {
    const easing = easingToLinear(ease);
    if (easing) parsedEase = easing;
  } else if (/** @type {Spring} */(ease).ease) {
    parsedEase = easingToLinear(/** @type {Spring} */(ease).ease);
  }
  return parsedEase;
};

const transformsShorthands = ['x', 'y', 'z'];
const commonDefaultPXProperties = [
  'perspective',
  'width',
  'height',
  'margin',
  'padding',
  'top',
  'right',
  'bottom',
  'left',
  'borderWidth',
  'fontSize',
  'borderRadius',
  ...transformsShorthands
];

const validIndividualTransforms = /*#__PURE__*/ (() => [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))])();

let transformsPropertiesRegistered = null;

/**
 * @param  {String} propName
 * @param  {WAAPIKeyframeValue} value
 * @param  {DOMTarget} $el
 * @param  {Number} i
 * @param  {Number} targetsLength
 * @return {String}
 */
const normalizeTweenValue = (propName, value, $el, i, targetsLength) => {
  // Do not try to compute strings with getFunctionValue otherwise it will convert CSS variables
  let v = isStr(value) ? value : getFunctionValue(/** @type {any} */(value), $el, i, targetsLength);
  if (!isNum(v)) return v;
  if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate')) return `${v}px`;
  if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew')) return `${v}deg`;
  return `${v}`;
};

/**
 * @param  {DOMTarget} $el
 * @param  {String} propName
 * @param  {WAAPIKeyframeValue} from
 * @param  {WAAPIKeyframeValue} to
 * @param  {Number} i
 * @param  {Number} targetsLength
 * @return {WAAPITweenValue}
 */
const parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {
  /** @type {WAAPITweenValue} */
  let tweenValue = '0';
  const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];
  if (!isUnd(from)) {
    const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);
    tweenValue = [computedFrom, computedTo];
  } else {
    tweenValue = isArr(to) ? to.map((/** @type {any} */v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;
  }
  return tweenValue;
};

class WAAPIAnimation {
/**
 * @param {DOMTargetsParam} targets
 * @param {WAAPIAnimationParams} params
 */
  constructor(targets, params) {

    if (scope.current) scope.current.register(this);

    // Skip the registration and fallback to no animation in case CSS.registerProperty is not supported
    if (isNil(transformsPropertiesRegistered)) {
      if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'))) {
        transformsPropertiesRegistered = false;
      } else {
        validTransforms.forEach(t => {
          const isSkew = stringStartsWith(t, 'skew');
          const isScale = stringStartsWith(t, 'scale');
          const isRotate = stringStartsWith(t, 'rotate');
          const isTranslate = stringStartsWith(t, 'translate');
          const isAngle = isRotate || isSkew;
          const syntax = isAngle ? '<angle>' : isScale ? "<number>" : isTranslate ? "<length-percentage>" : "*";
          try {
            CSS.registerProperty({
              name: '--' + t,
              syntax,
              inherits: false,
              initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0',
            });
          } catch {}        });
        transformsPropertiesRegistered = true;
      }
    }

    const parsedTargets = registerTargets(targets);
    const targetsLength = parsedTargets.length;

    if (!targetsLength) {
      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
    }

    const autoplay = setValue(params.autoplay, globals.defaults.autoplay);
    const scroll = autoplay && /** @type {ScrollObserver} */(autoplay).link ? autoplay : false;
    const alternate = params.alternate && /** @type {Boolean} */(params.alternate) === true;
    const reversed = params.reversed && /** @type {Boolean} */(params.reversed) === true;
    const loop = setValue(params.loop, globals.defaults.loop);
    const iterations = /** @type {Number} */((loop === true || loop === Infinity) ? Infinity : isNum(loop) ? loop + 1 : 1);
    /** @type {PlaybackDirection} */
    const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';
    /** @type {FillMode} */
    const fill = 'both'; // We use 'both' here because the animation can be reversed during playback
    const timeScale = (globals.timeScale === 1 ? 1 : K);

    /** @type {DOMTargetsArray}] */
    this.targets = parsedTargets;
    /** @type {Array<globalThis.Animation>}] */
    this.animations = [];
    /** @type {globalThis.Animation}] */
    this.controlAnimation = null;
    /** @type {Callback<this>} */
    this.onComplete = params.onComplete || /** @type {Callback<WAAPIAnimation>} */(/** @type {unknown} */(globals.defaults.onComplete));
    /** @type {Number} */
    this.duration = 0;
    /** @type {Boolean} */
    this.muteCallbacks = false;
    /** @type {Boolean} */
    this.completed = false;
    /** @type {Boolean} */
    this.paused = !autoplay || scroll !== false;
    /** @type {Boolean} */
    this.reversed = reversed;
    /** @type {Boolean} */
    this.persist = setValue(params.persist, globals.defaults.persist);
    /** @type {Boolean|ScrollObserver} */
    this.autoplay = autoplay;
    /** @type {Number} */
    this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);
    /** @type {Function} */
    this._resolve = noop; // Used by .then()
    /** @type {Number} */
    this._completed = 0;
    /** @type {Array.<Object>} */
    this._inlineStyles = [];

    parsedTargets.forEach(($el, i) => {

      const cachedTransforms = $el[transformsSymbol];
      const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));
      const elStyle = $el.style;
      const inlineStyles = this._inlineStyles[i] = {};

      const easeToParse = setValue(params.ease, globals.defaults.ease);

      const easeFunctionResult = getFunctionValue(easeToParse, $el, i, targetsLength);
      const keyEasing = isFnc(easeFunctionResult) || isStr(easeFunctionResult) ? easeFunctionResult : easeToParse;

      const spring = /** @type {Spring} */(easeToParse).ease && easeToParse;
      /** @type {String} */
      const easing = parseWAAPIEasing(keyEasing);

      /** @type {Number} */
      const duration = (spring ? /** @type {Spring} */(spring).settlingDuration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;
      /** @type {Number} */
      const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;
      /** @type {CompositeOperation} */
      const composite = /** @type {CompositeOperation} */(setValue(params.composition, 'replace'));

      for (let name in params) {
        if (!isKey(name)) continue;
        /** @type {PropertyIndexedKeyframes} */
        const keyframes = {};
        /** @type {KeyframeAnimationOptions} */
        const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };
        const propertyValue = params[name];
        const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;

        const styleName = individualTransformProperty ? 'transform' : name;
        if (!inlineStyles[styleName]) {
          inlineStyles[styleName] = elStyle[styleName];
        }

        let parsedPropertyValue;
        if (isObj(propertyValue)) {
          const tweenOptions = /** @type {WAAPITweenOptions} */(propertyValue);
          const tweenOptionsEase = setValue(tweenOptions.ease, easing);
          const tweenOptionsSpring = /** @type {Spring} */(tweenOptionsEase).ease && tweenOptionsEase;
          const to = /** @type {WAAPITweenOptions} */(tweenOptions).to;
          const from = /** @type {WAAPITweenOptions} */(tweenOptions).from;
          /** @type {Number} */
          tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */(tweenOptionsSpring).settlingDuration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;
          /** @type {Number} */
          tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;
          /** @type {CompositeOperation} */
          tweenParams.composite = /** @type {CompositeOperation} */(setValue(tweenOptions.composition, composite));
          /** @type {String} */
          tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);
          parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
          if (individualTransformProperty) {
            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
            cachedTransforms[individualTransformProperty] = parsedPropertyValue;
          } else {
            keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
          }
          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
          if (!isUnd(from)) {
            if (!individualTransformProperty) {
              elStyle[name] = keyframes[name][0];
            } else {
              const key = `--${individualTransformProperty}`;
              elStyle.setProperty(key, keyframes[key][0]);
            }
          }
        } else {
          parsedPropertyValue = isArr(propertyValue) ?
                                propertyValue.map((/** @type {any} */v) => normalizeTweenValue(name, v, $el, i, targetsLength)) :
                                normalizeTweenValue(name, /** @type {any} */(propertyValue), $el, i, targetsLength);
          if (individualTransformProperty) {
            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
            cachedTransforms[individualTransformProperty] = parsedPropertyValue;
          } else {
            keyframes[name] = parsedPropertyValue;
          }
          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
        }
      }
      if (hasIndividualTransforms) {
        let transforms = emptyString;
        for (let t in cachedTransforms) {
          transforms += `${transformsFragmentStrings[t]}var(--${t})) `;
        }
        elStyle.transform = transforms;
      }
    });

    if (scroll) {
      /** @type {ScrollObserver} */(this.autoplay).link(this);
    }
  }

  /**
   * @callback forEachCallback
   * @param {globalThis.Animation} animation
   */

  /**
   * @param  {forEachCallback|String} callback
   * @return {this}
   */
  forEach(callback) {
    try {
      const cb = isStr(callback) ? (/** @type {globalThis.Animation} */a) => a[callback]() : callback;
      this.animations.forEach(cb);
    } catch {}    return this;
  }

  get speed() {
    return this._speed;
  }

  set speed(speed) {
    this._speed = +speed;
    this.forEach(anim => anim.playbackRate = speed);
  }

  get currentTime() {
    const controlAnimation = this.controlAnimation;
    const timeScale = globals.timeScale;
    return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;
  }

  set currentTime(time) {
    const t = time * (globals.timeScale === 1 ? 1 : K);
    this.forEach(anim => {
      // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.
      // The "paused" play state supersedes the "finished" play state; if the animation is both paused and finished, the "paused" state is the one that will be reported.
      // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event
      // This is not needed for persisting animations since they never finish.
      if (!this.persist && t >= this.duration) anim.play();
      anim.currentTime = t;
    });
  }

  get progress() {
    return this.currentTime / this.duration;
  }

  set progress(progress) {
    this.forEach(anim => anim.currentTime = progress * this.duration || 0);
  }

  resume() {
    if (!this.paused) return this;
    this.paused = false;
    // TODO: Store the current time, and seek back to the last position
    return this.forEach('play');
  }

  pause() {
    if (this.paused) return this;
    this.paused = true;
    return this.forEach('pause');
  }

  alternate() {
    this.reversed = !this.reversed;
    this.forEach('reverse');
    if (this.paused) this.forEach('pause');
    return this;
  }

  play() {
    if (this.reversed) this.alternate();
    return this.resume();
  }

  reverse() {
    if (!this.reversed) this.alternate();
    return this.resume();
  }

 /**
  * @param {Number} time
  * @param {Boolean} muteCallbacks
  */
  seek(time, muteCallbacks = false) {
    if (muteCallbacks) this.muteCallbacks = true;
    if (time < this.duration) this.completed = false;
    this.currentTime = time;
    this.muteCallbacks = false;
    if (this.paused) this.pause();
    return this;
  }

  restart() {
    this.completed = false;
    return this.seek(0, true).resume();
  }

  commitStyles() {
    return this.forEach('commitStyles');
  }

  complete() {
    return this.seek(this.duration);
  }

  cancel() {
    this.muteCallbacks = true; // This prevents triggering the onComplete callback and resolving the Promise
    this.commitStyles().forEach('cancel');
    this.animations.length = 0; // Needed to release all animations from memory
    requestAnimationFrame(() => {
      this.targets.forEach(($el) => { // Needed to avoid unecessary inline transorms
        if ($el.style.transform === 'none') $el.style.removeProperty('transform');
      });
    });
    return this;
  }

  revert() {
    // NOTE: We need a better way to revert the transforms, since right now the entire transform property value is reverted,
    // This means if you have multiple animations animating different transforms on the same target,
    // reverting one of them will also override the transform property of the other animations.
    // A better approach would be to store the original custom property values if they exist instead of the entire transform value,
    // and update the CSS variables with the orignal value
    this.cancel().targets.forEach(($el, i) => {
      const targetStyle = $el.style;
      const targetInlineStyles = this._inlineStyles[i];
      for (let name in targetInlineStyles) {
        const originalInlinedValue = targetInlineStyles[name];
        if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
          targetStyle.removeProperty(toLowerCase(name));
        } else {
          $el.style[name] = originalInlinedValue;
        }
      }
      // Remove style attribute if empty
      if ($el.getAttribute('style') === emptyString) $el.removeAttribute('style');
    });
    return this;
  }

  /**
   * @typedef {this & {then: null}} ResolvedWAAPIAnimation
   */

  /**
   * @param  {Callback<ResolvedWAAPIAnimation>} [callback]
   * @return Promise<this>
   */
  then(callback = noop) {
    const then = this.then;
    const onResolve = () => {
      this.then = null;
      callback(/** @type {ResolvedWAAPIAnimation} */(this));
      this.then = then;
      this._resolve = noop;
    };
    return new Promise(r => {
      this._resolve = () => r(onResolve());
      if (this.completed) this._resolve();
      return this;
    });
  }
}

const waapi = {
/**
 * @param {DOMTargetsParam} targets
 * @param {WAAPIAnimationParams} params
 * @return {WAAPIAnimation}
 */
  animate: (targets, params) => new WAAPIAnimation(targets, params),
  convertEase: easingToLinear
};











/**
 * @typedef {DOMTargetSelector|Array<DOMTargetSelector>} LayoutChildrenParam
 */

/**
 * @typedef {Object} LayoutAnimationTimingsParams
 * @property {Number|FunctionValue} [delay]
 * @property {Number|FunctionValue} [duration]
 * @property {EasingParam|FunctionValue} [ease]
 */

/**
 * @typedef {Record<String, Number|String|FunctionValue>} LayoutStateAnimationProperties
 */

/**
 * @typedef {LayoutStateAnimationProperties & LayoutAnimationTimingsParams} LayoutStateParams
 */

/**
 * @typedef {Object} LayoutSpecificAnimationParams
 * @property {Number|FunctionValue} [delay]
 * @property {Number|FunctionValue} [duration]
 * @property {EasingParam|FunctionValue} [ease]
 * @property {EasingParam} [playbackEase]
 * @property {LayoutStateParams} [swapAt]
 * @property {LayoutStateParams} [enterFrom]
 * @property {LayoutStateParams} [leaveTo]
 */

/**
 * @typedef {LayoutSpecificAnimationParams & TimerParams & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} LayoutAnimationParams
 */

/**
 * @typedef {Object} LayoutOptions
 * @property {LayoutChildrenParam} [children]
 * @property {Array<String>} [properties]
 */

/**
 * @typedef {LayoutAnimationParams & LayoutOptions} AutoLayoutParams
 */

/**
 * @typedef {Record<String, Number|String|FunctionValue> & {
 *   transform: String,
 *   x: Number,
 *   y: Number,
 *   left: Number,
 *   top: Number,
 *   clientLeft: Number,
 *   clientTop: Number,
 *   width: Number,
 *   height: Number,
 * }} LayoutNodeProperties
 */

/**
 * @typedef {Object} LayoutNode
 * @property {String} id
 * @property {DOMTarget} $el
 * @property {Number} index
 * @property {Number} total
 * @property {Number} delay
 * @property {Number} duration
 * @property {EasingParam} ease
 * @property {DOMTarget} $measure
 * @property {LayoutSnapshot} state
 * @property {AutoLayout} layout
 * @property {LayoutNode|null} parentNode
 * @property {Boolean} isTarget
 * @property {Boolean} isEntering
 * @property {Boolean} isLeaving
 * @property {Boolean} hasTransform
 * @property {Array<String>} inlineStyles
 * @property {String|null} inlineTransforms
 * @property {String|null} inlineTransition
 * @property {Boolean} branchAdded
 * @property {Boolean} branchRemoved
 * @property {Boolean} branchNotRendered
 * @property {Boolean} sizeChanged
 * @property {Boolean} isInlined
 * @property {Boolean} hasVisibilitySwap
 * @property {Boolean} hasDisplayNone
 * @property {Boolean} hasVisibilityHidden
 * @property {String|null} measuredInlineTransform
 * @property {String|null} measuredInlineTransition
 * @property {String|null} measuredDisplay
 * @property {String|null} measuredVisibility
 * @property {String|null} measuredPosition
 * @property {Boolean} measuredHasDisplayNone
 * @property {Boolean} measuredHasVisibilityHidden
 * @property {Boolean} measuredIsVisible
 * @property {Boolean} measuredIsRemoved
 * @property {Boolean} measuredIsInsideRoot
 * @property {LayoutNodeProperties} properties
 * @property {LayoutNode|null} _head
 * @property {LayoutNode|null} _tail
 * @property {LayoutNode|null} _prev
 * @property {LayoutNode|null} _next
 */

/**
 * @callback LayoutNodeIterator
 * @param {LayoutNode} node
 * @param {Number} index
 * @return {void}
 */

let layoutId = 0;
let nodeId = 0;

/**
 * @param {DOMTarget} root
 * @param {DOMTarget} $el
 * @return {Boolean}
 */
const isElementInRoot = (root, $el) => {
  if (!root || !$el) return false;
  return root === $el || root.contains($el);
};

/**
 * @param {Node} node
 * @param {'previousSibling'|'nextSibling'} direction
 * @return {Boolean}
 */
const hasTextSibling = (node, direction) => {
  let sibling = node[direction];
  while (sibling && sibling.nodeType === Node.TEXT_NODE && !sibling.textContent.trim()) {
    sibling = sibling[direction];
  }
  return sibling && sibling.nodeType === Node.TEXT_NODE;
};

/**
 * @param {DOMTarget} $el
 * @return {Boolean}
 */
const isElementSurroundedByText = $el => hasTextSibling($el, 'previousSibling') || hasTextSibling($el, 'nextSibling');

/**
 * @param {DOMTarget|null} $el
 * @return {String|null}
 */
const muteElementTransition = $el => {
  if (!$el) return null;
  const style = $el.style;
  const transition = style.transition || '';
  style.setProperty('transition', 'none', 'important');
  return transition;
};

/**
 * @param {DOMTarget|null} $el
 * @param {String|null} transition
 */
const restoreElementTransition = ($el, transition) => {
  if (!$el) return;
  const style = $el.style;
  if (transition) {
    style.transition = transition;
  } else {
    style.removeProperty('transition');
  }
};

/**
 * @param {LayoutNode} node
 */
const muteNodeTransition = node => {
  const store = node.layout.transitionMuteStore;
  const $el = node.$el;
  const $measure = node.$measure;
  if ($el && !store.has($el)) store.set($el, muteElementTransition($el));
  if ($measure && !store.has($measure)) store.set($measure, muteElementTransition($measure));
};

/**
 * @param {Map<DOMTarget, String|null>} store
 */
const restoreLayoutTransition = store => {
  store.forEach((value, $el) => restoreElementTransition($el, value));
  store.clear();
};

const hiddenComputedStyle = /** @type {CSSStyleDeclaration} */({
  display: 'none',
  visibility: 'hidden',
  opacity: '0',
  transform: 'none',
  position: 'static',
});

/**
 * @param {LayoutNode|null} node
 */
const detachNode = node => {
  if (!node) return;
  const parent = node.parentNode;
  if (!parent) return;
  if (parent._head === node) parent._head = node._next;
  if (parent._tail === node) parent._tail = node._prev;
  if (node._prev) node._prev._next = node._next;
  if (node._next) node._next._prev = node._prev;
  node._prev = null;
  node._next = null;
  node.parentNode = null;
};

/**
 * @param {DOMTarget} $el
 * @param {LayoutNode|null} parentNode
 * @param {LayoutSnapshot} state
 * @param {LayoutNode} recycledNode
 * @return {LayoutNode}
 */
const createNode = ($el, parentNode, state, recycledNode) => {
  let dataId = $el.dataset.layoutId;
  if (!dataId) dataId = $el.dataset.layoutId = `node-${nodeId++}`;
  const node = recycledNode ? recycledNode : /** @type {LayoutNode} */({});
  node.$el = $el;
  node.$measure = $el;
  node.id = dataId;
  node.index = 0;
  node.total = 1;
  node.delay = 0;
  node.duration = 0;
  node.ease = null;
  node.state = state;
  node.layout = state.layout;
  node.parentNode = parentNode || null;
  node.isTarget = false;
  node.isEntering = false;
  node.isLeaving = false;
  node.isInlined = false;
  node.hasTransform = false;
  node.inlineStyles = [];
  node.inlineTransforms = null;
  node.inlineTransition = null;
  node.branchAdded = false;
  node.branchRemoved = false;
  node.branchNotRendered = false;
  node.sizeChanged = false;
  node.hasVisibilitySwap = false;
  node.hasDisplayNone = false;
  node.hasVisibilityHidden = false;
  node.measuredInlineTransform = null;
  node.measuredInlineTransition = null;
  node.measuredDisplay = null;
  node.measuredVisibility = null;
  node.measuredPosition = null;
  node.measuredHasDisplayNone = false;
  node.measuredHasVisibilityHidden = false;
  node.measuredIsVisible = false;
  node.measuredIsRemoved = false;
  node.measuredIsInsideRoot = false;
  node.properties = /** @type {LayoutNodeProperties} */({
    transform: 'none',
    x: 0,
    y: 0,
    left: 0,
    top: 0,
    clientLeft: 0,
    clientTop: 0,
    width: 0,
    height: 0,
  });
  node.layout.properties.forEach(prop => node.properties[prop] = 0);
  node._head = null;
  node._tail = null;
  node._prev = null;
  node._next = null;
  return node;
};

/**
 * @param {LayoutNode} node
 * @param {DOMTarget} $measure
 * @param {CSSStyleDeclaration} computedStyle
 * @param {Boolean} skipMeasurements
 * @return {LayoutNode}
 */
const recordNodeState = (node, $measure, computedStyle, skipMeasurements) => {
  const $el = node.$el;
  const root = node.layout.root;
  const isRoot = root === $el;
  const properties = node.properties;
  const rootNode = node.state.rootNode;
  const parentNode = node.parentNode;
  const computedTransforms = computedStyle.transform;
  const inlineTransforms = $el.style.transform;
  const parentNotRendered = parentNode ? parentNode.measuredIsRemoved : false;
  const position = computedStyle.position;
  if (isRoot) node.layout.absoluteCoords = position === 'fixed' || position === 'absolute';
  node.$measure = $measure;
  node.inlineTransforms = inlineTransforms;
  node.hasTransform = computedTransforms && computedTransforms !== 'none';
  node.measuredIsInsideRoot = isElementInRoot(root, $measure);
  node.measuredInlineTransform = null;
  node.measuredDisplay = computedStyle.display;
  node.measuredVisibility = computedStyle.visibility;
  node.measuredPosition = position;
  node.measuredHasDisplayNone = computedStyle.display === 'none';
  node.measuredHasVisibilityHidden = computedStyle.visibility === 'hidden';
  node.measuredIsVisible = !(node.measuredHasDisplayNone || node.measuredHasVisibilityHidden);
  node.measuredIsRemoved = node.measuredHasDisplayNone || node.measuredHasVisibilityHidden || parentNotRendered;
  node.isInlined = node.measuredDisplay.includes('inline') && isElementSurroundedByText($el);

  // Mute transforms (and transition to avoid triggering an animation) before the position calculation
  if (node.hasTransform && !skipMeasurements) {
    const transitionMuteStore = node.layout.transitionMuteStore;
    if (!transitionMuteStore.get($el)) node.inlineTransition = muteElementTransition($el);
    if ($measure === $el) {
      $el.style.transform = 'none';
    } else {
      if (!transitionMuteStore.get($measure)) node.measuredInlineTransition = muteElementTransition($measure);
      node.measuredInlineTransform = $measure.style.transform;
      $measure.style.transform = 'none';
    }
  }

  let left = 0;
  let top = 0;
  let width = 0;
  let height = 0;

  if (!skipMeasurements) {
    const rect = $measure.getBoundingClientRect();
    left = rect.left;
    top = rect.top;
    width = rect.width;
    height = rect.height;
  }

  for (let name in properties) {
    const computedProp = name === 'transform' ? computedTransforms : computedStyle[name] || (computedStyle.getPropertyValue && computedStyle.getPropertyValue(name));
    if (!isUnd(computedProp)) properties[name] = computedProp;
  }

  properties.left = left;
  properties.top = top;
  properties.clientLeft = skipMeasurements ? 0 : $measure.clientLeft;
  properties.clientTop = skipMeasurements ? 0 : $measure.clientTop;
  // Compute local x/y relative to parent
  let absoluteLeft, absoluteTop;
  if (isRoot) {
    if (!node.layout.absoluteCoords) {
      absoluteLeft = 0;
      absoluteTop = 0;
    } else {
      absoluteLeft = left;
      absoluteTop = top;
    }
  } else {
    const p = parentNode || rootNode;
    const parentLeft = p.properties.left;
    const parentTop = p.properties.top;
    const borderLeft = p.properties.clientLeft;
    const borderTop = p.properties.clientTop;
    if (!node.layout.absoluteCoords) {
      if (p === rootNode) {
        const rootLeft = rootNode.properties.left;
        const rootTop = rootNode.properties.top;
        const rootBorderLeft = rootNode.properties.clientLeft;
        const rootBorderTop = rootNode.properties.clientTop;
        absoluteLeft = left - rootLeft - rootBorderLeft;
        absoluteTop = top - rootTop - rootBorderTop;
      } else {
        absoluteLeft = left - parentLeft - borderLeft;
        absoluteTop = top - parentTop - borderTop;
      }
    } else {
      absoluteLeft = left - parentLeft - borderLeft;
      absoluteTop = top - parentTop - borderTop;
    }
  }
  properties.x = absoluteLeft;
  properties.y = absoluteTop;
  properties.width = width;
  properties.height = height;
  return node;
};

/**
 * @param {LayoutNode} node
 * @param {LayoutStateAnimationProperties} [props]
 */
const updateNodeProperties = (node, props) => {
  if (!props) return;
  for (let name in props) {
    node.properties[name] = props[name];
  }
};

/**
 * @param  {LayoutNode} node
 * @param  {LayoutAnimationTimingsParams} params
 */
const updateNodeTimingParams = (node, params) => {
  const easeFunctionResult = getFunctionValue(params.ease, node.$el, node.index, node.total);
  const keyEasing = isFnc(easeFunctionResult) ? easeFunctionResult : params.ease;
  const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);
  node.ease = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing;
  node.duration = hasSpring ? /** @type {Spring} */(keyEasing).settlingDuration : getFunctionValue(params.duration, node.$el, node.index, node.total);
  node.delay = getFunctionValue(params.delay, node.$el, node.index, node.total);
};

/**
 * @param {LayoutNode} node
 */
const recordNodeInlineStyles = node => {
  const style = node.$el.style;
  const stylesStore = node.inlineStyles;
  stylesStore.length = 0;
  node.layout.recordedProperties.forEach(prop => {
    stylesStore.push(prop, style[prop] || '');
  });
};

/**
 * @param {LayoutNode} node
 */
const restoreNodeInlineStyles = node => {
  const style = node.$el.style;
  const stylesStore = node.inlineStyles;
  for (let i = 0, l = stylesStore.length; i < l; i += 2) {
    const property = stylesStore[i];
    const styleValue = stylesStore[i + 1];
    if (styleValue && styleValue !== '') {
      style[property] = styleValue;
    } else {
      style[property] = '';
      style.removeProperty(property);
    }
  }
};

/**
 * @param {LayoutNode} node
 */
const restoreNodeTransform = node => {
  const inlineTransforms = node.inlineTransforms;
  const nodeStyle = node.$el.style;
  if (!node.hasTransform || !inlineTransforms || (node.hasTransform && nodeStyle.transform === 'none') || (inlineTransforms && inlineTransforms === 'none')) {
    nodeStyle.removeProperty('transform');
  } else if (inlineTransforms) {
    nodeStyle.transform = inlineTransforms;
  }
  const $measure = node.$measure;
  if (node.hasTransform && $measure !== node.$el) {
    const measuredStyle = $measure.style;
    const measuredInline = node.measuredInlineTransform;
    if (measuredInline && measuredInline !== '') {
      measuredStyle.transform = measuredInline;
    } else {
      measuredStyle.removeProperty('transform');
    }
  }
  node.measuredInlineTransform = null;
  if (node.inlineTransition !== null) {
    restoreElementTransition(node.$el, node.inlineTransition);
    node.inlineTransition = null;
  }
  if ($measure !== node.$el && node.measuredInlineTransition !== null) {
    restoreElementTransition($measure, node.measuredInlineTransition);
    node.measuredInlineTransition = null;
  }
};

/**
 * @param {LayoutNode} node
 */
const restoreNodeVisualState = node => {
  if (node.measuredIsRemoved || node.hasVisibilitySwap) {
    node.$el.style.removeProperty('display');
    node.$el.style.removeProperty('visibility');
    if (node.hasVisibilitySwap) {
      node.$measure.style.removeProperty('display');
      node.$measure.style.removeProperty('visibility');
    }
  }
  // if (node.measuredIsRemoved) {
  node.layout.pendingRemoval.delete(node.$el);
  // }
};

/**
 * @param {LayoutNode} node
 * @param {LayoutNode} targetNode
 * @param {LayoutSnapshot} newState
 * @return {LayoutNode}
 */
const cloneNodeProperties = (node, targetNode, newState) => {
  targetNode.properties = /** @type {LayoutNodeProperties} */({ ...node.properties });
  targetNode.state = newState;
  targetNode.isTarget = node.isTarget;
  targetNode.hasTransform = node.hasTransform;
  targetNode.inlineTransforms = node.inlineTransforms;
  targetNode.measuredIsVisible = node.measuredIsVisible;
  targetNode.measuredDisplay = node.measuredDisplay;
  targetNode.measuredIsRemoved = node.measuredIsRemoved;
  targetNode.measuredHasDisplayNone = node.measuredHasDisplayNone;
  targetNode.measuredHasVisibilityHidden = node.measuredHasVisibilityHidden;
  targetNode.hasDisplayNone = node.hasDisplayNone;
  targetNode.isInlined = node.isInlined;
  targetNode.hasVisibilityHidden = node.hasVisibilityHidden;
  return targetNode;
};

class LayoutSnapshot {
  /**
   * @param {AutoLayout} layout
   */
  constructor(layout) {
    /** @type {AutoLayout} */
    this.layout = layout;
    /** @type {LayoutNode|null} */
    this.rootNode = null;
    /** @type {Set<LayoutNode>} */
    this.rootNodes = new Set();
    /** @type {Map<String, LayoutNode>} */
    this.nodes = new Map();
    /** @type {Number} */
    this.scrollX = 0;
    /** @type {Number} */
    this.scrollY = 0;
  }

  /**
   * @return {this}
   */
  revert() {
    this.forEachNode(node => {
      this.layout.pendingRemoval.delete(node.$el);
      node.$el.removeAttribute('data-layout-id');
      node.$measure.removeAttribute('data-layout-id');
    });
    this.rootNode = null;
    this.rootNodes.clear();
    this.nodes.clear();
    return this;
  }

  /**
   * @param {DOMTarget} $el
   * @return {LayoutNode}
   */
  getNode($el) {
    if (!$el || !$el.dataset) return;
    return this.nodes.get($el.dataset.layoutId);
  }

  /**
   * @param {DOMTarget} $el
   * @param {String} prop
   * @return {Number|String}
   */
  getComputedValue($el, prop) {
    const node = this.getNode($el);
    if (!node) return;
    return /** @type {Number|String} */(node.properties[prop]);
  }

  /**
   * @param {LayoutNode|null} rootNode
   * @param {LayoutNodeIterator} cb
   */
  forEach(rootNode, cb) {
    let node = rootNode;
    let i = 0;
    while (node) {
      cb(node, i++);
      if (node._head) {
        node = node._head;
      } else if (node._next) {
        node = node._next;
      } else {
        while (node && !node._next) {
          node = node.parentNode;
        }
        if (node) node = node._next;
      }
    }
  }

  /**
   * @param {LayoutNodeIterator} cb
   */
  forEachRootNode(cb) {
    this.forEach(this.rootNode, cb);
  }

  /**
   * @param {LayoutNodeIterator} cb
   */
  forEachNode(cb) {
    for (const rootNode of this.rootNodes) {
      this.forEach(rootNode, cb);
    }
  }

  /**
   * @param {DOMTarget} $el
   * @param {LayoutNode|null} parentNode
   * @return {LayoutNode|null}
   */
  registerElement($el, parentNode) {
    if (!$el || $el.nodeType !== 1) return null;

    if (!this.layout.transitionMuteStore.has($el)) this.layout.transitionMuteStore.set($el, muteElementTransition($el));

    /** @type {Array<DOMTarget|LayoutNode|null>} */
    const stack = [$el, parentNode];
    const root = this.layout.root;
    let firstNode = null;

    while (stack.length) {
      /** @type {LayoutNode|null} */
      const $parent = /** @type {LayoutNode|null} */(stack.pop());
      /** @type {DOMTarget|null} */
      const $current = /** @type {DOMTarget|null} */(stack.pop());

      if (!$current || $current.nodeType !== 1 || isSvg($current)) continue;

      const skipMeasurements = $parent ? $parent.measuredIsRemoved : false;
      const computedStyle = skipMeasurements ? hiddenComputedStyle : getComputedStyle($current);
      const hasDisplayNone = skipMeasurements ? true : computedStyle.display === 'none';
      const hasVisibilityHidden = skipMeasurements ? true : computedStyle.visibility === 'hidden';
      const isVisible = !hasDisplayNone && !hasVisibilityHidden;
      const existingId = $current.dataset.layoutId;
      const isInsideRoot = isElementInRoot(root, $current);

      let node = existingId ? this.nodes.get(existingId) : null;

      if (node && node.$el !== $current) {
        const nodeInsideRoot = isElementInRoot(root, node.$el);
        const measuredVisible = node.measuredIsVisible;
        const shouldReassignNode = !nodeInsideRoot && (isInsideRoot || (!isInsideRoot && !measuredVisible && isVisible));
        const shouldReuseMeasurements = nodeInsideRoot && !measuredVisible && isVisible;
        // Rebind nodes that move into the root or whose detached twin just became visible
        if (shouldReassignNode) {
          detachNode(node);
          node = createNode($current, $parent, this, node);
        // for hidden element with in-root sibling, keep the hidden node but borrow measurements from its visible in-root twin element
        } else if (shouldReuseMeasurements) {
          recordNodeState(node, $current, computedStyle, skipMeasurements);
          let $child = $current.lastElementChild;
          while ($child) {
            stack.push(/** @type {DOMTarget} */($child), node);
            $child = $child.previousElementSibling;
          }
          if (!firstNode) firstNode = node;
          continue;
        // No reassignment needed so keep walking descendants under the current parent
        } else {
          let $child = $current.lastElementChild;
          while ($child) {
            stack.push(/** @type {DOMTarget} */($child), $parent);
            $child = $child.previousElementSibling;
          }
          if (!firstNode) firstNode = node;
          continue;
        }
      } else {
        node = createNode($current, $parent, this, node);
      }

      node.branchAdded = false;
      node.branchRemoved = false;
      node.branchNotRendered = false;
      node.isTarget = false;
      node.sizeChanged = false;
      node.hasVisibilityHidden = hasVisibilityHidden;
      node.hasDisplayNone = hasDisplayNone;
      node.hasVisibilitySwap = (hasVisibilityHidden && !node.measuredHasVisibilityHidden) || (hasDisplayNone && !node.measuredHasDisplayNone);

      this.nodes.set(node.id, node);

      node.parentNode = $parent || null;
      node._prev = null;
      node._next = null;

      if ($parent) {
        this.rootNodes.delete(node);
        if (!$parent._head) {
          $parent._head = node;
          $parent._tail = node;
        } else {
          $parent._tail._next = node;
          node._prev = $parent._tail;
          $parent._tail = node;
        }
      } else {
        // Each disconnected subtree becomes its own root in the snapshot graph
        this.rootNodes.add(node);
      }

      recordNodeState(node, node.$el, computedStyle, skipMeasurements);

      let $child = $current.lastElementChild;
      while ($child) {
        stack.push(/** @type {DOMTarget} */($child), node);
        $child = $child.previousElementSibling;
      }

      if (!firstNode) firstNode = node;
    }

    return firstNode;
  }

  /**
   * @param {DOMTarget} $el
   * @param {Set<DOMTarget>} candidates
   * @return {LayoutNode|null}
   */
  ensureDetachedNode($el, candidates) {
    if (!$el || $el === this.layout.root) return null;
    const existingId = $el.dataset.layoutId;
    const existingNode = existingId ? this.nodes.get(existingId) : null;
    if (existingNode && existingNode.$el === $el) return existingNode;
    let parentNode = null;
    let $ancestor = $el.parentElement;
    while ($ancestor && $ancestor !== this.layout.root) {
      if (candidates.has($ancestor)) {
        parentNode = this.ensureDetachedNode($ancestor, candidates);
        break;
      }
      $ancestor = $ancestor.parentElement;
    }
    return this.registerElement($el, parentNode);
  }

  /**
   * @return {this}
   */
  record() {
    const layout = this.layout;
    const children = layout.children;
    const root = layout.root;
    const toParse = isArr(children) ? children : [children];
    const scoped = [];
    const scopeRoot = children === '*' ? root : scope.root;

    // Mute transition and transforms of root ancestors before recording the state

    /** @type {Array<DOMTarget|String|null>} */
    const rootAncestorTransformStore = [];
    let $ancestor = root.parentElement;
    while ($ancestor && $ancestor.nodeType === 1) {
      const computedStyle = getComputedStyle($ancestor);
      if (computedStyle.transform && computedStyle.transform !== 'none') {
        const inlineTransform = $ancestor.style.transform || '';
        const inlineTransition = muteElementTransition($ancestor);
        rootAncestorTransformStore.push($ancestor, inlineTransform, inlineTransition);
        $ancestor.style.transform = 'none';
      }
      $ancestor = $ancestor.parentElement;
    }

    for (let i = 0, l = toParse.length; i < l; i++) {
      const child = toParse[i];
      scoped[i] = isStr(child) ? scopeRoot.querySelectorAll(child) : child;
    }

    const parsedChildren = registerTargets(scoped);

    this.nodes.clear();
    this.rootNodes.clear();

    const rootNode = this.registerElement(root, null);
    // Root node are always targets
    rootNode.isTarget = true;
    this.rootNode = rootNode;

    const inRootNodeIds = new Set();
    // Update index and total for inital timing calculation
    let index = 0, total = this.nodes.size;
    this.nodes.forEach((node, id) => {
      node.index = index++;
      node.total = total;
      // Track ids of nodes that belong to the current root to filter detached matches
      if (node && node.measuredIsInsideRoot) {
        inRootNodeIds.add(id);
      }
    });

    // Elements with a layout id outside the root that match the children selector
    const detachedElementsLookup = new Set();
    const orderedDetachedElements = [];

    for (let i = 0, l = parsedChildren.length; i < l; i++) {
      const $el = parsedChildren[i];
      if (!$el || $el.nodeType !== 1 || $el === root) continue;
      const insideRoot = isElementInRoot(root, $el);
      if (!insideRoot) {
        const layoutNodeId = $el.dataset.layoutId;
        if (!layoutNodeId || !inRootNodeIds.has(layoutNodeId)) continue;
      }
      if (!detachedElementsLookup.has($el)) {
        detachedElementsLookup.add($el);
        orderedDetachedElements.push($el);
      }
    }

    for (let i = 0, l = orderedDetachedElements.length; i < l; i++) {
      this.ensureDetachedNode(orderedDetachedElements[i], detachedElementsLookup);
    }

    for (let i = 0, l = parsedChildren.length; i < l; i++) {
      const $el = parsedChildren[i];
      const node = this.getNode($el);
      if (node) {
        let cur = node;
        while (cur) {
          if (cur.isTarget) break;
          cur.isTarget = true;
          cur = cur.parentNode;
        }
      }
    }

    this.scrollX = window.scrollX;
    this.scrollY = window.scrollY;

    this.forEachNode(restoreNodeTransform);

    // Restore transition and transforms of root ancestors

    for (let i = 0, l = rootAncestorTransformStore.length; i < l; i += 3) {
      const $el = /** @type {DOMTarget} */(rootAncestorTransformStore[i]);
      const inlineTransform = /** @type {String} */(rootAncestorTransformStore[i + 1]);
      const inlineTransition = /** @type {String|null} */(rootAncestorTransformStore[i + 2]);
      if (inlineTransform && inlineTransform !== '') {
        $el.style.transform = inlineTransform;
      } else {
        $el.style.removeProperty('transform');
      }
      restoreElementTransition($el, inlineTransition);
    }

    return this;
  }
}

/**
 * @param  {LayoutStateParams} params
 * @return {[LayoutStateAnimationProperties, LayoutAnimationTimingsParams]}
 */
function splitPropertiesFromParams(params) {
  /** @type {LayoutStateAnimationProperties} */
  const properties = {};
  /** @type {LayoutAnimationTimingsParams} */
  const parameters = {};
  for (let name in params) {
    const value = params[name];
    const isEase = name === 'ease';
    const isTiming = name === 'duration' || name === 'delay';
    if (isTiming || isEase) {
      if (isEase) {
        parameters[name] = /** @type {EasingParam} */(value);
      } else {
        parameters[name] = /** @type {Number|FunctionValue} */(value);
      }
    } else {
      properties[name] = /** @type {Number|String} */(value);
    }
  }
  return [properties, parameters];
}

class AutoLayout {
  /**
   * @param {DOMTargetSelector} root
   * @param {AutoLayoutParams} [params]
   */
  constructor(root, params = {}) {
    if (scope.current) scope.current.register(this);
    const swapAtSplitParams = splitPropertiesFromParams(params.swapAt);
    const enterFromSplitParams = splitPropertiesFromParams(params.enterFrom);
    const leaveToSplitParams = splitPropertiesFromParams(params.leaveTo);
    const transitionProperties = params.properties;
    /** @type {Number|FunctionValue} */
    params.duration = setValue(params.duration, 350);
    /** @type {Number|FunctionValue} */
    params.delay = setValue(params.delay, 0);
    /** @type {EasingParam|FunctionValue} */
    params.ease = setValue(params.ease, 'inOut(3.5)');
    /** @type {AutoLayoutParams} */
    this.params = params;
    /** @type {DOMTarget} */
    this.root = /** @type {DOMTarget} */(registerTargets(root)[0]);
    /** @type {Number} */
    this.id = layoutId++;
    /** @type {LayoutChildrenParam} */
    this.children = params.children || '*';
    /** @type {Boolean} */
    this.absoluteCoords = false;
    /** @type {LayoutStateParams} */
    this.swapAtParams = mergeObjects(params.swapAt || { opacity: 0 }, { ease: 'inOut(1.75)' });
    /** @type {LayoutStateParams} */
    this.enterFromParams = params.enterFrom || { opacity: 0 };
    /** @type {LayoutStateParams} */
    this.leaveToParams = params.leaveTo || { opacity: 0 };
    /** @type {Set<String>} */
    this.properties = new Set([
      'opacity',
      'fontSize',
      'color',
      'backgroundColor',
      'borderRadius',
      'border',
      'filter',
      'clipPath',
    ]);
    if (swapAtSplitParams[0]) for (let name in swapAtSplitParams[0]) this.properties.add(name);
    if (enterFromSplitParams[0]) for (let name in enterFromSplitParams[0]) this.properties.add(name);
    if (leaveToSplitParams[0]) for (let name in leaveToSplitParams[0]) this.properties.add(name);
    if (transitionProperties) for (let i = 0, l = transitionProperties.length; i < l; i++) this.properties.add(transitionProperties[i]);
    /** @type {Set<String>} */
    this.recordedProperties = new Set([
      'display',
      'visibility',
      'translate',
      'position',
      'left',
      'top',
      'marginLeft',
      'marginTop',
      'width',
      'height',
      'maxWidth',
      'maxHeight',
      'minWidth',
      'minHeight',
    ]);
    this.properties.forEach(prop => this.recordedProperties.add(prop));
    /** @type {WeakSet<DOMTarget>} */
    this.pendingRemoval = new WeakSet();
    /** @type {Map<DOMTarget, String|null>} */
    this.transitionMuteStore = new Map();
    /** @type {LayoutSnapshot} */
    this.oldState = new LayoutSnapshot(this);
    /** @type {LayoutSnapshot} */
    this.newState = new LayoutSnapshot(this);
    /** @type {Timeline} */
    this.timeline = null;
    /** @type {WAAPIAnimation} */
    this.transformAnimation = null;
    /** @type {Array<DOMTarget>} */
    this.animating = [];
    /** @type {Array<DOMTarget>} */
    this.swapping = [];
    /** @type {Array<DOMTarget>} */
    this.leaving = [];
    /** @type {Array<DOMTarget>} */
    this.entering = [];
    // Record the current state as the old state to init the data attributes and allow imediate .animate()
    this.oldState.record();
    // And all layout transition muted during the record
    restoreLayoutTransition(this.transitionMuteStore);
  }

  /**
   * @return {this}
   */
  revert() {
    this.root.classList.remove('is-animated');
    if (this.timeline) {
      this.timeline.complete();
      this.timeline = null;
    }
    if (this.transformAnimation) {
      this.transformAnimation.complete();
      this.transformAnimation = null;
    }
    this.animating.length = this.swapping.length = this.leaving.length = this.entering.length = 0;
    this.oldState.revert();
    this.newState.revert();
    requestAnimationFrame(() => restoreLayoutTransition(this.transitionMuteStore));
    return this;
  }

  /**
   * @return {this}
   */
  record() {
    // Commit transforms before measuring
    if (this.transformAnimation) {
      this.transformAnimation.cancel();
      this.transformAnimation = null;
    }
    // Record the old state
    this.oldState.record();
    // Cancel any running timeline
    if (this.timeline) {
      this.timeline.cancel();
      this.timeline = null;
    }
    // Restore previously captured inline styles
    this.newState.forEachRootNode(restoreNodeInlineStyles);
    return this;
  }

  /**
   * @param {LayoutAnimationParams} [params]
   * @return {Timeline}
   */
  animate(params = {}) {
    /** @type { LayoutAnimationTimingsParams } */
    const animationTimings = {
      ease: setValue(params.ease, this.params.ease),
      delay: setValue(params.delay, this.params.delay),
      duration: setValue(params.duration, this.params.duration),
    };
    /** @type {TimelineParams} */
    const tlParams = {};
    const onComplete = setValue(params.onComplete, this.params.onComplete);
    const onPause = setValue(params.onPause, this.params.onPause);
    for (let name in defaults) {
      if (name !== 'ease' && name !== 'duration' && name !== 'delay') {
        if (!isUnd(params[name])) {
          tlParams[name] = params[name];
        } else if (!isUnd(this.params[name])) {
          tlParams[name] = this.params[name];
        }
      }
    }
    tlParams.onComplete = () => {
      // Make sure to call .cancel() after restoreNodeInlineStyles(node); otehrwise the commited styles get reverted
      if (this.transformAnimation) this.transformAnimation.cancel();
      newState.forEachRootNode(node => {
        restoreNodeVisualState(node);
        restoreNodeInlineStyles(node);
      });
      for (let i = 0, l = transformed.length; i < l; i++) {
        const $el = transformed[i];
        $el.style.transform = newState.getComputedValue($el, 'transform');
      }
      if (this.root.classList.contains('is-animated')) {
        this.root.classList.remove('is-animated');
        if (onComplete) onComplete(this.timeline);
      }
      // Avoid CSS transitions at the end of the animation by restoring them on the next frame
      requestAnimationFrame(() => {
        if (this.root.classList.contains('is-animated')) return;
        restoreLayoutTransition(this.transitionMuteStore);
      });
    };
    tlParams.onPause = () => {
      if (!this.root.classList.contains('is-animated')) return;
      if (this.transformAnimation) this.transformAnimation.cancel();
      newState.forEachRootNode(restoreNodeVisualState);
      this.root.classList.remove('is-animated');
      if (onComplete) onComplete(this.timeline);
      if (onPause) onPause(this.timeline);
    };
    tlParams.composition = false;

    const swapAtParams = mergeObjects(mergeObjects(params.swapAt || {}, this.swapAtParams), animationTimings);
    const enterFromParams = mergeObjects(mergeObjects(params.enterFrom || {}, this.enterFromParams), animationTimings);
    const leaveToParams = mergeObjects(mergeObjects(params.leaveTo || {}, this.leaveToParams), animationTimings);
    const [ swapAtProps, swapAtTimings ] = splitPropertiesFromParams(swapAtParams);
    const [ enterFromProps, enterFromTimings ] = splitPropertiesFromParams(enterFromParams);
    const [ leaveToProps, leaveToTimings ] = splitPropertiesFromParams(leaveToParams);

    const oldState = this.oldState;
    const newState = this.newState;
    const animating = this.animating;
    const swapping = this.swapping;
    const entering = this.entering;
    const leaving = this.leaving;
    const pendingRemoval = this.pendingRemoval;

    animating.length = swapping.length = entering.length = leaving.length = 0;

    // Mute old state CSS transitions to prevent wrong properties calculation
    oldState.forEachRootNode(muteNodeTransition);
    // Capture the new state before animation
    newState.record();
    newState.forEachRootNode(recordNodeInlineStyles);

    const targets = [];
    const animated = [];
    const transformed = [];
    const animatedSwap = [];
    const rootNode = newState.rootNode;
    const $root = rootNode.$el;

    newState.forEachRootNode(node => {

      const $el = node.$el;
      const id = node.id;
      const parent = node.parentNode;
      const parentAdded = parent ? parent.branchAdded : false;
      const parentRemoved = parent ? parent.branchRemoved : false;
      const parentNotRendered = parent ? parent.branchNotRendered : false;

      let oldStateNode = oldState.nodes.get(id);

      const hasNoOldState = !oldStateNode;

      if (hasNoOldState) {
        oldStateNode = cloneNodeProperties(node, /** @type {LayoutNode} */({}), oldState);
        oldState.nodes.set(id, oldStateNode);
        oldStateNode.measuredIsRemoved = true;
      } else if (oldStateNode.measuredIsRemoved && !node.measuredIsRemoved) {
        cloneNodeProperties(node, oldStateNode, oldState);
        oldStateNode.measuredIsRemoved = true;
      }

      const oldParentNode = oldStateNode.parentNode;
      const oldParentId = oldParentNode ? oldParentNode.id : null;
      const newParentId = parent ? parent.id : null;
      const parentChanged = oldParentId !== newParentId;
      const elementChanged = oldStateNode.$el !== node.$el;
      const wasRemovedBefore = oldStateNode.measuredIsRemoved;
      const isRemovedNow = node.measuredIsRemoved;

      // Recalculate postion relative to their parent for elements that have been moved
      if (!oldStateNode.measuredIsRemoved && !isRemovedNow && !hasNoOldState && (parentChanged || elementChanged)) {
        const oldAbsoluteLeft = oldStateNode.properties.left;
        const oldAbsoluteTop = oldStateNode.properties.top;
        const newParent = parent || newState.rootNode;
        const oldParent = newParent.id ? oldState.nodes.get(newParent.id) : null;
        const parentLeft = oldParent ? oldParent.properties.left : newParent.properties.left;
        const parentTop = oldParent ? oldParent.properties.top : newParent.properties.top;
        const borderLeft = oldParent ? oldParent.properties.clientLeft : newParent.properties.clientLeft;
        const borderTop = oldParent ? oldParent.properties.clientTop : newParent.properties.clientTop;
        oldStateNode.properties.x = oldAbsoluteLeft - parentLeft - borderLeft;
        oldStateNode.properties.y = oldAbsoluteTop - parentTop - borderTop;
      }

      if (node.hasVisibilitySwap) {
        if (node.hasVisibilityHidden) {
          node.$el.style.visibility = 'visible';
          node.$measure.style.visibility = 'hidden';
        }
        if (node.hasDisplayNone) {
          node.$el.style.display = oldStateNode.measuredDisplay || node.measuredDisplay || '';
          // Setting visibility 'hidden' instead of display none to avoid calculation issues
          node.$measure.style.visibility = 'hidden';
          // @TODO: check why setting display here can cause calculation issues
          // node.$measure.style.display = 'none';
        }
      }

      const wasPendingRemoval = pendingRemoval.has($el);
      const wasVisibleBefore = oldStateNode.measuredIsVisible;
      const isVisibleNow = node.measuredIsVisible;
      const becomeVisible = !wasVisibleBefore && isVisibleNow && !parentNotRendered;
      const topLevelAdded = !isRemovedNow && (wasRemovedBefore || wasPendingRemoval) && !parentAdded;
      const newlyRemoved = isRemovedNow && !wasRemovedBefore && !parentRemoved;
      const topLevelRemoved = newlyRemoved || isRemovedNow && wasPendingRemoval && !parentRemoved;

      node.branchAdded = parentAdded || topLevelAdded;
      node.branchRemoved = parentRemoved || topLevelRemoved;
      node.branchNotRendered = parentNotRendered || isRemovedNow;

      if (isRemovedNow && wasVisibleBefore) {
        node.$el.style.display = oldStateNode.measuredDisplay;
        node.$el.style.visibility = 'visible';
        cloneNodeProperties(oldStateNode, node, newState);
      }

      // Node is leaving
      if (newlyRemoved) {
        if (node.isTarget) {
          leaving.push($el);
          node.isLeaving = true;
        }
        pendingRemoval.add($el);
      } else if (!isRemovedNow && wasPendingRemoval) {
        pendingRemoval.delete($el);
      }

      // Node is entering
      if ((topLevelAdded && !parentNotRendered) || becomeVisible) {
        updateNodeProperties(oldStateNode, enterFromProps);
        if (node.isTarget) {
          entering.push($el);
          node.isEntering = true;
        }
      // Node is leaving
      } else if (topLevelRemoved && !parentNotRendered) {
        updateNodeProperties(node, leaveToProps);
      }

      // Node is animating
      // The animating array is used only to calculate delays and duration on root children
      if (node !== rootNode && node.isTarget && !node.isEntering && !node.isLeaving) {
        animating.push($el);
      }

      targets.push($el);

    });

    let enteringIndex = 0;
    let leavingIndex = 0;
    let animatingIndex = 0;

    newState.forEachRootNode(node => {

      const $el = node.$el;
      const parent = node.parentNode;
      const oldStateNode = oldState.nodes.get(node.id);
      const nodeProperties = node.properties;
      const oldStateNodeProperties = oldStateNode.properties;

      // Use closest animated parent index and total values so that children staggered delays are in sync with their parent
      let animatedParent = parent !== rootNode && parent;
      while (animatedParent && !animatedParent.isTarget && animatedParent !== rootNode) {
        animatedParent = animatedParent.parentNode;
      }

      const animatingTotal = animating.length;

      // Root is always animated first in sync with the first child (animating.length is the total of children)
      if (node === rootNode) {
        node.index = 0;
        node.total = animatingTotal;
        updateNodeTimingParams(node, animationTimings);
      } else if (node.isEntering) {
        node.index = animatedParent ? animatedParent.index : enteringIndex;
        node.total = animatedParent ? animatingTotal : entering.length;
        updateNodeTimingParams(node, enterFromTimings);
        enteringIndex++;
      } else if (node.isLeaving) {
        node.index = animatedParent ? animatedParent.index : leavingIndex;
        node.total = animatedParent ? animatingTotal : leaving.length;
        leavingIndex++;
        updateNodeTimingParams(node, leaveToTimings);
      } else if (node.isTarget) {
        node.index = animatingIndex++;
        node.total = animatingTotal;
        updateNodeTimingParams(node, animationTimings);
      } else {
        node.index = animatedParent ? animatedParent.index : 0;
        node.total = animatingTotal;
        updateNodeTimingParams(node, swapAtTimings);
      }

      // Make sure the old state node has its inex and total values up to date for valid "from" function values calculation
      oldStateNode.index = node.index;
      oldStateNode.total = node.total;

      // Computes all values up front so we can check for changes and we don't have to re-compute them inside the animation props
      for (let prop in nodeProperties) {
        nodeProperties[prop] = getFunctionValue(nodeProperties[prop], $el, node.index, node.total);
        oldStateNodeProperties[prop] = getFunctionValue(oldStateNodeProperties[prop], $el, oldStateNode.index, oldStateNode.total);
      }

      // Use a 1px tolerance to detect dimensions changes to prevent width / height animations on barelly visible elements
      const sizeTolerance = 1;
      const widthChanged = Math.abs(nodeProperties.width - oldStateNodeProperties.width) > sizeTolerance;
      const heightChanged = Math.abs(nodeProperties.height - oldStateNodeProperties.height) > sizeTolerance;

      node.sizeChanged = (widthChanged || heightChanged);

      // const hiddenStateChanged = (topLevelAdded || newlyRemoved) && wasRemovedBefore !== isRemovedNow;

      if (node.isTarget && (!node.measuredIsRemoved && oldStateNode.measuredIsVisible || node.measuredIsRemoved && node.measuredIsVisible)) {
        if (!node.isInlined && (nodeProperties.transform !== 'none' || oldStateNodeProperties.transform !== 'none')) {
          node.hasTransform = true;
          transformed.push($el);
        }
        for (let prop in nodeProperties) {
          // if (prop !== 'transform' && (nodeProperties[prop] !== oldStateNodeProperties[prop] || hiddenStateChanged)) {
          if (prop !== 'transform' && (nodeProperties[prop] !== oldStateNodeProperties[prop])) {
            animated.push($el);
            break;
          }
        }
      }

      if (!node.isTarget) {
        swapping.push($el);
        if (node.sizeChanged && parent && parent.isTarget && parent.sizeChanged) {
          if (!node.isInlined && swapAtProps.transform) {
            node.hasTransform = true;
            transformed.push($el);
          }
          animatedSwap.push($el);
        }
      }

    });

    const timingParams = {
      delay: (/** @type {HTMLElement} */$el) => newState.getNode($el).delay,
      duration: (/** @type {HTMLElement} */$el) => newState.getNode($el).duration,
      ease: (/** @type {HTMLElement} */$el) => newState.getNode($el).ease,
    };

    tlParams.defaults = timingParams;

    this.timeline = createTimeline(tlParams);

    // Imediatly return the timeline if no layout changes detected
    if (!animated.length && !transformed.length && !swapping.length) {
      // Make sure to restore all CSS transition if no animation
      restoreLayoutTransition(this.transitionMuteStore);
      return this.timeline.complete();
    }

    if (targets.length) {

      this.root.classList.add('is-animated');

      for (let i = 0, l = targets.length; i < l; i++) {
        const $el = targets[i];
        const id = $el.dataset.layoutId;
        const oldNode = oldState.nodes.get(id);
        const newNode = newState.nodes.get(id);
        const oldNodeState = oldNode.properties;

        // muteNodeTransition(newNode);

        // Don't animate dimensions and positions of inlined elements
        if (!newNode.isInlined) {
          // Display grid can mess with the absolute positioning, so set it to block during transition
          if (oldNode.measuredDisplay === 'grid' || newNode.measuredDisplay === 'grid') $el.style.setProperty('display', 'block', 'important');
          // All children must be in position absolute or fixed
          if ($el !== $root || this.absoluteCoords) {
            $el.style.position = this.absoluteCoords ? 'fixed' : 'absolute';
            $el.style.left = '0px';
            $el.style.top = '0px';
            $el.style.marginLeft = '0px';
            $el.style.marginTop = '0px';
            $el.style.translate = `${oldNodeState.x}px ${oldNodeState.y}px`;
          }
          if ($el === $root && newNode.measuredPosition === 'static') {
            $el.style.position = 'relative';
            // Cancel left / trop in case the static element had muted values now activated by potision relative
            $el.style.left = '0px';
            $el.style.top = '0px';
          }
          $el.style.width = `${oldNodeState.width}px`;
          $el.style.height = `${oldNodeState.height}px`;
          // Overrides user defined min and max to prevents width and height clamping
          $el.style.minWidth = `auto`;
          $el.style.minHeight = `auto`;
          $el.style.maxWidth = `none`;
          $el.style.maxHeight = `none`;
        }
      }

      // Restore the scroll position if the oldState differs from the current state
      if (oldState.scrollX !== window.scrollX || oldState.scrollY !== window.scrollY) {
        // Restoring in the next frame avoids race conditions if for example a waapi animation commit styles that affect the root height
        requestAnimationFrame(() => window.scrollTo(oldState.scrollX, oldState.scrollY));
      }

      for (let i = 0, l = animated.length; i < l; i++) {
        const $el = animated[i];
        const id = $el.dataset.layoutId;
        const oldNode = oldState.nodes.get(id);
        const newNode = newState.nodes.get(id);
        const oldNodeState = oldNode.properties;
        const newNodeState = newNode.properties;
        let nodeHasChanged = false;
        /** @type {AnimationParams} */
        const animatedProps = {
          composition: 'none',
        };
        if (!newNode.isInlined) {
          if (oldNodeState.width !== newNodeState.width) {
            animatedProps.width = [oldNodeState.width, newNodeState.width];
            nodeHasChanged = true;
          }
          if (oldNodeState.height !== newNodeState.height) {
            animatedProps.height = [oldNodeState.height, newNodeState.height];
            nodeHasChanged = true;
          }
          // If the node has transforms we handle the translate animation in wappi otherwise translate and other transforms can be out of sync
          // Always animate translate
          if (!newNode.hasTransform) {
            animatedProps.translate = [`${oldNodeState.x}px ${oldNodeState.y}px`, `${newNodeState.x}px ${newNodeState.y}px`];
            nodeHasChanged = true;
          }
        }
        this.properties.forEach(prop => {
          const oldVal = oldNodeState[prop];
          const newVal = newNodeState[prop];
          if (prop !== 'transform' && oldVal !== newVal) {
            animatedProps[prop] = [oldVal, newVal];
            nodeHasChanged = true;
          }
        });
        if (nodeHasChanged) {
          this.timeline.add($el, animatedProps, 0);
        }
      }

    }

    if (swapping.length) {

      for (let i = 0, l = swapping.length; i < l; i++) {
        const $el = swapping[i];
        const oldNode = oldState.getNode($el);
        if (!oldNode.isInlined) {
          const oldNodeProps = oldNode.properties;
          $el.style.width = `${oldNodeProps.width}px`;
          $el.style.height = `${oldNodeProps.height}px`;
          // Overrides user defined min and max to prevents width and height clamping
          $el.style.minWidth = `auto`;
          $el.style.minHeight = `auto`;
          $el.style.maxWidth = `none`;
          $el.style.maxHeight = `none`;
          $el.style.translate = `${oldNodeProps.x}px ${oldNodeProps.y}px`;
        }
        this.properties.forEach(prop => {
          if (prop !== 'transform') {
            $el.style[prop] = `${oldState.getComputedValue($el, prop)}`;
          }
        });
      }

      for (let i = 0, l = swapping.length; i < l; i++) {
        const $el = swapping[i];
        const newNode = newState.getNode($el);
        const newNodeProps = newNode.properties;
        this.timeline.call(() => {
          if (!newNode.isInlined) {
            $el.style.width = `${newNodeProps.width}px`;
            $el.style.height = `${newNodeProps.height}px`;
            // Overrides user defined min and max to prevents width and height clamping
            $el.style.minWidth = `auto`;
            $el.style.minHeight = `auto`;
            $el.style.maxWidth = `none`;
            $el.style.maxHeight = `none`;
            $el.style.translate = `${newNodeProps.x}px ${newNodeProps.y}px`;
          }
          this.properties.forEach(prop => {
            if (prop !== 'transform') {
              $el.style[prop] = `${newState.getComputedValue($el, prop)}`;
            }
          });
        }, newNode.delay + newNode.duration / 2);
      }

      if (animatedSwap.length) {
        const ease = parseEase(newState.nodes.get(animatedSwap[0].dataset.layoutId).ease);
        const inverseEased = t => 1 - ease(1 - t);
        const animatedSwapParams = /** @type {AnimationParams} */({});
        if (swapAtProps) {
          for (let prop in swapAtProps) {
            if (prop !== 'transform') {
              animatedSwapParams[prop] = [
                { from: (/** @type {HTMLElement} */$el) => oldState.getComputedValue($el, prop), to: swapAtProps[prop] },
                { from: swapAtProps[prop], to: (/** @type {HTMLElement} */$el) => newState.getComputedValue($el, prop), ease: inverseEased }
              ];
            }
          }
        }
        this.timeline.add(animatedSwap, animatedSwapParams, 0);
      }

    }

    const transformedLength = transformed.length;

    if (transformedLength) {
      // We only need to set the transform property here since translate is alread defined in the targets loop
      for (let i = 0; i < transformedLength; i++) {
        const $el = transformed[i];
        $el.style.translate = `${oldState.getComputedValue($el, 'x')}px ${oldState.getComputedValue($el, 'y')}px`,
        $el.style.transform = oldState.getComputedValue($el, 'transform');
        if (animatedSwap.includes($el)) {
          const node = newState.getNode($el);
          node.ease = getFunctionValue(swapAtParams.ease, $el, node.index, node.total);
          node.duration = getFunctionValue(swapAtParams.duration, $el, node.index, node.total);
        }
      }
      this.transformAnimation = waapi.animate(transformed, {
        translate: (/** @type {HTMLElement} */$el) => `${newState.getComputedValue($el, 'x')}px ${newState.getComputedValue($el, 'y')}px`,
        transform: (/** @type {HTMLElement} */$el) => {
          const newValue = newState.getComputedValue($el, 'transform');
          if (!animatedSwap.includes($el)) return newValue;
          const oldValue = oldState.getComputedValue($el, 'transform');
          const node = newState.getNode($el);
          return [oldValue, getFunctionValue(swapAtProps.transform, $el, node.index, node.total), newValue]
        },
        autoplay: false,
        persist: true,
        ...timingParams,
      });
      this.timeline.sync(this.transformAnimation, 0);
    }

    return this.timeline.init();
  }

  /**
   * @param {(layout: this) => void} callback
   * @param {LayoutAnimationParams} [params]
   * @return {Timeline}
   */
  update(callback, params = {}) {
    this.record();
    callback(this);
    return this.animate(params);
  }
}

/**
 * @param {DOMTargetSelector} root
 * @param {AutoLayoutParams} [params]
 * @return {AutoLayout}
 */
const createLayout = (root, params) => new AutoLayout(root, params);

// Chain-able utilities

const numberUtils = numberImports; // Needed to keep the import when bundling

const chainables = {};

/**
 * @callback UtilityFunction
 * @param {...*} args
 * @return {Number|String}
 *
 * @param {UtilityFunction} fn
 * @param {Number} [last=0]
 * @return {function(...(Number|String)): function(Number|String): (Number|String)}
 */
const curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);

/**
 * @param {Function} fn
 * @return {function(...(Number|String))}
 */
const chain = fn => {
   return (...args) => {
    const result = fn(...args);
    return new Proxy(noop, {
      apply: (_, __, [v]) => result(v),
      get: (_, prop) => chain(/**@param {...Number|String} nextArgs */(...nextArgs) => {
        const nextResult = chainables[prop](...nextArgs);
        return (/**@type {Number|String} */v) => nextResult(result(v));
      })
    });
  }
};

/**
 * @param {UtilityFunction} fn
 * @param {String} name
 * @param {Number} [right]
 * @return {function(...(Number|String)): UtilityFunction}
 */
const makeChainable = (name, fn, right = 0) => {
  const chained = (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);
  if (!chainables[name]) chainables[name] = chained;
  return chained;
};

/**
 * @typedef {Object} ChainablesMap
 * @property {ChainedClamp} clamp
 * @property {ChainedRound} round
 * @property {ChainedSnap} snap
 * @property {ChainedWrap} wrap
 * @property {ChainedLerp} lerp
 * @property {ChainedDamp} damp
 * @property {ChainedMapRange} mapRange
 * @property {ChainedRoundPad} roundPad
 * @property {ChainedPadStart} padStart
 * @property {ChainedPadEnd} padEnd
 * @property {ChainedDegToRad} degToRad
 * @property {ChainedRadToDeg} radToDeg
 */

/**
 * @callback ChainedUtilsResult
 * @param {Number} value - The value to process through the chained operations
 * @return {Number} The processed result
 */

/**
 * @typedef {ChainablesMap & ChainedUtilsResult} ChainableUtil
 */

// Chainable

/**
 * @callback ChainedRoundPad
 * @param {Number} decimalLength - Number of decimal places
 * @return {ChainableUtil}
 */
const roundPad = /** @type {typeof numberUtils.roundPad & ChainedRoundPad} */(makeChainable('roundPad', numberUtils.roundPad));

/**
 * @callback ChainedPadStart
 * @param {Number} totalLength - Target length
 * @param {String} padString - String to pad with
 * @return {ChainableUtil}
 */
const padStart = /** @type {typeof numberUtils.padStart & ChainedPadStart} */(makeChainable('padStart', numberUtils.padStart));

/**
 * @callback ChainedPadEnd
 * @param {Number} totalLength - Target length
 * @param {String} padString - String to pad with
 * @return {ChainableUtil}
 */
const padEnd = /** @type {typeof numberUtils.padEnd & ChainedPadEnd} */(makeChainable('padEnd', numberUtils.padEnd));

/**
 * @callback ChainedWrap
 * @param {Number} min - Minimum boundary
 * @param {Number} max - Maximum boundary
 * @return {ChainableUtil}
 */
const wrap = /** @type {typeof numberUtils.wrap & ChainedWrap} */(makeChainable('wrap', numberUtils.wrap));

/**
 * @callback ChainedMapRange
 * @param {Number} inLow - Input range minimum
 * @param {Number} inHigh - Input range maximum
 * @param {Number} outLow - Output range minimum
 * @param {Number} outHigh - Output range maximum
 * @return {ChainableUtil}
 */
const mapRange = /** @type {typeof numberUtils.mapRange & ChainedMapRange} */(makeChainable('mapRange', numberUtils.mapRange));

/**
 * @callback ChainedDegToRad
 * @return {ChainableUtil}
 */
const degToRad = /** @type {typeof numberUtils.degToRad & ChainedDegToRad} */(makeChainable('degToRad', numberUtils.degToRad));

/**
 * @callback ChainedRadToDeg
 * @return {ChainableUtil}
 */
const radToDeg = /** @type {typeof numberUtils.radToDeg & ChainedRadToDeg} */(makeChainable('radToDeg', numberUtils.radToDeg));

/**
 * @callback ChainedSnap
 * @param {Number|Array<Number>} increment - Step size or array of snap points
 * @return {ChainableUtil}
 */
const snap = /** @type {typeof numberUtils.snap & ChainedSnap} */(makeChainable('snap', numberUtils.snap));

/**
 * @callback ChainedClamp
 * @param {Number} min - Minimum boundary
 * @param {Number} max - Maximum boundary
 * @return {ChainableUtil}
 */
const clamp = /** @type {typeof numberUtils.clamp & ChainedClamp} */(makeChainable('clamp', numberUtils.clamp));

/**
 * @callback ChainedRound
 * @param {Number} decimalLength - Number of decimal places
 * @return {ChainableUtil}
 */
const round = /** @type {typeof numberUtils.round & ChainedRound} */(makeChainable('round', numberUtils.round));

/**
 * @callback ChainedLerp
 * @param {Number} start - Starting value
 * @param {Number} end - Ending value
 * @return {ChainableUtil}
 */
const lerp = /** @type {typeof numberUtils.lerp & ChainedLerp} */(makeChainable('lerp', numberUtils.lerp, 1));

/**
 * @callback ChainedDamp
 * @param {Number} start - Starting value
 * @param {Number} end - Target value
 * @param {Number} deltaTime - Delta time in ms
 * @return {ChainableUtil}
 */
const damp = /** @type {typeof numberUtils.damp & ChainedDamp} */(makeChainable('damp', numberUtils.damp, 1));

/**
 * Generate a random number between optional min and max (inclusive) and decimal precision
 *
 * @callback RandomNumberGenerator
 * @param    {Number} [min=0] - The minimum value (inclusive)
 * @param    {Number} [max=1] - The maximum value (inclusive)
 * @param    {Number} [decimalLength=0] - Number of decimal places to round to
 * @return   {Number} A random number between min and max
 */

/**
 * Generates a random number between min and max (inclusive) with optional decimal precision
 *
 * @type {RandomNumberGenerator}
 */
const random = (min = 0, max = 1, decimalLength = 0) => {
  const m = 10 ** decimalLength;
  return Math.floor((Math.random() * (max - min + (1 / m)) + min) * m) / m;
};

let _seed = 0;

/**
 * Creates a seeded pseudorandom number generator function
 *
 * @param  {Number} [seed] - The seed value for the random number generator
 * @param  {Number} [seededMin=0] - The minimum default value (inclusive) of the returned function
 * @param  {Number} [seededMax=1] - The maximum default value (inclusive) of the returned function
 * @param  {Number} [seededDecimalLength=0] - Default number of decimal places to round to of the returned function
 * @return {RandomNumberGenerator} A function to generate a random number between optional min and max (inclusive) and decimal precision
 */
const createSeededRandom = (seed, seededMin = 0, seededMax = 1, seededDecimalLength = 0) => {
  let t = seed === undefined ? _seed++ : seed;
  return (min = seededMin, max = seededMax, decimalLength = seededDecimalLength) => {
    t += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    const m = 10 ** decimalLength;
    return Math.floor(((((t ^ t >>> 14) >>> 0) / 4294967296) * (max - min + (1 / m)) + min) * m) / m;
  }
};

/**
 * Picks a random element from an array or a string
 *
 * @template T
 * @param    {String|Array<T>} items - The array or string to pick from
 * @return   {String|T} A random element from the array or character from the string
 */
const randomPick = items => items[random(0, items.length - 1)];

/**
 * Shuffles an array in-place using the Fisher-Yates algorithm
 * Adapted from https://bost.ocks.org/mike/shuffle/
 *
 * @param  {Array} items - The array to shuffle (will be modified in-place)
 * @return {Array} The same array reference, now shuffled
 */
const shuffle = items => {
  let m = items.length, t, i;
  while (m) { i = random(0, --m); t = items[m]; items[m] = items[i]; items[i] = t; }
  return items;
};





/**
 * @overload
 * @param {Number} val
 * @param {StaggerParams} [params]
 * @return {StaggerFunction<Number>}
 */
/**
 * @overload
 * @param {String} val
 * @param {StaggerParams} [params]
 * @return {StaggerFunction<String>}
 */
/**
 * @overload
 * @param {[Number, Number]} val
 * @param {StaggerParams} [params]
 * @return {StaggerFunction<Number>}
 */
/**
 * @overload
 * @param {[String, String]} val
 * @param {StaggerParams} [params]
 * @return {StaggerFunction<String>}
 */
/**
 * @param {Number|String|[Number, Number]|[String, String]} val The staggered value or range
 * @param {StaggerParams} [params] The stagger parameters
 * @return {StaggerFunction<Number|String>}
 */
const stagger = (val, params = {}) => {
  let values = [];
  let maxValue = 0;
  const from = params.from;
  const reversed = params.reversed;
  const ease = params.ease;
  const hasEasing = !isUnd(ease);
  const hasSpring = hasEasing && !isUnd(/** @type {Spring} */(ease).ease);
  const staggerEase = hasSpring ? /** @type {Spring} */(ease).ease : hasEasing ? parseEase(ease) : null;
  const grid = params.grid;
  const axis = params.axis;
  const customTotal = params.total;
  const fromFirst = isUnd(from) || from === 0 || from === 'first';
  const fromCenter = from === 'center';
  const fromLast = from === 'last';
  const fromRandom = from === 'random';
  const isRange = isArr(val);
  const useProp = params.use;
  const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);
  const val2 = isRange ? parseNumber(val[1]) : 0;
  const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);
  const start = params.start || 0 + (isRange ? val1 : 0);
  let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;
  return (target, i, t, tl) => {
    const [ registeredTarget ] = registerTargets(target);
    const total = isUnd(customTotal) ? t : customTotal;
    const customIndex = !isUnd(useProp) ? isFnc(useProp) ? useProp(registeredTarget, i, total) : getOriginalAnimatableValue(registeredTarget, useProp) : false;
    const staggerIndex = isNum(customIndex) || isStr(customIndex) && isNum(+customIndex) ? +customIndex : i;
    if (fromCenter) fromIndex = (total - 1) / 2;
    if (fromLast) fromIndex = total - 1;
    if (!values.length) {
      for (let index = 0; index < total; index++) {
        if (!grid) {
          values.push(abs(fromIndex - index));
        } else {
          const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
          const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
          const toX = index % grid[0];
          const toY = floor(index / grid[0]);
          const distanceX = fromX - toX;
          const distanceY = fromY - toY;
          let value = sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') value = -distanceX;
          if (axis === 'y') value = -distanceY;
          values.push(value);
        }
        maxValue = max(...values);
      }
      if (staggerEase) values = values.map(val => staggerEase(val / maxValue) * maxValue);
      if (reversed) values = values.map(val => axis ? (val < 0) ? val * -1 : -val : abs(maxValue - val));
      if (fromRandom) values = shuffle(values);
    }
    const spacing = isRange ? (val2 - val1) / maxValue : val1;
    const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */(start);
    /** @type {String|Number} */
    let output = offset + ((spacing * round$1(values[staggerIndex], 2)) || 0);
    if (params.modifier) output = params.modifier(output);
    if (unitMatch) output = `${output}${unitMatch[2]}`;
    return output;
  }
};

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  $: registerTargets,
  clamp: clamp,
  cleanInlineStyles: cleanInlineStyles,
  createSeededRandom: createSeededRandom,
  damp: damp,
  degToRad: degToRad,
  get: get,
  keepTime: keepTime,
  lerp: lerp,
  mapRange: mapRange,
  padEnd: padEnd,
  padStart: padStart,
  radToDeg: radToDeg,
  random: random,
  randomPick: randomPick,
  remove: remove,
  round: round,
  roundPad: roundPad,
  set: set,
  shuffle: shuffle,
  snap: snap,
  stagger: stagger,
  sync: sync,
  wrap: wrap
});



/**
 * @param  {TargetsParam} path
 * @return {SVGGeometryElement|void}
 */
const getPath = path => {
  const parsedTargets = parseTargets(path);
  const $parsedSvg = /** @type {SVGGeometryElement} */(parsedTargets[0]);
  if (!$parsedSvg || !isSvg($parsedSvg)) return console.warn(`${path} is not a valid SVGGeometryElement`);
  return $parsedSvg;
};



// Motion path animation

/**
 * @param {SVGGeometryElement} $path
 * @param {Number} totalLength
 * @param {Number} progress
 * @param {Number} lookup
 * @param {Boolean} shouldClamp
 * @return {DOMPoint}
 */
const getPathPoint = ($path, totalLength, progress, lookup, shouldClamp) => {
  const point = progress + lookup;
  const pointOnPath = shouldClamp
    ? Math.max(0, Math.min(point, totalLength)) // Clamp between 0 and totalLength
    : (point % totalLength + totalLength) % totalLength; // Wrap around
  return $path.getPointAtLength(pointOnPath);
};

/**
 * @param {SVGGeometryElement} $path
 * @param {String} pathProperty
 * @param {Number} [offset=0]
 * @return {FunctionValue}
 */
const getPathProgess = ($path, pathProperty, offset = 0) => {
  return $el => {
    const totalLength = +($path.getTotalLength());
    const inSvg = $el[isSvgSymbol];
    const ctm = $path.getCTM();
    const shouldClamp = offset === 0;
    /** @type {TweenObjectValue} */
    return {
      from: 0,
      to: totalLength,
      /** @type {TweenModifier} */
      modifier: progress => {
        const offsetLength = offset * totalLength;
        const newProgress = progress + offsetLength;
        if (pathProperty === 'a') {
          const p0 = getPathPoint($path, totalLength, newProgress, -1, shouldClamp);
          const p1 = getPathPoint($path, totalLength, newProgress, 1, shouldClamp);
          return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;
        } else {
          const p = getPathPoint($path, totalLength, newProgress, 0, shouldClamp);
          return pathProperty === 'x' ?
            inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e :
            inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f
        }
      }
    }
  }
};

/**
 * @param {TargetsParam} path
 * @param {Number} [offset=0]
 */
const createMotionPath = (path, offset = 0) => {
  const $path = getPath(path);
  if (!$path) return;
  return {
    translateX: getPathProgess($path, 'x', offset),
    translateY: getPathProgess($path, 'y', offset),
    rotate: getPathProgess($path, 'a', offset),
  }
};



/**
 * @param {SVGGeometryElement} [$el]
 * @return {Number}
 */
const getScaleFactor = $el => {
  let scaleFactor = 1;
  if ($el && $el.getCTM) {
    const ctm = $el.getCTM();
    if (ctm) {
      const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);
      const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);
      scaleFactor = (scaleX + scaleY) / 2;
    }
  }
  return scaleFactor;
};

/**
 * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.
 * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable
 * @param {number} start - Starting position (0-1)
 * @param {number} end - Ending position (0-1)
 * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality
 */
const createDrawableProxy = ($el, start, end) => {
  const pathLength = K;
  const computedStyles = getComputedStyle($el);
  const strokeLineCap = computedStyles.strokeLinecap;
  // @ts-ignore
  const $scalled = computedStyles.vectorEffect === 'non-scaling-stroke' ? $el : null;
  let currentCap = strokeLineCap;

  const proxy = new Proxy($el, {
    get(target, property) {
      const value = target[property];
      if (property === proxyTargetSymbol) return target;
      if (property === 'setAttribute') {
        return (...args) => {
          if (args[0] === 'draw') {
            const value = args[1];
            const values = value.split(' ');
            const v1 = +values[0];
            const v2 = +values[1];
            // TOTO: Benchmark if performing two slices is more performant than one split
            // const spaceIndex = value.indexOf(' ');
            // const v1 = round(+value.slice(0, spaceIndex), precision);
            // const v2 = round(+value.slice(spaceIndex + 1), precision);
            const scaleFactor = getScaleFactor($scalled);
            const os = v1 * -pathLength * scaleFactor;
            const d1 = (v2 * pathLength * scaleFactor) + os;
            const d2 = (pathLength * scaleFactor +
                      ((v1 === 0 && v2 === 1) || (v1 === 1 && v2 === 0) ? 0 : 10 * scaleFactor) - d1);
            if (strokeLineCap !== 'butt') {
              const newCap = v1 === v2 ? 'butt' : strokeLineCap;
              if (currentCap !== newCap) {
                target.style.strokeLinecap = `${newCap}`;
                currentCap = newCap;
              }
            }
            target.setAttribute('stroke-dashoffset', `${os}`);
            target.setAttribute('stroke-dasharray', `${d1} ${d2}`);
          }
          return Reflect.apply(value, target, args);
        };
      }

      if (isFnc(value)) {
        return (...args) => Reflect.apply(value, target, args);
      } else {
        return value;
      }
    }
  });

  if ($el.getAttribute('pathLength') !== `${pathLength}`) {
    $el.setAttribute('pathLength', `${pathLength}`);
    proxy.setAttribute('draw', `${start} ${end}`);
  }

  return /** @type {DrawableSVGGeometry} */(proxy);
};

/**
 * Creates drawable proxies for multiple SVG elements.
 * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors
 * @param {number} [start=0] - Starting position (0-1)
 * @param {number} [end=0] - Ending position (0-1)
 * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality
 */
const createDrawable = (selector, start = 0, end = 0) => {
  const els = parseTargets(selector);
  return els.map($el => createDrawableProxy(
    /** @type {SVGGeometryElement} */($el),
    start,
    end
  ));
};



/**
 * @param  {TargetsParam} path2
 * @param  {Number} [precision]
 * @return {FunctionValue}
 */
const morphTo = (path2, precision = .33) => ($path1) => {
  const tagName1 = ($path1.tagName || '').toLowerCase();
  if (!tagName1.match(/^(path|polygon|polyline)$/)) {
    throw new Error(`Can't morph a <${$path1.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);
  }
  const $path2 = /** @type {SVGGeometryElement} */(getPath(path2));
  if (!$path2) {
    throw new Error("Can't morph to an invalid target. 'path2' must resolve to an existing <path>, <polygon> or <polyline> SVG element.");
  }
  const tagName2 = ($path2.tagName || '').toLowerCase();
  if (!tagName2.match(/^(path|polygon|polyline)$/)) {
    throw new Error(`Can't morph a <${$path2.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);
  }
  const isPath = $path1.tagName === 'path';
  const separator = isPath ? ' ' : ',';
  const previousPoints = $path1[morphPointsSymbol];
  if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);

  let v1 = '', v2 = '';

  if (!precision) {
    v1 = $path1.getAttribute(isPath ? 'd' : 'points');
    v2 = $path2.getAttribute(isPath ? 'd' : 'points');
  } else {
    const length1 = /** @type {SVGGeometryElement} */($path1).getTotalLength();
    const length2 = $path2.getTotalLength();
    const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));
    for (let i = 0; i < maxPoints; i++) {
      const t = i / (maxPoints - 1);
      const pointOnPath1 = /** @type {SVGGeometryElement} */($path1).getPointAtLength(length1 * t);
      const pointOnPath2 = $path2.getPointAtLength(length2 * t);
      const prefix = isPath ? (i === 0 ? 'M' : 'L') : '';
      v1 += prefix + round$1(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';
      v2 += prefix + round$1(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';
    }
  }

  $path1[morphPointsSymbol] = v2;

  return [v1, v2];
};

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createDrawable: createDrawable,
  createMotionPath: createMotionPath,
  morphTo: morphTo
});



const segmenter = (typeof Intl !== 'undefined') && Intl.Segmenter;
const valueRgx = /\{value\}/g;
const indexRgx = /\{i\}/g;
const whiteSpaceGroupRgx = /(\s+)/;
const whiteSpaceRgx = /^\s+$/;
const lineType = 'line';
const wordType = 'word';
const charType = 'char';
const dataLine = `data-line`;

/**
 * @typedef {Object} Segment
 * @property {String} segment
 * @property {Boolean} [isWordLike]
 */

/**
 * @typedef {Object} Segmenter
 * @property {function(String): Iterable<Segment>} segment
 */

/** @type {Segmenter} */
let wordSegmenter = null;
/** @type {Segmenter} */
let graphemeSegmenter = null;
let $splitTemplate = null;

/**
 * @param  {Segment} seg
 * @return {Boolean}
 */
const isSegmentWordLike = seg => {
  return seg.isWordLike ||
         seg.segment === ' ' || // Consider spaces as words first, then handle them diffrently later
         isNum(+seg.segment);   // Safari doesn't considers numbers as words
};

/**
 * @param {HTMLElement} $el
 */
const setAriaHidden = $el => $el.setAttribute('aria-hidden', 'true');

/**
 * @param {DOMTarget} $el
 * @param {String} type
 * @return {Array<HTMLElement>}
 */
const getAllTopLevelElements = ($el, type) => [.../** @type {*} */($el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`))];

const debugColors = { line: '#00D672', word: '#FF4B4B', char: '#5A87FF' };

/**
 * @param {HTMLElement} $el
 */
const filterEmptyElements = $el => {
  if (!$el.childElementCount && !$el.textContent.trim()) {
    const $parent = $el.parentElement;
    $el.remove();
    if ($parent) filterEmptyElements($parent);
  }
};

/**
 * @param {HTMLElement} $el
 * @param {Number} lineIndex
 * @param {Set<HTMLElement|Node>} bin
 * @returns {Set<HTMLElement|Node>}
 */
const filterLineElements = ($el, lineIndex, bin) => {
  const dataLineAttr = $el.getAttribute(dataLine);
  if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === 'BR') {
    bin.add($el);
    // Also remove adjacent whitespace-only text nodes
    const prev = $el.previousSibling;
    const next = $el.nextSibling;
    if (prev && prev.nodeType === 3 && whiteSpaceRgx.test(prev.textContent)) {
      bin.add(prev);
    }
    if (next && next.nodeType === 3 && whiteSpaceRgx.test(next.textContent)) {
      bin.add(next);
    }
  }
  let i = $el.childElementCount;
  while (i--) filterLineElements(/** @type {HTMLElement} */($el.children[i]), lineIndex, bin);
  return bin;
};

/**
 * @param  {'line'|'word'|'char'} type
 * @param  {SplitTemplateParams} params
 * @return {String}
 */
const generateTemplate = (type, params = {}) => {
  let template = ``;
  const classString = isStr(params.class) ? ` class="${params.class}"` : '';
  const cloneType = setValue(params.clone, false);
  const wrapType = setValue(params.wrap, false);
  const overflow = wrapType ? wrapType === true ? 'clip' : wrapType : cloneType ? 'clip' : false;
  if (wrapType) template += `<span${overflow ? ` style="overflow:${overflow};"` : ''}>`;
  template += `<span${classString}${cloneType ? ` style="position:relative;"` : ''} data-${type}="{i}">`;
  if (cloneType) {
    const left = cloneType === 'left' ? '-100%' : cloneType === 'right' ? '100%' : '0';
    const top = cloneType === 'top' ? '-100%' : cloneType === 'bottom' ? '100%' : '0';
    template += `<span>{value}</span>`;
    template += `<span inert style="position:absolute;top:${top};left:${left};white-space:nowrap;">{value}</span>`;
  } else {
    template += `{value}`;
  }
  template += `</span>`;
  if (wrapType) template += `</span>`;
  return template;
};

/**
 * @param  {String|SplitFunctionValue} htmlTemplate
 * @param  {Array<HTMLElement>} store
 * @param  {Node|HTMLElement} node
 * @param  {DocumentFragment} $parentFragment
 * @param  {'line'|'word'|'char'} type
 * @param  {Boolean} debug
 * @param  {Number} lineIndex
 * @param  {Number} [wordIndex]
 * @param  {Number} [charIndex]
 * @return {HTMLElement}
 */
const processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {
  const isLine = type === lineType;
  const isChar = type === charType;
  const className = `_${type}_`;
  const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;
  const displayStyle = isLine ? 'block' : 'inline-block';
  $splitTemplate.innerHTML = template
    .replace(valueRgx, `<i class="${className}"></i>`)
    .replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);
  const $content = $splitTemplate.content;
  const $highestParent = /** @type {HTMLElement} */($content.firstElementChild);
  const $split = /** @type {HTMLElement} */($content.querySelector(`[data-${type}]`)) || $highestParent;
  const $replacables = /** @type {NodeListOf<HTMLElement>} */($content.querySelectorAll(`i.${className}`));
  const replacablesLength = $replacables.length;
  if (replacablesLength) {
    $highestParent.style.display = displayStyle;
    $split.style.display = displayStyle;
    $split.setAttribute(dataLine, `${lineIndex}`);
    if (!isLine) {
      $split.setAttribute('data-word', `${wordIndex}`);
      if (isChar) $split.setAttribute('data-char', `${charIndex}`);
    }
    let i = replacablesLength;
    while (i--) {
      const $replace = $replacables[i];
      const $closestParent = $replace.parentElement;
      $closestParent.style.display = displayStyle;
      if (isLine) {
        $closestParent.innerHTML = /** @type {HTMLElement} */(node).innerHTML;
      } else {
        $closestParent.replaceChild(node.cloneNode(true), $replace);
      }
    }
    store.push($split);
    $parentFragment.appendChild($content);
  } else {
    console.warn(`The expression "{value}" is missing from the provided template.`);
  }
  if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;
  return $highestParent;
};

/**
 * A class that splits text into words and wraps them in span elements while preserving the original HTML structure.
 * @class
 */
class TextSplitter {
  /**
   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target
   * @param  {TextSplitterParams} [parameters]
   */
  constructor(target, parameters = {}) {
    // Only init segmenters when needed
    if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], { granularity: wordType }) : {
      segment: (text) => {
        const segments = [];
        const words = text.split(whiteSpaceGroupRgx);
        for (let i = 0, l = words.length; i < l; i++) {
          const segment = words[i];
          segments.push({
            segment,
            isWordLike: !whiteSpaceRgx.test(segment), // Consider non-whitespace as word-like
          });
        }
        return segments;
      }
    };
    if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], { granularity: 'grapheme' }) : {
      segment: text => [...text].map(char => ({ segment: char }))
    };
    if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement('template');
    if (scope.current) scope.current.register(this);
    const { words, chars, lines, accessible, includeSpaces, debug } = parameters;
    const $target = /** @type {HTMLElement} */((target = isArr(target) ? target[0] : target) && /** @type {Node} */(target).nodeType ? target : (getNodeList(target) || [])[0]);
    const lineParams = lines === true ? {} : lines;
    const wordParams = words === true || isUnd(words) ? {} : words;
    const charParams = chars === true ? {} : chars;
    this.debug = setValue(debug, false);
    this.includeSpaces = setValue(includeSpaces, false);
    this.accessible = setValue(accessible, true);
    this.linesOnly = lineParams && (!wordParams && !charParams);
    /** @type {String|false|SplitFunctionValue} */
    this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, /** @type {SplitTemplateParams} */(lineParams)) : lineParams;
    /** @type {String|false|SplitFunctionValue} */
    this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, /** @type {SplitTemplateParams} */(wordParams)) : wordParams;
    /** @type {String|false|SplitFunctionValue} */
    this.charTemplate = isObj(charParams) ? generateTemplate(charType, /** @type {SplitTemplateParams} */(charParams)) : charParams;
    this.$target = $target;
    this.html = $target && $target.innerHTML;
    this.lines = [];
    this.words = [];
    this.chars = [];
    this.effects = [];
    this.effectsCleanups = [];
    this.cache = null;
    this.ready = false;
    this.width = 0;
    this.resizeTimeout = null;
    const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();
    // Make sure this is declared before calling handleSplit() in case revert() is called inside an effect callback
    this.resizeObserver = new ResizeObserver(() => {
      // Use a setTimeout instead of a Timer for better tree shaking
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => {
        const currentWidth = /** @type {HTMLElement} */($target).offsetWidth;
        if (currentWidth === this.width) return;
        this.width = currentWidth;
        handleSplit();
      }, 150);
    });
    // Only declare the font ready promise when splitting by lines and not alreay split
    if (this.lineTemplate && !this.ready) {
      doc.fonts.ready.then(handleSplit);
    } else {
      handleSplit();
    }
    $target ? this.resizeObserver.observe($target) : console.warn('No Text Splitter target found.');
  }

  /**
   * @param  {(...args: any[]) => Tickable | (() => void)} effect
   * @return this
   */
  addEffect(effect) {
    if (!isFnc(effect)) return console.warn('Effect must return a function.');
    const refreshableEffect = keepTime(effect);
    this.effects.push(refreshableEffect);
    if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);
    return this;
  }

  revert() {
    clearTimeout(this.resizeTimeout);
    this.lines.length = this.words.length = this.chars.length = 0;
    this.resizeObserver.disconnect();
    // Make sure to revert the effects after disconnecting the resizeObserver to avoid triggering it in the process
    this.effectsCleanups.forEach(cleanup => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());
    this.$target.innerHTML = this.html;
    return this;
  }

  /**
   * Recursively processes a node and its children
   * @param {Node} node
   */
  splitNode(node) {
    const wordTemplate = this.wordTemplate;
    const charTemplate = this.charTemplate;
    const includeSpaces = this.includeSpaces;
    const debug = this.debug;
    const nodeType = node.nodeType;
    if (nodeType === 3) {
      const nodeText = node.nodeValue;
      // If the nodeText is only whitespace, leave it as is
      if (nodeText.trim()) {
        const tempWords = [];
        const words = this.words;
        const chars = this.chars;
        const wordSegments = wordSegmenter.segment(nodeText);
        const $wordsFragment = doc.createDocumentFragment();
        let prevSeg = null;
        for (const wordSegment of wordSegments) {
          const segment = wordSegment.segment;
          const isWordLike = isSegmentWordLike(wordSegment);
          // Determine if this segment should be a new word, first segment always becomes a new word
          if (!prevSeg || (isWordLike && (prevSeg && (isSegmentWordLike(prevSeg))))) {
            tempWords.push(segment);
          } else {
            // Only concatenate if both current and previous are non-word-like and don't contain spaces
            const lastWordIndex = tempWords.length - 1;
            const lastWord = tempWords[lastWordIndex];
            if (!whiteSpaceGroupRgx.test(lastWord) && !whiteSpaceGroupRgx.test(segment)) {
              tempWords[lastWordIndex] += segment;
            } else {
              tempWords.push(segment);
            }
          }
          prevSeg = wordSegment;
        }

        for (let i = 0, l = tempWords.length; i < l; i++) {
          const word = tempWords[i];
          if (!word.trim()) {
            // Preserve whitespace only if includeSpaces is false and if the current space is not the first node
            if (i && includeSpaces) continue;
            $wordsFragment.appendChild(doc.createTextNode(word));
          } else {
            const nextWord = tempWords[i + 1];
            const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();
            const wordToProcess = word;
            const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;
            const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + '\xa0' : word);
            if (charTemplate) {
              const charSegmentsArray = [...charSegments];
              for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {
                const charSegment = charSegmentsArray[j];
                const isLastChar = j === jl - 1;
                // If this is the last character and includeSpaces is true with a following space, append the space
                const charText = isLastChar && hasWordFollowingSpace ? charSegment.segment + '\xa0' : charSegment.segment;
                const $charNode = doc.createTextNode(charText);
                processHTMLTemplate(charTemplate, chars, $charNode, /** @type {DocumentFragment} */($charsFragment), charType, debug, -1, words.length, chars.length);
              }
            }
            if (wordTemplate) {
              processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);
              // Chars elements must be re-parsed in the split() method if both words and chars are parsed
            } else if (charTemplate) {
              $wordsFragment.appendChild($charsFragment);
            } else {
              $wordsFragment.appendChild(doc.createTextNode(word));
            }
            // Skip the next iteration if we included a space
            if (hasWordFollowingSpace) i++;
          }
        }
        node.parentNode.replaceChild($wordsFragment, node);
      }
    } else if (nodeType === 1) {
      // Converting to an array is necessary to work around childNodes pottential mutation
      const childNodes = /** @type {Array<Node>} */([.../** @type {*} */(node.childNodes)]);
      for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);
    }
  }

  /**
   * @param {Boolean} clearCache
   * @return {this}
   */
  split(clearCache = false) {
    const $el = this.$target;
    const isCached = !!this.cache && !clearCache;
    const lineTemplate = this.lineTemplate;
    const wordTemplate = this.wordTemplate;
    const charTemplate = this.charTemplate;
    const fontsReady = doc.fonts.status !== 'loading';
    const canSplitLines = lineTemplate && fontsReady;
    this.ready = !lineTemplate || fontsReady;
    if (canSplitLines || clearCache) {
      // No need to revert effects animations here since it's already taken care by the refreshable
      this.effectsCleanups.forEach(cleanup => isFnc(cleanup) && cleanup(this));
    }
    if (!isCached) {
      if (clearCache) {
        $el.innerHTML = this.html;
        this.words.length = this.chars.length = 0;
      }
      this.splitNode($el);
      this.cache = $el.innerHTML;
    }
    if (canSplitLines) {
      if (isCached) $el.innerHTML = this.cache;
      this.lines.length = 0;
      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);
    }
    // Always reparse characters after a line reset or if both words and chars are activated
    if (charTemplate && (canSplitLines || wordTemplate)) {
      this.chars = getAllTopLevelElements($el, charType);
    }
    // Words are used when lines only and prioritized over chars
    const elementsArray = this.words.length ? this.words : this.chars;
    let y, linesCount = 0;
    for (let i = 0, l = elementsArray.length; i < l; i++) {
      const $el = elementsArray[i];
      const { top, height } = $el.getBoundingClientRect();
      if (!isUnd(y) && top - y > height * .5) linesCount++;
      $el.setAttribute(dataLine, `${linesCount}`);
      const nested = $el.querySelectorAll(`[${dataLine}]`);
      let c = nested.length;
      while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);
      y = top;
    }
    if (canSplitLines) {
      const linesFragment = doc.createDocumentFragment();
      const parents = new Set();
      const clones = [];
      for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {
        const $clone = /** @type {HTMLElement} */($el.cloneNode(true));
        filterLineElements($clone, lineIndex, new Set()).forEach($el => {
          const $parent = $el.parentNode;
          if ($parent) {
            if ($el.nodeType === 1) parents.add(/** @type {HTMLElement} */($parent));
            $parent.removeChild($el);
          }
        });
        clones.push($clone);
      }
      parents.forEach(filterEmptyElements);
      for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) {
        processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);
      }
      $el.innerHTML = '';
      $el.appendChild(linesFragment);
      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);
      if (charTemplate) this.chars = getAllTopLevelElements($el, charType);
    }

    // Remove the word wrappers and clear the words array if lines split only
    if (this.linesOnly) {
      const words = this.words;
      let w = words.length;
      while (w--) {
        const $word = words[w];
        $word.replaceWith($word.textContent);
      }
      words.length = 0;
    }
    if (this.accessible && (canSplitLines || !isCached)) {
      const $accessible = doc.createElement('span');
      // Make the accessible element visually-hidden (https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html)
      $accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;
      // $accessible.setAttribute('tabindex', '-1');
      $accessible.innerHTML = this.html;
      $el.insertBefore($accessible, $el.firstChild);
      this.lines.forEach(setAriaHidden);
      this.words.forEach(setAriaHidden);
      this.chars.forEach(setAriaHidden);
    }
    this.width = /** @type {HTMLElement} */($el).offsetWidth;
    if (canSplitLines || clearCache) {
      this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));
    }
    return this;
  }

  refresh() {
    this.split(true);
  }
}

/**
 * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target
 * @param  {TextSplitterParams} [parameters]
 * @return {TextSplitter}
 */
const splitText = (target, parameters) => new TextSplitter(target, parameters);

/**
 * @deprecated text.split() is deprecated, import splitText() directly, or text.splitText()
 *
 * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target
 * @param  {TextSplitterParams} [parameters]
 * @return {TextSplitter}
 */
const split = (target, parameters) => {
  console.warn('text.split() is deprecated, import splitText() directly, or text.splitText()');
  return new TextSplitter(target, parameters);
};

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TextSplitter: TextSplitter,
  split: split,
  splitText: splitText
});

export { registerTargets as $, Animatable, AutoLayout, Draggable, JSAnimation, Scope, ScrollObserver, Spring, TextSplitter, Timeline, Timer, WAAPIAnimation, animate, clamp, cleanInlineStyles, createAnimatable, createDraggable, createDrawable, createLayout, createMotionPath, createScope, createSeededRandom, createSpring, createTimeline, createTimer, cubicBezier, damp, degToRad, eases, index$3 as easings, engine, get, irregular, keepTime, lerp, linear, mapRange, morphTo, onScroll, padEnd, padStart, radToDeg, random, randomPick, remove, round, roundPad, scrollContainers, set, shuffle, snap, split, splitText, spring, stagger, steps, index$1 as svg, sync, index as text, index$2 as utils, waapi, wrap };


## Links discovered
- [y](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [j](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [l](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [prop](https://github.com/juliangarnier/anime/blob/master/dist/bundles/...nextArgs)

--- dist/bundles/anime.esm.min.js ---
/**
 * Anime.js - ESM minified bundle
 * @version v4.3.0
 * @license MIT
 * @copyright 2026 - Julian Garnier
 */
const t="undefined"!=typeof window,e=t?window:null,s=t?document:null,i={OBJECT:0,ATTRIBUTE:1,CSS:2,TRANSFORM:3,CSS_VAR:4},r={NUMBER:0,UNIT:1,COLOR:2,COMPLEX:3},n={NONE:0,AUTO:1,FORCE:2},o={replace:0,none:1,blend:2},a=Symbol(),l=Symbol(),h=Symbol(),d=Symbol(),c=Symbol(),u=Symbol(),p=1e-11,m=1e12,f=1e3,g=240,y="",v="var(",_=(()=>{const t=new Map;return t.set("x","translateX"),t.set("y","translateY"),t.set("z","translateZ"),t})(),b=["translateX","translateY","translateZ","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","matrix","matrix3d","perspective"],T=b.reduce((t,e)=>({...t,[e]:e+"("}),{}),x=()=>{},S=/(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i,w=/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i,$=/rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i,E=/hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i,C=/hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i,N=/[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi,k=/^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i,R=/([a-z])([A-Z])/g,D=/(\w+)(\([^)]+\)+)/g,I=/(\*=|\+=|-=)/,A=/var\(\s*(--[\w-]+)(?:\s*,\s*([^)]+))?\s*\)/,L={id:null,keyframes:null,playbackEase:null,playbackRate:1,frameRate:g,loop:0,reversed:!1,alternate:!1,autoplay:!0,persist:!1,duration:f,delay:0,loopDelay:0,ease:"out(2)",composition:o.replace,modifier:t=>t,onBegin:x,onBeforeUpdate:x,onUpdate:x,onLoop:x,onPause:x,onComplete:x,onRender:x},O={current:null,root:s},B={defaults:L,precision:4,timeScale:1,tickThreshold:200},P=t&&e.AnimeJSDevTools,F={version:"4.3.0",engine:null};t&&(e.AnimeJS||(e.AnimeJS=[]),e.AnimeJS.push(F));const M=t=>t.replace(R,"$1-$2").toLowerCase(),V=(t,e)=>0===t.indexOf(e),z=Date.now,X=Array.isArray,H=t=>t&&t.constructor===Object,U=t=>"number"==typeof t&&!isNaN(t),Y=t=>"string"==typeof t,W=t=>"function"==typeof t,q=t=>void 0===t,j=t=>q(t)||null===t,G=e=>t&&e instanceof SVGElement,Q=t=>S.test(t),J=t=>V(t,"rgb")&&")"===t[t.length-1],Z=t=>V(t,"hsl")&&")"===t[t.length-1],K=t=>Q(t)||J(t)||Z(t),tt=t=>!B.defaults.hasOwnProperty(t),et=["opacity","rotate","overflow","color"],st=(t,e)=>{if(et.includes(e))return!1;if(t.getAttribute(e)||e in t){if("scale"===e){const e=t.parentNode;return e&&"filter"===e.tagName}return!0}},it=t=>Y(t)?parseFloat(t):t,rt=Math.pow,nt=Math.sqrt,ot=Math.sin,at=Math.cos,lt=Math.abs,ht=Math.exp,dt=Math.ceil,ct=Math.floor,ut=Math.asin,pt=Math.max,mt=Math.atan2,ft=Math.PI,gt=Math.round,yt=(t,e,s)=>t<e?e:t>s?s:t,vt={},_t=(t,e)=>{if(e<0)return t;if(!e)return gt(t);let s=vt[e];return s||(s=vt[e]=10**e),gt(t*s)/s},bt=(t,e)=>X(e)?e.reduce((e,s)=>lt(s-t)<lt(e-t)?s:e):e?gt(t/e)*e:t,Tt=(t,e,s)=>t+(e-t)*s,xt=t=>t===1/0?m:t===-1/0?-m:t,St=t=>t<=p?p:xt(_t(t,11)),wt=t=>X(t)?[...t]:t,$t=(t,e)=>{const s={...t};for(let i in e){const r=t[i];s[i]=q(r)?e[i]:r}return s},Et=(t,e,s,i="_prev",r="_next")=>{let n=t._head,o=r;for(s&&(n=t._tail,o=i);n;){const t=n[o];e(n),n=t}},Ct=(t,e,s="_prev",i="_next")=>{const r=e[s],n=e[i];r?r[i]=n:t._head=n,n?n[s]=r:t._tail=r,e[s]=null,e[i]=null},Nt=(t,e,s,i="_prev",r="_next")=>{let n=t._tail;for(;n&&s&&s(n,e);)n=n[i];const o=n?n[r]:t._head;n?n[r]=e:t._head=e,o?o[i]=e:t._tail=e,e[i]=n,e[r]=o},kt=(t,e,s)=>{const i=t.style.transform;let r;if(i){const n=t[d];let o;for(;o=D.exec(i);){const t=o[1],i=o[2].slice(1,-1);n[t]=i,t===e&&(r=i,s&&(s[e]=i))}}return i&&!q(r)?r:V(e,"scale")?"1":V(e,"rotate")||V(e,"skew")?"0deg":"0px"},Rt=t=>{const e=w.exec(t)||$.exec(t),s=q(e[4])?1:+e[4];return[+e[1],+e[2],+e[3],s]},Dt=t=>{const e=t.length,s=4===e||5===e;return[+("0x"+t[1]+t[s?1:2]),+("0x"+t[s?2:3]+t[s?2:4]),+("0x"+t[s?3:5]+t[s?3:6]),5===e||9===e?+(+("0x"+t[s?4:7]+t[s?4:8])/255).toFixed(3):1]},It=(t,e,s)=>(s<0&&(s+=1),s>1&&(s-=1),s<1/6?t+6*(e-t)*s:s<.5?e:s<2/3?t+(e-t)*(2/3-s)*6:t),At=t=>{const e=E.exec(t)||C.exec(t),s=+e[1]/360,i=+e[2]/100,r=+e[3]/100,n=q(e[4])?1:+e[4];let o,a,l;if(0===i)o=a=l=r;else{const t=r<.5?r*(1+i):r+i-r*i,e=2*r-t;o=_t(255*It(e,t,s+1/3),0),a=_t(255*It(e,t,s),0),l=_t(255*It(e,t,s-1/3),0)}return[o,a,l,n]},Lt=t=>J(t)?Rt(t):Q(t)?Dt(t):Z(t)?At(t):[0,0,0,1],Ot=(t,e)=>q(t)?e:t,Bt=(t,e,s,i,r)=>{let n;if(W(t))n=()=>{const r=t(e,s,i);return isNaN(+r)?r||0:+r};else{if(!Y(t)||!V(t,v))return t;n=()=>{const s=t.match(A),i=s[1],r=s[2];let n=getComputedStyle(e)?.getPropertyValue(i);return n&&n.trim()!==y||!r||(n=r.trim()),n||0}}return r&&(r.func=n),n()},Pt=(t,e)=>t[l]?t[h]&&st(t,e)?i.ATTRIBUTE:b.includes(e)||_.get(e)?i.TRANSFORM:V(e,"--")?i.CSS_VAR:e in t.style?i.CSS:e in t?i.OBJECT:i.ATTRIBUTE:i.OBJECT,Ft=(t,e,s)=>{const i=t.style[e];i&&s&&(s[e]=i);const r=i||getComputedStyle(t[u]||t).getPropertyValue(e);return"auto"===r?"0":r},Mt=(t,e,s,r)=>{const n=q(s)?Pt(t,e):s;return n===i.OBJECT?t[e]||0:n===i.ATTRIBUTE?t.getAttribute(e):n===i.TRANSFORM?kt(t,e,r):n===i.CSS_VAR?Ft(t,e,r).trimStart():Ft(t,e,r)},Vt=(t,e,s)=>"-"===s?t-e:"+"===s?t+e:t*e,zt=()=>({t:r.NUMBER,n:0,u:null,o:null,d:null,s:null}),Xt=(t,e)=>{if(e.t=r.NUMBER,e.n=0,e.u=null,e.o=null,e.d=null,e.s=null,!t)return e;const s=+t;if(isNaN(s)){let s=t;"="===s[1]&&(e.o=s[0],s=s.slice(2));const i=!s.includes(" ")&&k.exec(s);if(i)return e.t=r.UNIT,e.n=+i[1],e.u=i[2],e;if(e.o)return e.n=+s,e;if(K(s))return e.t=r.COLOR,e.d=Lt(s),e;{const t=s.match(N);return e.t=r.COMPLEX,e.d=t?t.map(Number):[],e.s=s.split(N)||[],e}}return e.n=s,e},Ht=(t,e)=>(e.t=t._valueType,e.n=t._toNumber,e.u=t._unit,e.o=null,e.d=wt(t._toNumbers),e.s=wt(t._strings),e),Ut=zt(),Yt=(t,e,s,a,l)=>{const h=t.parent,c=t.duration,u=t.completed,m=t.iterationDuration,f=t.iterationCount,g=t._currentIteration,v=t._loopDelay,_=t._reversed,b=t._alternate,x=t._hasChildren,S=t._delay,w=t._currentTime,$=S+m,E=e-S,C=yt(w,-S,c),N=yt(E,-S,c),k=E-w,R=N>0,D=N>=c,I=c<=p,A=l===n.FORCE;let L=0,O=E,P=0;if(f>1){const e=~~(N/(m+(D?0:v)));t._currentIteration=yt(e,0,f),D&&t._currentIteration--,L=t._currentIteration%2,O=N%(m+v)||0}const F=_^(b&&L),M=t._ease;let V=D?F?0:c:F?m-O:O;M&&(V=m*M(V/m)||0);const z=(h?h.backwards:E<w)?!F:!!F;if(t._currentTime=E,t._iterationTime=V,t.backwards=z,R&&!t.began?(t.began=!0,s||h&&(z||!h.began)||t.onBegin(t)):E<=0&&(t.began=!1),s||x||!R||t._currentIteration===g||t.onLoop(t),A||l===n.AUTO&&(e>=S&&e<=$||e<=S&&C>S||e>=$&&C!==c)||V>=$&&C!==c||V<=S&&C>0||e<=C&&C===c&&u||D&&!u&&I){if(R&&(t.computeDeltaTime(C),s||t.onBeforeUpdate(t)),!x){const e=A||(z?-1*k:k)>=B.tickThreshold,n=t._offset+(h?h._offset:0)+S+V;let l,c,u,p,m=t._head,f=0;for(;m;){const t=m._composition,s=m._currentTime,h=m._changeDuration,g=m._absoluteStartTime+m._changeDuration,v=m._nextRep,_=m._prevRep,b=t!==o.none;if((e||(s!==h||n<=g+(v?v._delay:0))&&(0!==s||n>=m._absoluteStartTime))&&(!b||!m._isOverridden&&(!m._isOverlapped||n<=g)&&(!v||v._isOverridden||n<=v._absoluteStartTime)&&(!_||_._isOverridden||n>=_._absoluteStartTime+_._changeDuration+m._delay))){const e=m._currentTime=yt(V-m._startTime,0,h),s=m._ease(e/m._updateDuration),n=m._modifier,g=m._valueType,y=m._tweenType,v=y===i.OBJECT,_=g===r.NUMBER,T=_&&v||0===s||1===s?-1:B.precision;let x,S;if(_)x=S=n(_t(Tt(m._fromNumber,m._toNumber,s),T));else if(g===r.UNIT)S=n(_t(Tt(m._fromNumber,m._toNumber,s),T)),x=`${S}${m._unit}`;else if(g===r.COLOR){const t=m._fromNumbers,e=m._toNumbers,i=_t(yt(n(Tt(t[0],e[0],s)),0,255),0),r=_t(yt(n(Tt(t[1],e[1],s)),0,255),0),o=_t(yt(n(Tt(t[2],e[2],s)),0,255),0),a=yt(n(_t(Tt(t[3],e[3],s),T)),0,1);if(x=`rgba(${i},${r},${o},${a})`,b){const t=m._numbers;t[0]=i,t[1]=r,t[2]=o,t[3]=a}}else if(g===r.COMPLEX){x=m._strings[0];for(let t=0,e=m._toNumbers.length;t<e;t++){const e=n(_t(Tt(m._fromNumbers[t],m._toNumbers[t],s),T)),i=m._strings[t+1];x+=`${i?e+i:e}`,b&&(m._numbers[t]=e)}}if(b&&(m._number=S),a||t===o.blend)m._value=x;else{const t=m.property;l=m.target,v?l[t]=x:y===i.ATTRIBUTE?l.setAttribute(t,x):(c=l.style,y===i.TRANSFORM?(l!==u&&(u=l,p=l[d]),p[t]=x,f=1):y===i.CSS?c[t]=x:y===i.CSS_VAR&&c.setProperty(t,x)),R&&(P=1)}}if(f&&m._renderTransforms){let t=y;for(let e in p)t+=`${T[e]}${p[e]}) `;c.transform=t,f=0}m=m._next}!s&&P&&t.onRender(t)}!s&&R&&t.onUpdate(t)}return h&&I?!s&&(h.began&&!z&&E>0&&!u||z&&E<=p&&u)&&(t.onComplete(t),t.completed=!z):R&&D?f===1/0?t._startTime+=t.duration:t._currentIteration>=f-1&&(t.paused=!0,u||x||(t.completed=!0,s||h&&(z||!h.began)||(t.onComplete(t),t._resolve(t)))):t.completed=!1,P},Wt=(t,e,s,i,r)=>{const o=t._currentIteration;if(Yt(t,e,s,i,r),t._hasChildren){const a=t,l=a.backwards,h=i?e:a._iterationTime,d=z();let c=0,u=!0;if(!i&&a._currentIteration!==o){const t=a.iterationDuration;Et(a,e=>{if(l){const i=e.duration,r=e._offset+e._delay;s||!(i<=p)||r&&r+i!==t||e.onComplete(e)}else!e.completed&&!e.backwards&&e._currentTime<e.iterationDuration&&Yt(e,t,s,1,n.FORCE),e.began=!1,e.completed=!1}),s||a.onLoop(a)}Et(a,t=>{const e=_t((h-t._offset)*t._speed,12),n=t._fps<a._fps?t.requestTick(d):r;c+=Yt(t,e,s,i,n),!t.completed&&u&&(u=!1)},l),!s&&c&&a.onRender(a),(u||l)&&a._currentTime>=a.duration&&(a.paused=!0,a.completed||(a.completed=!0,s||(a.onComplete(a),a._resolve(a))))}},qt={},jt=(t,e,s)=>{if(s===i.TRANSFORM)return _.get(t)||t;if(s===i.CSS||s===i.ATTRIBUTE&&G(e)&&t in e.style){const e=qt[t];if(e)return e;{const e=t?M(t):t;return qt[t]=e,e}}return t},Gt=t=>{if(t._hasChildren)Et(t,Gt,!0);else{const e=t;e.pause(),Et(e,t=>{const s=t.property,r=t.target;if(r[l]){const n=r.style,o=t._inlineValue,a=j(o)||o===y;if(t._tweenType===i.TRANSFORM){const e=r[d];if(a?delete e[s]:e[s]=o,t._renderTransforms)if(Object.keys(e).length){let t=y;for(let s in e)t+=T[s]+e[s]+") ";n.transform=t}else n.removeProperty("transform")}else a?n.removeProperty(M(s)):n[s]=o;e._tail===t&&e.targets.forEach(t=>{t.getAttribute&&t.getAttribute("style")===y&&t.removeAttribute("style")})}})}return t};class Qt{constructor(t=0){this.deltaTime=0,this._currentTime=t,this._lastTickTime=t,this._startTime=t,this._lastTime=t,this._scheduledTime=0,this._frameDuration=f/g,this._fps=g,this._speed=1,this._hasChildren=!1,this._head=null,this._tail=null}get fps(){return this._fps}set fps(t){const e=this._frameDuration,s=+t,i=s<p?p:s,r=f/i;i>L.frameRate&&(L.frameRate=i),this._fps=i,this._frameDuration=r,this._scheduledTime+=r-e}get speed(){return this._speed}set speed(t){const e=+t;this._speed=e<p?p:e}requestTick(t){const e=this._scheduledTime;if(this._lastTickTime=t,t<e)return n.NONE;const s=this._frameDuration,i=t-e;return this._scheduledTime+=i<s?s:i,n.AUTO}computeDeltaTime(t){const e=t-this._lastTime;return this.deltaTime=e,this._lastTime=t,e}}const Jt={animation:null,update:x},Zt=t=>{let e=Jt.animation;return e||(e={duration:p,computeDeltaTime:x,_offset:0,_delay:0,_head:null,_tail:null},Jt.animation=e,Jt.update=()=>{t.forEach(t=>{for(let e in t){const s=t[e],i=s._head;if(i){const t=i._valueType,e=t===r.COMPLEX||t===r.COLOR?wt(i._fromNumbers):null;let n=i._fromNumber,o=s._tail;for(;o&&o!==i;){if(e)for(let t=0,s=o._numbers.length;t<s;t++)e[t]+=o._numbers[t];else n+=o._number;o=o._prevAdd}i._toNumber=n,i._toNumbers=e}}}),Yt(e,1,1,0,n.FORCE)}),e},Kt=(()=>t?requestAnimationFrame:setImmediate)(),te=(()=>t?cancelAnimationFrame:clearImmediate)();class ee extends Qt{constructor(t){super(t),this.useDefaultMainLoop=!0,this.pauseOnDocumentHidden=!0,this.defaults=L,this.paused=!0,this.reqId=0}update(){const t=this._currentTime=z();if(this.requestTick(t)){this.computeDeltaTime(t);const e=this._speed,s=this._fps;let i=this._head;for(;i;){const r=i._next;i.paused?(Ct(this,i),this._hasChildren=!!this._tail,i._running=!1,i.completed&&!i._cancelled&&i.cancel()):Wt(i,(t-i._startTime)*i._speed*e,0,0,i._fps<s?i.requestTick(t):n.AUTO),i=r}Jt.update()}}wake(){return this.useDefaultMainLoop&&!this.reqId&&(this.requestTick(z()),this.reqId=Kt(ie)),this}pause(){if(this.reqId)return this.paused=!0,re()}resume(){if(this.paused)return this.paused=!1,Et(this,t=>t.resetTime()),this.wake()}get speed(){return this._speed*(1===B.timeScale?1:f)}set speed(t){this._speed=t*B.timeScale,Et(this,t=>t.speed=t._speed)}get timeUnit(){return 1===B.timeScale?"ms":"s"}set timeUnit(t){const e="s"===t,s=e?.001:1;if(B.timeScale!==s){B.timeScale=s,B.tickThreshold=200*s;const t=e?.001:f;this.defaults.duration*=t,this._speed*=t}}get precision(){return B.precision}set precision(t){B.precision=t}}const se=(()=>{const e=new ee(z());return t&&(F.engine=e,s.addEventListener("visibilitychange",()=>{e.pauseOnDocumentHidden&&(s.hidden?e.pause():e.resume())})),e})(),ie=()=>{se._head?(se.reqId=Kt(ie),se.update()):se.reqId=0},re=()=>(te(se.reqId),se.reqId=0,se),ne={_rep:new WeakMap,_add:new Map},oe=(t,e,s="_rep")=>{const i=ne[s];let r=i.get(t);return r||(r={},i.set(t,r)),r[e]?r[e]:r[e]={_head:null,_tail:null}},ae=(t,e)=>t._isOverridden||t._absoluteStartTime>e._absoluteStartTime,le=t=>{t._isOverlapped=1,t._isOverridden=1,t._changeDuration=p,t._currentTime=p},he=(t,e)=>{const s=t._composition;if(s===o.replace){const s=t._absoluteStartTime;Nt(e,t,ae,"_prevRep","_nextRep");const i=t._prevRep;if(i){const e=i.parent,r=i._absoluteStartTime+i._changeDuration;if(t.parent.id!==e.id&&e.iterationCount>1&&r+(e.duration-e.iterationDuration)>s){le(i);let t=i._prevRep;for(;t&&t.parent.id===e.id;)le(t),t=t._prevRep}const n=s-t._delay;if(r>n){const t=i._startTime,e=r-(t+i._updateDuration),s=_t(n-e-t,12);i._changeDuration=s,i._currentTime=s,i._isOverlapped=1,s<p&&le(i)}let o=!0;if(Et(e,t=>{t._isOverlapped||(o=!1)}),o){const t=e.parent;if(t){let s=!0;Et(t,t=>{t!==e&&Et(t,t=>{t._isOverlapped||(s=!1)})}),s&&t.cancel()}else e.cancel()}}}else if(s===o.blend){const e=oe(t.target,t.property,"_add"),s=Zt(ne._add);let i=e._head;i||(i={...t},i._composition=o.replace,i._updateDuration=p,i._startTime=0,i._numbers=wt(t._fromNumbers),i._number=0,i._next=null,i._prev=null,Nt(e,i),Nt(s,i));const r=t._toNumber;if(t._fromNumber=i._fromNumber-r,t._toNumber=0,t._numbers=wt(t._fromNumbers),t._number=0,i._fromNumber=r,t._toNumbers){const e=wt(t._toNumbers);e&&e.forEach((e,s)=>{t._fromNumbers[s]=i._fromNumbers[s]-e,t._toNumbers[s]=0}),i._fromNumbers=e}Nt(e,t,null,"_prevAdd","_nextAdd")}return t},de=t=>{const e=t._composition;if(e!==o.none){const s=t.target,i=t.property,r=ne._rep.get(s)[i];if(Ct(r,t,"_prevRep","_nextRep"),e===o.blend){const e=ne._add,r=e.get(s);if(!r)return;const n=r[i],o=Jt.animation;Ct(n,t,"_prevAdd","_nextAdd");const a=n._head;if(a&&a===n._tail){Ct(n,a,"_prevAdd","_nextAdd"),Ct(o,a);let t=!0;for(let e in r)if(r[e]._head){t=!1;break}t&&e.delete(s)}}}return t},ce=(t,e,s)=>{let r=!1;return Et(e,n=>{const o=n.target;if(t.includes(o)){const t=n.property,a=n._tweenType,l=jt(s,o,a);(!l||l&&l===t)&&(n.parent._tail===n&&n._tweenType===i.TRANSFORM&&n._prev&&n._prev._tweenType===i.TRANSFORM&&(n._prev._renderTransforms=1),Ct(e,n),de(n),r=!0)}},!0),r},ue=(t,e,s)=>{const i=e||se;let r;if(i._hasChildren){let e=0;Et(i,n=>{if(!n._hasChildren)if(r=ce(t,n,s),r&&!n._head)n.cancel(),Ct(i,n);else{const t=n._offset+n._delay+n.duration;t>e&&(e=t)}n._head?ue(t,n,s):n._hasChildren=!1},!0),q(i.iterationDuration)||(i.iterationDuration=e)}else r=ce(t,i,s);r&&!i._head&&(i._hasChildren=!1,i.cancel&&i.cancel())},pe=t=>(t.paused=!0,t.began=!1,t.completed=!1,t),me=t=>t._cancelled?(t._hasChildren?Et(t,me):Et(t,t=>{t._composition!==o.none&&he(t,oe(t.target,t.property))}),t._cancelled=0,t):t;let fe=0;class ge extends Qt{constructor(t={},e=null,s=0){super(0),++fe;const{id:i,delay:r,duration:n,reversed:o,alternate:a,loop:l,loopDelay:h,autoplay:d,frameRate:c,playbackRate:u,onComplete:m,onLoop:f,onPause:g,onBegin:y,onBeforeUpdate:v,onUpdate:_}=t;O.current&&O.current.register(this);const b=e?0:se._lastTickTime,T=e?e.defaults:B.defaults,S=W(r)||q(r)?T.delay:+r,w=W(n)||q(n)?1/0:+n,$=Ot(l,T.loop),E=Ot(h,T.loopDelay);let C=!0===$||$===1/0||$<0?1/0:$+1;if(P){const s=C===1/0;if(P.register(this,t,s)&&s){const t=a?2:1,s=e?P.maxNestedInfiniteLoops:P.maxInfiniteLoops;C=Math.max(s,t)}}let N=0;e?N=s:(se.reqId||se.requestTick(z()),N=(se._lastTickTime-se._startTime)*B.timeScale),this.id=q(i)?fe:i,this.parent=e,this.duration=xt((w+E)*C-E)||p,this.backwards=!1,this.paused=!0,this.began=!1,this.completed=!1,this.onBegin=y||T.onBegin,this.onBeforeUpdate=v||T.onBeforeUpdate,this.onUpdate=_||T.onUpdate,this.onLoop=f||T.onLoop,this.onPause=g||T.onPause,this.onComplete=m||T.onComplete,this.iterationDuration=w,this.iterationCount=C,this._autoplay=!e&&Ot(d,T.autoplay),this._offset=N,this._delay=S,this._loopDelay=E,this._iterationTime=0,this._currentIteration=0,this._resolve=x,this._running=!1,this._reversed=+Ot(o,T.reversed),this._reverse=this._reversed,this._cancelled=0,this._alternate=Ot(a,T.alternate),this._prev=null,this._next=null,this._lastTickTime=b,this._startTime=b,this._lastTime=b,this._fps=Ot(c,T.frameRate),this._speed=Ot(u,T.playbackRate)}get cancelled(){return!!this._cancelled}set cancelled(t){t?this.cancel():this.reset(!0).play()}get currentTime(){return yt(_t(this._currentTime,B.precision),-this._delay,this.duration)}set currentTime(t){const e=this.paused;this.pause().seek(+t),e||this.resume()}get iterationCurrentTime(){return yt(_t(this._iterationTime,B.precision),0,this.iterationDuration)}set iterationCurrentTime(t){this.currentTime=this.iterationDuration*this._currentIteration+t}get progress(){return yt(_t(this._currentTime/this.duration,10),0,1)}set progress(t){this.currentTime=this.duration*t}get iterationProgress(){return yt(_t(this._iterationTime/this.iterationDuration,10),0,1)}set iterationProgress(t){const e=this.iterationDuration;this.currentTime=e*this._currentIteration+e*t}get currentIteration(){return this._currentIteration}set currentIteration(t){this.currentTime=this.iterationDuration*yt(+t,0,this.iterationCount-1)}get reversed(){return!!this._reversed}set reversed(t){t?this.reverse():this.play()}get speed(){return super.speed}set speed(t){super.speed=t,this.resetTime()}reset(t=!1){return me(this),this._reversed&&!this._reverse&&(this.reversed=!1),this._iterationTime=this.iterationDuration,Wt(this,0,1,~~t,n.FORCE),pe(this),this._hasChildren&&Et(this,pe),this}init(t=!1){this.fps=this._fps,this.speed=this._speed,!t&&this._hasChildren&&Wt(this,this.duration,1,~~t,n.FORCE),this.reset(t);const e=this._autoplay;return!0===e?this.resume():e&&!q(e.linked)&&e.link(this),this}resetTime(){const t=1/(this._speed*se._speed);return this._startTime=z()-(this._currentTime+this._delay)*t,this}pause(){return this.paused||(this.paused=!0,this.onPause(this)),this}resume(){return this.paused?(this.paused=!1,this.duration<=p&&!this._hasChildren?Wt(this,p,0,0,n.FORCE):(this._running||(Nt(se,this),se._hasChildren=!0,this._running=!0),this.resetTime(),this._startTime-=12,se.wake()),this):this}restart(){return this.reset().resume()}seek(t,e=0,s=0){me(this),this.completed=!1;const i=this.paused;return this.paused=!0,Wt(this,t+this._delay,~~e,~~s,n.AUTO),i?this:this.resume()}alternate(){const t=this._reversed,e=this.iterationCount,s=this.iterationDuration,i=e===1/0?ct(m/s):e;return this._reversed=+(!this._alternate||i%2?!t:t),e===1/0?this.iterationProgress=this._reversed?1-this.iterationProgress:this.iterationProgress:this.seek(s*i-this._currentTime),this.resetTime(),this}play(){return this._reversed&&this.alternate(),this.resume()}reverse(){return this._reversed||this.alternate(),this.resume()}cancel(){return this._hasChildren?Et(this,t=>t.cancel(),!0):Et(this,de),this._cancelled=1,this.pause()}stretch(t){const e=this.duration,s=St(t);if(e===s)return this;const i=t/e,r=t<=p;return this.duration=r?p:s,this.iterationDuration=r?p:St(this.iterationDuration*i),this._offset*=i,this._delay*=i,this._loopDelay*=i,this}revert(){Wt(this,0,1,0,n.AUTO);const t=this._autoplay;return t&&t.linked&&t.linked===this&&t.revert(),this.cancel()}complete(t=0){return this.seek(this.duration,t).cancel()}then(t=x){const e=this.then,s=()=>{this.then=null,t(this),this.then=e,this._resolve=x};return new Promise(t=>(this._resolve=()=>t(s()),this.completed&&this._resolve(),this))}}const ye=t=>new ge(t,null,0).init();function ve(t){const e=Y(t)?O.root.querySelectorAll(t):t;if(e instanceof NodeList||e instanceof HTMLCollection)return e}function _e(e){if(j(e))return[];if(!t)return X(e)&&e.flat(1/0)||[e];if(X(e)){const t=e.flat(1/0),s=[];for(let e=0,i=t.length;e<i;e++){const i=t[e];if(!j(i)){const t=ve(i);if(t)for(let e=0,i=t.length;e<i;e++){const i=t[e];if(!j(i)){let t=!1;for(let e=0,r=s.length;e<r;e++)if(s[e]===i){t=!0;break}t||s.push(i)}}else{let t=!1;for(let e=0,r=s.length;e<r;e++)if(s[e]===i){t=!0;break}t||s.push(i)}}}return s}const s=ve(e);return s?Array.from(s):[e]}function be(t){const e=_e(t),s=e.length;if(s)for(let t=0;t<s;t++){const s=e[t];if(!s[a]){s[a]=!0;const t=G(s);(s.nodeType||t)&&(s[l]=!0,s[h]=t,s[d]={})}}return e}const Te={deg:1,rad:180/ft,turn:360},xe={},Se=(t,e,i,n=!1)=>{const o=e.u,a=e.n;if(e.t===r.UNIT&&o===i)return e;const l=a+o+i,h=xe[l];if(q(h)||n){let r;if(o in Te)r=a*Te[o]/Te[i];else{const e=100,n=t.cloneNode(),l=t.parentNode,h=l&&l!==s?l:s.body;h.appendChild(n);const d=n.style;d.width=e+o;const c=n.offsetWidth||e;d.width=e+i;const u=c/(n.offsetWidth||e);h.removeChild(n),r=u*a}e.n=r,xe[l]=r}else e.n=h;return e.t,e.u=i,e},we=t=>t,$e=(t=1.68)=>e=>rt(e,+t),Ee={in:t=>e=>t(e),out:t=>e=>1-t(1-e),inOut:t=>e=>e<.5?t(2*e)/2:1-t(-2*e+2)/2,outIn:t=>e=>e<.5?(1-t(1-2*e))/2:(t(2*e-1)+1)/2},Ce=ft/2,Ne=2*ft,ke={[y]:$e,Quad:$e(2),Cubic:$e(3),Quart:$e(4),Quint:$e(5),Sine:t=>1-at(t*Ce),Circ:t=>1-nt(1-t*t),Expo:t=>t?rt(2,10*t-10):0,Bounce:t=>{let e,s=4;for(;t<((e=rt(2,--s))-1)/11;);return 1/rt(4,3-s)-7.5625*rt((3*e-2)/22-t,2)},Back:(t=1.7)=>e=>(+t+1)*e*e*e-+t*e*e,Elastic:(t=1,e=.3)=>{const s=yt(+t,1,10),i=yt(+e,p,2),r=i/Ne*ut(1/s),n=Ne/i;return t=>0===t||1===t?t:-s*rt(2,-10*(1-t))*ot((1-t-r)*n)}},Re=(()=>{const t={linear:we,none:we};for(let e in Ee)for(let s in ke){const i=ke[s],r=Ee[e];t[e+s]=s===y||"Back"===s||"Elastic"===s?(t,e)=>r(i(t,e)):r(i)}return t})(),De={linear:we,none:we},Ie=t=>{if(De[t])return De[t];if(t.indexOf("(")<=-1){const e=Ee[t]||t.includes("Back")||t.includes("Elastic")?Re[t]():Re[t];return e?De[t]=e:we}{const e=t.slice(0,-1).split("("),s=Re[e[0]];return s?De[t]=s(...e[1].split(",")):we}},Ae=["steps(","irregular(","linear(","cubicBezier("],Le=t=>{if(Y(t))for(let e=0,s=Ae.length;e<s;e++)if(V(t,Ae[e]))return console.warn(`String syntax for \`ease: "${t}"\` has been removed from the core and replaced by importing and passing the easing function directly: \`ease: ${t}\``),we;return W(t)?t:Y(t)?Ie(t):we},Oe=zt(),Be=zt(),Pe={},Fe={func:null},Me=[null],Ve=[null,null],ze={to:null};let Xe,He,Ue=0,Ye=0;const We=(t,e)=>{const s={};if(X(t)){const e=[].concat(...t.map(t=>Object.keys(t))).filter(tt);for(let i=0,r=e.length;i<r;i++){const r=e[i],n=t.map(t=>{const e={};for(let s in t){const i=t[s];tt(s)?s===r&&(e.to=i):e[s]=i}return e});s[r]=n}}else{const i=Ot(e.duration,B.defaults.duration),r=Object.keys(t).map(e=>({o:parseFloat(e)/100,p:t[e]})).sort((t,e)=>t.o-e.o);r.forEach(t=>{const e=t.o,r=t.p;for(let t in r)if(tt(t)){let n=s[t];n||(n=s[t]=[]);const o=e*i;let a=n.length,l=n[a-1];const h={to:r[t]};let d=0;for(let t=0;t<a;t++)d+=n[t].duration;1===a&&(h.from=l.to),r.ease&&(h.ease=r.ease),h.duration=o-(a?d:0),n.push(h)}return t});for(let t in s){const e=s[t];let i;for(let t=0,s=e.length;t<s;t++){const s=e[t],r=s.ease;s.ease=i||void 0,i=r}e[0].duration||e.shift()}}return s};class qe extends ge{constructor(t,e,s,n,a=!1,l=0,h=0){super(e,s,n),++Ye;const d=be(t),c=d.length,u=e.keyframes,m=u?$t(We(u,e),e):e,{id:g,delay:y,duration:v,ease:_,playbackEase:b,modifier:T,composition:x,onRender:S}=m,w=s?s.defaults:B.defaults,$=Ot(_,w.ease),E=Ot(b,w.playbackEase),C=E?Le(E):null,N=!q($.ease),k=N?$.ease:Ot(_,C?"linear":w.ease),R=N?$.settlingDuration:Ot(v,w.duration),D=Ot(y,w.delay),I=T||w.modifier,A=q(x)&&c>=f?o.none:q(x)?w.composition:x,L=this._offset+(s?s._offset:0);N&&($.parent=this);let O=NaN,P=NaN,F=0,M=0;for(let t=0;t<c;t++){const e=d[t],n=l||t,u=h||c;let f=NaN,g=NaN;for(let t in m)if(tt(t)){const l=Pt(e,t),h=jt(t,e,l);let d=m[t];const c=X(d);if(a&&!c&&(Ve[0]=d,Ve[1]=d,d=Ve),c){const t=d.length,e=!H(d[0]);2===t&&e?(ze.to=d,Me[0]=ze,Xe=Me):t>2&&e?(Xe=[],d.forEach((t,e)=>{e?1===e?(Ve[1]=t,Xe.push(Ve)):Xe.push(t):Ve[0]=t})):Xe=d}else Me[0]=d,Xe=Me;let y=null,v=null,_=NaN,b=0,T=0;for(let t=Xe.length;T<t;T++){const i=Xe[T];H(i)?He=i:(ze.to=i,He=ze),Fe.func=null;const a=Bt(He.to,e,n,u,Fe);let d;H(a)&&!q(a.to)?(He=a,d=a.to):d=a;const c=Bt(He.from,e,n,u),m=He.ease||k,f=Bt(m,e,n,u),g=W(f)||Y(f)?f:m,x=!q(g)&&!q(g.ease),S=x?g.ease:g,w=x?g.settlingDuration:Bt(Ot(He.duration,t>1?Bt(R,e,n,u)/t:R),e,n,u),$=Bt(Ot(He.delay,T?0:D),e,n,u),E=Bt(Ot(He.composition,A),e,n,u),C=U(E)?E:o[E],N=He.modifier||I,O=!q(c),B=!q(d),P=X(d),V=P||O&&B,z=v?b+$:$,G=_t(L+z,12);M||!O&&!P||(M=1);let Q=v;if(C!==o.none){y||(y=oe(e,h));let t=y._head;for(;t&&!t._isOverridden&&t._absoluteStartTime<=G;)if(Q=t,t=t._nextRep,t&&t._absoluteStartTime>=G)for(;t;)le(t),t=t._nextRep}if(V){Xt(P?Bt(d[0],e,n,u):c,Oe),Xt(P?Bt(d[1],e,n,u,Fe):d,Be);const t=Mt(e,h,l,Pe);Oe.t===r.NUMBER&&(Q?Q._valueType===r.UNIT&&(Oe.t=r.UNIT,Oe.u=Q._unit):(Xt(t,Ut),Ut.t===r.UNIT&&(Oe.t=r.UNIT,Oe.u=Ut.u)))}else B?Xt(d,Be):v?Ht(v,Be):Xt(s&&Q&&Q.parent.parent===s?Q._value:Mt(e,h,l,Pe),Be),O?Xt(c,Oe):v?Ht(v,Oe):Xt(s&&Q&&Q.parent.parent===s?Q._value:Mt(e,h,l,Pe),Oe);if(Oe.o&&(Oe.n=Vt(Q?Q._toNumber:Xt(Mt(e,h,l,Pe),Ut).n,Oe.n,Oe.o)),Be.o&&(Be.n=Vt(Oe.n,Be.n,Be.o)),Oe.t!==Be.t)if(Oe.t===r.COMPLEX||Be.t===r.COMPLEX){const t=Oe.t===r.COMPLEX?Oe:Be,e=Oe.t===r.COMPLEX?Be:Oe;e.t=r.COMPLEX,e.s=wt(t.s),e.d=t.d.map(()=>e.n)}else if(Oe.t===r.UNIT||Be.t===r.UNIT){const t=Oe.t===r.UNIT?Oe:Be,e=Oe.t===r.UNIT?Be:Oe;e.t=r.UNIT,e.u=t.u}else if(Oe.t===r.COLOR||Be.t===r.COLOR){const t=Oe.t===r.COLOR?Oe:Be,e=Oe.t===r.COLOR?Be:Oe;e.t=r.COLOR,e.s=t.s,e.d=[0,0,0,1]}if(Oe.u!==Be.u){let t=Be.u?Oe:Be;t=Se(e,t,Be.u?Be.u:Oe.u,!1)}if(Be.d&&Oe.d&&Be.d.length!==Oe.d.length){const t=Oe.d.length>Be.d.length?Oe:Be,e=t===Oe?Be:Oe;e.d=t.d.map((t,s)=>q(e.d[s])?0:e.d[s]),e.s=wt(t.s)}const J=_t(+w||p,12);let Z=Pe[h];j(Z)||(Pe[h]=null);const K={parent:this,id:Ue++,property:h,target:e,_value:null,_func:Fe.func,_ease:Le(S),_fromNumbers:wt(Oe.d),_toNumbers:wt(Be.d),_strings:wt(Be.s),_fromNumber:Oe.n,_toNumber:Be.n,_numbers:wt(Oe.d),_number:Oe.n,_unit:Be.u,_modifier:N,_currentTime:0,_startTime:z,_delay:+$,_updateDuration:J,_changeDuration:J,_absoluteStartTime:G,_tweenType:l,_valueType:Be.t,_composition:C,_isOverlapped:0,_isOverridden:0,_renderTransforms:0,_inlineValue:Z,_prevRep:null,_nextRep:null,_prevAdd:null,_nextAdd:null,_prev:null,_next:null};C!==o.none&&he(K,y),isNaN(_)&&(_=K._startTime),b=_t(z+J,12),v=K,F++,Nt(this,K)}(isNaN(P)||_<P)&&(P=_),(isNaN(O)||b>O)&&(O=b),l===i.TRANSFORM&&(f=F-T,g=F)}if(!isNaN(f)){let t=0;Et(this,e=>{t>=f&&t<g&&(e._renderTransforms=1,e._composition===o.blend&&Et(Jt.animation,t=>{t.id===e.id&&(t._renderTransforms=1)})),t++})}}c||console.warn("No target found. Make sure the element you're trying to animate is accessible before creating your animation."),P?(Et(this,t=>{t._startTime-t._delay||(t._delay-=P),t._startTime-=P}),O-=P):P=0,O||(O=p,this.iterationCount=0),this.targets=d,this.id=q(g)?Ye:g,this.duration=O===p?p:xt((O+this._loopDelay)*this.iterationCount-this._loopDelay)||p,this.onRender=S||w.onRender,this._ease=C,this._delay=P,this.iterationDuration=O,!this._autoplay&&M&&this.onRender(this)}stretch(t){const e=this.duration;if(e===St(t))return this;const s=t/e;return Et(this,t=>{t._updateDuration=St(t._updateDuration*s),t._changeDuration=St(t._changeDuration*s),t._currentTime*=s,t._startTime*=s,t._absoluteStartTime*=s}),super.stretch(t)}refresh(){return Et(this,t=>{const e=t._func;if(e){const s=Mt(t.target,t.property,t._tweenType);Xt(s,Ut),Xt(e(),Be),t._fromNumbers=wt(Ut.d),t._fromNumber=Ut.n,t._toNumbers=wt(Be.d),t._strings=wt(Be.s),t._toNumber=Be.o?Vt(Ut.n,Be.n,Be.o):Be.n}}),this.duration===p&&this.restart(),this}revert(){return super.revert(),Gt(this)}then(t){return super.then(t)}}const je=(t,e)=>new qe(t,e,null,0,!1).init(),Ge={_head:null,_tail:null},Qe=(t,e,s)=>{let i,r=Ge._head;for(;r;){const n=r._next,o=r.$el===t,a=!e||r.property===e,l=!s||r.parent===s;if(o&&a&&l){i=r.animation;try{i.commitStyles()}catch{}i.cancel(),Ct(Ge,r);const t=r.parent;t&&(t._completed++,t.animations.length===t._completed&&(t.completed=!0,t.paused=!0,t.muteCallbacks||(t.onComplete(t),t._resolve(t))))}r=n}return i},Je=(t,e,s,i,r)=>{const n=e.animate(i,r),o=r.delay+ +r.duration*r.iterations;n.playbackRate=t._speed,t.paused&&n.pause(),t.duration<o&&(t.duration=o,t.controlAnimation=n),t.animations.push(n),Qe(e,s),Nt(Ge,{parent:t,animation:n,$el:e,property:s,_next:null,_prev:null});const a=()=>{Qe(e,s,t)};return n.oncancel=a,n.onremove=a,t.persist||(n.onfinish=a),n};function Ze(t,e,s){const i=be(t);if(!i.length)return;const[n]=i,o=Pt(n,e),a=jt(e,n,o);let l=Mt(n,a);if(q(s))return l;if(Xt(l,Ut),Ut.t===r.NUMBER||Ut.t===r.UNIT){if(!1===s)return Ut.n;{const t=Se(n,Ut,s,!1);return`${_t(t.n,B.precision)}${t.u}`}}}const Ke=(t,e)=>{if(!q(e))return e.duration=p,e.composition=Ot(e.composition,o.none),new qe(t,e,null,0,!0).resume()},ts=(t,e,s)=>{const i=_e(t);for(let t=0,r=i.length;t<r;t++)Qe(i[t],s,e&&e.controlAnimation&&e);return ue(i,e,s),i},es=(t,e)=>{if(V(e,"<")){const s="<"===e[1],i=t._tail,r=i?i._offset+i._delay:0;return s?r:r+i.duration}},ss=(t,e)=>{let s=t.iterationDuration;if(s===p&&(s=0),q(e))return s;if(U(+e))return+e;const i=e,r=t?t.labels:null,n=!j(r),o=es(t,i),a=!q(o),l=I.exec(i);if(l){const t=l[0],e=i.split(t),h=n&&e[0]?r[e[0]]:s,d=a?o:n?h:s,c=+e[1];return Vt(d,c,t[0])}return a?o:n?q(r[i])?s:r[i]:s};function is(t){return xt((t.iterationDuration+t._loopDelay)*t.iterationCount-t._loopDelay)||p}function rs(t,e,s,i,r,o){const a=U(t.duration)&&t.duration<=p?s-p:s;e.composition&&Wt(e,a,1,1,n.AUTO);const l=i?new qe(i,t,e,a,!1,r,o):new ge(t,e,a);return e.composition&&l.init(!0),Nt(e,l),Et(e,t=>{const s=t._offset+t._delay+t.duration;s>e.iterationDuration&&(e.iterationDuration=s)}),e.duration=is(e),e}let ns=0;class os extends ge{constructor(t={}){super(t,null,0),++ns,this.id=q(t.id)?ns:t.id,this.duration=0,this.labels={};const e=t.defaults,s=B.defaults;this.defaults=e?$t(e,s):s,this.composition=Ot(t.composition,!0),this.onRender=t.onRender||s.onRender;const i=Ot(t.playbackEase,s.playbackEase);this._ease=i?Le(i):null,this.iterationDuration=0}add(t,e,s){const i=H(e),r=H(t);if(i||r){if(this._hasChildren=!0,i){const i=e;if(W(s)){const e=s,r=_e(t),n=this.duration,o=this.iterationDuration,a=i.id;let l=0;const h=r.length;r.forEach(t=>{const s={...i};this.duration=n,this.iterationDuration=o,q(a)||(s.id=a+"-"+l),rs(s,this,ss(this,e(t,l,h,this)),t,l,h),l++})}else rs(i,this,ss(this,s),t)}else rs(t,this,ss(this,e));return this.composition&&this.init(!0),this}}sync(t,e){if(q(t)||t&&q(t.pause))return this;t.pause();const s=+(t.effect?t.effect.getTiming().duration:t.duration);return this.add(t,{currentTime:[0,s],duration:s,delay:0,ease:"linear",playbackEase:"linear"},e)}set(t,e,s){return q(e)?this:(e.duration=p,e.composition=o.replace,this.add(t,e,s))}call(t,e){return q(t)||t&&!W(t)?this:this.add({duration:0,delay:0,onComplete:()=>t(this)},e)}label(t,e){return q(t)||t&&!Y(t)||(this.labels[t]=ss(this,e)),this}remove(t,e){return ue(_e(t),this,e),this}stretch(t){const e=this.duration;if(e===St(t))return this;const s=t/e,i=this.labels;Et(this,t=>t.stretch(t.duration*s));for(let t in i)i[t]*=s;return super.stretch(t)}refresh(){return Et(this,t=>{t.refresh&&t.refresh()}),this}revert(){return super.revert(),Et(this,t=>t.revert,!0),Gt(this)}then(t){return super.then(t)}}const as=t=>new os(t).init();class ls{constructor(t,e){O.current&&O.current.register(this);const s=()=>{if(this.callbacks.completed)return;let t=!0;for(let e in this.animations)if(!this.animations[e].paused&&t){t=!1;break}t&&this.callbacks.complete()},i={onBegin:()=>{this.callbacks.completed&&this.callbacks.reset(),this.callbacks.play()},onComplete:s,onPause:s},r={v:1,autoplay:!1},n={};if(this.targets=[],this.animations={},this.callbacks=null,!q(t)&&!q(e)){for(let t in e){const s=e[t];tt(t)?n[t]=s:V(t,"on")?r[t]=s:i[t]=s}this.callbacks=new qe({v:0},r);for(let e in n){const s=n[e],r=H(s);let a={},l="+=0";if(r){const t=s.unit;Y(t)&&(l+=t)}else a.duration=s;a[e]=r?$t({to:l},s):l;const h=$t(i,a);h.composition=o.replace,h.autoplay=!1;const d=this.animations[e]=new qe(t,h,null,0,!1).init();this.targets.length||this.targets.push(...d.targets),this[e]=(t,e,s)=>{const i=d._head;if(q(t)&&i){const t=i._numbers;return t&&t.length?t:i._modifier(i._number)}return Et(d,e=>{if(X(t))for(let s=0,i=t.length;s<i;s++)q(e._numbers[s])||(e._fromNumbers[s]=e._modifier(e._numbers[s]),e._toNumbers[s]=t[s]);else e._fromNumber=e._modifier(e._number),e._toNumber=t;q(s)||(e._ease=Le(s)),e._currentTime=0}),q(e)||d.stretch(e),d.reset(!0).resume(),this}}}}revert(){for(let t in this.animations)this[t]=x,this.animations[t].revert();return this.animations={},this.targets.length=0,this.callbacks&&this.callbacks.revert(),this}}const hs=(t,e)=>new ls(t,e),ds=(t,e)=>(+t).toFixed(e),cs=(t,e,s)=>`${t}`.padStart(e,s),us=(t,e,s)=>`${t}`.padEnd(e,s),ps=(t,e,s)=>((t-e)%(s-e)+(s-e))%(s-e)+e,ms=(t,e,s,i,r)=>i+(t-e)/(s-e)*(r-i),fs=t=>t*Math.PI/180,gs=t=>180*t/Math.PI,ys=(t,e,s,i)=>i?1===i?e:Tt(t,e,1-Math.exp(-i*s*.1)):t;var vs=Object.freeze({__proto__:null,clamp:yt,damp:ys,degToRad:fs,lerp:Tt,mapRange:ms,padEnd:us,padStart:cs,radToDeg:gs,round:_t,roundPad:ds,snap:bt,wrap:ps});const _s=10*f;class bs{constructor(t={}){const e=!q(t.bounce)||!q(t.duration);this.timeStep=.02,this.restThreshold=5e-4,this.restDuration=200,this.maxDuration=6e4,this.maxRestSteps=this.restDuration/this.timeStep/f,this.maxIterations=this.maxDuration/this.timeStep/f,this.bn=yt(Ot(t.bounce,.5),-1,1),this.pd=yt(Ot(t.duration,628),10*B.timeScale,_s*B.timeScale),this.m=yt(Ot(t.mass,1),1,_s),this.s=yt(Ot(t.stiffness,100),p,_s),this.d=yt(Ot(t.damping,10),p,_s),this.v=yt(Ot(t.velocity,0),-1e4,_s),this.w0=0,this.zeta=0,this.wd=0,this.b=0,this.completed=!1,this.solverDuration=0,this.settlingDuration=0,this.parent=null,this.onComplete=t.onComplete||x,e&&this.calculateSDFromBD(),this.compute(),this.ease=t=>{const e=t*this.settlingDuration,s=this.completed,i=this.pd;return e>=i&&!s&&(this.completed=!0,this.onComplete(this.parent)),e<i&&s&&(this.completed=!1),0===t||1===t?t:this.solve(t*this.solverDuration)}}solve(t){const{zeta:e,w0:s,wd:i,b:r}=this;let n=t;return n=e<1?ht(-n*e*s)*(1*at(i*n)+r*ot(i*n)):1===e?(1+r*n)*ht(-n*s):((1+r)*ht((-e*s+i)*n)+(1-r)*ht((-e*s-i)*n))/2,1-n}calculateSDFromBD(){const t=1===B.timeScale?this.pd/f:this.pd;this.m=1,this.v=0,this.s=rt(2*ft/t,2),this.bn>=0?this.d=4*(1-this.bn)*ft/t:this.d=4*ft/(t*(1+this.bn)),this.s=_t(yt(this.s,p,_s),3),this.d=_t(yt(this.d,p,300),3)}calculateBDFromSD(){const t=2*ft/nt(this.s);this.pd=t*(1===B.timeScale?f:1);const e=this.d/(2*nt(this.s));this.bn=e<=1?1-this.d*t/(4*ft):4*ft/(this.d*t)-1,this.bn=_t(yt(this.bn,-1,1),3),this.pd=_t(yt(this.pd,10*B.timeScale,_s*B.timeScale),3)}compute(){const{maxRestSteps:t,maxIterations:e,restThreshold:s,timeStep:i,m:r,d:n,s:o,v:a}=this,l=this.w0=yt(nt(o/r),p,f),h=this.zeta=n/(2*nt(o*r));h<1?(this.wd=l*nt(1-h*h),this.b=(h*l-a)/this.wd):1===h?(this.wd=0,this.b=-a+l):(this.wd=l*nt(h*h-1),this.b=(h*l-a)/this.wd);let d=0,c=0,u=0;for(;c<=t&&u<=e;)lt(1-this.solve(d))<s?c++:c=0,this.solverDuration=d,d+=i,u++;this.settlingDuration=_t(this.solverDuration*f,0)*B.timeScale}get bounce(){return this.bn}set bounce(t){this.bn=yt(Ot(t,1),-1,1),this.calculateSDFromBD(),this.compute()}get duration(){return this.pd}set duration(t){this.pd=yt(Ot(t,1),10*B.timeScale,_s*B.timeScale),this.calculateSDFromBD(),this.compute()}get stiffness(){return this.s}set stiffness(t){this.s=yt(Ot(t,100),p,_s),this.calculateBDFromSD(),this.compute()}get damping(){return this.d}set damping(t){this.d=yt(Ot(t,10),p,_s),this.calculateBDFromSD(),this.compute()}get mass(){return this.m}set mass(t){this.m=yt(Ot(t,1),1,_s),this.compute()}get velocity(){return this.v}set velocity(t){this.v=yt(Ot(t,0),-1e4,_s),this.compute()}}const Ts=t=>new bs(t),xs=t=>(console.warn("createSpring() is deprecated use spring() instead"),new bs(t)),Ss=t=>{t.cancelable&&t.preventDefault()};class ws{constructor(t){this.el=t,this.zIndex=0,this.parentElement=null,this.classList={add:x,remove:x}}get x(){return this.el.x||0}set x(t){this.el.x=t}get y(){return this.el.y||0}set y(t){this.el.y=t}get width(){return this.el.width||0}set width(t){this.el.width=t}get height(){return this.el.height||0}set height(t){this.el.height=t}getBoundingClientRect(){return{top:this.y,right:this.x,bottom:this.y+this.height,left:this.x+this.width}}}class $s{constructor(t){this.$el=t,this.inlineTransforms=[],this.point=new DOMPoint,this.inversedMatrix=this.getMatrix().inverse()}normalizePoint(t,e){return this.point.x=t,this.point.y=e,this.point.matrixTransform(this.inversedMatrix)}traverseUp(t){let e=this.$el.parentElement,i=0;for(;e&&e!==s;)t(e,i),e=e.parentElement,i++}getMatrix(){const t=new DOMMatrix;return this.traverseUp(e=>{const s=getComputedStyle(e).transform;if(s){const e=new DOMMatrix(s);t.preMultiplySelf(e)}}),t}remove(){this.traverseUp((t,e)=>{this.inlineTransforms[e]=t.style.transform,t.style.transform="none"})}revert(){this.traverseUp((t,e)=>{const s=this.inlineTransforms[e];""===s?t.style.removeProperty("transform"):t.style.transform=s})}}const Es=(t,e)=>t&&W(t)?t(e):t;let Cs=0;class Ns{constructor(t,i={}){if(!t)return;O.current&&O.current.register(this);const r=i.x,n=i.y,o=i.trigger,a=i.modifier,l=i.releaseEase,h=l&&Le(l),d=!q(l)&&!q(l.ease),c=H(r)&&!q(r.mapTo)?r.mapTo:"translateX",u=H(n)&&!q(n.mapTo)?n.mapTo:"translateY",p=Es(i.container,this);this.containerArray=X(p)?p:null,this.$container=p&&!this.containerArray?_e(p)[0]:s.body,this.useWin=this.$container===s.body,this.$scrollContainer=this.useWin?e:this.$container,this.$target=H(t)?new ws(t):_e(t)[0],this.$trigger=_e(o||t)[0],this.fixed="fixed"===Ze(this.$target,"position"),this.isFinePointer=!0,this.containerPadding=[0,0,0,0],this.containerFriction=0,this.releaseContainerFriction=0,this.snapX=0,this.snapY=0,this.scrollSpeed=0,this.scrollThreshold=0,this.dragSpeed=0,this.dragThreshold=3,this.maxVelocity=0,this.minVelocity=0,this.velocityMultiplier=0,this.cursor=!1,this.releaseXSpring=d?l:Ts({mass:Ot(i.releaseMass,1),stiffness:Ot(i.releaseStiffness,80),damping:Ot(i.releaseDamping,20)}),this.releaseYSpring=d?l:Ts({mass:Ot(i.releaseMass,1),stiffness:Ot(i.releaseStiffness,80),damping:Ot(i.releaseDamping,20)}),this.releaseEase=h||Re.outQuint,this.hasReleaseSpring=d,this.onGrab=i.onGrab||x,this.onDrag=i.onDrag||x,this.onRelease=i.onRelease||x,this.onUpdate=i.onUpdate||x,this.onSettle=i.onSettle||x,this.onSnap=i.onSnap||x,this.onResize=i.onResize||x,this.onAfterResize=i.onAfterResize||x,this.disabled=[0,0];const f={};if(a&&(f.modifier=a),q(r)||!0===r)f[c]=0;else if(H(r)){const t=r,e={};t.modifier&&(e.modifier=t.modifier),t.composition&&(e.composition=t.composition),f[c]=e}else!1===r&&(f[c]=0,this.disabled[0]=1);if(q(n)||!0===n)f[u]=0;else if(H(n)){const t=n,e={};t.modifier&&(e.modifier=t.modifier),t.composition&&(e.composition=t.composition),f[u]=e}else!1===n&&(f[u]=0,this.disabled[1]=1);this.animate=new ls(this.$target,f),this.xProp=c,this.yProp=u,this.destX=0,this.destY=0,this.deltaX=0,this.deltaY=0,this.scroll={x:0,y:0},this.coords=[this.x,this.y,0,0],this.snapped=[0,0],this.pointer=[0,0,0,0,0,0,0,0],this.scrollView=[0,0],this.dragArea=[0,0,0,0],this.containerBounds=[-m,m,m,-m],this.scrollBounds=[0,0,0,0],this.targetBounds=[0,0,0,0],this.window=[0,0],this.velocityStack=[0,0,0],this.velocityStackIndex=0,this.velocityTime=z(),this.velocity=0,this.angle=0,this.cursorStyles=null,this.triggerStyles=null,this.bodyStyles=null,this.targetStyles=null,this.touchActionStyles=null,this.transforms=new $s(this.$target),this.overshootCoords={x:0,y:0},this.overshootTicker=new ge({autoplay:!1,onUpdate:()=>{this.updated=!0,this.manual=!0,this.disabled[0]||this.animate[this.xProp](this.overshootCoords.x,1),this.disabled[1]||this.animate[this.yProp](this.overshootCoords.y,1)},onComplete:()=>{this.manual=!1,this.disabled[0]||this.animate[this.xProp](this.overshootCoords.x,0),this.disabled[1]||this.animate[this.yProp](this.overshootCoords.y,0)}},null,0).init(),this.updateTicker=new ge({autoplay:!1,onUpdate:()=>this.update()},null,0).init(),this.contained=!q(p),this.manual=!1,this.grabbed=!1,this.dragged=!1,this.updated=!1,this.released=!1,this.canScroll=!1,this.enabled=!1,this.initialized=!1,this.activeProp=this.disabled[1]?c:u,this.animate.callbacks.onRender=()=>{const t=this.updated,e=!(this.grabbed&&t)&&this.released,s=this.x,i=this.y,r=s-this.coords[2],n=i-this.coords[3];this.deltaX=r,this.deltaY=n,this.coords[2]=s,this.coords[3]=i,t&&(r||n)&&this.onUpdate(this),e?(this.computeVelocity(r,n),this.angle=mt(n,r)):this.updated=!1},this.animate.callbacks.onComplete=()=>{!this.grabbed&&this.released&&(this.released=!1),this.manual||(this.deltaX=0,this.deltaY=0,this.velocity=0,this.velocityStack[0]=0,this.velocityStack[1]=0,this.velocityStack[2]=0,this.velocityStackIndex=0,this.onSettle(this))},this.resizeTicker=new ge({autoplay:!1,duration:150*B.timeScale,onComplete:()=>{this.onResize(this),this.refresh(),this.onAfterResize(this)}}).init(),this.parameters=i,this.resizeObserver=new ResizeObserver(()=>{this.initialized?this.resizeTicker.restart():this.initialized=!0}),this.enable(),this.refresh(),this.resizeObserver.observe(this.$container),H(t)||this.resizeObserver.observe(this.$target)}computeVelocity(t,e){const s=this.velocityTime,i=z(),r=i-s;if(r<17)return this.velocity;this.velocityTime=i;const n=this.velocityStack,o=this.velocityMultiplier,a=this.minVelocity,l=this.maxVelocity,h=this.velocityStackIndex;n[h]=_t(yt(nt(t*t+e*e)/r*o,a,l),5);const d=pt(n[0],n[1],n[2]);return this.velocity=d,this.velocityStackIndex=(h+1)%3,d}setX(t,e=!1){if(this.disabled[0])return;const s=_t(t,5);return this.overshootTicker.pause(),this.manual=!0,this.updated=!e,this.destX=s,this.snapped[0]=bt(s,this.snapX),this.animate[this.xProp](s,0),this.manual=!1,this}setY(t,e=!1){if(this.disabled[1])return;const s=_t(t,5);return this.overshootTicker.pause(),this.manual=!0,this.updated=!e,this.destY=s,this.snapped[1]=bt(s,this.snapY),this.animate[this.yProp](s,0),this.manual=!1,this}get x(){return _t(this.animate[this.xProp](),B.precision)}set x(t){this.setX(t,!1)}get y(){return _t(this.animate[this.yProp](),B.precision)}set y(t){this.setY(t,!1)}get progressX(){return ms(this.x,this.containerBounds[3],this.containerBounds[1],0,1)}set progressX(t){this.setX(ms(t,0,1,this.containerBounds[3],this.containerBounds[1]),!1)}get progressY(){return ms(this.y,this.containerBounds[0],this.containerBounds[2],0,1)}set progressY(t){this.setY(ms(t,0,1,this.containerBounds[0],this.containerBounds[2]),!1)}updateScrollCoords(){const t=_t(this.useWin?e.scrollX:this.$container.scrollLeft,0),s=_t(this.useWin?e.scrollY:this.$container.scrollTop,0),[i,r,n,o]=this.containerPadding,a=this.scrollThreshold;this.scroll.x=t,this.scroll.y=s,this.scrollBounds[0]=s-this.targetBounds[0]+i-a,this.scrollBounds[1]=t-this.targetBounds[1]-r+a,this.scrollBounds[2]=s-this.targetBounds[2]-n+a,this.scrollBounds[3]=t-this.targetBounds[3]+o-a}updateBoundingValues(){const t=this.$container;if(!t)return;const i=this.x,r=this.y,n=this.coords[2],o=this.coords[3];this.coords[2]=0,this.coords[3]=0,this.setX(0,!0),this.setY(0,!0),this.transforms.remove();const a=this.window[0]=e.innerWidth,l=this.window[1]=e.innerHeight,h=this.useWin,d=t.scrollWidth,c=t.scrollHeight,u=this.fixed,p=t.getBoundingClientRect(),[m,f,g,y]=this.containerPadding;this.dragArea[0]=h?0:p.left,this.dragArea[1]=h?0:p.top,this.scrollView[0]=h?yt(d,a,d):d,this.scrollView[1]=h?yt(c,l,c):c,this.updateScrollCoords();const{width:v,height:_,left:b,top:T,right:x,bottom:S}=t.getBoundingClientRect();this.dragArea[2]=_t(h?yt(v,a,a):v,0),this.dragArea[3]=_t(h?yt(_,l,l):_,0);const w=Ze(t,"overflow"),$="visible"===w,E="hidden"===w;if(this.canScroll=!u&&this.contained&&(t===s.body&&$||!E&&!$)&&(d>this.dragArea[2]+y-f||c>this.dragArea[3]+m-g)&&(!this.containerArray||this.containerArray&&!X(this.containerArray)),this.contained){const e=this.scroll.x,s=this.scroll.y,i=this.canScroll,r=this.$target.getBoundingClientRect(),n=i?h?0:t.scrollLeft:0,o=i?h?0:t.scrollTop:0,d=i?this.scrollView[0]-n-v:0,c=i?this.scrollView[1]-o-_:0;this.targetBounds[0]=_t(r.top+s-(h?0:T),0),this.targetBounds[1]=_t(r.right+e-(h?a:x),0),this.targetBounds[2]=_t(r.bottom+s-(h?l:S),0),this.targetBounds[3]=_t(r.left+e-(h?0:b),0),this.containerArray?(this.containerBounds[0]=this.containerArray[0]+m,this.containerBounds[1]=this.containerArray[1]-f,this.containerBounds[2]=this.containerArray[2]-g,this.containerBounds[3]=this.containerArray[3]+y):(this.containerBounds[0]=-_t(r.top-(u?yt(T,0,l):T)+o-m,0),this.containerBounds[1]=-_t(r.right-(u?yt(x,0,a):x)-d+f,0),this.containerBounds[2]=-_t(r.bottom-(u?yt(S,0,l):S)-c+g,0),this.containerBounds[3]=-_t(r.left-(u?yt(b,0,a):b)+n-y,0))}this.transforms.revert(),this.coords[2]=n,this.coords[3]=o,this.setX(i,!0),this.setY(r,!0)}isOutOfBounds(t,e,s){if(!this.contained)return 0;const[i,r,n,o]=t,[a,l]=this.disabled,h=!a&&e<o||!a&&e>r,d=!l&&s<i||!l&&s>n;return h&&!d?1:!h&&d?2:h&&d?3:0}refresh(){const t=this.parameters,i=t.x,r=t.y,n=Es(t.container,this),o=Es(t.containerPadding,this)||0,a=X(o)?o:[o,o,o,o],l=this.x,h=this.y,d=Es(t.cursor,this),c={onHover:"grab",onGrab:"grabbing"};if(d){const{onHover:t,onGrab:e}=d;t&&(c.onHover=t),e&&(c.onGrab=e)}const u=Es(t.dragThreshold,this),p={mouse:3,touch:7};if(U(u))p.mouse=u,p.touch=u;else if(u){const{mouse:t,touch:e}=u;q(t)||(p.mouse=t),q(e)||(p.touch=e)}this.containerArray=X(n)?n:null,this.$container=n&&!this.containerArray?_e(n)[0]:s.body,this.useWin=this.$container===s.body,this.$scrollContainer=this.useWin?e:this.$container,this.isFinePointer=matchMedia("(pointer:fine)").matches,this.containerPadding=Ot(a,[0,0,0,0]),this.containerFriction=yt(Ot(Es(t.containerFriction,this),.8),0,1),this.releaseContainerFriction=yt(Ot(Es(t.releaseContainerFriction,this),this.containerFriction),0,1),this.snapX=Es(H(i)&&!q(i.snap)?i.snap:t.snap,this),this.snapY=Es(H(r)&&!q(r.snap)?r.snap:t.snap,this),this.scrollSpeed=Ot(Es(t.scrollSpeed,this),1.5),this.scrollThreshold=Ot(Es(t.scrollThreshold,this),20),this.dragSpeed=Ot(Es(t.dragSpeed,this),1),this.dragThreshold=this.isFinePointer?p.mouse:p.touch,this.minVelocity=Ot(Es(t.minVelocity,this),0),this.maxVelocity=Ot(Es(t.maxVelocity,this),50),this.velocityMultiplier=Ot(Es(t.velocityMultiplier,this),1),this.cursor=!1!==d&&c,this.updateBoundingValues();const[m,f,g,y]=this.containerBounds;this.setX(yt(l,y,f),!0),this.setY(yt(h,m,g),!0)}update(){if(this.updateScrollCoords(),this.canScroll){const[t,e,s,i]=this.containerPadding,[r,n]=this.scrollView,o=this.dragArea[2],a=this.dragArea[3],l=this.scroll.x,h=this.scroll.y,d=this.$container.scrollWidth,c=this.$container.scrollHeight,u=this.useWin?yt(d,this.window[0],d):d,p=this.useWin?yt(c,this.window[1],c):c,m=r-u,f=n-p;this.dragged&&m>0&&(this.coords[0]-=m,this.scrollView[0]=u),this.dragged&&f>0&&(this.coords[1]-=f,this.scrollView[1]=p);const g=10*this.scrollSpeed,y=this.scrollThreshold,[v,_]=this.coords,[b,T,x,S]=this.scrollBounds,w=_t(yt((_-b+t)/y,-1,0)*g,0),$=_t(yt((v-T-e)/y,0,1)*g,0),E=_t(yt((_-x-s)/y,0,1)*g,0),C=_t(yt((v-S+i)/y,-1,0)*g,0);if(w||E||C||$){const[t,e]=this.disabled;let s=l,i=h;t||(s=_t(yt(l+(C||$),0,r-o),0),this.coords[0]-=l-s),e||(i=_t(yt(h+(w||E),0,n-a),0),this.coords[1]-=h-i),this.useWin?this.$scrollContainer.scrollBy(-(l-s),-(h-i)):this.$scrollContainer.scrollTo(s,i)}}const[t,e,s,i]=this.containerBounds,[r,n,o,a,l,h]=this.pointer;this.coords[0]+=(r-l)*this.dragSpeed,this.coords[1]+=(n-h)*this.dragSpeed,this.pointer[4]=r,this.pointer[5]=n;const[d,c]=this.coords,[u,p]=this.snapped,m=(1-this.containerFriction)*this.dragSpeed;this.setX(d>e?e+(d-e)*m:d<i?i+(d-i)*m:d,!1),this.setY(c>s?s+(c-s)*m:c<t?t+(c-t)*m:c,!1),this.computeVelocity(r-l,n-h),this.angle=mt(n-a,r-o);const[f,g]=this.snapped;(f!==u&&this.snapX||g!==p&&this.snapY)&&this.onSnap(this)}stop(){this.updateTicker.pause(),this.overshootTicker.pause();for(let t in this.animate.animations)this.animate.animations[t].pause();return ue([this],null,"x"),ue([this],null,"y"),ue([this],null,"progressX"),ue([this],null,"progressY"),ue([this.scroll]),ue([this.overshootCoords]),this}scrollInView(t,e=0,s=Re.inOutQuad){this.updateScrollCoords();const i=this.destX,r=this.destY,n=this.scroll,o=this.scrollBounds,a=this.canScroll;if(!this.containerArray&&this.isOutOfBounds(o,i,r)){const[l,h,d,c]=o,u=_t(yt(r-l,-m,0),0),p=_t(yt(i-h,0,m),0),f=_t(yt(r-d,0,m),0),g=_t(yt(i-c,-m,0),0);new qe(n,{x:_t(n.x+(g?g-e:p?p+e:0),0),y:_t(n.y+(u?u-e:f?f+e:0),0),duration:q(t)?350*B.timeScale:t,ease:s,onUpdate:()=>{this.canScroll=!1,this.$scrollContainer.scrollTo(n.x,n.y)}}).init().then(()=>{this.canScroll=a})}return this}handleHover(){this.isFinePointer&&this.cursor&&!this.cursorStyles&&(this.cursorStyles=Ke(this.$trigger,{cursor:this.cursor.onHover}))}animateInView(t,e=0,s=Re.inOutQuad){this.stop(),this.updateBoundingValues();const i=this.x,r=this.y,[n,o,a,l]=this.containerPadding,h=this.scroll.y-this.targetBounds[0]+n+e,d=this.scroll.x-this.targetBounds[1]-o-e,c=this.scroll.y-this.targetBounds[2]-a-e,u=this.scroll.x-this.targetBounds[3]+l+e,p=this.isOutOfBounds([h,d,c,u],i,r);if(p){const[e,n]=this.disabled,o=yt(bt(i,this.snapX),u,d),a=yt(bt(r,this.snapY),h,c),l=q(t)?350*B.timeScale:t;e||1!==p&&3!==p||this.animate[this.xProp](o,l,s),n||2!==p&&3!==p||this.animate[this.yProp](a,l,s)}return this}handleDown(t){const e=t.target;if(this.grabbed||"range"===e.type)return;t.stopPropagation(),this.grabbed=!0,this.released=!1,this.stop(),this.updateBoundingValues();const i=t.changedTouches,r=i?i[0].clientX:t.clientX,n=i?i[0].clientY:t.clientY,{x:o,y:a}=this.transforms.normalizePoint(r,n),[l,h,d,c]=this.containerBounds,u=(1-this.containerFriction)*this.dragSpeed,p=this.x,m=this.y;this.coords[0]=this.coords[2]=u?p>h?h+(p-h)/u:p<c?c+(p-c)/u:p:p,this.coords[1]=this.coords[3]=u?m>d?d+(m-d)/u:m<l?l+(m-l)/u:m:m,this.pointer[0]=o,this.pointer[1]=a,this.pointer[2]=o,this.pointer[3]=a,this.pointer[4]=o,this.pointer[5]=a,this.pointer[6]=o,this.pointer[7]=a,this.deltaX=0,this.deltaY=0,this.velocity=0,this.velocityStack[0]=0,this.velocityStack[1]=0,this.velocityStack[2]=0,this.velocityStackIndex=0,this.angle=0,this.targetStyles&&(this.targetStyles.revert(),this.targetStyles=null);const f=Ze(this.$target,"zIndex",!1);Cs=(f>Cs?f:Cs)+1,this.targetStyles=Ke(this.$target,{zIndex:Cs}),this.triggerStyles&&(this.triggerStyles.revert(),this.triggerStyles=null),this.cursorStyles&&(this.cursorStyles.revert(),this.cursorStyles=null),this.isFinePointer&&this.cursor&&(this.bodyStyles=Ke(s.body,{cursor:this.cursor.onGrab})),this.scrollInView(100,0,Re.out(3)),this.onGrab(this),s.addEventListener("touchmove",this),s.addEventListener("touchend",this),s.addEventListener("touchcancel",this),s.addEventListener("mousemove",this),s.addEventListener("mouseup",this),s.addEventListener("selectstart",this)}handleMove(t){if(!this.grabbed)return;const e=t.changedTouches,s=e?e[0].clientX:t.clientX,i=e?e[0].clientY:t.clientY,{x:r,y:n}=this.transforms.normalizePoint(s,i),o=r-this.pointer[6],a=n-this.pointer[7];let l=t.target,h=!1,d=!1,c=!1;for(;e&&l&&l!==this.$trigger;){const t=Ze(l,"overflow-y");if("hidden"!==t&&"visible"!==t){const{scrollTop:t,scrollHeight:e,clientHeight:s}=l;if(e>s){c=!0,h=t<=3,d=t>=e-s-3;break}}l=l.parentElement}c&&(!h&&!d||h&&a<0||d&&a>0)?(this.pointer[0]=r,this.pointer[1]=n,this.pointer[2]=r,this.pointer[3]=n,this.pointer[4]=r,this.pointer[5]=n,this.pointer[6]=r,this.pointer[7]=n):(Ss(t),this.triggerStyles||(this.triggerStyles=Ke(this.$trigger,{pointerEvents:"none"})),this.$trigger.addEventListener("touchstart",Ss,{passive:!1}),this.$trigger.addEventListener("touchmove",Ss,{passive:!1}),this.$trigger.addEventListener("touchend",Ss),(this.dragged||!this.disabled[0]&&lt(o)>this.dragThreshold||!this.disabled[1]&&lt(a)>this.dragThreshold)&&(this.updateTicker.resume(),this.pointer[2]=this.pointer[0],this.pointer[3]=this.pointer[1],this.pointer[0]=r,this.pointer[1]=n,this.dragged=!0,this.released=!1,this.onDrag(this)))}handleUp(){if(!this.grabbed)return;this.updateTicker.pause(),this.triggerStyles&&(this.triggerStyles.revert(),this.triggerStyles=null),this.bodyStyles&&(this.bodyStyles.revert(),this.bodyStyles=null);const[t,e]=this.disabled,[i,r,n,a,l,h]=this.pointer,[d,c,u,p]=this.containerBounds,[m,f]=this.snapped,g=this.releaseXSpring,y=this.releaseYSpring,v=this.releaseEase,_=this.hasReleaseSpring,b=this.overshootCoords,T=this.x,x=this.y,S=this.computeVelocity(i-l,r-h),w=this.angle=mt(r-a,i-n),$=150*S,E=(1-this.releaseContainerFriction)*this.dragSpeed,C=T+at(w)*$,N=x+ot(w)*$,k=C>c?c+(C-c)*E:C<p?p+(C-p)*E:C,R=N>u?u+(N-u)*E:N<d?d+(N-d)*E:N,D=this.destX=yt(_t(bt(k,this.snapX),5),p,c),I=this.destY=yt(_t(bt(R,this.snapY),5),d,u),A=this.isOutOfBounds(this.containerBounds,C,N);let L=0,O=0,P=v,F=v,M=0;if(b.x=T,b.y=x,!t){const t=D===c?T>c?-1:1:T<p?-1:1,s=_t(T-D,0);g.velocity=e&&_?s?$*t/lt(s):0:S;const{ease:i,settlingDuration:r,restDuration:n}=g;L=T===D?0:_?r:r-n*B.timeScale,_&&(P=i),L>M&&(M=L)}if(!e){const e=I===u?x>u?-1:1:x<d?-1:1,s=_t(x-I,0);y.velocity=t&&_?s?$*e/lt(s):0:S;const{ease:i,settlingDuration:r,restDuration:n}=y;O=x===I?0:_?r:r-n*B.timeScale,_&&(F=i),O>M&&(M=O)}if(!_&&A&&E&&(L||O)){const t=o.blend;new qe(b,{x:{to:k,duration:.65*L},y:{to:R,duration:.65*O},ease:v,composition:t}).init(),new qe(b,{x:{to:D,duration:L},y:{to:I,duration:O},ease:v,composition:t}).init(),this.overshootTicker.stretch(pt(L,O)).restart()}else t||this.animate[this.xProp](D,L,P),e||this.animate[this.yProp](I,O,F);this.scrollInView(M,this.scrollThreshold,v);let V=!1;D!==m&&(this.snapped[0]=D,this.snapX&&(V=!0)),I!==f&&this.snapY&&(this.snapped[1]=I,this.snapY&&(V=!0)),V&&this.onSnap(this),this.grabbed=!1,this.dragged=!1,this.updated=!0,this.released=!0,this.onRelease(this),this.$trigger.removeEventListener("touchstart",Ss),this.$trigger.removeEventListener("touchmove",Ss),this.$trigger.removeEventListener("touchend",Ss),s.removeEventListener("touchmove",this),s.removeEventListener("touchend",this),s.removeEventListener("touchcancel",this),s.removeEventListener("mousemove",this),s.removeEventListener("mouseup",this),s.removeEventListener("selectstart",this)}reset(){return this.stop(),this.resizeTicker.pause(),this.grabbed=!1,this.dragged=!1,this.updated=!1,this.released=!1,this.canScroll=!1,this.setX(0,!0),this.setY(0,!0),this.coords[0]=0,this.coords[1]=0,this.pointer[0]=0,this.pointer[1]=0,this.pointer[2]=0,this.pointer[3]=0,this.pointer[4]=0,this.pointer[5]=0,this.pointer[6]=0,this.pointer[7]=0,this.velocity=0,this.velocityStack[0]=0,this.velocityStack[1]=0,this.velocityStack[2]=0,this.velocityStackIndex=0,this.angle=0,this}enable(){return this.enabled||(this.enabled=!0,this.$target.classList.remove("is-disabled"),this.touchActionStyles=Ke(this.$trigger,{touchAction:this.disabled[0]?"pan-x":this.disabled[1]?"pan-y":"none"}),this.$trigger.addEventListener("touchstart",this,{passive:!0}),this.$trigger.addEventListener("mousedown",this,{passive:!0}),this.$trigger.addEventListener("mouseenter",this)),this}disable(){return this.enabled=!1,this.grabbed=!1,this.dragged=!1,this.updated=!1,this.released=!1,this.canScroll=!1,this.touchActionStyles.revert(),this.cursorStyles&&(this.cursorStyles.revert(),this.cursorStyles=null),this.triggerStyles&&(this.triggerStyles.revert(),this.triggerStyles=null),this.bodyStyles&&(this.bodyStyles.revert(),this.bodyStyles=null),this.targetStyles&&(this.targetStyles.revert(),this.targetStyles=null),this.$target.classList.add("is-disabled"),this.$trigger.removeEventListener("touchstart",this),this.$trigger.removeEventListener("mousedown",this),this.$trigger.removeEventListener("mouseenter",this),s.removeEventListener("touchmove",this),s.removeEventListener("touchend",this),s.removeEventListener("touchcancel",this),s.removeEventListener("mousemove",this),s.removeEventListener("mouseup",this),s.removeEventListener("selectstart",this),this}revert(){return this.reset(),this.disable(),this.$target.classList.remove("is-disabled"),this.updateTicker.revert(),this.overshootTicker.revert(),this.resizeTicker.revert(),this.animate.revert(),this.resizeObserver.disconnect(),this}handleEvent(t){switch(t.type){case"mousedown":case"touchstart":this.handleDown(t);break;case"mousemove":case"touchmove":this.handleMove(t);break;case"mouseup":case"touchend":case"touchcancel":this.handleUp();break;case"mouseenter":this.handleHover();break;case"selectstart":Ss(t)}}}const ks=(t,e)=>new Ns(t,e),Rs=(t=x)=>new ge({duration:1*B.timeScale,onComplete:t},null,0).resume(),Ds=t=>{let e;return(...s)=>{let i,r,n,o;e&&(i=e.currentIteration,r=e.iterationProgress,n=e.reversed,o=e._alternate,e.revert());const a=t(...s);return a&&!W(a)&&a.revert&&(e=a),q(r)||(e.currentIteration=i,e.iterationProgress=(o&&i%2?!n:n)?1-r:r),a||x}};class Is{constructor(t={}){O.current&&O.current.register(this);const i=t.root;let r=s;i&&(r=i.current||i.nativeElement||_e(i)[0]||s);const n=t.defaults,o=B.defaults,a=t.mediaQueries;if(this.defaults=n?$t(n,o):o,this.root=r,this.constructors=[],this.revertConstructors=[],this.revertibles=[],this.constructorsOnce=[],this.revertConstructorsOnce=[],this.revertiblesOnce=[],this.once=!1,this.onceIndex=0,this.methods={},this.matches={},this.mediaQueryLists={},this.data={},a)for(let t in a){const s=e.matchMedia(a[t]);this.mediaQueryLists[t]=s,s.addEventListener("change",this)}}register(t){(this.once?this.revertiblesOnce:this.revertibles).push(t)}execute(t){let e=O.current,s=O.root,i=B.defaults;O.current=this,O.root=this.root,B.defaults=this.defaults;const r=this.mediaQueryLists;for(let t in r)this.matches[t]=r[t].matches;const n=t(this);return O.current=e,O.root=s,B.defaults=i,n}refresh(){return this.onceIndex=0,this.execute(()=>{let t=this.revertibles.length,e=this.revertConstructors.length;for(;t--;)this.revertibles[t].revert();for(;e--;)this.revertConstructors[e](this);this.revertibles.length=0,this.revertConstructors.length=0,this.constructors.forEach(t=>{const e=t(this);W(e)&&this.revertConstructors.push(e)})}),this}add(t,e){if(this.once=!1,W(t)){const e=t;this.constructors.push(e),this.execute(()=>{const t=e(this);W(t)&&this.revertConstructors.push(t)})}else this.methods[t]=(...t)=>this.execute(()=>e(...t));return this}addOnce(t){if(this.once=!0,W(t)){const e=this.onceIndex++;if(this.constructorsOnce[e])return this;const s=t;this.constructorsOnce[e]=s,this.execute(()=>{const t=s(this);W(t)&&this.revertConstructorsOnce.push(t)})}return this}keepTime(t){this.once=!0;const e=this.onceIndex++,s=this.constructorsOnce[e];if(W(s))return s(this);const i=Ds(t);let r;return this.constructorsOnce[e]=i,this.execute(()=>{r=i(this)}),r}handleEvent(t){"change"===t.type&&this.refresh()}revert(){const t=this.revertibles,e=this.revertConstructors,s=this.revertiblesOnce,i=this.revertConstructorsOnce,r=this.mediaQueryLists;let n=t.length,o=e.length,a=s.length,l=i.length;for(;n--;)t[n].revert();for(;o--;)e[o](this);for(;a--;)s[a].revert();for(;l--;)i[l](this);for(let t in r)r[t].removeEventListener("change",this);t.length=0,e.length=0,this.constructors.length=0,s.length=0,i.length=0,this.constructorsOnce.length=0,this.onceIndex=0,this.matches={},this.methods={},this.mediaQueryLists={},this.data={}}}const As=t=>new Is(t),Ls=()=>{const t=s.createElement("div");s.body.appendChild(t),t.style.height="100lvh";const e=t.offsetHeight;return s.body.removeChild(t),e},Os=(t,e)=>t&&W(t)?t(e):t,Bs=new Map;class Ps{constructor(t){this.element=t,this.useWin=this.element===s.body,this.winWidth=0,this.winHeight=0,this.width=0,this.height=0,this.left=0,this.top=0,this.scale=1,this.zIndex=0,this.scrollX=0,this.scrollY=0,this.prevScrollX=0,this.prevScrollY=0,this.scrollWidth=0,this.scrollHeight=0,this.velocity=0,this.backwardX=!1,this.backwardY=!1,this.scrollTicker=new ge({autoplay:!1,onBegin:()=>this.dataTimer.resume(),onUpdate:()=>{const t=this.backwardX||this.backwardY;Et(this,t=>t.handleScroll(),t)},onComplete:()=>this.dataTimer.pause()}).init(),this.dataTimer=new ge({autoplay:!1,frameRate:30,onUpdate:t=>{const e=t.deltaTime,s=this.prevScrollX,i=this.prevScrollY,r=this.scrollX,n=this.scrollY,o=s-r,a=i-n;this.prevScrollX=r,this.prevScrollY=n,o&&(this.backwardX=s>r),a&&(this.backwardY=i>n),this.velocity=_t(e>0?Math.sqrt(o*o+a*a)/e:0,5)}}).init(),this.resizeTicker=new ge({autoplay:!1,duration:250*B.timeScale,onComplete:()=>{this.updateWindowBounds(),this.refreshScrollObservers(),this.handleScroll()}}).init(),this.wakeTicker=new ge({autoplay:!1,duration:500*B.timeScale,onBegin:()=>{this.scrollTicker.resume()},onComplete:()=>{this.scrollTicker.pause()}}).init(),this._head=null,this._tail=null,this.updateScrollCoords(),this.updateWindowBounds(),this.updateBounds(),this.refreshScrollObservers(),this.handleScroll(),this.resizeObserver=new ResizeObserver(()=>this.resizeTicker.restart()),this.resizeObserver.observe(this.element),(this.useWin?e:this.element).addEventListener("scroll",this,!1)}updateScrollCoords(){const t=this.useWin,s=this.element;this.scrollX=_t(t?e.scrollX:s.scrollLeft,0),this.scrollY=_t(t?e.scrollY:s.scrollTop,0)}updateWindowBounds(){this.winWidth=e.innerWidth,this.winHeight=Ls()}updateBounds(){const t=getComputedStyle(this.element),e=this.element;let s,i;if(this.scrollWidth=e.scrollWidth+parseFloat(t.marginLeft)+parseFloat(t.marginRight),this.scrollHeight=e.scrollHeight+parseFloat(t.marginTop)+parseFloat(t.marginBottom),this.updateWindowBounds(),this.useWin)s=this.winWidth,i=this.winHeight;else{const t=e.getBoundingClientRect();s=e.clientWidth,i=e.clientHeight,this.top=t.top,this.left=t.left,this.scale=t.width?s/t.width:t.height?i/t.height:1}this.width=s,this.height=i}refreshScrollObservers(){Et(this,t=>{t._debug&&t.removeDebug()}),this.updateBounds(),Et(this,t=>{t.refresh(),t._debug&&t.debug()})}refresh(){this.updateWindowBounds(),this.updateBounds(),this.refreshScrollObservers(),this.handleScroll()}handleScroll(){this.updateScrollCoords(),this.wakeTicker.restart()}handleEvent(t){"scroll"===t.type&&this.handleScroll()}revert(){this.scrollTicker.cancel(),this.dataTimer.cancel(),this.resizeTicker.cancel(),this.wakeTicker.cancel(),this.resizeObserver.disconnect(),(this.useWin?e:this.element).removeEventListener("scroll",this),Bs.delete(this.element)}}const Fs=t=>{const e=t&&_e(t)[0]||s.body;let i=Bs.get(e);return i||(i=new Ps(e),Bs.set(e,i)),i},Ms=(t,e,s,i,r)=>{const n="min"===e,o="max"===e,a="top"===e||"left"===e||"start"===e||n?0:"bottom"===e||"right"===e||"end"===e||o?"100%":"center"===e?"50%":e,{n:l,u:h}=Xt(a,Ut);let d=l;return"%"===h?d=l/100*s:h&&(d=Se(t,Ut,"px",!0).n),o&&i<0&&(d+=i),n&&r>0&&(d+=r),d},Vs=(t,e,s,i,r)=>{let n;if(Y(e)){const o=I.exec(e);if(o){const a=o[0],l=a[0],h=e.split(a),d="min"===h[0],c="max"===h[0],u=Ms(t,h[0],s,i,r),p=Ms(t,h[1],s,i,r);if(d){const e=Vt(Ms(t,"min",s),p,l);n=e<u?u:e}else if(c){const e=Vt(Ms(t,"max",s),p,l);n=e>u?u:e}else n=Vt(u,p,l)}else n=Ms(t,e,s,i,r)}else n=e;return _t(n,0)},zs=t=>{let e;const s=t.targets;for(let t=0,i=s.length;t<i;t++){const i=s[t];if(i[l]){e=i;break}}return e};let Xs=0;const Hs=["#FF4B4B","#FF971B","#FFC730","#F9F640","#7AFF5A","#18FF74","#17E09B","#3CFFEC","#05DBE9","#33B3F1","#638CF9","#C563FE","#FF4FCF","#F93F8A"];class Us{constructor(t={}){O.current&&O.current.register(this);const e=Ot(t.sync,"play pause"),i=e?Le(e):null,r=e&&("linear"===e||e===we),n=e&&!(i===we&&!r),o=e&&(U(e)||!0===e||r),a=e&&Y(e)&&!n&&!o,l=a?e.split(" ").map(t=>()=>{const e=this.linked;return e&&e[t]?e[t]():null}):null,h=a&&l.length>2;this.index=Xs++,this.id=q(t.id)?this.index:t.id,this.container=Fs(t.container),this.target=null,this.linked=null,this.repeat=null,this.horizontal=null,this.enter=null,this.leave=null,this.sync=n||o||!!l,this.syncEase=n?i:null,this.syncSmooth=o?!0===e||r?1:e:null,this.onSyncEnter=l&&!h&&l[0]?l[0]:x,this.onSyncLeave=l&&!h&&l[1]?l[1]:x,this.onSyncEnterForward=l&&h&&l[0]?l[0]:x,this.onSyncLeaveForward=l&&h&&l[1]?l[1]:x,this.onSyncEnterBackward=l&&h&&l[2]?l[2]:x,this.onSyncLeaveBackward=l&&h&&l[3]?l[3]:x,this.onEnter=t.onEnter||x,this.onLeave=t.onLeave||x,this.onEnterForward=t.onEnterForward||x,this.onLeaveForward=t.onLeaveForward||x,this.onEnterBackward=t.onEnterBackward||x,this.onLeaveBackward=t.onLeaveBackward||x,this.onUpdate=t.onUpdate||x,this.onSyncComplete=t.onSyncComplete||x,this.reverted=!1,this.ready=!1,this.completed=!1,this.began=!1,this.isInView=!1,this.forceEnter=!1,this.hasEntered=!1,this.offset=0,this.offsetStart=0,this.offsetEnd=0,this.distance=0,this.prevProgress=0,this.thresholds=["start","end","end","start"],this.coords=[0,0,0,0],this.debugStyles=null,this.$debug=null,this._params=t,this._debug=Ot(t.debug,!1),this._next=null,this._prev=null,Nt(this.container,this),Rs(()=>{if(!this.reverted){if(!this.target){const e=_e(t.target)[0];this.target=e||s.body,this.refresh()}this._debug&&this.debug()}})}link(t){if(t&&(t.pause(),this.linked=t,q(t)||(t.persist=!0),!this._params.target)){let e;q(t.targets)?Et(t,t=>{t.targets&&!e&&(e=zs(t))}):e=zs(t),this.target=e||s.body,this.refresh()}return this}get velocity(){return this.container.velocity}get backward(){return this.horizontal?this.container.backwardX:this.container.backwardY}get scroll(){return this.horizontal?this.container.scrollX:this.container.scrollY}get progress(){const t=(this.scroll-this.offsetStart)/this.distance;return t===1/0||isNaN(t)?0:_t(yt(t,0,1),6)}refresh(){this.ready=!0,this.reverted=!1;const t=this._params;return this.repeat=Ot(Os(t.repeat,this),!0),this.horizontal="x"===Ot(Os(t.axis,this),"y"),this.enter=Ot(Os(t.enter,this),"end start"),this.leave=Ot(Os(t.leave,this),"start end"),this.updateBounds(),this.handleScroll(),this}removeDebug(){return this.$debug&&(this.$debug.parentNode.removeChild(this.$debug),this.$debug=null),this.debugStyles&&(this.debugStyles.revert(),this.$debug=null),this}debug(){this.removeDebug();const t=this.container,e=this.horizontal,i=t.element.querySelector(":scope > .animejs-onscroll-debug"),r=s.createElement("div"),n=s.createElement("div"),o=s.createElement("div"),a=Hs[this.index%Hs.length],l=t.useWin,h=l?t.winWidth:t.width,d=l?t.winHeight:t.height,c=t.scrollWidth,u=t.scrollHeight,p=this.container.width>360?320:260,m=e?0:10,f=e?10:0,g=e?24:p/2,y=e?g:15,v=e?60:g,_=e?v:y,b=e?"repeat-x":"repeat-y",T=t=>e?"0px "+t+"px":t+"px 2px",x=t=>`linear-gradient(${e?90:0}deg, ${t} 2px, transparent 1px)`,S=(t,e,s,i,r)=>`position:${t};left:${e}px;top:${s}px;width:${i}px;height:${r}px;`;r.style.cssText=`${S("absolute",m,f,e?c:p,e?p:u)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${e?"column":"row"};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `,n.style.cssText=`${S("sticky",0,0,e?h:g,e?g:d)}`,i||(n.style.cssText+=`background:\n        ${x("#FFFF")}${T(g-10)} / 100px 100px ${b},\n        ${x("#FFF8")}${T(g-10)} / 10px 10px ${b};\n      `),o.style.cssText=`${S("relative",0,0,e?c:g,e?g:u)}`,i||(o.style.cssText+=`background:\n        ${x("#FFFF")}${T(0)} / ${e?"100px 10px":"10px 100px"} ${b},\n        ${x("#FFF8")}${T(0)} / ${e?"10px 0px":"0px 10px"} ${b};\n      `);const w=[" enter: "," leave: "];this.coords.forEach((t,i)=>{const r=i>1,l=(r?0:this.offset)+t,m=i%2,f=l<_,g=l>(r?e?h:d:e?c:u)-_,b=(r?m&&!f:!m&&!f)||g,T=s.createElement("div"),x=s.createElement("div"),$=e?b?"right":"left":b?"bottom":"top",E=b?(e?v:y)+(r?e?-1:g?0:-2:e?-1:-2):e?1:0;x.innerHTML=`${this.id}${w[m]}${this.thresholds[i]}`,T.style.cssText=`${S("absolute",0,0,v,y)}\n        display: flex;\n        flex-direction: ${e?"column":"row"};\n        justify-content: flex-${r?"start":"end"};\n        align-items: flex-${b?"end":"start"};\n        border-${$}: 2px solid ${a};\n      `,x.style.cssText=`\n        overflow: hidden;\n        max-width: ${p/2-10}px;\n        height: ${y};\n        margin-${e?b?"right":"left":b?"bottom":"top"}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${e&&b||!e&&!r?"right":"left"};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${m?a:"rgba(0,0,0,.75)"};\n        background-color: ${m?"rgba(0,0,0,.65)":a};\n        border: 2px solid ${m?a:"transparent"};\n        border-${e?b?"top-left":"top-right":b?"top-left":"bottom-left"}-radius: 5px;\n        border-${e?b?"bottom-left":"bottom-right":b?"top-right":"bottom-right"}-radius: 5px;\n      `,T.appendChild(x);let C=l-E+(e?1:0);T.style[e?"left":"top"]=`${C}px`,(r?n:o).appendChild(T)}),r.appendChild(n),r.appendChild(o),t.element.appendChild(r),i||r.classList.add("animejs-onscroll-debug"),this.$debug=r,"static"===Ze(t.element,"position")&&(this.debugStyles=Ke(t.element,{position:"relative "}))}updateBounds(){let t;this._debug&&this.removeDebug();const e=this.target,i=this.container,r=this.horizontal,n=this.linked;let o,a=e;for(n&&(o=n.currentTime,n.seek(0,!0)),a.parentElement;a&&a!==i.element&&a!==s.body;){const e="sticky"===Ze(a,"position")&&Ke(a,{position:"static"});a=a.parentElement,e&&(t||(t=[]),t.push(e))}const l=e.getBoundingClientRect(),h=i.scale,d=(r?l.left+i.scrollX-i.left:l.top+i.scrollY-i.top)*h,c=(r?l.width:l.height)*h,u=r?i.width:i.height,p=(r?i.scrollWidth:i.scrollHeight)-u,m=this.enter,f=this.leave;let g="start",y="end",v="end",_="start";if(Y(m)){const t=m.split(" ");v=t[0],g=t.length>1?t[1]:g}else if(H(m)){const t=m;q(t.container)||(v=t.container),q(t.target)||(g=t.target)}else U(m)&&(v=m);if(Y(f)){const t=f.split(" ");_=t[0],y=t.length>1?t[1]:y}else if(H(f)){const t=f;q(t.container)||(_=t.container),q(t.target)||(y=t.target)}else U(f)&&(_=f);const b=Vs(e,g,c),T=Vs(e,y,c),x=b+d-u,S=T+d-p,w=Vs(e,v,u,x,S),$=Vs(e,_,u,x,S),E=b+d-w,C=T+d-$,N=C-E;this.offset=d,this.offsetStart=E,this.offsetEnd=C,this.distance=N<=0?0:N,this.thresholds=[g,y,v,_],this.coords=[b,T,w,$],t&&t.forEach(t=>t.revert()),n&&n.seek(o,!0),this._debug&&this.debug()}handleScroll(){if(!this.ready)return;const t=this.linked,e=this.sync,s=this.syncEase,i=this.syncSmooth,r=t&&(s||i),n=this.horizontal,o=this.container,a=this.scroll,l=a<=this.offsetStart,h=a>=this.offsetEnd,d=!l&&!h,c=a===this.offsetStart||a===this.offsetEnd,u=!this.hasEntered&&c,p=this._debug&&this.$debug;let m=!1,f=!1,g=this.progress;if(l&&this.began&&(this.began=!1),g>0&&!this.began&&(this.began=!0),r){const e=t.progress;if(i&&U(i)){if(i<1){const t=1e-4,s=e<g&&1===g?t:e>g&&!g?-t:0;g=_t(Tt(e,g,Tt(.01,.2,i))+s,6)}}else s&&(g=s(g));m=g!==this.prevProgress,f=1===e,m&&!f&&i&&e&&o.wakeTicker.restart()}if(p){const t=n?o.scrollY:o.scrollX;p.style[n?"top":"left"]=t+10+"px"}(d&&!this.isInView||u&&!this.forceEnter&&!this.hasEntered)&&(d&&(this.isInView=!0),this.forceEnter&&this.hasEntered?d&&(this.forceEnter=!1):(p&&d&&(p.style.zIndex=""+this.container.zIndex++),this.onSyncEnter(this),this.onEnter(this),this.backward?(this.onSyncEnterBackward(this),this.onEnterBackward(this)):(this.onSyncEnterForward(this),this.onEnterForward(this)),this.hasEntered=!0,u&&(this.forceEnter=!0))),(d||!d&&this.isInView)&&(m=!0),m&&(r&&t.seek(t.duration*g),this.onUpdate(this)),!d&&this.isInView&&(this.isInView=!1,this.onSyncLeave(this),this.onLeave(this),this.backward?(this.onSyncLeaveBackward(this),this.onLeaveBackward(this)):(this.onSyncLeaveForward(this),this.onLeaveForward(this)),e&&!i&&(f=!0)),g>=1&&this.began&&!this.completed&&(e&&f||!e)&&(e&&this.onSyncComplete(this),this.completed=!0,(!this.repeat&&!t||!this.repeat&&t&&t.completed)&&this.revert()),g<1&&this.completed&&(this.completed=!1),this.prevProgress=g}revert(){if(this.reverted)return;const t=this.container;return Ct(t,this),t._head||t.revert(),this._debug&&this.removeDebug(),this.reverted=!0,this.ready=!1,this}}const Ys=(t={})=>new Us(t),Ws=(t,e,s)=>(((1-3*s+3*e)*t+(3*s-6*e))*t+3*e)*t,qs=(t,e,s)=>{let i,r,n=0,o=1,a=0;do{r=n+(o-n)/2,i=Ws(r,e,s)-t,i>0?o=r:n=r}while(lt(i)>1e-7&&++a<100);return r},js=(t=.5,e=0,s=.5,i=1)=>t===e&&s===i?we:r=>0===r||1===r?r:Ws(qs(r,t,s),e,i),Gs=(t=10,e)=>{const s=e?dt:ct;return e=>s(yt(e,0,1)*t)*(1/t)},Qs=(...t)=>{const e=t.length;if(!e)return we;const s=e-1,i=t[0],r=t[s],n=[0],o=[it(i)];for(let e=1;e<s;e++){const i=t[e],r=Y(i)?i.trim().split(" "):[i],a=r[0],l=r[1];n.push(q(l)?e/s:it(l)/100),o.push(it(a))}return o.push(it(r)),n.push(1),function(t){for(let e=1,s=n.length;e<s;e++){const s=n[e];if(t<=s){const i=n[e-1],r=o[e-1];return r+(o[e]-r)*(t-i)/(s-i)}}return o[o.length-1]}},Js=(t=10,e=1)=>{const s=[0],i=t-1;for(let t=1;t<i;t++){const r=s[t-1],n=t/i,o=n*(1-e)+(n+((t+1)/i-n)*Math.random())*e;s.push(yt(o,r,1))}return s.push(1),Qs(...s)};var Zs=Object.freeze({__proto__:null,Spring:bs,createSpring:xs,cubicBezier:js,eases:Re,irregular:Js,linear:Qs,spring:Ts,steps:Gs});const Ks=(t,e=100)=>{const s=[];for(let i=0;i<=e;i++)s.push(_t(t(i/e),4));return`linear(${s.join(", ")})`},ti={},ei=t=>{let e=ti[t];if(e)return e;if(e="linear",Y(t)){if(V(t,"linear")||V(t,"cubic-")||V(t,"steps")||V(t,"ease"))e=t;else if(V(t,"cubicB"))e=M(t);else{const s=Ie(t);W(s)&&(e=s===we?"linear":Ks(s))}ti[t]=e}else if(W(t)){const s=Ks(t);s&&(e=s)}else t.ease&&(e=Ks(t.ease));return e},si=["x","y","z"],ii=["perspective","width","height","margin","padding","top","right","bottom","left","borderWidth","fontSize","borderRadius",...si],ri=(()=>[...si,...b.filter(t=>["X","Y","Z"].some(e=>t.endsWith(e)))])();let ni=null;const oi=(t,e,s,i,r)=>{let n=Y(e)?e:Bt(e,s,i,r);return U(n)?ii.includes(t)||V(t,"translate")?`${n}px`:V(t,"rotate")||V(t,"skew")?`${n}deg`:`${n}`:n},ai=(t,e,s,i,r,n)=>{let o="0";const a=q(i)?getComputedStyle(t)[e]:oi(e,i,t,r,n);return o=q(s)?X(i)?i.map(s=>oi(e,s,t,r,n)):a:[oi(e,s,t,r,n),a],o};class li{constructor(e,s){O.current&&O.current.register(this),j(ni)&&(!t||!q(CSS)&&Object.hasOwnProperty.call(CSS,"registerProperty")?(b.forEach(t=>{const e=V(t,"skew"),s=V(t,"scale"),i=V(t,"rotate"),r=V(t,"translate"),n=i||e,o=n?"<angle>":s?"<number>":r?"<length-percentage>":"*";try{CSS.registerProperty({name:"--"+t,syntax:o,inherits:!1,initialValue:r?"0px":n?"0deg":s?"1":"0"})}catch{}}),ni=!0):ni=!1);const i=be(e),r=i.length;r||console.warn("No target found. Make sure the element you're trying to animate is accessible before creating your animation.");const n=Ot(s.autoplay,B.defaults.autoplay),o=!(!n||!n.link)&&n,a=s.alternate&&!0===s.alternate,l=s.reversed&&!0===s.reversed,h=Ot(s.loop,B.defaults.loop),c=!0===h||h===1/0?1/0:U(h)?h+1:1,u=a?l?"alternate-reverse":"alternate":l?"reverse":"normal",p=1===B.timeScale?1:f;this.targets=i,this.animations=[],this.controlAnimation=null,this.onComplete=s.onComplete||B.defaults.onComplete,this.duration=0,this.muteCallbacks=!1,this.completed=!1,this.paused=!n||!1!==o,this.reversed=l,this.persist=Ot(s.persist,B.defaults.persist),this.autoplay=n,this._speed=Ot(s.playbackRate,B.defaults.playbackRate),this._resolve=x,this._completed=0,this._inlineStyles=[],i.forEach((t,e)=>{const i=t[d],n=ri.some(t=>s.hasOwnProperty(t)),o=t.style,a=this._inlineStyles[e]={},l=Ot(s.ease,B.defaults.ease),h=Bt(l,t,e,r),m=W(h)||Y(h)?h:l,f=l.ease&&l,g=ei(m),v=(f?f.settlingDuration:Bt(Ot(s.duration,B.defaults.duration),t,e,r))*p,x=Bt(Ot(s.delay,B.defaults.delay),t,e,r)*p,S=Ot(s.composition,"replace");for(let l in s){if(!tt(l))continue;const h={},d={iterations:c,direction:u,fill:"both",easing:g,duration:v,delay:x,composite:S},m=s[l],f=!!n&&(b.includes(l)?l:_.get(l)),y=f?"transform":l;let T;if(a[y]||(a[y]=o[y]),H(m)){const s=m,n=Ot(s.ease,g),a=n.ease&&n,c=s.to,u=s.from;if(d.duration=(a?a.settlingDuration:Bt(Ot(s.duration,v),t,e,r))*p,d.delay=Bt(Ot(s.delay,x),t,e,r)*p,d.composite=Ot(s.composition,S),d.easing=ei(n),T=ai(t,l,u,c,e,r),f?(h[`--${f}`]=T,i[f]=T):h[l]=ai(t,l,u,c,e,r),Je(this,t,l,h,d),!q(u))if(f){const t=`--${f}`;o.setProperty(t,h[t][0])}else o[l]=h[l][0]}else T=X(m)?m.map(s=>oi(l,s,t,e,r)):oi(l,m,t,e,r),f?(h[`--${f}`]=T,i[f]=T):h[l]=T,Je(this,t,l,h,d)}if(n){let t=y;for(let e in i)t+=`${T[e]}var(--${e})) `;o.transform=t}}),o&&this.autoplay.link(this)}forEach(t){try{const e=Y(t)?e=>e[t]():t;this.animations.forEach(e)}catch{}return this}get speed(){return this._speed}set speed(t){this._speed=+t,this.forEach(e=>e.playbackRate=t)}get currentTime(){const t=this.controlAnimation,e=B.timeScale;return this.completed?this.duration:t?+t.currentTime*(1===e?1:e):0}set currentTime(t){const e=t*(1===B.timeScale?1:f);this.forEach(t=>{!this.persist&&e>=this.duration&&t.play(),t.currentTime=e})}get progress(){return this.currentTime/this.duration}set progress(t){this.forEach(e=>e.currentTime=t*this.duration||0)}resume(){return this.paused?(this.paused=!1,this.forEach("play")):this}pause(){return this.paused?this:(this.paused=!0,this.forEach("pause"))}alternate(){return this.reversed=!this.reversed,this.forEach("reverse"),this.paused&&this.forEach("pause"),this}play(){return this.reversed&&this.alternate(),this.resume()}reverse(){return this.reversed||this.alternate(),this.resume()}seek(t,e=!1){return e&&(this.muteCallbacks=!0),t<this.duration&&(this.completed=!1),this.currentTime=t,this.muteCallbacks=!1,this.paused&&this.pause(),this}restart(){return this.completed=!1,this.seek(0,!0).resume()}commitStyles(){return this.forEach("commitStyles")}complete(){return this.seek(this.duration)}cancel(){return this.muteCallbacks=!0,this.commitStyles().forEach("cancel"),this.animations.length=0,requestAnimationFrame(()=>{this.targets.forEach(t=>{"none"===t.style.transform&&t.style.removeProperty("transform")})}),this}revert(){return this.cancel().targets.forEach((t,e)=>{const s=t.style,i=this._inlineStyles[e];for(let e in i){const r=i[e];q(r)||r===y?s.removeProperty(M(e)):t.style[e]=r}t.getAttribute("style")===y&&t.removeAttribute("style")}),this}then(t=x){const e=this.then,s=()=>{this.then=null,t(this),this.then=e,this._resolve=x};return new Promise(t=>(this._resolve=()=>t(s()),this.completed&&this._resolve(),this))}}const hi={animate:(t,e)=>new li(t,e),convertEase:Ks};let di=0,ci=0;const ui=(t,e)=>!(!t||!e)&&(t===e||t.contains(e)),pi=(t,e)=>{let s=t[e];for(;s&&s.nodeType===Node.TEXT_NODE&&!s.textContent.trim();)s=s[e];return s&&s.nodeType===Node.TEXT_NODE},mi=t=>pi(t,"previousSibling")||pi(t,"nextSibling"),fi=t=>{if(!t)return null;const e=t.style,s=e.transition||"";return e.setProperty("transition","none","important"),s},gi=(t,e)=>{if(!t)return;const s=t.style;e?s.transition=e:s.removeProperty("transition")},yi=t=>{const e=t.layout.transitionMuteStore,s=t.$el,i=t.$measure;s&&!e.has(s)&&e.set(s,fi(s)),i&&!e.has(i)&&e.set(i,fi(i))},vi=t=>{t.forEach((t,e)=>gi(e,t)),t.clear()},_i={display:"none",visibility:"hidden",opacity:"0",transform:"none",position:"static"},bi=t=>{if(!t)return;const e=t.parentNode;e&&(e._head===t&&(e._head=t._next),e._tail===t&&(e._tail=t._prev),t._prev&&(t._prev._next=t._next),t._next&&(t._next._prev=t._prev),t._prev=null,t._next=null,t.parentNode=null)},Ti=(t,e,s,i)=>{let r=t.dataset.layoutId;r||(r=t.dataset.layoutId="node-"+ci++);const n=i||{};return n.$el=t,n.$measure=t,n.id=r,n.index=0,n.total=1,n.delay=0,n.duration=0,n.ease=null,n.state=s,n.layout=s.layout,n.parentNode=e||null,n.isTarget=!1,n.isEntering=!1,n.isLeaving=!1,n.isInlined=!1,n.hasTransform=!1,n.inlineStyles=[],n.inlineTransforms=null,n.inlineTransition=null,n.branchAdded=!1,n.branchRemoved=!1,n.branchNotRendered=!1,n.sizeChanged=!1,n.hasVisibilitySwap=!1,n.hasDisplayNone=!1,n.hasVisibilityHidden=!1,n.measuredInlineTransform=null,n.measuredInlineTransition=null,n.measuredDisplay=null,n.measuredVisibility=null,n.measuredPosition=null,n.measuredHasDisplayNone=!1,n.measuredHasVisibilityHidden=!1,n.measuredIsVisible=!1,n.measuredIsRemoved=!1,n.measuredIsInsideRoot=!1,n.properties={transform:"none",x:0,y:0,left:0,top:0,clientLeft:0,clientTop:0,width:0,height:0},n.layout.properties.forEach(t=>n.properties[t]=0),n._head=null,n._tail=null,n._prev=null,n._next=null,n},xi=(t,e,s,i)=>{const r=t.$el,n=t.layout.root,o=n===r,a=t.properties,l=t.state.rootNode,h=t.parentNode,d=s.transform,c=r.style.transform,u=!!h&&h.measuredIsRemoved,p=s.position;if(o&&(t.layout.absoluteCoords="fixed"===p||"absolute"===p),t.$measure=e,t.inlineTransforms=c,t.hasTransform=d&&"none"!==d,t.measuredIsInsideRoot=ui(n,e),t.measuredInlineTransform=null,t.measuredDisplay=s.display,t.measuredVisibility=s.visibility,t.measuredPosition=p,t.measuredHasDisplayNone="none"===s.display,t.measuredHasVisibilityHidden="hidden"===s.visibility,t.measuredIsVisible=!(t.measuredHasDisplayNone||t.measuredHasVisibilityHidden),t.measuredIsRemoved=t.measuredHasDisplayNone||t.measuredHasVisibilityHidden||u,t.isInlined=t.measuredDisplay.includes("inline")&&mi(r),t.hasTransform&&!i){const s=t.layout.transitionMuteStore;s.get(r)||(t.inlineTransition=fi(r)),e===r?r.style.transform="none":(s.get(e)||(t.measuredInlineTransition=fi(e)),t.measuredInlineTransform=e.style.transform,e.style.transform="none")}let m,f,g=0,y=0,v=0,_=0;if(!i){const t=e.getBoundingClientRect();g=t.left,y=t.top,v=t.width,_=t.height}for(let t in a){const e="transform"===t?d:s[t]||s.getPropertyValue&&s.getPropertyValue(t);q(e)||(a[t]=e)}if(a.left=g,a.top=y,a.clientLeft=i?0:e.clientLeft,a.clientTop=i?0:e.clientTop,o)t.layout.absoluteCoords?(m=g,f=y):(m=0,f=0);else{const e=h||l,s=e.properties.left,i=e.properties.top,r=e.properties.clientLeft,n=e.properties.clientTop;if(t.layout.absoluteCoords)m=g-s-r,f=y-i-n;else if(e===l){const t=l.properties.left,e=l.properties.top;m=g-t-l.properties.clientLeft,f=y-e-l.properties.clientTop}else m=g-s-r,f=y-i-n}return a.x=m,a.y=f,a.width=v,a.height=_,t},Si=(t,e)=>{if(e)for(let s in e)t.properties[s]=e[s]},wi=(t,e)=>{const s=Bt(e.ease,t.$el,t.index,t.total),i=W(s)?s:e.ease,r=!q(i)&&!q(i.ease);t.ease=r?i.ease:i,t.duration=r?i.settlingDuration:Bt(e.duration,t.$el,t.index,t.total),t.delay=Bt(e.delay,t.$el,t.index,t.total)},$i=t=>{const e=t.$el.style,s=t.inlineStyles;s.length=0,t.layout.recordedProperties.forEach(t=>{s.push(t,e[t]||"")})},Ei=t=>{const e=t.$el.style,s=t.inlineStyles;for(let t=0,i=s.length;t<i;t+=2){const i=s[t],r=s[t+1];r&&""!==r?e[i]=r:(e[i]="",e.removeProperty(i))}},Ci=t=>{const e=t.inlineTransforms,s=t.$el.style;!t.hasTransform||!e||t.hasTransform&&"none"===s.transform||e&&"none"===e?s.removeProperty("transform"):e&&(s.transform=e);const i=t.$measure;if(t.hasTransform&&i!==t.$el){const e=i.style,s=t.measuredInlineTransform;s&&""!==s?e.transform=s:e.removeProperty("transform")}t.measuredInlineTransform=null,null!==t.inlineTransition&&(gi(t.$el,t.inlineTransition),t.inlineTransition=null),i!==t.$el&&null!==t.measuredInlineTransition&&(gi(i,t.measuredInlineTransition),t.measuredInlineTransition=null)},Ni=t=>{(t.measuredIsRemoved||t.hasVisibilitySwap)&&(t.$el.style.removeProperty("display"),t.$el.style.removeProperty("visibility"),t.hasVisibilitySwap&&(t.$measure.style.removeProperty("display"),t.$measure.style.removeProperty("visibility"))),t.layout.pendingRemoval.delete(t.$el)},ki=(t,e,s)=>(e.properties={...t.properties},e.state=s,e.isTarget=t.isTarget,e.hasTransform=t.hasTransform,e.inlineTransforms=t.inlineTransforms,e.measuredIsVisible=t.measuredIsVisible,e.measuredDisplay=t.measuredDisplay,e.measuredIsRemoved=t.measuredIsRemoved,e.measuredHasDisplayNone=t.measuredHasDisplayNone,e.measuredHasVisibilityHidden=t.measuredHasVisibilityHidden,e.hasDisplayNone=t.hasDisplayNone,e.isInlined=t.isInlined,e.hasVisibilityHidden=t.hasVisibilityHidden,e);class Ri{constructor(t){this.layout=t,this.rootNode=null,this.rootNodes=new Set,this.nodes=new Map,this.scrollX=0,this.scrollY=0}revert(){return this.forEachNode(t=>{this.layout.pendingRemoval.delete(t.$el),t.$el.removeAttribute("data-layout-id"),t.$measure.removeAttribute("data-layout-id")}),this.rootNode=null,this.rootNodes.clear(),this.nodes.clear(),this}getNode(t){if(t&&t.dataset)return this.nodes.get(t.dataset.layoutId)}getComputedValue(t,e){const s=this.getNode(t);if(s)return s.properties[e]}forEach(t,e){let s=t,i=0;for(;s;)if(e(s,i++),s._head)s=s._head;else if(s._next)s=s._next;else{for(;s&&!s._next;)s=s.parentNode;s&&(s=s._next)}}forEachRootNode(t){this.forEach(this.rootNode,t)}forEachNode(t){for(const e of this.rootNodes)this.forEach(e,t)}registerElement(t,e){if(!t||1!==t.nodeType)return null;this.layout.transitionMuteStore.has(t)||this.layout.transitionMuteStore.set(t,fi(t));const s=[t,e],i=this.layout.root;let r=null;for(;s.length;){const t=s.pop(),e=s.pop();if(!e||1!==e.nodeType||G(e))continue;const n=!!t&&t.measuredIsRemoved,o=n?_i:getComputedStyle(e),a=!!n||"none"===o.display,l=!!n||"hidden"===o.visibility,h=!a&&!l,d=e.dataset.layoutId,c=ui(i,e);let u=d?this.nodes.get(d):null;if(u&&u.$el!==e){const a=ui(i,u.$el),l=u.measuredIsVisible;if(a||!c&&(c||l||!h)){if(a&&!l&&h){xi(u,e,o,n);let t=e.lastElementChild;for(;t;)s.push(t,u),t=t.previousElementSibling;r||(r=u);continue}{let i=e.lastElementChild;for(;i;)s.push(i,t),i=i.previousElementSibling;r||(r=u);continue}}bi(u),u=Ti(e,t,this,u)}else u=Ti(e,t,this,u);u.branchAdded=!1,u.branchRemoved=!1,u.branchNotRendered=!1,u.isTarget=!1,u.sizeChanged=!1,u.hasVisibilityHidden=l,u.hasDisplayNone=a,u.hasVisibilitySwap=l&&!u.measuredHasVisibilityHidden||a&&!u.measuredHasDisplayNone,this.nodes.set(u.id,u),u.parentNode=t||null,u._prev=null,u._next=null,t?(this.rootNodes.delete(u),t._head?(t._tail._next=u,u._prev=t._tail,t._tail=u):(t._head=u,t._tail=u)):this.rootNodes.add(u),xi(u,u.$el,o,n);let p=e.lastElementChild;for(;p;)s.push(p,u),p=p.previousElementSibling;r||(r=u)}return r}ensureDetachedNode(t,e){if(!t||t===this.layout.root)return null;const s=t.dataset.layoutId,i=s?this.nodes.get(s):null;if(i&&i.$el===t)return i;let r=null,n=t.parentElement;for(;n&&n!==this.layout.root;){if(e.has(n)){r=this.ensureDetachedNode(n,e);break}n=n.parentElement}return this.registerElement(t,r)}record(){const t=this.layout,e=t.children,s=t.root,i=X(e)?e:[e],r=[],n="*"===e?s:O.root,o=[];let a=s.parentElement;for(;a&&1===a.nodeType;){const t=getComputedStyle(a);if(t.transform&&"none"!==t.transform){const t=a.style.transform||"",e=fi(a);o.push(a,t,e),a.style.transform="none"}a=a.parentElement}for(let t=0,e=i.length;t<e;t++){const e=i[t];r[t]=Y(e)?n.querySelectorAll(e):e}const l=be(r);this.nodes.clear(),this.rootNodes.clear();const h=this.registerElement(s,null);h.isTarget=!0,this.rootNode=h;const d=new Set;let c=0,u=this.nodes.size;this.nodes.forEach((t,e)=>{t.index=c++,t.total=u,t&&t.measuredIsInsideRoot&&d.add(e)});const p=new Set,m=[];for(let t=0,e=l.length;t<e;t++){const e=l[t];if(e&&1===e.nodeType&&e!==s){if(!ui(s,e)){const t=e.dataset.layoutId;if(!t||!d.has(t))continue}p.has(e)||(p.add(e),m.push(e))}}for(let t=0,e=m.length;t<e;t++)this.ensureDetachedNode(m[t],p);for(let t=0,e=l.length;t<e;t++){const e=l[t],s=this.getNode(e);if(s){let t=s;for(;t&&!t.isTarget;)t.isTarget=!0,t=t.parentNode}}this.scrollX=window.scrollX,this.scrollY=window.scrollY,this.forEachNode(Ci);for(let t=0,e=o.length;t<e;t+=3){const e=o[t],s=o[t+1],i=o[t+2];s&&""!==s?e.style.transform=s:e.style.removeProperty("transform"),gi(e,i)}return this}}function Di(t){const e={},s={};for(let i in t){const r=t[i];"duration"===i||"delay"===i||"ease"===i?s[i]=r:e[i]=r}return[e,s]}class Ii{constructor(t,e={}){O.current&&O.current.register(this);const s=Di(e.swapAt),i=Di(e.enterFrom),r=Di(e.leaveTo),n=e.properties;if(e.duration=Ot(e.duration,350),e.delay=Ot(e.delay,0),e.ease=Ot(e.ease,"inOut(3.5)"),this.params=e,this.root=be(t)[0],this.id=di++,this.children=e.children||"*",this.absoluteCoords=!1,this.swapAtParams=$t(e.swapAt||{opacity:0},{ease:"inOut(1.75)"}),this.enterFromParams=e.enterFrom||{opacity:0},this.leaveToParams=e.leaveTo||{opacity:0},this.properties=new Set(["opacity","fontSize","color","backgroundColor","borderRadius","border","filter","clipPath"]),s[0])for(let t in s[0])this.properties.add(t);if(i[0])for(let t in i[0])this.properties.add(t);if(r[0])for(let t in r[0])this.properties.add(t);if(n)for(let t=0,e=n.length;t<e;t++)this.properties.add(n[t]);this.recordedProperties=new Set(["display","visibility","translate","position","left","top","marginLeft","marginTop","width","height","maxWidth","maxHeight","minWidth","minHeight"]),this.properties.forEach(t=>this.recordedProperties.add(t)),this.pendingRemoval=new WeakSet,this.transitionMuteStore=new Map,this.oldState=new Ri(this),this.newState=new Ri(this),this.timeline=null,this.transformAnimation=null,this.animating=[],this.swapping=[],this.leaving=[],this.entering=[],this.oldState.record(),vi(this.transitionMuteStore)}revert(){return this.root.classList.remove("is-animated"),this.timeline&&(this.timeline.complete(),this.timeline=null),this.transformAnimation&&(this.transformAnimation.complete(),this.transformAnimation=null),this.animating.length=this.swapping.length=this.leaving.length=this.entering.length=0,this.oldState.revert(),this.newState.revert(),requestAnimationFrame(()=>vi(this.transitionMuteStore)),this}record(){return this.transformAnimation&&(this.transformAnimation.cancel(),this.transformAnimation=null),this.oldState.record(),this.timeline&&(this.timeline.cancel(),this.timeline=null),this.newState.forEachRootNode(Ei),this}animate(t={}){const e={ease:Ot(t.ease,this.params.ease),delay:Ot(t.delay,this.params.delay),duration:Ot(t.duration,this.params.duration)},s={},i=Ot(t.onComplete,this.params.onComplete),r=Ot(t.onPause,this.params.onPause);for(let e in L)"ease"!==e&&"duration"!==e&&"delay"!==e&&(q(t[e])?q(this.params[e])||(s[e]=this.params[e]):s[e]=t[e]);s.onComplete=()=>{this.transformAnimation&&this.transformAnimation.cancel(),f.forEachRootNode(t=>{Ni(t),Ei(t)});for(let t=0,e=S.length;t<e;t++){const e=S[t];e.style.transform=f.getComputedValue(e,"transform")}this.root.classList.contains("is-animated")&&(this.root.classList.remove("is-animated"),i&&i(this.timeline)),requestAnimationFrame(()=>{this.root.classList.contains("is-animated")||vi(this.transitionMuteStore)})},s.onPause=()=>{this.root.classList.contains("is-animated")&&(this.transformAnimation&&this.transformAnimation.cancel(),f.forEachRootNode(Ni),this.root.classList.remove("is-animated"),i&&i(this.timeline),r&&r(this.timeline))},s.composition=!1;const n=$t($t(t.swapAt||{},this.swapAtParams),e),o=$t($t(t.enterFrom||{},this.enterFromParams),e),a=$t($t(t.leaveTo||{},this.leaveToParams),e),[l,h]=Di(n),[d,c]=Di(o),[u,p]=Di(a),m=this.oldState,f=this.newState,g=this.animating,y=this.swapping,v=this.entering,_=this.leaving,b=this.pendingRemoval;g.length=y.length=v.length=_.length=0,m.forEachRootNode(yi),f.record(),f.forEachRootNode($i);const T=[],x=[],S=[],w=[],$=f.rootNode,E=$.$el;f.forEachRootNode(t=>{const e=t.$el,s=t.id,i=t.parentNode,r=!!i&&i.branchAdded,n=!!i&&i.branchRemoved,o=!!i&&i.branchNotRendered;let a=m.nodes.get(s);const l=!a;l?(a=ki(t,{},m),m.nodes.set(s,a),a.measuredIsRemoved=!0):a.measuredIsRemoved&&!t.measuredIsRemoved&&(ki(t,a,m),a.measuredIsRemoved=!0);const h=a.parentNode,c=(h?h.id:null)!==(i?i.id:null),p=a.$el!==t.$el,y=a.measuredIsRemoved,x=t.measuredIsRemoved;if(!a.measuredIsRemoved&&!x&&!l&&(c||p)){const t=a.properties.left,e=a.properties.top,s=i||f.rootNode,r=s.id?m.nodes.get(s.id):null,n=r?r.properties.left:s.properties.left,o=r?r.properties.top:s.properties.top,l=r?r.properties.clientLeft:s.properties.clientLeft,h=r?r.properties.clientTop:s.properties.clientTop;a.properties.x=t-n-l,a.properties.y=e-o-h}t.hasVisibilitySwap&&(t.hasVisibilityHidden&&(t.$el.style.visibility="visible",t.$measure.style.visibility="hidden"),t.hasDisplayNone&&(t.$el.style.display=a.measuredDisplay||t.measuredDisplay||"",t.$measure.style.visibility="hidden"));const S=b.has(e),w=a.measuredIsVisible,E=t.measuredIsVisible,C=!w&&E&&!o,N=!x&&(y||S)&&!r,k=x&&!y&&!n,R=k||x&&S&&!n;t.branchAdded=r||N,t.branchRemoved=n||R,t.branchNotRendered=o||x,x&&w&&(t.$el.style.display=a.measuredDisplay,t.$el.style.visibility="visible",ki(a,t,f)),k?(t.isTarget&&(_.push(e),t.isLeaving=!0),b.add(e)):!x&&S&&b.delete(e),N&&!o||C?(Si(a,d),t.isTarget&&(v.push(e),t.isEntering=!0)):R&&!o&&Si(t,u),t===$||!t.isTarget||t.isEntering||t.isLeaving||g.push(e),T.push(e)});let C=0,N=0,k=0;f.forEachRootNode(t=>{const s=t.$el,i=t.parentNode,r=m.nodes.get(t.id),n=t.properties,o=r.properties;let a=i!==$&&i;for(;a&&!a.isTarget&&a!==$;)a=a.parentNode;const d=g.length;t===$?(t.index=0,t.total=d,wi(t,e)):t.isEntering?(t.index=a?a.index:C,t.total=a?d:v.length,wi(t,c),C++):t.isLeaving?(t.index=a?a.index:N,t.total=a?d:_.length,N++,wi(t,p)):t.isTarget?(t.index=k++,t.total=d,wi(t,e)):(t.index=a?a.index:0,t.total=d,wi(t,h)),r.index=t.index,r.total=t.total;for(let e in n)n[e]=Bt(n[e],s,t.index,t.total),o[e]=Bt(o[e],s,r.index,r.total);const u=Math.abs(n.width-o.width)>1,f=Math.abs(n.height-o.height)>1;if(t.sizeChanged=u||f,t.isTarget&&(!t.measuredIsRemoved&&r.measuredIsVisible||t.measuredIsRemoved&&t.measuredIsVisible)){t.isInlined||"none"===n.transform&&"none"===o.transform||(t.hasTransform=!0,S.push(s));for(let t in n)if("transform"!==t&&n[t]!==o[t]){x.push(s);break}}t.isTarget||(y.push(s),t.sizeChanged&&i&&i.isTarget&&i.sizeChanged&&(!t.isInlined&&l.transform&&(t.hasTransform=!0,S.push(s)),w.push(s)))});const R={delay:t=>f.getNode(t).delay,duration:t=>f.getNode(t).duration,ease:t=>f.getNode(t).ease};if(s.defaults=R,this.timeline=as(s),!x.length&&!S.length&&!y.length)return vi(this.transitionMuteStore),this.timeline.complete();if(T.length){this.root.classList.add("is-animated");for(let t=0,e=T.length;t<e;t++){const e=T[t],s=e.dataset.layoutId,i=m.nodes.get(s),r=f.nodes.get(s),n=i.properties;r.isInlined||("grid"!==i.measuredDisplay&&"grid"!==r.measuredDisplay||e.style.setProperty("display","block","important"),(e!==E||this.absoluteCoords)&&(e.style.position=this.absoluteCoords?"fixed":"absolute",e.style.left="0px",e.style.top="0px",e.style.marginLeft="0px",e.style.marginTop="0px",e.style.translate=`${n.x}px ${n.y}px`),e===E&&"static"===r.measuredPosition&&(e.style.position="relative",e.style.left="0px",e.style.top="0px"),e.style.width=`${n.width}px`,e.style.height=`${n.height}px`,e.style.minWidth="auto",e.style.minHeight="auto",e.style.maxWidth="none",e.style.maxHeight="none")}m.scrollX===window.scrollX&&m.scrollY===window.scrollY||requestAnimationFrame(()=>window.scrollTo(m.scrollX,m.scrollY));for(let t=0,e=x.length;t<e;t++){const e=x[t],s=e.dataset.layoutId,i=m.nodes.get(s),r=f.nodes.get(s),n=i.properties,o=r.properties;let a=!1;const l={composition:"none"};r.isInlined||(n.width!==o.width&&(l.width=[n.width,o.width],a=!0),n.height!==o.height&&(l.height=[n.height,o.height],a=!0),r.hasTransform||(l.translate=[`${n.x}px ${n.y}px`,`${o.x}px ${o.y}px`],a=!0)),this.properties.forEach(t=>{const e=n[t],s=o[t];"transform"!==t&&e!==s&&(l[t]=[e,s],a=!0)}),a&&this.timeline.add(e,l,0)}}if(y.length){for(let t=0,e=y.length;t<e;t++){const e=y[t],s=m.getNode(e);if(!s.isInlined){const t=s.properties;e.style.width=`${t.width}px`,e.style.height=`${t.height}px`,e.style.minWidth="auto",e.style.minHeight="auto",e.style.maxWidth="none",e.style.maxHeight="none",e.style.translate=`${t.x}px ${t.y}px`}this.properties.forEach(t=>{"transform"!==t&&(e.style[t]=`${m.getComputedValue(e,t)}`)})}for(let t=0,e=y.length;t<e;t++){const e=y[t],s=f.getNode(e),i=s.properties;this.timeline.call(()=>{s.isInlined||(e.style.width=`${i.width}px`,e.style.height=`${i.height}px`,e.style.minWidth="auto",e.style.minHeight="auto",e.style.maxWidth="none",e.style.maxHeight="none",e.style.translate=`${i.x}px ${i.y}px`),this.properties.forEach(t=>{"transform"!==t&&(e.style[t]=`${f.getComputedValue(e,t)}`)})},s.delay+s.duration/2)}if(w.length){const t=Le(f.nodes.get(w[0].dataset.layoutId).ease),e=e=>1-t(1-e),s={};if(l)for(let t in l)"transform"!==t&&(s[t]=[{from:e=>m.getComputedValue(e,t),to:l[t]},{from:l[t],to:e=>f.getComputedValue(e,t),ease:e}]);this.timeline.add(w,s,0)}}const D=S.length;if(D){for(let t=0;t<D;t++){const e=S[t];if(e.style.translate=`${m.getComputedValue(e,"x")}px ${m.getComputedValue(e,"y")}px`,e.style.transform=m.getComputedValue(e,"transform"),w.includes(e)){const t=f.getNode(e);t.ease=Bt(n.ease,e,t.index,t.total),t.duration=Bt(n.duration,e,t.index,t.total)}}this.transformAnimation=hi.animate(S,{translate:t=>`${f.getComputedValue(t,"x")}px ${f.getComputedValue(t,"y")}px`,transform:t=>{const e=f.getComputedValue(t,"transform");if(!w.includes(t))return e;const s=m.getComputedValue(t,"transform"),i=f.getNode(t);return[s,Bt(l.transform,t,i.index,i.total),e]},autoplay:!1,persist:!0,...R}),this.timeline.sync(this.transformAnimation,0)}return this.timeline.init()}update(t,e={}){return this.record(),t(this),this.animate(e)}}const Ai=(t,e)=>new Ii(t,e),Li=vs,Oi={},Bi=(t,e=0)=>(...s)=>e?e=>t(...s,e):e=>t(e,...s),Pi=t=>(...e)=>{const s=t(...e);return new Proxy(x,{apply:(t,e,[i])=>s(i),get:(t,e)=>Pi((...t)=>{const i=Oi[e](...t);return t=>i(s(t))})})},Fi=(t,e,s=0)=>{const i=(...t)=>(t.length<e.length?Pi(Bi(e,s)):e)(...t);return Oi[t]||(Oi[t]=i),i},Mi=Fi("roundPad",Li.roundPad),Vi=Fi("padStart",Li.padStart),zi=Fi("padEnd",Li.padEnd),Xi=Fi("wrap",Li.wrap),Hi=Fi("mapRange",Li.mapRange),Ui=Fi("degToRad",Li.degToRad),Yi=Fi("radToDeg",Li.radToDeg),Wi=Fi("snap",Li.snap),qi=Fi("clamp",Li.clamp),ji=Fi("round",Li.round),Gi=Fi("lerp",Li.lerp,1),Qi=Fi("damp",Li.damp,1),Ji=(t=0,e=1,s=0)=>{const i=10**s;return Math.floor((Math.random()*(e-t+1/i)+t)*i)/i};let Zi=0;const Ki=(t,e=0,s=1,i=0)=>{let r=void 0===t?Zi++:t;return(t=e,n=s,o=i)=>{r+=1831565813,r=Math.imul(r^r>>>15,1|r),r^=r+Math.imul(r^r>>>7,61|r);const a=10**o;return Math.floor((((r^r>>>14)>>>0)/4294967296*(n-t+1/a)+t)*a)/a}},tr=t=>t[Ji(0,t.length-1)],er=t=>{let e,s,i=t.length;for(;i;)s=Ji(0,--i),e=t[i],t[i]=t[s],t[s]=e;return t},sr=(t,e={})=>{let s=[],i=0;const r=e.from,n=e.reversed,o=e.ease,a=!q(o),l=a&&!q(o.ease)?o.ease:a?Le(o):null,h=e.grid,d=e.axis,c=e.total,u=q(r)||0===r||"first"===r,p="center"===r,m="last"===r,f="random"===r,g=X(t),v=e.use,_=it(g?t[0]:t),b=g?it(t[1]):0,T=k.exec((g?t[1]:t)+y),x=e.start||0+(g?_:0);let S=u?0:U(r)?r:0;return(t,r,o,a)=>{const[u]=be(t),y=q(c)?o:c,w=!q(v)&&(W(v)?v(u,r,y):Mt(u,v)),$=U(w)||Y(w)&&U(+w)?+w:r;if(p&&(S=(y-1)/2),m&&(S=y-1),!s.length){for(let t=0;t<y;t++){if(h){const e=p?(h[0]-1)/2:S%h[0],i=p?(h[1]-1)/2:ct(S/h[0]),r=e-t%h[0],n=i-ct(t/h[0]);let o=nt(r*r+n*n);"x"===d&&(o=-r),"y"===d&&(o=-n),s.push(o)}else s.push(lt(S-t));i=pt(...s)}l&&(s=s.map(t=>l(t/i)*i)),n&&(s=s.map(t=>d?t<0?-1*t:-t:lt(i-t))),f&&(s=er(s))}const E=g?(b-_)/i:_;let C=(a?ss(a,q(e.start)?a.iterationDuration:x):x)+(E*_t(s[$],2)||0);return e.modifier&&(C=e.modifier(C)),T&&(C=`${C}${T[2]}`),C}};var ir=Object.freeze({__proto__:null,$:be,clamp:qi,cleanInlineStyles:Gt,createSeededRandom:Ki,damp:Qi,degToRad:Ui,get:Ze,keepTime:Ds,lerp:Gi,mapRange:Hi,padEnd:zi,padStart:Vi,radToDeg:Yi,random:Ji,randomPick:tr,remove:ts,round:ji,roundPad:Mi,set:Ke,shuffle:er,snap:Wi,stagger:sr,sync:Rs,wrap:Xi});const rr=t=>{const e=_e(t)[0];return e&&G(e)?e:console.warn(`${t} is not a valid SVGGeometryElement`)},nr=(t,e,s,i,r)=>{const n=s+i,o=r?Math.max(0,Math.min(n,e)):(n%e+e)%e;return t.getPointAtLength(o)},or=(t,e,s=0)=>i=>{const r=+t.getTotalLength(),n=i[h],o=t.getCTM(),a=0===s;return{from:0,to:r,modifier:i=>{const l=i+s*r;if("a"===e){const e=nr(t,r,l,-1,a),s=nr(t,r,l,1,a);return 180*mt(s.y-e.y,s.x-e.x)/ft}{const s=nr(t,r,l,0,a);return"x"===e?n||!o?s.x:s.x*o.a+s.y*o.c+o.e:n||!o?s.y:s.x*o.b+s.y*o.d+o.f}}}},ar=(t,e=0)=>{const s=rr(t);if(s)return{translateX:or(s,"x",e),translateY:or(s,"y",e),rotate:or(s,"a",e)}},lr=t=>{let e=1;if(t&&t.getCTM){const s=t.getCTM();s&&(e=(nt(s.a*s.a+s.b*s.b)+nt(s.c*s.c+s.d*s.d))/2)}return e},hr=(t,e,s)=>{const i=f,r=getComputedStyle(t),n=r.strokeLinecap,o="non-scaling-stroke"===r.vectorEffect?t:null;let a=n;const l=new Proxy(t,{get(t,e){const s=t[e];return e===u?t:"setAttribute"===e?(...e)=>{if("draw"===e[0]){const s=e[1].split(" "),r=+s[0],l=+s[1],h=lr(o),d=-1e3*r*h,c=l*i*h+d,u=i*h+(0===r&&1===l||1===r&&0===l?0:10*h)-c;if("butt"!==n){const e=r===l?"butt":n;a!==e&&(t.style.strokeLinecap=`${e}`,a=e)}t.setAttribute("stroke-dashoffset",`${d}`),t.setAttribute("stroke-dasharray",`${c} ${u}`)}return Reflect.apply(s,t,e)}:W(s)?(...e)=>Reflect.apply(s,t,e):s}});return"1000"!==t.getAttribute("pathLength")&&(t.setAttribute("pathLength","1000"),l.setAttribute("draw",`${e} ${s}`)),l},dr=(t,e=0,s=0)=>_e(t).map(t=>hr(t,e,s)),cr=(t,e=.33)=>s=>{if(!(s.tagName||"").toLowerCase().match(/^(path|polygon|polyline)$/))throw new Error(`Can't morph a <${s.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);const i=rr(t);if(!i)throw new Error("Can't morph to an invalid target. 'path2' must resolve to an existing <path>, <polygon> or <polyline> SVG element.");if(!(i.tagName||"").toLowerCase().match(/^(path|polygon|polyline)$/))throw new Error(`Can't morph a <${i.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);const r="path"===s.tagName,n=r?" ":",",o=s[c];o&&s.setAttribute(r?"d":"points",o);let a="",l="";if(e){const t=s.getTotalLength(),o=i.getTotalLength(),h=Math.max(Math.ceil(t*e),Math.ceil(o*e));for(let e=0;e<h;e++){const d=e/(h-1),c=s.getPointAtLength(t*d),u=i.getPointAtLength(o*d),p=r?0===e?"M":"L":"";a+=p+_t(c.x,3)+n+c.y+" ",l+=p+_t(u.x,3)+n+u.y+" "}}else a=s.getAttribute(r?"d":"points"),l=i.getAttribute(r?"d":"points");return s[c]=l,[a,l]};var ur=Object.freeze({__proto__:null,createDrawable:dr,createMotionPath:ar,morphTo:cr});const pr="undefined"!=typeof Intl&&Intl.Segmenter,mr=/\{value\}/g,fr=/\{i\}/g,gr=/(\s+)/,yr=/^\s+$/,vr="line",_r="word",br="char",Tr="data-line";let xr=null,Sr=null,wr=null;const $r=t=>t.isWordLike||" "===t.segment||U(+t.segment),Er=t=>t.setAttribute("aria-hidden","true"),Cr=(t,e)=>[...t.querySelectorAll(`[data-${e}]:not([data-${e}] [data-${e}])`)],Nr={line:"#00D672",word:"#FF4B4B",char:"#5A87FF"},kr=t=>{if(!t.childElementCount&&!t.textContent.trim()){const e=t.parentElement;t.remove(),e&&kr(e)}},Rr=(t,e,s)=>{const i=t.getAttribute(Tr);if(null!==i&&+i!==e||"BR"===t.tagName){s.add(t);const e=t.previousSibling,i=t.nextSibling;e&&3===e.nodeType&&yr.test(e.textContent)&&s.add(e),i&&3===i.nodeType&&yr.test(i.textContent)&&s.add(i)}let r=t.childElementCount;for(;r--;)Rr(t.children[r],e,s);return s},Dr=(t,e={})=>{let s="";const i=Y(e.class)?` class="${e.class}"`:"",r=Ot(e.clone,!1),n=Ot(e.wrap,!1),o=n?!0===n?"clip":n:!!r&&"clip";return n&&(s+=`<span${o?` style="overflow:${o};"`:""}>`),s+=`<span${i}${r?' style="position:relative;"':""} data-${t}="{i}">`,r?(s+="<span>{value}</span>",s+=`<span inert style="position:absolute;top:${"top"===r?"-100%":"bottom"===r?"100%":"0"};left:${"left"===r?"-100%":"right"===r?"100%":"0"};white-space:nowrap;">{value}</span>`):s+="{value}",s+="</span>",n&&(s+="</span>"),s},Ir=(t,e,s,i,r,n,o,a,l)=>{const h=r===vr,d=r===br,c=`_${r}_`,u=W(t)?t(s):t,p=h?"block":"inline-block";wr.innerHTML=u.replace(mr,`<i class="${c}"></i>`).replace(fr,`${d?l:h?o:a}`);const m=wr.content,f=m.firstElementChild,g=m.querySelector(`[data-${r}]`)||f,y=m.querySelectorAll(`i.${c}`),v=y.length;if(v){f.style.display=p,g.style.display=p,g.setAttribute(Tr,`${o}`),h||(g.setAttribute("data-word",`${a}`),d&&g.setAttribute("data-char",`${l}`));let t=v;for(;t--;){const e=y[t],i=e.parentElement;i.style.display=p,h?i.innerHTML=s.innerHTML:i.replaceChild(s.cloneNode(!0),e)}e.push(g),i.appendChild(m)}else console.warn('The expression "{value}" is missing from the provided template.');return n&&(f.style.outline=`1px dotted ${Nr[r]}`),f};class Ar{constructor(e,i={}){xr||(xr=pr?new pr([],{granularity:_r}):{segment:t=>{const e=[],s=t.split(gr);for(let t=0,i=s.length;t<i;t++){const i=s[t];e.push({segment:i,isWordLike:!yr.test(i)})}return e}}),Sr||(Sr=pr?new pr([],{granularity:"grapheme"}):{segment:t=>[...t].map(t=>({segment:t}))}),!wr&&t&&(wr=s.createElement("template")),O.current&&O.current.register(this);const{words:r,chars:n,lines:o,accessible:a,includeSpaces:l,debug:h}=i,d=(e=X(e)?e[0]:e)&&e.nodeType?e:(ve(e)||[])[0],c=!0===o?{}:o,u=!0===r||q(r)?{}:r,p=!0===n?{}:n;this.debug=Ot(h,!1),this.includeSpaces=Ot(l,!1),this.accessible=Ot(a,!0),this.linesOnly=c&&!u&&!p,this.lineTemplate=H(c)?Dr(vr,c):c,this.wordTemplate=H(u)||this.linesOnly?Dr(_r,u):u,this.charTemplate=H(p)?Dr(br,p):p,this.$target=d,this.html=d&&d.innerHTML,this.lines=[],this.words=[],this.chars=[],this.effects=[],this.effectsCleanups=[],this.cache=null,this.ready=!1,this.width=0,this.resizeTimeout=null;const m=()=>this.html&&(c||u||p)&&this.split();this.resizeObserver=new ResizeObserver(()=>{clearTimeout(this.resizeTimeout),this.resizeTimeout=setTimeout(()=>{const t=d.offsetWidth;t!==this.width&&(this.width=t,m())},150)}),this.lineTemplate&&!this.ready?s.fonts.ready.then(m):m(),d?this.resizeObserver.observe(d):console.warn("No Text Splitter target found.")}addEffect(t){if(!W(t))return console.warn("Effect must return a function.");const e=Ds(t);return this.effects.push(e),this.ready&&(this.effectsCleanups[this.effects.length-1]=e(this)),this}revert(){return clearTimeout(this.resizeTimeout),this.lines.length=this.words.length=this.chars.length=0,this.resizeObserver.disconnect(),this.effectsCleanups.forEach(t=>W(t)?t(this):t.revert&&t.revert()),this.$target.innerHTML=this.html,this}splitNode(t){const e=this.wordTemplate,i=this.charTemplate,r=this.includeSpaces,n=this.debug,o=t.nodeType;if(3===o){const o=t.nodeValue;if(o.trim()){const a=[],l=this.words,h=this.chars,d=xr.segment(o),c=s.createDocumentFragment();let u=null;for(const t of d){const e=t.segment,s=$r(t);if(!u||s&&u&&$r(u))a.push(e);else{const t=a.length-1,s=a[t];gr.test(s)||gr.test(e)?a.push(e):a[t]+=e}u=t}for(let t=0,o=a.length;t<o;t++){const o=a[t];if(o.trim()){const d=a[t+1],u=r&&d&&!d.trim(),p=o,m=i?Sr.segment(p):null,f=i?s.createDocumentFragment():s.createTextNode(u?o+"":o);if(i){const t=[...m];for(let e=0,r=t.length;e<r;e++){const o=t[e],a=e===r-1&&u?o.segment+"":o.segment,d=s.createTextNode(a);Ir(i,h,d,f,br,n,-1,l.length,h.length)}}e?Ir(e,l,f,c,_r,n,-1,l.length,h.length):i?c.appendChild(f):c.appendChild(s.createTextNode(o)),u&&t++}else{if(t&&r)continue;c.appendChild(s.createTextNode(o))}}t.parentNode.replaceChild(c,t)}}else if(1===o){const e=[...t.childNodes];for(let t=0,s=e.length;t<s;t++)this.splitNode(e[t])}}split(t=!1){const e=this.$target,i=!!this.cache&&!t,r=this.lineTemplate,n=this.wordTemplate,o=this.charTemplate,a="loading"!==s.fonts.status,l=r&&a;this.ready=!r||a,(l||t)&&this.effectsCleanups.forEach(t=>W(t)&&t(this)),i||(t&&(e.innerHTML=this.html,this.words.length=this.chars.length=0),this.splitNode(e),this.cache=e.innerHTML),l&&(i&&(e.innerHTML=this.cache),this.lines.length=0,n&&(this.words=Cr(e,_r))),o&&(l||n)&&(this.chars=Cr(e,br));const h=this.words.length?this.words:this.chars;let d,c=0;for(let t=0,e=h.length;t<e;t++){const e=h[t],{top:s,height:i}=e.getBoundingClientRect();!q(d)&&s-d>.5*i&&c++,e.setAttribute(Tr,`${c}`);const r=e.querySelectorAll(`[${Tr}]`);let n=r.length;for(;n--;)r[n].setAttribute(Tr,`${c}`);d=s}if(l){const t=s.createDocumentFragment(),i=new Set,a=[];for(let t=0;t<c+1;t++){const s=e.cloneNode(!0);Rr(s,t,new Set).forEach(t=>{const e=t.parentNode;e&&(1===t.nodeType&&i.add(e),e.removeChild(t))}),a.push(s)}i.forEach(kr);for(let e=0,s=a.length;e<s;e++)Ir(r,this.lines,a[e],t,vr,this.debug,e);e.innerHTML="",e.appendChild(t),n&&(this.words=Cr(e,_r)),o&&(this.chars=Cr(e,br))}if(this.linesOnly){const t=this.words;let e=t.length;for(;e--;){const s=t[e];s.replaceWith(s.textContent)}t.length=0}if(this.accessible&&(l||!i)){const t=s.createElement("span");t.style.cssText="position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;",t.innerHTML=this.html,e.insertBefore(t,e.firstChild),this.lines.forEach(Er),this.words.forEach(Er),this.chars.forEach(Er)}return this.width=e.offsetWidth,(l||t)&&this.effects.forEach((t,e)=>this.effectsCleanups[e]=t(this)),this}refresh(){this.split(!0)}}const Lr=(t,e)=>new Ar(t,e),Or=(t,e)=>(console.warn("text.split() is deprecated, import splitText() directly, or text.splitText()"),new Ar(t,e));var Br=Object.freeze({__proto__:null,TextSplitter:Ar,split:Or,splitText:Lr});export{be as $,ls as Animatable,Ii as AutoLayout,Ns as Draggable,qe as JSAnimation,Is as Scope,Us as ScrollObserver,bs as Spring,Ar as TextSplitter,os as Timeline,ge as Timer,li as WAAPIAnimation,je as animate,qi as clamp,Gt as cleanInlineStyles,hs as createAnimatable,ks as createDraggable,dr as createDrawable,Ai as createLayout,ar as createMotionPath,As as createScope,Ki as createSeededRandom,xs as createSpring,as as createTimeline,ye as createTimer,js as cubicBezier,Qi as damp,Ui as degToRad,Re as eases,Zs as easings,se as engine,Ze as get,Js as irregular,Ds as keepTime,Gi as lerp,Qs as linear,Hi as mapRange,cr as morphTo,Ys as onScroll,zi as padEnd,Vi as padStart,Yi as radToDeg,Ji as random,tr as randomPick,ts as remove,ji as round,Mi as roundPad,Bs as scrollContainers,Ke as set,er as shuffle,Wi as snap,Or as split,Lr as splitText,Ts as spring,sr as stagger,Gs as steps,ur as svg,Rs as sync,Br as text,ir as utils,hi as waapi,Xi as wrap};


## Links discovered
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.overshootCoords.x,1)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.overshootCoords.y,1)
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.overshootCoords.x,0)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.overshootCoords.y,0)
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/s,0.md)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/s,0.md)
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/o,l,s.md)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/a,l,s.md)
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/D,L,P.md)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/I,O,F.md)
- [e](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [o](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [l](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [e](https://github.com/juliangarnier/anime/blob/master/dist/bundles/...t)

--- dist/bundles/anime.umd.js ---
/**
 * Anime.js - UMD bundle
 * @version v4.3.0
 * @license MIT
 * @copyright 2026 - Julian Garnier
 */

// Global types

/**
 * @typedef {Object} DefaultsParams
 * @property {Number|String} [id]
 * @property {PercentageKeyframes|DurationKeyframes} [keyframes]
 * @property {EasingParam} [playbackEase]
 * @property {Number} [playbackRate]
 * @property {Number} [frameRate]
 * @property {Number|Boolean} [loop]
 * @property {Boolean} [reversed]
 * @property {Boolean} [alternate]
 * @property {Boolean} [persist]
 * @property {Boolean|ScrollObserver} [autoplay]
 * @property {Number|FunctionValue} [duration]
 * @property {Number|FunctionValue} [delay]
 * @property {Number} [loopDelay]
 * @property {EasingParam|FunctionValue} [ease]
 * @property {'none'|'replace'|'blend'|compositionTypes} [composition]
 * @property {(v: any) => any} [modifier]
 * @property {Callback<Tickable>} [onBegin]
 * @property {Callback<Tickable>} [onBeforeUpdate]
 * @property {Callback<Tickable>} [onUpdate]
 * @property {Callback<Tickable>} [onLoop]
 * @property {Callback<Tickable>} [onPause]
 * @property {Callback<Tickable>} [onComplete]
 * @property {Callback<Renderable>} [onRender]
 */

/** @typedef {JSAnimation|Timeline} Renderable */
/** @typedef {Timer|Renderable} Tickable */
/** @typedef {Timer&JSAnimation&Timeline} CallbackArgument */
/** @typedef {Animatable|Tickable|WAAPIAnimation|Draggable|ScrollObserver|TextSplitter|Scope|AutoLayout} Revertible */

// Stagger types

/**
 * @template T
 * @callback StaggerFunction
 * @param {Target} [target]
 * @param {Number} [index]
 * @param {Number} [length]
 * @param {Timeline} [tl]
 * @return {T}
 */

/**
 * @typedef  {Object} StaggerParams
 * @property {Number|String} [start]
 * @property {Number|'first'|'center'|'last'|'random'} [from]
 * @property {Boolean} [reversed]
 * @property {Array.<Number>} [grid]
 * @property {('x'|'y')} [axis]
 * @property {String|((target: Target, i: Number, length: Number) => Number)} [use]
 * @property {Number} [total]
 * @property {EasingParam} [ease]
 * @property {TweenModifier} [modifier]
 */

// Targets types

/** @typedef {HTMLElement|SVGElement} DOMTarget */
/** @typedef {Record<String, any>} JSTarget */
/** @typedef {DOMTarget|JSTarget} Target */
/** @typedef {Target|NodeList|String} TargetSelector */
/** @typedef {DOMTarget|NodeList|String} DOMTargetSelector */
/** @typedef {Array.<DOMTargetSelector>|DOMTargetSelector} DOMTargetsParam */
/** @typedef {Array.<DOMTarget>} DOMTargetsArray */
/** @typedef {Array.<JSTarget>|JSTarget} JSTargetsParam */
/** @typedef {Array.<JSTarget>} JSTargetsArray */
/** @typedef {Array.<TargetSelector>|TargetSelector} TargetsParam */
/** @typedef {Array.<Target>} TargetsArray */

// Eases types

/**
 * @callback EasingFunction
 * @param {Number} time
 * @return {Number}
 */

/**
 * @typedef {('linear'|'none'|'in'|'out'|'inOut'|'inQuad'|'outQuad'|'inOutQuad'|'inCubic'|'outCubic'|'inOutCubic'|'inQuart'|'outQuart'|'inOutQuart'|'inQuint'|'outQuint'|'inOutQuint'|'inSine'|'outSine'|'inOutSine'|'inCirc'|'outCirc'|'inOutCirc'|'inExpo'|'outExpo'|'inOutExpo'|'inBounce'|'outBounce'|'inOutBounce'|'inBack'|'outBack'|'inOutBack'|'inElastic'|'outElastic'|'inOutElastic'|'out(p = 1.675)'|'inOut(p = 1.675)'|'inBack(overshoot = 1.7)'|'outBack(overshoot = 1.7)'|'inOutBack(overshoot = 1.7)'|'inElastic(amplitude = 1, period = .3)'|'outElastic(amplitude = 1, period = .3)'|'inOutElastic(amplitude = 1, period = .3)')} EaseStringParamNames
 */

/**
 * @typedef {('ease'|'ease-in'|'ease-out'|'ease-in-out'|'linear(0, 0.25, 1)'|'steps'|'steps(6, start)'|'step-start'|'step-end'|'cubic-bezier(0.42, 0, 1, 1)') } WAAPIEaseStringParamNames
 */

/**
 * @callback PowerEasing
 * @param {Number|String} [power=1.675]
 * @return {EasingFunction}
 */

/**
 * @callback BackEasing
 * @param {Number|String} [overshoot=1.7]
 * @return {EasingFunction}
 */

/**
 * @callback ElasticEasing
 * @param {Number|String} [amplitude=1]
 * @param {Number|String} [period=.3]
 * @return {EasingFunction}
 */

/** @typedef {PowerEasing|BackEasing|ElasticEasing} EasingFunctionWithParams */

// A hack to get both ease names suggestions AND allow any strings
// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421
/** @typedef {(String & {})|EaseStringParamNames|EasingFunction|Spring} EasingParam */
/** @typedef {(String & {})|EaseStringParamNames|WAAPIEaseStringParamNames|EasingFunction|Spring} WAAPIEasingParam */

// Spring types

/**
 * @typedef {Object} SpringParams
 * @property {Number} [mass=1] - Mass, default 1
 * @property {Number} [stiffness=100] - Stiffness, default 100
 * @property {Number} [damping=10] - Damping, default 10
 * @property {Number} [velocity=0] - Initial velocity, default 0
 * @property {Number} [bounce=0] - Initial bounce, default 0
 * @property {Number} [duration=0] - The perceived duration, default 0
 * @property {Callback<JSAnimation>} [onComplete] - Callback function called when the spring currentTime hits the perceived duration
 */

 // Callback types

/**
 * @template T
 * @callback Callback
 * @param {T} self - Returns itself
 * @param {PointerEvent} [e]
 * @return {*}
 */

/**
 * @template {object} T
 * @typedef {Object} TickableCallbacks
 * @property {Callback<T>} [onBegin]
 * @property {Callback<T>} [onBeforeUpdate]
 * @property {Callback<T>} [onUpdate]
 * @property {Callback<T>} [onLoop]
 * @property {Callback<T>} [onPause]
 * @property {Callback<T>} [onComplete]
 */

/**
 * @template {object} T
 * @typedef {Object} RenderableCallbacks
 * @property {Callback<T>} [onRender]
 */

// Timer types

/**
 * @typedef {Object} TimerOptions
 * @property {Number|String} [id]
 * @property {TweenParamValue} [duration]
 * @property {TweenParamValue} [delay]
 * @property {Number} [loopDelay]
 * @property {Boolean} [reversed]
 * @property {Boolean} [alternate]
 * @property {Boolean|Number} [loop]
 * @property {Boolean|ScrollObserver} [autoplay]
 * @property {Number} [frameRate]
 * @property {Number} [playbackRate]
 */

/**
 * @typedef {TimerOptions & TickableCallbacks<Timer>} TimerParams
 */

// Tween types

/**
 * @callback FunctionValue
 * @param {Target} target - The animated target
 * @param {Number} index - The target index
 * @param {Number} length - The total number of animated targets
 * @return {Number|String|TweenObjectValue|EasingParam|Array.<Number|String|TweenObjectValue>}
 */

/**
 * @callback TweenModifier
 * @param {Number} value - The animated value
 * @return {Number|String}
 */

/** @typedef {[Number, Number, Number, Number]} ColorArray */

/**
 * @typedef {Object} Tween
 * @property {Number} id
 * @property {JSAnimation} parent
 * @property {String} property
 * @property {Target} target
 * @property {String|Number} _value
 * @property {Function|null} _func
 * @property {EasingFunction} _ease
 * @property {Array.<Number>} _fromNumbers
 * @property {Array.<Number>} _toNumbers
 * @property {Array.<String>} _strings
 * @property {Number} _fromNumber
 * @property {Number} _toNumber
 * @property {Array.<Number>} _numbers
 * @property {Number} _number
 * @property {String} _unit
 * @property {TweenModifier} _modifier
 * @property {Number} _currentTime
 * @property {Number} _delay
 * @property {Number} _updateDuration
 * @property {Number} _startTime
 * @property {Number} _changeDuration
 * @property {Number} _absoluteStartTime
 * @property {tweenTypes} _tweenType
 * @property {valueTypes} _valueType
 * @property {Number} _composition
 * @property {Number} _isOverlapped
 * @property {Number} _isOverridden
 * @property {Number} _renderTransforms
 * @property {String} _inlineValue
 * @property {Tween} _prevRep
 * @property {Tween} _nextRep
 * @property {Tween} _prevAdd
 * @property {Tween} _nextAdd
 * @property {Tween} _prev
 * @property {Tween} _next
 */

/**
 * @typedef TweenDecomposedValue
 * @property {Number} t - Type
 * @property {Number} n - Single number value
 * @property {String} u - Value unit
 * @property {String} o - Value operator
 * @property {Array.<Number>} d - Array of Numbers (in case of complex value type)
 * @property {Array.<String>} s - Strings (in case of complex value type)
 */

/** @typedef {{_head: null|Tween, _tail: null|Tween}} TweenPropertySiblings */
/** @typedef {Record<String, TweenPropertySiblings>} TweenLookups */
/** @typedef {WeakMap.<Target, TweenLookups>} TweenReplaceLookups */
/** @typedef {Map.<Target, TweenLookups>} TweenAdditiveLookups */

// JSAnimation types

/**
 * @typedef {Number|String|FunctionValue|EasingParam} TweenParamValue
 */

/**
 * @typedef {TweenParamValue|[TweenParamValue, TweenParamValue]} TweenPropValue
 */

/**
 * @typedef {(String & {})|'none'|'replace'|'blend'|compositionTypes} TweenComposition
 */

/**
 * @typedef {Object} TweenParamsOptions
 * @property {TweenParamValue} [duration]
 * @property {TweenParamValue} [delay]
 * @property {EasingParam|FunctionValue} [ease]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 */

/**
 * @typedef {Object} TweenValues
 * @property {TweenParamValue} [from]
 * @property {TweenPropValue} [to]
 * @property {TweenPropValue} [fromTo]
 */

/**
 * @typedef {TweenParamsOptions & TweenValues} TweenKeyValue
 */

/**
 * @typedef {Array.<TweenKeyValue|TweenPropValue>} ArraySyntaxValue
 */

/**
 * @typedef {TweenParamValue|ArraySyntaxValue|TweenKeyValue} TweenOptions
 */

/**
 * @typedef {Partial<{to: TweenParamValue|Array.<TweenParamValue>; from: TweenParamValue|Array.<TweenParamValue>; fromTo: TweenParamValue|Array.<TweenParamValue>;}>} TweenObjectValue
 */

/**
 * @typedef {Object} PercentageKeyframeOptions
 * @property {EasingParam} [ease]
 */

/**
 * @typedef {Record<String, TweenParamValue>} PercentageKeyframeParams
 */

/**
 * @typedef {Record<String, PercentageKeyframeParams & PercentageKeyframeOptions>} PercentageKeyframes
 */

/**
 * @typedef {Array<Record<String, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>} DurationKeyframes
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {PercentageKeyframes|DurationKeyframes} [keyframes]
 * @property {EasingParam} [playbackEase]
 */

// TODO: Currently setting TweenModifier to the intersected Record<> makes the FunctionValue type target param any if only one parameter is set
/**
 * @typedef {Record<String, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | DurationKeyframes | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>} AnimationParams
 */

// Timeline types

/**
 * Accepts:<br>
 * - `Number` - Absolute position in milliseconds (e.g., `500` places element at exactly 500ms)<br>
 * - `'+=Number'` - Addition: Position element X ms after the last element (e.g., `'+=100'`)<br>
 * - `'-=Number'` - Subtraction: Position element X ms before the last element's end (e.g., `'-=100'`)<br>
 * - `'*=Number'` - Multiplier: Position element at a fraction of the total duration (e.g., `'*=.5'` for halfway)<br>
 * - `'<'` - Previous end: Position element at the end position of the previous element<br>
 * - `'<<'` - Previous start: Position element at the start position of the previous element<br>
 * - `'<<+=Number'` - Combined: Position element relative to previous element's start (e.g., `'<<+=250'`)<br>
 * - `'label'` - Label: Position element at a named label position (e.g., `'My Label'`)
 *
 * @typedef {Number|`+=${Number}`|`-=${Number}`|`*=${Number}`|'<'|'<<'|`<<+=${Number}`|`<<-=${Number}`|String} TimelinePosition
 */

/**
 * Accepts:<br>
 * - `Number` - Absolute position in milliseconds (e.g., `500` places animation at exactly 500ms)<br>
 * - `'+=Number'` - Addition: Position animation X ms after the last animation (e.g., `'+=100'`)<br>
 * - `'-=Number'` - Subtraction: Position animation X ms before the last animation's end (e.g., `'-=100'`)<br>
 * - `'*=Number'` - Multiplier: Position animation at a fraction of the total duration (e.g., `'*=.5'` for halfway)<br>
 * - `'<'` - Previous end: Position animation at the end position of the previous animation<br>
 * - `'<<'` - Previous start: Position animation at the start position of the previous animation<br>
 * - `'<<+=Number'` - Combined: Position animation relative to previous animation's start (e.g., `'<<+=250'`)<br>
 * - `'label'` - Label: Position animation at a named label position (e.g., `'My Label'`)<br>
 * - `stagger(String|Nummber)` - Stagger multi-elements animation positions (e.g., 10, 20, 30...)
 *
 * @typedef {TimelinePosition | StaggerFunction<Number|String>} TimelineAnimationPosition
 */

/**
 * @typedef {Object} TimelineOptions
 * @property {DefaultsParams} [defaults]
 * @property {EasingParam} [playbackEase]
 * @property {Boolean} [composition]
 */

/**
 * @typedef {TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} TimelineParams
 */

// WAAPIAnimation types

/**
 * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue
 */

/**
 * @callback WAAPIFunctionValue
 * @param {DOMTarget} target - The animated target
 * @param {Number} index - The target index
 * @param {Number} length - The total number of animated targets
 * @return {WAAPITweenValue|WAAPIEasingParam}
 */

/**
 * @typedef {WAAPITweenValue|WAAPIFunctionValue|Array<String|Number|WAAPIFunctionValue>} WAAPIKeyframeValue
 */

/**
 * @typedef {Object} WAAPITweenOptions
 * @property {WAAPIKeyframeValue} [to]
 * @property {WAAPIKeyframeValue} [from]
 * @property {Number|WAAPIFunctionValue} [duration]
 * @property {Number|WAAPIFunctionValue} [delay]
 * @property {WAAPIEasingParam} [ease]
 * @property {CompositeOperation} [composition]
 */

/**
 * @typedef {Object} WAAPIAnimationOptions
 * @property {Number|Boolean} [loop]
 * @property {Boolean} [Reversed]
 * @property {Boolean} [Alternate]
 * @property {Boolean|ScrollObserver} [autoplay]
 * @property {Number} [playbackRate]
 * @property {Number|WAAPIFunctionValue} [duration]
 * @property {Number|WAAPIFunctionValue} [delay]
 * @property {WAAPIEasingParam|WAAPIFunctionValue} [ease]
 * @property {CompositeOperation} [composition]
 * @property {Boolean} [persist]
 * @property {Callback<WAAPIAnimation>} [onComplete]
 */

/**
 * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | Callback<WAAPIAnimation> | WAAPIEasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams
 */

// Animatable types

/**
 * @callback AnimatablePropertySetter
 * @param  {Number|Array.<Number>} to
 * @param  {Number} [duration]
 * @param  {EasingParam} [ease]
 * @return {AnimatableObject}
 */

/**
 * @callback AnimatablePropertyGetter
 * @return {Number|Array.<Number>}
 */

/**
 * @typedef {AnimatablePropertySetter & AnimatablePropertyGetter} AnimatableProperty
 */

/**
 * @typedef {Animatable & Record<String, AnimatableProperty>} AnimatableObject
 */

/**
 * @typedef {Object} AnimatablePropertyParamsOptions
 * @property {String} [unit]
 * @property {TweenParamValue} [duration]
 * @property {EasingParam} [ease]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 */

/**
 * @typedef {Record<String, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions} AnimatableParams
 */

// Scope types

/**
 * @typedef {Object} ReactRef
 * @property {HTMLElement|SVGElement|null} [current]
 */

/**
 * @typedef {Object} AngularRef
 * @property {HTMLElement|SVGElement} [nativeElement]
 */

/**
 * @typedef {Object} ScopeParams
 * @property {DOMTargetSelector|ReactRef|AngularRef} [root]
 * @property {DefaultsParams} [defaults]
 * @property {Record<String, String>} [mediaQueries]
 */

/**
 * @template T
 * @callback ScopedCallback
 * @param {Scope} scope
 * @return {T}
 */

/**
 * @callback ScopeCleanupCallback
 * @param {Scope} [scope]
 */

/**
 * @callback ScopeConstructorCallback
 * @param {Scope} [scope]
 * @return {ScopeCleanupCallback|void}
 */

/**
 * @callback ScopeMethod
 * @param {...*} args
 * @return {ScopeCleanupCallback|void}
 */

// Scroll types

/**
 * @typedef {String|Number} ScrollThresholdValue
 */

/**
 * @typedef {Object} ScrollThresholdParam
 * @property {ScrollThresholdValue} [target]
 * @property {ScrollThresholdValue} [container]
 */

/**
 * @callback ScrollObserverAxisCallback
 * @param {ScrollObserver} self
 * @return {'x'|'y'}
 */

/**
 * @callback ScrollThresholdCallback
 * @param {ScrollObserver} self
 * @return {ScrollThresholdValue|ScrollThresholdParam}
 */

/**
 * @typedef {Object} ScrollObserverParams
 * @property {Number|String} [id]
 * @property {Boolean|Number|String|EasingParam} [sync]
 * @property {TargetsParam} [container]
 * @property {TargetsParam} [target]
 * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]
 * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]
 * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]
 * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]
 * @property {Boolean} [debug]
 * @property {Callback<ScrollObserver>} [onEnter]
 * @property {Callback<ScrollObserver>} [onLeave]
 * @property {Callback<ScrollObserver>} [onEnterForward]
 * @property {Callback<ScrollObserver>} [onLeaveForward]
 * @property {Callback<ScrollObserver>} [onEnterBackward]
 * @property {Callback<ScrollObserver>} [onLeaveBackward]
 * @property {Callback<ScrollObserver>} [onUpdate]
 * @property {Callback<ScrollObserver>} [onSyncComplete]
 */

// Draggable types

/**
 * @typedef {Object} DraggableAxisParam
 * @property {String} [mapTo]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]
 */

/**
 * @typedef {Object} DraggableCursorParams
 * @property {String} [onHover]
 * @property {String} [onGrab]
 */

/**
 * @typedef {Object} DraggableDragThresholdParams
 * @property {Number} [mouse]
 * @property {Number} [touch]
 */

/**
 * @typedef {Object} DraggableParams
 * @property {DOMTargetSelector} [trigger]
 * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]
 * @property {Boolean|DraggableAxisParam} [x]
 * @property {Boolean|DraggableAxisParam} [y]
 * @property {TweenModifier} [modifier]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]
 * @property {Number|((draggable: Draggable) => Number)} [containerFriction]
 * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]
 * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]
 * @property {Number|DraggableDragThresholdParams|((draggable: Draggable) => Number|DraggableDragThresholdParams)} [dragThreshold]
 * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]
 * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]
 * @property {Number|((draggable: Draggable) => Number)} [minVelocity]
 * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]
 * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]
 * @property {Number} [releaseMass]
 * @property {Number} [releaseStiffness]
 * @property {Number} [releaseDamping]
 * @property {Boolean} [releaseDamping]
 * @property {EasingParam} [releaseEase]
 * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]
 * @property {Callback<Draggable>} [onGrab]
 * @property {Callback<Draggable>} [onDrag]
 * @property {Callback<Draggable>} [onRelease]
 * @property {Callback<Draggable>} [onUpdate]
 * @property {Callback<Draggable>} [onSettle]
 * @property {Callback<Draggable>} [onSnap]
 * @property {Callback<Draggable>} [onResize]
 * @property {Callback<Draggable>} [onAfterResize]
 */

// Text types

/**
 * @typedef {Object} SplitTemplateParams
 * @property {false|String} [class]
 * @property {Boolean|'hidden'|'clip'|'visible'|'scroll'|'auto'} [wrap]
 * @property {Boolean|'top'|'right'|'bottom'|'left'|'center'} [clone]
 */

/**
 * @typedef {Boolean|String} SplitValue
 */

/**
 * @callback SplitFunctionValue
 * @param {Node|HTMLElement} [value]
 * @return String
 */

/**
 * @typedef {Object} TextSplitterParams
 * @property {SplitValue|SplitTemplateParams|SplitFunctionValue} [lines]
 * @property {SplitValue|SplitTemplateParams|SplitFunctionValue} [words]
 * @property {SplitValue|SplitTemplateParams|SplitFunctionValue} [chars]
 * @property {Boolean} [accessible]
 * @property {Boolean} [includeSpaces]
 * @property {Boolean} [debug]
 */

// SVG types

/**
 * @typedef {SVGGeometryElement & {
 *   setAttribute(name: 'draw', value: `${number} ${number}`): void;
 *   draw: `${number} ${number}`;
 * }} DrawableSVGGeometry
 */


(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.anime = {}));
})(this, (function (exports) { 'use strict';

  // Environments

  // TODO: Do we need to check if we're running inside a worker ?
  const isBrowser = typeof window !== 'undefined';

  /** @typedef {Window & {AnimeJS: Array} & {AnimeJSDevTools: any}|null} AnimeJSWindow

  /** @type {AnimeJSWindow} */
  const win = isBrowser ? /** @type {AnimeJSWindow} */(/** @type {unknown} */(window)) : null;

  /** @type {Document|null} */
  const doc = isBrowser ? document : null;

  // Enums

  /** @enum {Number} */
  const tweenTypes = {
    OBJECT: 0,
    ATTRIBUTE: 1,
    CSS: 2,
    TRANSFORM: 3,
    CSS_VAR: 4,
  };

  /** @enum {Number} */
  const valueTypes = {
    NUMBER: 0,
    UNIT: 1,
    COLOR: 2,
    COMPLEX: 3,
  };

  /** @enum {Number} */
  const tickModes = {
    NONE: 0,
    AUTO: 1,
    FORCE: 2,
  };

  /** @enum {Number} */
  const compositionTypes = {
    replace: 0,
    none: 1,
    blend: 2,
  };

  // Cache symbols

  const isRegisteredTargetSymbol = Symbol();
  const isDomSymbol = Symbol();
  const isSvgSymbol = Symbol();
  const transformsSymbol = Symbol();
  const morphPointsSymbol = Symbol();
  const proxyTargetSymbol = Symbol();

  // Numbers

  const minValue = 1e-11;
  const maxValue = 1e12;
  const K = 1e3;
  const maxFps = 240;

  // Strings

  const emptyString = '';
  const cssVarPrefix = 'var(';

  const shortTransforms = /*#__PURE__*/ (() => {
    const map = new Map();
    map.set('x', 'translateX');
    map.set('y', 'translateY');
    map.set('z', 'translateZ');
    return map;
  })();

  const validTransforms = [
    'translateX',
    'translateY',
    'translateZ',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'scale',
    'scaleX',
    'scaleY',
    'scaleZ',
    'skew',
    'skewX',
    'skewY',
    'matrix',
    'matrix3d',
    'perspective',
  ];

  const transformsFragmentStrings = /*#__PURE__*/ validTransforms.reduce((a, v) => ({...a, [v]: v + '('}), {});

  // Functions

  /** @return {void} */
  const noop = () => {};

  // Regex

  const hexTestRgx = /(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;
  const rgbExecRgx = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;
  const rgbaExecRgx = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
  const hslExecRgx = /hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;
  const hslaExecRgx = /hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
  // export const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g;
  const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi;
  // export const unitsExecRgx = /^([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)+([a-z]+|%)$/i;
  const unitsExecRgx = /^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i;
  const lowerCaseRgx = /([a-z])([A-Z])/g;
  const transformsExecRgx = /(\w+)(\([^)]+\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()
  const relativeValuesExecRgx = /(\*=|\+=|-=)/;
  const cssVariableMatchRgx = /var\(\s*(--[\w-]+)(?:\s*,\s*([^)]+))?\s*\)/;

  

  /** @type {DefaultsParams} */
  const defaults = {
    id: null,
    keyframes: null,
    playbackEase: null,
    playbackRate: 1,
    frameRate: maxFps,
    loop: 0,
    reversed: false,
    alternate: false,
    autoplay: true,
    persist: false,
    duration: K,
    delay: 0,
    loopDelay: 0,
    ease: 'out(2)',
    composition: compositionTypes.replace,
    modifier: v => v,
    onBegin: noop,
    onBeforeUpdate: noop,
    onUpdate: noop,
    onLoop: noop,
    onPause: noop,
    onComplete: noop,
    onRender: noop,
  };

  const scope = {
    /** @type {Scope} */
    current: null,
    /** @type {Document|DOMTarget} */
    root: doc,
  };

  const globals = {
    /** @type {DefaultsParams} */
    defaults,
    /** @type {Number} */
    precision: 4,
    /** @type {Number} equals 1 in ms mode, 0.001 in s mode */
    timeScale: 1,
    /** @type {Number} */
    tickThreshold: 200,
  };

  const devTools = isBrowser && win.AnimeJSDevTools;

  const globalVersions = { version: '4.3.0', engine: null };

  if (isBrowser) {
    if (!win.AnimeJS) win.AnimeJS = [];
    win.AnimeJS.push(globalVersions);
  }

  

  // Strings

  /**
   * @param  {String} str
   * @return {String}
   */
  const toLowerCase = str => str.replace(lowerCaseRgx, '$1-$2').toLowerCase();

  /**
   * Prioritize this method instead of regex when possible
   * @param  {String} str
   * @param  {String} sub
   * @return {Boolean}
   */
  const stringStartsWith = (str, sub) => str.indexOf(sub) === 0;

  // Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.
  const now = Date.now;

  // Types checkers

  const isArr = Array.isArray;
  /**@param {any} a @return {a is Record<String, any>} */
  const isObj = a => a && a.constructor === Object;
  /**@param {any} a @return {a is Number} */
  const isNum = a => typeof a === 'number' && !isNaN(a);
  /**@param {any} a @return {a is String} */
  const isStr = a => typeof a === 'string';
  /**@param {any} a @return {a is Function} */
  const isFnc = a => typeof a === 'function';
  /**@param {any} a @return {a is undefined} */
  const isUnd = a => typeof a === 'undefined';
  /**@param {any} a @return {a is null | undefined} */
  const isNil = a => isUnd(a) || a === null;
  /**@param {any} a @return {a is SVGElement} */
  const isSvg = a => isBrowser && a instanceof SVGElement;
  /**@param {any} a @return {Boolean} */
  const isHex = a => hexTestRgx.test(a);
  /**@param {any} a @return {Boolean} */
  const isRgb = a => stringStartsWith(a, 'rgb') && a[a.length - 1] === ')';
  /**@param {any} a @return {Boolean} */
  const isHsl = a => stringStartsWith(a, 'hsl') && a[a.length - 1] === ')';
  /**@param {any} a @return {Boolean} */
  const isCol = a => isHex(a) || isRgb(a) || isHsl(a);
  /**@param {any} a @return {Boolean} */
  const isKey = a => !globals.defaults.hasOwnProperty(a);

  // SVG

  // Consider the following as CSS animation
  // CSS opacity animation has better default values (opacity: 1 instead of 0))
  // rotate is more commonly intended to be used as a transform
  const svgCssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];

  /**
   * @param  {Target} el
   * @param  {String} propertyName
   * @return {Boolean}
   */
  const isValidSVGAttribute = (el, propertyName) => {
    if (svgCssReservedProperties.includes(propertyName)) return false;
    if (el.getAttribute(propertyName) || propertyName in el) {
      if (propertyName === 'scale') { // Scale
        const elParentNode = /** @type {SVGGeometryElement} */(/** @type {DOMTarget} */(el).parentNode);
        // Only consider scale as a valid SVG attribute on filter element
        return elParentNode && elParentNode.tagName === 'filter';
      }
      return true;
    }
  };

  // Number

  /**
   * @param  {Number|String} str
   * @return {Number}
   */
  const parseNumber = str => isStr(str) ?
    parseFloat(/** @type {String} */(str)) :
    /** @type {Number} */(str);

  // Math

  const pow = Math.pow;
  const sqrt = Math.sqrt;
  const sin = Math.sin;
  const cos = Math.cos;
  const abs = Math.abs;
  const exp = Math.exp;
  const ceil = Math.ceil;
  const floor = Math.floor;
  const asin = Math.asin;
  const max = Math.max;
  const atan2 = Math.atan2;
  const PI = Math.PI;
  const _round = Math.round;

  /**
   * Clamps a value between min and max bounds
   *
   * @param  {Number} v - Value to clamp
   * @param  {Number} min - Minimum boundary
   * @param  {Number} max - Maximum boundary
   * @return {Number}
   */
  const clamp$1 = (v, min, max) => v < min ? min : v > max ? max : v;

  const powCache = {};

  /**
   * Rounds a number to specified decimal places
   *
   * @param  {Number} v - Value to round
   * @param  {Number} decimalLength - Number of decimal places
   * @return {Number}
   */
  const round$1 = (v, decimalLength) => {
    if (decimalLength < 0) return v;
    if (!decimalLength) return _round(v);
    let p = powCache[decimalLength];
    if (!p) p = powCache[decimalLength] = 10 ** decimalLength;
    return _round(v * p) / p;
  };

  /**
   * Snaps a value to nearest increment or array value
   *
   * @param  {Number} v - Value to snap
   * @param  {Number|Array<Number>} increment - Step size or array of snap points
   * @return {Number}
   */
  const snap$1 = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => (abs(cv - v) < abs(closest - v) ? cv : closest)) : increment ? _round(v / increment) * increment : v;

  /**
   * Linear interpolation between two values
   *
   * @param  {Number} start - Starting value
   * @param  {Number} end - Ending value
   * @param  {Number} factor - Interpolation factor in the range [0, 1]
   * @return {Number} The interpolated value
   */
  const lerp$1 = (start, end, factor) => start + (end - start) * factor;

  /**
   * Replaces infinity with maximum safe value
   *
   * @param  {Number} v - Value to check
   * @return {Number}
   */
  const clampInfinity = v => v === Infinity ? maxValue : v === -Infinity ? -maxValue : v;

  /**
   * Normalizes time value with minimum threshold
   *
   * @param  {Number} v - Time value to normalize
   * @return {Number}
   */
  const normalizeTime = v => v <= minValue ? minValue : clampInfinity(round$1(v, 11));

  // Arrays

  /**
   * @template T
   * @param    {T[]} a
   * @return   {T[]}
   */
  const cloneArray = a => isArr(a) ? [ ...a ] : a;

  // Objects

  /**
   * @template T
   * @template U
   * @param    {T} o1
   * @param    {U} o2
   * @return   {T & U}
   */
  const mergeObjects = (o1, o2) => {
    const merged = /** @type {T & U} */({ ...o1 });
    for (let p in o2) {
      const o1p = /** @type {T & U} */(o1)[p];
      merged[p] = isUnd(o1p) ? /** @type {T & U} */(o2)[p] : o1p;
    }  return merged;
  };

  // Linked lists

  /**
   * @param  {Object} parent
   * @param  {Function} callback
   * @param  {Boolean} [reverse]
   * @param  {String} [prevProp]
   * @param  {String} [nextProp]
   * @return {void}
   */
  const forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {
    let next = parent._head;
    let adjustedNextProp = nextProp;
    if (reverse) {
      next = parent._tail;
      adjustedNextProp = prevProp;
    }
    while (next) {
      const currentNext = next[adjustedNextProp];
      callback(next);
      next = currentNext;
    }
  };

  /**
   * @param  {Object} parent
   * @param  {Object} child
   * @param  {String} [prevProp]
   * @param  {String} [nextProp]
   * @return {void}
   */
  const removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {
    const prev = child[prevProp];
    const next = child[nextProp];
    prev ? prev[nextProp] = next : parent._head = next;
    next ? next[prevProp] = prev : parent._tail = prev;
    child[prevProp] = null;
    child[nextProp] = null;
  };

  /**
   * @param  {Object} parent
   * @param  {Object} child
   * @param  {Function} [sortMethod]
   * @param  {String} prevProp
   * @param  {String} nextProp
   * @return {void}
   */
  const addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {
    let prev = parent._tail;
    while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];
    const next = prev ? prev[nextProp] : parent._head;
    prev ? prev[nextProp] = child : parent._head = child;
    next ? next[prevProp] = child : parent._tail = child;
    child[prevProp] = prev;
    child[nextProp] = next;
  };

  

  /**
   * @param  {DOMTarget} target
   * @param  {String} propName
   * @param  {Object} animationInlineStyles
   * @return {String}
   */
  const parseInlineTransforms = (target, propName, animationInlineStyles) => {
    const inlineTransforms = target.style.transform;
    let inlinedStylesPropertyValue;
    if (inlineTransforms) {
      const cachedTransforms = target[transformsSymbol];
      let t; while (t = transformsExecRgx.exec(inlineTransforms)) {
        const inlinePropertyName = t[1];
        // const inlinePropertyValue = t[2];
        const inlinePropertyValue = t[2].slice(1, -1);
        cachedTransforms[inlinePropertyName] = inlinePropertyValue;
        if (inlinePropertyName === propName) {
          inlinedStylesPropertyValue = inlinePropertyValue;
          // Store the new parsed inline styles if animationInlineStyles is provided
          if (animationInlineStyles) {
            animationInlineStyles[propName] = inlinePropertyValue;
          }
        }
      }
    }
    return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue :
      stringStartsWith(propName, 'scale') ? '1' :
      stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew') ? '0deg' : '0px';
  };

  

  /**
   * RGB / RGBA Color value string -> RGBA values array
   * @param  {String} rgbValue
   * @return {ColorArray}
   */
  const rgbToRgba = rgbValue => {
    const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);
    const a = !isUnd(rgba[4]) ? +rgba[4] : 1;
    return [
      +rgba[1],
      +rgba[2],
      +rgba[3],
      a
    ]
  };

  /**
   * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array
   * @param  {String} hexValue
   * @return {ColorArray}
   */
  const hexToRgba = hexValue => {
    const hexLength = hexValue.length;
    const isShort = hexLength === 4 || hexLength === 5;
    return [
      +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),
      +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),
      +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),
      ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)
    ]
  };

  /**
   * @param  {Number} p
   * @param  {Number} q
   * @param  {Number} t
   * @return {Number}
   */
  const hue2rgb = (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    return t < 1 / 6 ? p + (q - p) * 6 * t :
           t < 1 / 2 ? q :
           t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :
           p;
  };

  /**
   * HSL / HSLA Color value string -> RGBA values array
   * @param  {String} hslValue
   * @return {ColorArray}
   */
  const hslToRgba = hslValue => {
    const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);
    const h = +hsla[1] / 360;
    const s = +hsla[2] / 100;
    const l = +hsla[3] / 100;
    const a = !isUnd(hsla[4]) ? +hsla[4] : 1;
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const q = l < .5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = round$1(hue2rgb(p, q, h + 1 / 3) * 255, 0);
      g = round$1(hue2rgb(p, q, h) * 255, 0);
      b = round$1(hue2rgb(p, q, h - 1 / 3) * 255, 0);
    }
    return [r, g, b, a];
  };

  /**
   * All in one color converter that converts a color string value into an array of RGBA values
   * @param  {String} colorString
   * @return {ColorArray}
   */
  const convertColorStringValuesToRgbaArray = colorString => {
    return isRgb(colorString) ? rgbToRgba(colorString) :
           isHex(colorString) ? hexToRgba(colorString) :
           isHsl(colorString) ? hslToRgba(colorString) :
           [0, 0, 0, 1];
  };

  

  /**
   * @template T, D
   * @param {T|undefined} targetValue
   * @param {D} defaultValue
   * @return {T|D}
   */
  const setValue = (targetValue, defaultValue) => {
    return isUnd(targetValue) ? defaultValue : targetValue;
  };

  /**
   * @param  {TweenPropValue} value
   * @param  {Target} target
   * @param  {Number} index
   * @param  {Number} total
   * @param  {Object} [store]
   * @return {any}
   */
  const getFunctionValue = (value, target, index, total, store) => {
    let func;
    if (isFnc(value)) {
      func = () => {
        const computed = /** @type {Function} */(value)(target, index, total);
        // Fallback to 0 if the function returns undefined / NaN / null / false / 0
        return !isNaN(+computed) ? +computed : computed || 0;
      };
    } else if (isStr(value) && stringStartsWith(value, cssVarPrefix)) {
      func = () => {
        const match = value.match(cssVariableMatchRgx);
        const cssVarName = match[1];
        const fallbackValue = match[2];
        let computed = getComputedStyle(/** @type {HTMLElement} */(target))?.getPropertyValue(cssVarName);
        // Use fallback if CSS variable is not set or empty
        if ((!computed || computed.trim() === emptyString) && fallbackValue) {
          computed = fallbackValue.trim();
        }
        return computed || 0;
      };
    } else {
      return value;
    }
    if (store) store.func = func;
    return func();
  };

  /**
   * @param  {Target} target
   * @param  {String} prop
   * @return {tweenTypes}
   */
  const getTweenType = (target, prop) => {
    return !target[isDomSymbol] ? tweenTypes.OBJECT :
      // Handle SVG attributes
      target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE :
      // Handle CSS Transform properties differently than CSS to allow individual animations
      validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM :
      // CSS variables
      stringStartsWith(prop, '--') ? tweenTypes.CSS_VAR :
      // All other CSS properties
      prop in /** @type {DOMTarget} */(target).style ? tweenTypes.CSS :
      // Handle other DOM Attributes
      prop in target ? tweenTypes.OBJECT :
      tweenTypes.ATTRIBUTE;
  };

  /**
   * @param  {DOMTarget} target
   * @param  {String} propName
   * @param  {Object} animationInlineStyles
   * @return {String}
   */
  const getCSSValue = (target, propName, animationInlineStyles) => {
    const inlineStyles = target.style[propName];
    if (inlineStyles && animationInlineStyles) {
      animationInlineStyles[propName] = inlineStyles;
    }
    const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);
    return value === 'auto' ? '0' : value;
  };

  /**
   * @param {Target} target
   * @param {String} propName
   * @param {tweenTypes} [tweenType]
   * @param {Object|void} [animationInlineStyles]
   * @return {String|Number}
   */
  const getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {
    const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);
    return type === tweenTypes.OBJECT ? target[propName] || 0 :
           type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */(target).getAttribute(propName) :
           type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */(target), propName, animationInlineStyles) :
           type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles).trimStart() :
           getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles);
  };

  /**
   * @param  {Number} x
   * @param  {Number} y
   * @param  {String} operator
   * @return {Number}
   */
  const getRelativeValue = (x, y, operator) => {
    return operator === '-' ? x - y :
           operator === '+' ? x + y :
           x * y;
  };

  /** @return {TweenDecomposedValue} */
  const createDecomposedValueTargetObject = () => {
    return {
      /** @type {valueTypes} */
      t: valueTypes.NUMBER,
      n: 0,
      u: null,
      o: null,
      d: null,
      s: null,
    }
  };

  /**
   * @param  {String|Number} rawValue
   * @param  {TweenDecomposedValue} targetObject
   * @return {TweenDecomposedValue}
   */
  const decomposeRawValue = (rawValue, targetObject) => {
    /** @type {valueTypes} */
    targetObject.t = valueTypes.NUMBER;
    targetObject.n = 0;
    targetObject.u = null;
    targetObject.o = null;
    targetObject.d = null;
    targetObject.s = null;
    if (!rawValue) return targetObject;
    const num = +rawValue;
    if (!isNaN(num)) {
      // It's a number
      targetObject.n = num;
      return targetObject;
    } else {
      // let str = /** @type {String} */(rawValue).trim();
      let str = /** @type {String} */(rawValue);
      // Parsing operators (+=, -=, *=) manually is much faster than using regex here
      if (str[1] === '=') {
        targetObject.o = str[0];
        str = str.slice(2);
      }
      // Skip exec regex if the value type is complex or color to avoid long regex backtracking
      const unitMatch = str.includes(' ') ? false : unitsExecRgx.exec(str);
      if (unitMatch) {
        // Has a number and a unit
        targetObject.t = valueTypes.UNIT;
        targetObject.n = +unitMatch[1];
        targetObject.u = unitMatch[2];
        return targetObject;
      } else if (targetObject.o) {
        // Has an operator (+=, -=, *=)
        targetObject.n = +str;
        return targetObject;
      } else if (isCol(str)) {
        // Is a color
        targetObject.t = valueTypes.COLOR;
        targetObject.d = convertColorStringValuesToRgbaArray(str);
        return targetObject;
      } else {
        // Is a more complex string (generally svg coords, calc() or filters CSS values)
        const matchedNumbers = str.match(digitWithExponentRgx);
        targetObject.t = valueTypes.COMPLEX;
        targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];
        targetObject.s = str.split(digitWithExponentRgx) || [];
        return targetObject;
      }
    }
  };

  /**
   * @param  {Tween} tween
   * @param  {TweenDecomposedValue} targetObject
   * @return {TweenDecomposedValue}
   */
  const decomposeTweenValue = (tween, targetObject) => {
    targetObject.t = tween._valueType;
    targetObject.n = tween._toNumber;
    targetObject.u = tween._unit;
    targetObject.o = null;
    targetObject.d = cloneArray(tween._toNumbers);
    targetObject.s = cloneArray(tween._strings);
    return targetObject;
  };

  const decomposedOriginalValue = createDecomposedValueTargetObject();

  

  

  

  /**
   * @param  {Tickable} tickable
   * @param  {Number} time
   * @param  {Number} muteCallbacks
   * @param  {Number} internalRender
   * @param  {tickModes} tickMode
   * @return {Number}
   */
  const render = (tickable, time, muteCallbacks, internalRender, tickMode) => {

    const parent = tickable.parent;
    const duration = tickable.duration;
    const completed = tickable.completed;
    const iterationDuration = tickable.iterationDuration;
    const iterationCount = tickable.iterationCount;
    const _currentIteration = tickable._currentIteration;
    const _loopDelay = tickable._loopDelay;
    const _reversed = tickable._reversed;
    const _alternate = tickable._alternate;
    const _hasChildren = tickable._hasChildren;
    const tickableDelay = tickable._delay;
    const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime

    const tickableEndTime = tickableDelay + iterationDuration;
    const tickableAbsoluteTime = time - tickableDelay;
    const tickablePrevTime = clamp$1(tickablePrevAbsoluteTime, -tickableDelay, duration);
    const tickableCurrentTime = clamp$1(tickableAbsoluteTime, -tickableDelay, duration);
    const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;
    const isCurrentTimeAboveZero = tickableCurrentTime > 0;
    const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;
    const isSetter = duration <= minValue;
    const forcedTick = tickMode === tickModes.FORCE;

    let isOdd = 0;
    let iterationElapsedTime = tickableAbsoluteTime;
    // Render checks
    // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer
    let hasRendered = 0;

    // Execute the "expensive" iterations calculations only when necessary
    if (iterationCount > 1) {
      // bitwise NOT operator seems to be generally faster than Math.floor() across browsers
      const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));
      tickable._currentIteration = clamp$1(currentIteration, 0, iterationCount);
      // Prevent the iteration count to go above the max iterations when reaching the end of the animation
      if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;
      isOdd = tickable._currentIteration % 2;
      iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;
    }

    // Checks if exactly one of _reversed and (_alternate && isOdd) is true
    const isReversed = _reversed ^ (_alternate && isOdd);
    const _ease = /** @type {Renderable} */(tickable)._ease;
    let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;
    if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;
    const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;

    tickable._currentTime = tickableAbsoluteTime;
    tickable._iterationTime = iterationTime;
    tickable.backwards = isRunningBackwards;

    if (isCurrentTimeAboveZero && !tickable.began) {
      tickable.began = true;
      if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
        tickable.onBegin(/** @type {CallbackArgument} */(tickable));
      }
    } else if (tickableAbsoluteTime <= 0) {
      tickable.began = false;
    }

    // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function
    // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values
    if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {
      tickable.onLoop(/** @type {CallbackArgument} */(tickable));
    }

    if (
      forcedTick ||
      tickMode === tickModes.AUTO && (
        time >= tickableDelay && time <= tickableEndTime || // Normal render
        time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state
        time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state
      ) ||
      iterationTime >= tickableEndTime && tickablePrevTime !== duration ||
      iterationTime <= tickableDelay && tickablePrevTime > 0 ||
      time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation
      isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped
    ) {

      if (isCurrentTimeAboveZero) {
        // Trigger onUpdate callback before rendering
        tickable.computeDeltaTime(tickablePrevTime);
        if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */(tickable));
      }

      // Start tweens rendering
      if (!_hasChildren) {

        // Time has jumped more than globals.tickThreshold so consider this tick manual
        const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;
        const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;

        // Only Animation can have tweens, Timer returns undefined
        let tween = /** @type {Tween} */(/** @type {JSAnimation} */(tickable)._head);
        let tweenTarget;
        let tweenStyle;
        let tweenTargetTransforms;
        let tweenTargetTransformsProperties;
        let tweenTransformsNeedUpdate = 0;

        while (tween) {

          const tweenComposition = tween._composition;
          const tweenCurrentTime = tween._currentTime;
          const tweenChangeDuration = tween._changeDuration;
          const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;
          const tweenNextRep = tween._nextRep;
          const tweenPrevRep = tween._prevRep;
          const tweenHasComposition = tweenComposition !== compositionTypes.none;

          if ((forcedRender || (
              (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&
              (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)
            )) && (!tweenHasComposition || (
              !tween._isOverridden &&
              (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&
              (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&
              (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))
            ))
          ) {

            const tweenNewTime = tween._currentTime = clamp$1(iterationTime - tween._startTime, 0, tweenChangeDuration);
            const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);
            const tweenModifier = tween._modifier;
            const tweenValueType = tween._valueType;
            const tweenType = tween._tweenType;
            const tweenIsObject = tweenType === tweenTypes.OBJECT;
            const tweenIsNumber = tweenValueType === valueTypes.NUMBER;
            // Only round the in-between frames values if the final value is a string
            const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;

            // Recompose tween value
            /** @type {String|Number} */
            let value;
            /** @type {Number} */
            let number;

            if (tweenIsNumber) {
              value = number = /** @type {Number} */(tweenModifier(round$1(lerp$1(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision )));
            } else if (tweenValueType === valueTypes.UNIT) {
              // Rounding the values speed up string composition
              number = /** @type {Number} */(tweenModifier(round$1(lerp$1(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision)));
              value = `${number}${tween._unit}`;
            } else if (tweenValueType === valueTypes.COLOR) {
              const fn = tween._fromNumbers;
              const tn = tween._toNumbers;
              const r = round$1(clamp$1(/** @type {Number} */(tweenModifier(lerp$1(fn[0], tn[0], tweenProgress))), 0, 255), 0);
              const g = round$1(clamp$1(/** @type {Number} */(tweenModifier(lerp$1(fn[1], tn[1], tweenProgress))), 0, 255), 0);
              const b = round$1(clamp$1(/** @type {Number} */(tweenModifier(lerp$1(fn[2], tn[2], tweenProgress))), 0, 255), 0);
              const a = clamp$1(/** @type {Number} */(tweenModifier(round$1(lerp$1(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);
              value = `rgba(${r},${g},${b},${a})`;
              if (tweenHasComposition) {
                const ns = tween._numbers;
                ns[0] = r;
                ns[1] = g;
                ns[2] = b;
                ns[3] = a;
              }
            } else if (tweenValueType === valueTypes.COMPLEX) {
              value = tween._strings[0];
              for (let j = 0, l = tween._toNumbers.length; j < l; j++) {
                const n = /** @type {Number} */(tweenModifier(round$1(lerp$1(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));
                const s = tween._strings[j + 1];
                value += `${s ? n + s : n}`;
                if (tweenHasComposition) {
                  tween._numbers[j] = n;
                }
              }
            }

            // For additive tweens and Animatables
            if (tweenHasComposition) {
              tween._number = number;
            }

            if (!internalRender && tweenComposition !== compositionTypes.blend) {

              const tweenProperty = tween.property;
              tweenTarget = tween.target;

              if (tweenIsObject) {
                tweenTarget[tweenProperty] = value;
              } else if (tweenType === tweenTypes.ATTRIBUTE) {
                /** @type {DOMTarget} */(tweenTarget).setAttribute(tweenProperty, /** @type {String} */(value));
              } else {
                tweenStyle = /** @type {DOMTarget} */(tweenTarget).style;
                if (tweenType === tweenTypes.TRANSFORM) {
                  if (tweenTarget !== tweenTargetTransforms) {
                    tweenTargetTransforms = tweenTarget;
                    // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.
                    tweenTargetTransformsProperties = tweenTarget[transformsSymbol];
                  }
                  tweenTargetTransformsProperties[tweenProperty] = value;
                  tweenTransformsNeedUpdate = 1;
                } else if (tweenType === tweenTypes.CSS) {
                  tweenStyle[tweenProperty] = value;
                } else if (tweenType === tweenTypes.CSS_VAR) {
                  tweenStyle.setProperty(tweenProperty,/** @type {String} */(value));
                }
              }

              if (isCurrentTimeAboveZero) hasRendered = 1;

            } else {
              // Used for composing timeline tweens without having to do a real render
              tween._value = value;
            }

          }

          // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax
          // to reduce memory usage on string composition
          if (tweenTransformsNeedUpdate && tween._renderTransforms) {
            let str = emptyString;
            for (let key in tweenTargetTransformsProperties) {
              str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;
            }
            tweenStyle.transform = str;
            tweenTransformsNeedUpdate = 0;
          }

          tween = tween._next;
        }

        if (!muteCallbacks && hasRendered) {
          /** @type {JSAnimation} */(tickable).onRender(/** @type {JSAnimation} */(tickable));
        }
      }

      if (!muteCallbacks && isCurrentTimeAboveZero) {
        tickable.onUpdate(/** @type {CallbackArgument} */(tickable));
      }

    }

    // End tweens rendering

    // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards
    if (parent && isSetter) {
      if (!muteCallbacks && (
        // (tickableAbsoluteTime > 0 instead) of (tickableAbsoluteTime >= duration) to prevent floating point precision issues
        // see: https://github.com/juliangarnier/anime/issues/1088
        (parent.began && !isRunningBackwards && tickableAbsoluteTime > 0 && !completed) ||
        (isRunningBackwards && tickableAbsoluteTime <= minValue && completed)
      )) {
        tickable.onComplete(/** @type {CallbackArgument} */(tickable));
        tickable.completed = !isRunningBackwards;
      }
    // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops
    } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {
      if (iterationCount === Infinity) {
        // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer
        tickable._startTime += tickable.duration;
      } else if (tickable._currentIteration >= iterationCount - 1) {
        // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick
        tickable.paused = true;
        if (!completed && !_hasChildren) {
          // If the tickable has children, triggers onComplete() only when all children have completed in the tick function
          tickable.completed = true;
          if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
            tickable.onComplete(/** @type {CallbackArgument} */(tickable));
            tickable._resolve(/** @type {CallbackArgument} */(tickable));
          }
        }
      }
    // Otherwise set the completed flag to false
    } else {
      tickable.completed = false;
    }

    // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?
    return hasRendered;
  };

  /**
   * @param  {Tickable} tickable
   * @param  {Number} time
   * @param  {Number} muteCallbacks
   * @param  {Number} internalRender
   * @param  {Number} tickMode
   * @return {void}
   */
  const tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {
    const _currentIteration = tickable._currentIteration;
    render(tickable, time, muteCallbacks, internalRender, tickMode);
    if (tickable._hasChildren) {
      const tl = /** @type {Timeline} */(tickable);
      const tlIsRunningBackwards = tl.backwards;
      const tlChildrenTime = internalRender ? time : tl._iterationTime;
      const tlCildrenTickTime = now();

      let tlChildrenHasRendered = 0;
      let tlChildrenHaveCompleted = true;

      // If the timeline has looped forward, we need to manually triggers children skipped callbacks
      if (!internalRender && tl._currentIteration !== _currentIteration) {
        const tlIterationDuration = tl.iterationDuration;
        forEachChildren(tl, (/** @type {JSAnimation} */child) => {
          if (!tlIsRunningBackwards) {
            // Force an internal render to trigger the callbacks if the child has not completed on loop
            if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {
              render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);
            }
            // Reset their began and completed flags to allow retrigering callbacks on the next iteration
            child.began = false;
            child.completed = false;
          } else {
            const childDuration = child.duration;
            const childStartTime = child._offset + child._delay;
            const childEndTime = childStartTime + childDuration;
            // Triggers the onComplete callback on reverse for children on the edges of the timeline
            if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {
              child.onComplete(child);
            }
          }
        });
        if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */(tl));
      }

      forEachChildren(tl, (/** @type {JSAnimation} */child) => {
        const childTime = round$1((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds
        const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;
        tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);
        if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;
      }, tlIsRunningBackwards);

      // Renders on timeline are triggered by its children so it needs to be set after rendering the children
      if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */(tl));

      // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end
      if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {
        // Make sure the paused flag is false in case it has been skipped in the render function
        tl.paused = true;
        if (!tl.completed) {
          tl.completed = true;
          if (!muteCallbacks) {
            tl.onComplete(/** @type {CallbackArgument} */(tl));
            tl._resolve(/** @type {CallbackArgument} */(tl));
          }
        }
      }
    }
  };

  

  

  const propertyNamesCache = {};

  /**
   * @param  {String} propertyName
   * @param  {Target} target
   * @param  {tweenTypes} tweenType
   * @return {String}
   */
  const sanitizePropertyName = (propertyName, target, tweenType) => {
    if (tweenType === tweenTypes.TRANSFORM) {
      const t = shortTransforms.get(propertyName);
      return t ? t : propertyName;
    } else if (
      tweenType === tweenTypes.CSS ||
      // Handle special cases where properties like "strokeDashoffset" needs to be set as "stroke-dashoffset"
      // but properties like "baseFrequency" should stay in lowerCamelCase
      (tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */(target).style))
    ) {
      const cachedPropertyName = propertyNamesCache[propertyName];
      if (cachedPropertyName) {
        return cachedPropertyName;
      } else {
        const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;
        propertyNamesCache[propertyName] = lowerCaseName;
        return lowerCaseName;
      }
    } else {
      return propertyName;
    }
  };

  /**
   * @template {Renderable} T
   * @param {T} renderable
   * @return {T}
   */
  const cleanInlineStyles = renderable => {
    // Allow cleanInlineStyles() to be called on timelines
    if (renderable._hasChildren) {
      forEachChildren(renderable, cleanInlineStyles, true);
    } else {
      const animation = /** @type {JSAnimation} */(renderable);
      animation.pause();
      forEachChildren(animation, (/** @type {Tween} */tween) => {
        const tweenProperty = tween.property;
        const tweenTarget = tween.target;
        if (tweenTarget[isDomSymbol]) {
          const targetStyle = /** @type {DOMTarget} */(tweenTarget).style;
          const originalInlinedValue = tween._inlineValue;
          const tweenHadNoInlineValue = isNil(originalInlinedValue) || originalInlinedValue === emptyString;
          if (tween._tweenType === tweenTypes.TRANSFORM) {
            const cachedTransforms = tweenTarget[transformsSymbol];
            if (tweenHadNoInlineValue) {
              delete cachedTransforms[tweenProperty];
            } else {
              cachedTransforms[tweenProperty] = originalInlinedValue;
            }
            if (tween._renderTransforms) {
              if (!Object.keys(cachedTransforms).length) {
                targetStyle.removeProperty('transform');
              } else {
                let str = emptyString;
                for (let key in cachedTransforms) {
                  str += transformsFragmentStrings[key] + cachedTransforms[key] + ') ';
                }
                targetStyle.transform = str;
              }
            }
          } else {
            if (tweenHadNoInlineValue) {
              targetStyle.removeProperty(toLowerCase(tweenProperty));
            } else {
              targetStyle[tweenProperty] = originalInlinedValue;
            }
          }
          if (animation._tail === tween) {
            animation.targets.forEach(t => {
              if (t.getAttribute && t.getAttribute('style') === emptyString) {
                t.removeAttribute('style');
              }          });
          }
        }
      });
    }
    return renderable;
  };

  

  /*
   * Base class to control framerate and playback rate.
   * Inherited by Engine, Timer, Animation and Timeline.
   */
  class Clock {

    /** @param {Number} [initTime] */
    constructor(initTime = 0) {
      /** @type {Number} */
      this.deltaTime = 0;
      /** @type {Number} */
      this._currentTime = initTime;
      /** @type {Number} */
      this._lastTickTime = initTime;
      /** @type {Number} */
      this._startTime = initTime;
      /** @type {Number} */
      this._lastTime = initTime;
      /** @type {Number} */
      this._scheduledTime = 0;
      /** @type {Number} */
      this._frameDuration = K / maxFps;
      /** @type {Number} */
      this._fps = maxFps;
      /** @type {Number} */
      this._speed = 1;
      /** @type {Boolean} */
      this._hasChildren = false;
      /** @type {Tickable|Tween} */
      this._head = null;
      /** @type {Tickable|Tween} */
      this._tail = null;
    }

    get fps() {
      return this._fps;
    }

    set fps(frameRate) {
      const previousFrameDuration = this._frameDuration;
      const fr = +frameRate;
      const fps = fr < minValue ? minValue : fr;
      const frameDuration = K / fps;
      if (fps > defaults.frameRate) defaults.frameRate = fps;
      this._fps = fps;
      this._frameDuration = frameDuration;
      this._scheduledTime += frameDuration - previousFrameDuration;
    }

    get speed() {
      return this._speed;
    }

    set speed(playbackRate) {
      const pbr = +playbackRate;
      this._speed = pbr < minValue ? minValue : pbr;
    }

    /**
     * @param  {Number} time
     * @return {tickModes}
     */
    requestTick(time) {
      const scheduledTime = this._scheduledTime;
      this._lastTickTime = time;
      // If the current time is lower than the scheduled time
      // this means not enough time has passed to hit one frameDuration
      // so skip that frame
      if (time < scheduledTime) return tickModes.NONE;
      const frameDuration = this._frameDuration;
      const frameDelta = time - scheduledTime;
      // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.
      // Skips ahead if the actual elapsed time is higher.
      this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;
      return tickModes.AUTO;
    }

    /**
     * @param  {Number} time
     * @return {Number}
     */
    computeDeltaTime(time) {
      const delta = time - this._lastTime;
      this.deltaTime = delta;
      this._lastTime = time;
      return delta;
    }

  }

  const additive = {
    animation: null,
    update: noop,
  };

  

  /**
   * @typedef AdditiveAnimation
   * @property {Number} duration
   * @property {Number} _offset
   * @property {Number} _delay
   * @property {Tween} _head
   * @property {Tween} _tail
   */

  /**
   * @param  {TweenAdditiveLookups} lookups
   * @return {AdditiveAnimation}
   */
  const addAdditiveAnimation = lookups => {
    let animation = additive.animation;
    if (!animation) {
      animation = {
        duration: minValue,
        computeDeltaTime: noop,
        _offset: 0,
        _delay: 0,
        _head: null,
        _tail: null,
      };
      additive.animation = animation;
      additive.update = () => {
        lookups.forEach(propertyAnimation => {
          for (let propertyName in propertyAnimation) {
            const tweens = propertyAnimation[propertyName];
            const lookupTween = tweens._head;
            if (lookupTween) {
              const valueType = lookupTween._valueType;
              const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;
              let additiveValue = lookupTween._fromNumber;
              let tween = tweens._tail;
              while (tween && tween !== lookupTween) {
                if (additiveValues) {
                  for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];
                } else {
                  additiveValue += tween._number;
                }
                tween = tween._prevAdd;
              }
              lookupTween._toNumber = additiveValue;
              lookupTween._toNumbers = additiveValues;
            }
          }
        });
        // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop
        render(animation, 1, 1, 0, tickModes.FORCE);
      };
    }
    return animation;
  };

  

  

  const engineTickMethod = /*#__PURE__*/ (() => isBrowser ? requestAnimationFrame : setImmediate)();
  const engineCancelMethod = /*#__PURE__*/ (() => isBrowser ? cancelAnimationFrame : clearImmediate)();

  class Engine extends Clock {

    /** @param {Number} [initTime] */
    constructor(initTime) {
      super(initTime);
      this.useDefaultMainLoop = true;
      this.pauseOnDocumentHidden = true;
      /** @type {DefaultsParams} */
      this.defaults = defaults;
      // this.paused = isBrowser && doc.hidden ? true  : false;
      this.paused = true;
      /** @type {Number|NodeJS.Immediate} */
      this.reqId = 0;
    }

    update() {
      const time = this._currentTime = now();
      if (this.requestTick(time)) {
        this.computeDeltaTime(time);
        const engineSpeed = this._speed;
        const engineFps = this._fps;
        let activeTickable = /** @type {Tickable} */(this._head);
        while (activeTickable) {
          const nextTickable = activeTickable._next;
          if (!activeTickable.paused) {
            tick(
              activeTickable,
              (time - activeTickable._startTime) * activeTickable._speed * engineSpeed,
              0, // !muteCallbacks
              0, // !internalRender
              activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO
            );
          } else {
            removeChild(this, activeTickable);
            this._hasChildren = !!this._tail;
            activeTickable._running = false;
            if (activeTickable.completed && !activeTickable._cancelled) {
              activeTickable.cancel();
            }
          }
          activeTickable = nextTickable;
        }
        additive.update();
      }
    }

    wake() {
      if (this.useDefaultMainLoop && !this.reqId) {
        // Imediatly request a tick to update engine._lastTickTime and get accurate offsetPosition calculation in timer.js
        this.requestTick(now());
        this.reqId = engineTickMethod(tickEngine);
      }
      return this;
    }

    pause() {
      if (!this.reqId) return;
      this.paused = true;
      return killEngine();
    }

    resume() {
      if (!this.paused) return;
      this.paused = false;
      forEachChildren(this, (/** @type {Tickable} */child) => child.resetTime());
      return this.wake();
    }

    // Getter and setter for speed
    get speed() {
      return this._speed * (globals.timeScale === 1 ? 1 : K);
    }

    set speed(playbackRate) {
      this._speed = playbackRate * globals.timeScale;
      forEachChildren(this, (/** @type {Tickable} */child) => child.speed = child._speed);
    }

    // Getter and setter for timeUnit
    get timeUnit() {
      return globals.timeScale === 1 ? 'ms' : 's';
    }

    set timeUnit(unit) {
      const secondsScale = 0.001;
      const isSecond = unit === 's';
      const newScale = isSecond ? secondsScale : 1;
      if (globals.timeScale !== newScale) {
        globals.timeScale = newScale;
        globals.tickThreshold = 200 * newScale;
        const scaleFactor = isSecond ? secondsScale : K;
        /** @type {Number} */
        (this.defaults.duration) *= scaleFactor;
        this._speed *= scaleFactor;
      }
    }

    // Getter and setter for precision
    get precision() {
      return globals.precision;
    }

    set precision(precision) {
      globals.precision = precision;
    }

  }

  const engine = /*#__PURE__*/(() => {
    const engine = new Engine(now());
    if (isBrowser) {
      globalVersions.engine = engine;
      doc.addEventListener('visibilitychange', () => {
        if (!engine.pauseOnDocumentHidden) return;
        doc.hidden ? engine.pause() : engine.resume();
      });
    }
    return engine;
  })();


  const tickEngine = () => {
    if (engine._head) {
      engine.reqId = engineTickMethod(tickEngine);
      engine.update();
    } else {
      engine.reqId = 0;
    }
  };

  const killEngine = () => {
    engineCancelMethod(/** @type {NodeJS.Immediate & Number} */(engine.reqId));
    engine.reqId = 0;
    return engine;
  };

  

  const lookups = {
    /** @type {TweenReplaceLookups} */
    _rep: new WeakMap(),
    /** @type {TweenAdditiveLookups} */
    _add: new Map(),
  };

  /**
   * @param  {Target} target
   * @param  {String} property
   * @param  {String} lookup
   * @return {TweenPropertySiblings}
   */
  const getTweenSiblings = (target, property, lookup = '_rep') => {
    const lookupMap = lookups[lookup];
    let targetLookup = lookupMap.get(target);
    if (!targetLookup) {
      targetLookup = {};
      lookupMap.set(target, targetLookup);
    }
    return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {
      _head: null,
      _tail: null,
    }
  };

  /**
   * @param  {Tween} p
   * @param  {Tween} c
   * @return {Number|Boolean}
   */
  const addTweenSortMethod = (p, c) => {
    return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;
  };

  /**
   * @param {Tween} tween
   */
  const overrideTween = tween => {
    tween._isOverlapped = 1;
    tween._isOverridden = 1;
    tween._changeDuration = minValue;
    tween._currentTime = minValue;
  };

  /**
   * @param  {Tween} tween
   * @param  {TweenPropertySiblings} siblings
   * @return {Tween}
   */
  const composeTween = (tween, siblings) => {

    const tweenCompositionType = tween._composition;

    // Handle replaced tweens

    if (tweenCompositionType === compositionTypes.replace) {

      const tweenAbsStartTime = tween._absoluteStartTime;

      addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');

      const prevSibling = tween._prevRep;

      // Update the previous siblings for composition replace tweens

      if (prevSibling) {

        const prevParent = prevSibling.parent;
        const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;

        // Handle looped animations tween

        if (
          // Check if the previous tween is from a different animation
          tween.parent.id !== prevParent.id &&
          // Check if the animation has loops
          prevParent.iterationCount> 1 &&
          // Check if _absoluteChangeEndTime of last loop overlaps the current tween
          prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime
        ) {

          // TODO: Find a way to only override the iterations overlapping with the tween
          overrideTween(prevSibling);

          let prevPrevSibling = prevSibling._prevRep;

          // If the tween was part of a set of keyframes, override its siblings
          while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {
            overrideTween(prevPrevSibling);
            prevPrevSibling = prevPrevSibling._prevRep;
          }

        }

        const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;

        if (prevAbsEndTime > absoluteUpdateStartTime) {

          const prevChangeStartTime = prevSibling._startTime;
          const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);
          // Rounding is necessary here to minimize floating point errors when working in seconds
          const updatedPrevChangeDuration = round$1(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);

          prevSibling._changeDuration = updatedPrevChangeDuration;
          prevSibling._currentTime = updatedPrevChangeDuration;
          prevSibling._isOverlapped = 1;

          // Override the previous tween if its new _changeDuration is lower than minValue
          // TODO: See if it's even neceseeary to test against minValue, checking for 0 might be enough
          if (updatedPrevChangeDuration < minValue) {
            overrideTween(prevSibling);
          }
        }

        // Pause (and cancel) the parent if it only contains overlapped tweens

        let pausePrevParentAnimation = true;

        forEachChildren(prevParent, (/** @type Tween */t) => {
          if (!t._isOverlapped) pausePrevParentAnimation = false;
        });

        if (pausePrevParentAnimation) {
          const prevParentTL = prevParent.parent;
          if (prevParentTL) {
            let pausePrevParentTL = true;
            forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {
              if (a !== prevParent) {
                forEachChildren(a, (/** @type Tween */t) => {
                  if (!t._isOverlapped) pausePrevParentTL = false;
                });
              }
            });
            if (pausePrevParentTL) {
              prevParentTL.cancel();
            }
          } else {
            prevParent.cancel();
            // Previously, calling .cancel() on a timeline child would affect the render order of other children
            // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop
            // This is no longer needed since timeline tween composition is now handled separately
            // Keeping this here for reference
            // prevParent.completed = true;
            // prevParent.pause();
          }
        }

      }

      // let nextSibling = tween._nextRep;

      // // All the next siblings are automatically overridden

      // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {
      //   while (nextSibling) {
      //     overrideTween(nextSibling);
      //     nextSibling = nextSibling._nextRep;
      //   }
      // }

      // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {
      //   while (nextSibling) {
      //     overrideTween(nextSibling);
      //     console.log(tween.id, nextSibling.id);
      //     nextSibling = nextSibling._nextRep;
      //   }
      // }

    // Handle additive tweens composition

    } else if (tweenCompositionType === compositionTypes.blend) {

      const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');
      const additiveAnimation = addAdditiveAnimation(lookups._add);

      let lookupTween = additiveTweenSiblings._head;

      if (!lookupTween) {
        lookupTween = { ...tween };
        lookupTween._composition = compositionTypes.replace;
        lookupTween._updateDuration = minValue;
        lookupTween._startTime = 0;
        lookupTween._numbers = cloneArray(tween._fromNumbers);
        lookupTween._number = 0;
        lookupTween._next = null;
        lookupTween._prev = null;
        addChild(additiveTweenSiblings, lookupTween);
        addChild(additiveAnimation, lookupTween);
      }

      // Convert the values of TO to FROM and set TO to 0

      const toNumber = tween._toNumber;
      tween._fromNumber = lookupTween._fromNumber - toNumber;
      tween._toNumber = 0;
      tween._numbers = cloneArray(tween._fromNumbers);
      tween._number = 0;
      lookupTween._fromNumber = toNumber;

      if (tween._toNumbers) {
        const toNumbers = cloneArray(tween._toNumbers);
        if (toNumbers) {
          toNumbers.forEach((value, i) => {
            tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;
            tween._toNumbers[i] = 0;
          });
        }
        lookupTween._fromNumbers = toNumbers;
      }

      addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');

    }

    return tween;

  };

  /**
   * @param  {Tween} tween
   * @return {Tween}
   */
  const removeTweenSliblings = tween => {
    const tweenComposition = tween._composition;
    if (tweenComposition !== compositionTypes.none) {
      const tweenTarget = tween.target;
      const tweenProperty = tween.property;
      const replaceTweensLookup = lookups._rep;
      const replaceTargetProps = replaceTweensLookup.get(tweenTarget);
      const tweenReplaceSiblings = replaceTargetProps[tweenProperty];
      removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');
      if (tweenComposition === compositionTypes.blend) {
        const addTweensLookup = lookups._add;
        const addTargetProps = addTweensLookup.get(tweenTarget);
        if (!addTargetProps) return;
        const additiveTweenSiblings = addTargetProps[tweenProperty];
        const additiveAnimation = additive.animation;
        removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');
        // If only one tween is left in the additive lookup, it's the tween lookup
        const lookupTween = additiveTweenSiblings._head;
        if (lookupTween && lookupTween === additiveTweenSiblings._tail) {
          removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');
          removeChild(additiveAnimation, lookupTween);
          let shouldClean = true;
          for (let prop in addTargetProps) {
            if (addTargetProps[prop]._head) {
              shouldClean = false;
              break;
            }
          }
          if (shouldClean) {
            addTweensLookup.delete(tweenTarget);
          }
        }
      }
    }
    return tween;
  };

  /**
   * @param  {TargetsArray} targetsArray
   * @param  {JSAnimation} animation
   * @param  {String} [propertyName]
   * @return {Boolean}
   */
  const removeTargetsFromJSAnimation = (targetsArray, animation, propertyName) => {
    let tweensMatchesTargets = false;
    forEachChildren(animation, (/**@type {Tween} */tween) => {
      const tweenTarget = tween.target;
      if (targetsArray.includes(tweenTarget)) {
        const tweenName = tween.property;
        const tweenType = tween._tweenType;
        const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);
        if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {
          // Make sure to flag the previous CSS transform tween to renderTransform
          if (tween.parent._tail === tween &&
              tween._tweenType === tweenTypes.TRANSFORM &&
              tween._prev &&
              tween._prev._tweenType === tweenTypes.TRANSFORM
          ) {
            tween._prev._renderTransforms = 1;
          }
          // Removes the tween from the selected animation
          removeChild(animation, tween);
          // Detach the tween from its siblings to make sure blended tweens are correctlly removed
          removeTweenSliblings(tween);
          tweensMatchesTargets = true;
        }
      }
    }, true);
    return tweensMatchesTargets;
  };

  /**
   * @param  {TargetsArray} targetsArray
   * @param  {Renderable} [renderable]
   * @param  {String} [propertyName]
   */
  const removeTargetsFromRenderable = (targetsArray, renderable, propertyName) => {
    const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : engine);
    let removeMatches;
    if (parent._hasChildren) {
      let iterationDuration = 0;
      forEachChildren(parent, (/** @type {Renderable} */child) => {
        if (!child._hasChildren) {
          removeMatches = removeTargetsFromJSAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);
          // Remove the child from its parent if no tweens and no children left after the removal
          if (removeMatches && !child._head) {
            child.cancel();
            removeChild(parent, child);
          } else {
            // Calculate the new iterationDuration value to handle onComplete with last child in render()
            const childTLOffset = child._offset + child._delay;
            const childDur = childTLOffset + child.duration;
            if (childDur > iterationDuration) {
              iterationDuration = childDur;
            }
          }
        }
        // Make sure to also remove engine's children targets
        // NOTE: Avoid recursion?
        if (child._head) {
          removeTargetsFromRenderable(targetsArray, child, propertyName);
        } else {
          child._hasChildren = false;
        }
      }, true);
      // Update iterationDuration value to handle onComplete with last child in render()
      if (!isUnd(/** @type {Renderable} */(parent).iterationDuration)) {
        /** @type {Renderable} */(parent).iterationDuration = iterationDuration;
      }
    } else {
      removeMatches = removeTargetsFromJSAnimation(
        targetsArray,
        /** @type {JSAnimation} */(parent),
        propertyName
      );
    }
    if (removeMatches && !parent._head) {
      parent._hasChildren = false;
      // Cancel the parent if there are no tweens and no children left after the removal
      // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself
      if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();
    }
  };

  

  

  

  /**
   * @param  {Timer} timer
   * @return {Timer}
   */
  const resetTimerProperties = timer => {
    timer.paused = true;
    timer.began = false;
    timer.completed = false;
    return timer;
  };

  /**
   * @param  {Timer} timer
   * @return {Timer}
   */
  const reviveTimer = timer => {
    if (!timer._cancelled) return timer;
    if (timer._hasChildren) {
      forEachChildren(timer, reviveTimer);
    } else {
      forEachChildren(timer, (/** @type {Tween} tween */tween) => {
        if (tween._composition !== compositionTypes.none) {
          composeTween(tween, getTweenSiblings(tween.target, tween.property));
        }
      });
    }
    timer._cancelled = 0;
    return timer;
  };

  let timerId = 0;

  /**
   * Base class used to create Timers, Animations and Timelines
   */
  class Timer extends Clock {
    /**
     * @param {TimerParams} [parameters]
     * @param {Timeline} [parent]
     * @param {Number} [parentPosition]
     */
    constructor(parameters = {}, parent = null, parentPosition = 0) {

      super(0);

      ++timerId;

      const {
        id,
        delay,
        duration,
        reversed,
        alternate,
        loop,
        loopDelay,
        autoplay,
        frameRate,
        playbackRate,
        onComplete,
        onLoop,
        onPause,
        onBegin,
        onBeforeUpdate,
        onUpdate,
      } = parameters;

      if (scope.current) scope.current.register(this);

      const timerInitTime = parent ? 0 : engine._lastTickTime;
      const timerDefaults = parent ? parent.defaults : globals.defaults;
      const timerDelay = /** @type {Number} */(isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay);
      const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;
      const timerLoop = setValue(loop, timerDefaults.loop);
      const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);
      let timerIterationCount = timerLoop === true ||
                                timerLoop === Infinity ||
                                /** @type {Number} */(timerLoop) < 0 ? Infinity :
                                /** @type {Number} */(timerLoop) + 1;

      if (devTools) {
        const isInfinite = timerIterationCount === Infinity;
        const registered = devTools.register(this, parameters, isInfinite);
        if (registered && isInfinite) {
          const minIterations = alternate ? 2 : 1;
          const iterations = parent ? devTools.maxNestedInfiniteLoops : devTools.maxInfiniteLoops;
          timerIterationCount = Math.max(iterations, minIterations);
        }
      }

      let offsetPosition = 0;

      if (parent) {
        offsetPosition = parentPosition;
      } else {
        // Make sure to tick the engine once if not currently running to get up to date engine._lastTickTime
        // to avoid big gaps with the following offsetPosition calculation
        if (!engine.reqId) engine.requestTick(now());
        // Make sure to scale the offset position with globals.timeScale to properly handle seconds unit
        offsetPosition = (engine._lastTickTime - engine._startTime) * globals.timeScale;
      }

      // Timer's parameters
      /** @type {String|Number} */
      this.id = !isUnd(id) ? id : timerId;
      /** @type {Timeline} */
      this.parent = parent;
      // Total duration of the timer
      this.duration = clampInfinity(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || minValue;
      /** @type {Boolean} */
      this.backwards = false;
      /** @type {Boolean} */
      this.paused = true;
      /** @type {Boolean} */
      this.began = false;
      /** @type {Boolean} */
      this.completed = false;
      /** @type {Callback<this>} */
      this.onBegin = onBegin || timerDefaults.onBegin;
      /** @type {Callback<this>} */
      this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;
      /** @type {Callback<this>} */
      this.onUpdate = onUpdate || timerDefaults.onUpdate;
      /** @type {Callback<this>} */
      this.onLoop = onLoop || timerDefaults.onLoop;
      /** @type {Callback<this>} */
      this.onPause = onPause || timerDefaults.onPause;
      /** @type {Callback<this>} */
      this.onComplete = onComplete || timerDefaults.onComplete;
      /** @type {Number} */
      this.iterationDuration = timerDuration; // Duration of one loop
      /** @type {Number} */
      this.iterationCount = timerIterationCount; // Number of loops
      /** @type {Boolean|ScrollObserver} */
      this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);
      /** @type {Number} */
      this._offset = offsetPosition;
      /** @type {Number} */
      this._delay = timerDelay;
      /** @type {Number} */
      this._loopDelay = timerLoopDelay;
      /** @type {Number} */
      this._iterationTime = 0;
      /** @type {Number} */
      this._currentIteration = 0; // Current loop index
      /** @type {Function} */
      this._resolve = noop; // Used by .then()
      /** @type {Boolean} */
      this._running = false;
      /** @type {Number} */
      this._reversed = +setValue(reversed, timerDefaults.reversed);
      /** @type {Number} */
      this._reverse = this._reversed;
      /** @type {Number} */
      this._cancelled = 0;
      /** @type {Boolean} */
      this._alternate = setValue(alternate, timerDefaults.alternate);
      /** @type {Renderable} */
      this._prev = null;
      /** @type {Renderable} */
      this._next = null;

      // Clock's parameters
      /** @type {Number} */
      this._lastTickTime = timerInitTime;
      /** @type {Number} */
      this._startTime = timerInitTime;
      /** @type {Number} */
      this._lastTime = timerInitTime;
      /** @type {Number} */
      this._fps = setValue(frameRate, timerDefaults.frameRate);
      /** @type {Number} */
      this._speed = setValue(playbackRate, timerDefaults.playbackRate);
    }

    get cancelled() {
      return !!this._cancelled;
    }

    set cancelled(cancelled) {
      cancelled ? this.cancel() : this.reset(true).play();
    }

    get currentTime() {
      return clamp$1(round$1(this._currentTime, globals.precision), -this._delay, this.duration);
    }

    set currentTime(time) {
      const paused = this.paused;
      // Pausing the timer is necessary to avoid time jumps on a running instance
      this.pause().seek(+time);
      if (!paused) this.resume();
    }

    get iterationCurrentTime() {
      return clamp$1(round$1(this._iterationTime, globals.precision), 0, this.iterationDuration);
    }

    set iterationCurrentTime(time) {
      this.currentTime = (this.iterationDuration * this._currentIteration) + time;
    }

    get progress() {
      return clamp$1(round$1(this._currentTime / this.duration, 10), 0, 1);
    }

    set progress(progress) {
      this.currentTime = this.duration * progress;
    }

    get iterationProgress() {
      return clamp$1(round$1(this._iterationTime / this.iterationDuration, 10), 0, 1);
    }

    set iterationProgress(progress) {
      const iterationDuration = this.iterationDuration;
      this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);
    }

    get currentIteration() {
      return this._currentIteration;
    }

    set currentIteration(iterationCount) {
      this.currentTime = (this.iterationDuration * clamp$1(+iterationCount, 0, this.iterationCount - 1));
    }

    get reversed() {
      return !!this._reversed;
    }

    set reversed(reverse) {
      reverse ? this.reverse() : this.play();
    }

    get speed() {
      return super.speed;
    }

    set speed(playbackRate) {
      super.speed = playbackRate;
      this.resetTime();
    }

    /**
     * @param  {Boolean} [softReset]
     * @return {this}
     */
    reset(softReset = false) {
      // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings
      reviveTimer(this);
      if (this._reversed && !this._reverse) this.reversed = false;
      // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden
      // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order
      // NOTE: This is only required for Timelines and might be better to move to the Timeline class?
      this._iterationTime = this.iterationDuration;
      // Set tickMode to tickModes.FORCE to force rendering
      tick(this, 0, 1, ~~softReset, tickModes.FORCE);
      // Reset timer properties after revive / render to make sure the props are not updated again
      resetTimerProperties(this);
      // Also reset children properties
      if (this._hasChildren) {
        forEachChildren(this, resetTimerProperties);
      }
      return this;
    }

    /**
     * @param  {Boolean} internalRender
     * @return {this}
     */
    init(internalRender = false) {
      this.fps = this._fps;
      this.speed = this._speed;
      // Manually calling .init() on timelines should render all children intial state
      // Forces all children to render once then render to 0 when reseted
      if (!internalRender && this._hasChildren) {
        tick(this, this.duration, 1, ~~internalRender, tickModes.FORCE);
      }
      this.reset(internalRender);
      // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link
      const autoplay = this._autoplay;
      if (autoplay === true) {
        this.resume();
      } else if (autoplay && !isUnd(/** @type {ScrollObserver} */(autoplay).linked)) {
        /** @type {ScrollObserver} */(autoplay).link(this);
      }
      return this;
    }

    /** @return {this} */
    resetTime() {
      const timeScale = 1 / (this._speed * engine._speed);
      // TODO: See if we can safely use engine._lastTickTime here
      // if (!engine.reqId) engine.requestTick(now())
      // this._startTime = engine._lastTickTime - (this._currentTime + this._delay) * timeScale;
      this._startTime = now() - (this._currentTime + this._delay) * timeScale;
      return this;
    }

    /** @return {this} */
    pause() {
      if (this.paused) return this;
      this.paused = true;
      this.onPause(this);
      return this;
    }

    /** @return {this} */
    resume() {
      if (!this.paused) return this;
      this.paused = false;
      // We can safely imediatly render a timer that has no duration and no children
      if (this.duration <= minValue && !this._hasChildren) {
        tick(this, minValue, 0, 0, tickModes.FORCE);
      } else {
        if (!this._running) {
          addChild(engine, this);
          engine._hasChildren = true;
          this._running = true;
        }
        this.resetTime();
        // Forces the timer to advance by at least one frame when the next tick occurs
        this._startTime -= 12;
        engine.wake();
      }
      return this;
    }

    /** @return {this} */
    restart() {
      return this.reset().resume();
    }

    /**
     * @param  {Number} time
     * @param  {Boolean|Number} [muteCallbacks]
     * @param  {Boolean|Number} [internalRender]
     * @return {this}
     */
    seek(time, muteCallbacks = 0, internalRender = 0) {
      // Recompose the tween siblings in case the timer has been cancelled
      reviveTimer(this);
      // If you seek a completed animation, otherwise the next play will starts at 0
      this.completed = false;
      const isPaused = this.paused;
      this.paused = true;
      // timer, time, muteCallbacks, internalRender, tickMode
      tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);
      return isPaused ? this : this.resume();
    }

    /** @return {this} */
    alternate() {
      const reversed = this._reversed;
      const count = this.iterationCount;
      const duration = this.iterationDuration;
      // Calculate the maximum iterations possible given the iteration duration
      const iterations = count === Infinity ? floor(maxValue / duration) : count;
      this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);
      if (count === Infinity) {
        // Handle infinite loops to loop on themself
        this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;
      } else {
        this.seek((duration * iterations) - this._currentTime);
      }
      this.resetTime();
      return this;
    }

    /** @return {this} */
    play() {
      if (this._reversed) this.alternate();
      return this.resume();
    }

    /** @return {this} */
    reverse() {
      if (!this._reversed) this.alternate();
      return this.resume();
    }

    // TODO: Move all the animation / tweens / children related code to Animation / Timeline

    /** @return {this} */
    cancel() {
      if (this._hasChildren) {
        forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);
      } else {
        forEachChildren(this, removeTweenSliblings);
      }
      this._cancelled = 1;
      // Pausing the timer removes it from the engine
      return this.pause();
    }

    /**
     * @param  {Number} newDuration
     * @return {this}
     */
    stretch(newDuration) {
      const currentDuration = this.duration;
      const normlizedDuration = normalizeTime(newDuration);
      if (currentDuration === normlizedDuration) return this;
      const timeScale = newDuration / currentDuration;
      const isSetter = newDuration <= minValue;
      this.duration = isSetter ? minValue : normlizedDuration;
      this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);
      this._offset *= timeScale;
      this._delay *= timeScale;
      this._loopDelay *= timeScale;
      return this;
    }

   /**
     * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary
     * @return {this}
     */
    revert() {
      tick(this, 0, 1, 0, tickModes.AUTO);
      const ap = /** @type {ScrollObserver} */(this._autoplay);
      if (ap && ap.linked && ap.linked === this) ap.revert();
      return this.cancel();
    }

   /**
     * Imediatly completes the timer, cancels it and triggers the onComplete callback
     * @param  {Boolean|Number} [muteCallbacks]
     * @return {this}
     */
    complete(muteCallbacks = 0) {
      return this.seek(this.duration, muteCallbacks).cancel();
    }

    /**
     * @typedef {this & {then: null}} ResolvedTimer
     */

    /**
     * @param  {Callback<ResolvedTimer>} [callback]
     * @return Promise<this>
     */
    then(callback = noop) {
      const then = this.then;
      const onResolve = () => {
        // this.then = null prevents infinite recursion if returned by an async function
        // https://github.com/juliangarnierorg/anime-beta/issues/26
        this.then = null;
        callback(/** @type {ResolvedTimer} */(this));
        this.then = then;
        this._resolve = noop;
      };
      return new Promise(r => {
        this._resolve = () => r(onResolve());
        // Make sure to resolve imediatly if the timer has already completed
        if (this.completed) this._resolve();
        return this;
      });
    }

  }

  /**
   * @param {TimerParams} [parameters]
   * @return {Timer}
   */
  const createTimer = parameters => new Timer(parameters, null, 0).init();

  

  /**
   * @param  {DOMTargetsParam|TargetsParam} v
   * @return {NodeList|HTMLCollection}
   */
  function getNodeList(v) {
    const n = isStr(v) ? scope.root.querySelectorAll(v) : v;
    if (n instanceof NodeList || n instanceof HTMLCollection) return n;
  }

  /**
   * @overload
   * @param  {DOMTargetsParam} targets
   * @return {DOMTargetsArray}
   *
   * @overload
   * @param  {JSTargetsParam} targets
   * @return {JSTargetsArray}
   *
   * @overload
   * @param  {TargetsParam} targets
   * @return {TargetsArray}
   *
   * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
   */
  function parseTargets(targets) {
    if (isNil(targets)) return /** @type {TargetsArray} */([]);
    if (!isBrowser) return /** @type {JSTargetsArray} */(isArr(targets) && targets.flat(Infinity) || [targets]);
    if (isArr(targets)) {
      const flattened = targets.flat(Infinity);
      /** @type {TargetsArray} */
      const parsed = [];
      for (let i = 0, l = flattened.length; i < l; i++) {
        const item = flattened[i];
        if (!isNil(item)) {
          const nodeList = getNodeList(item);
          if (nodeList) {
            for (let j = 0, jl = nodeList.length; j < jl; j++) {
              const subItem = nodeList[j];
              if (!isNil(subItem)) {
                let isDuplicate = false;
                for (let k = 0, kl = parsed.length; k < kl; k++) {
                  if (parsed[k] === subItem) {
                    isDuplicate = true;
                    break;
                  }
                }
                if (!isDuplicate) {
                  parsed.push(subItem);
                }
              }
            }
          } else {
            let isDuplicate = false;
            for (let j = 0, jl = parsed.length; j < jl; j++) {
              if (parsed[j] === item) {
                isDuplicate = true;
                break;
              }
            }
            if (!isDuplicate) {
              parsed.push(item);
            }
          }
        }
      }
      return parsed;
    }
    const nodeList = getNodeList(targets);
    if (nodeList) return /** @type {DOMTargetsArray} */(Array.from(nodeList));
    return /** @type {TargetsArray} */([targets]);
  }

  /**
   * @overload
   * @param  {DOMTargetsParam} targets
   * @return {DOMTargetsArray}
   *
   * @overload
   * @param  {JSTargetsParam} targets
   * @return {JSTargetsArray}
   *
   * @overload
   * @param  {TargetsParam} targets
   * @return {TargetsArray}
   *
   * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
   */
  function registerTargets(targets) {
    const parsedTargetsArray = parseTargets(targets);
    const parsedTargetsLength = parsedTargetsArray.length;
    if (parsedTargetsLength) {
      for (let i = 0; i < parsedTargetsLength; i++) {
        const target = parsedTargetsArray[i];
        if (!target[isRegisteredTargetSymbol]) {
          target[isRegisteredTargetSymbol] = true;
          const isSvgType = isSvg(target);
          const isDom = /** @type {DOMTarget} */(target).nodeType || isSvgType;
          if (isDom) {
            target[isDomSymbol] = true;
            target[isSvgSymbol] = isSvgType;
            target[transformsSymbol] = {};
          }
        }
      }
    }
    return parsedTargetsArray;
  }

  const angleUnitsMap = { 'deg': 1, 'rad': 180 / PI, 'turn': 360 };
  const convertedValuesCache = {};

  

  /**
   * @param  {DOMTarget} el
   * @param  {TweenDecomposedValue} decomposedValue
   * @param  {String} unit
   * @param  {Boolean} [force]
   * @return {TweenDecomposedValue}
   */
  const convertValueUnit = (el, decomposedValue, unit, force = false) => {
    const currentUnit = decomposedValue.u;
    const currentNumber = decomposedValue.n;
    if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) { // TODO: Check if checking against the same unit string is necessary
      return decomposedValue;
    }
    const cachedKey = currentNumber + currentUnit + unit;
    const cached = convertedValuesCache[cachedKey];
    if (!isUnd(cached) && !force) {
      decomposedValue.n = cached;
    } else {
      let convertedValue;
      if (currentUnit in angleUnitsMap) {
        convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];
      } else {
        const baseline = 100;
        const tempEl = /** @type {DOMTarget} */(el.cloneNode());
        const parentNode = el.parentNode;
        const parentEl = (parentNode && (parentNode !== doc)) ? parentNode : doc.body;
        parentEl.appendChild(tempEl);
        const elStyle = tempEl.style;
        elStyle.width = baseline + currentUnit;
        const currentUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;
        elStyle.width = baseline + unit;
        const newUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;
        const factor = currentUnitWidth / newUnitWidth;
        parentEl.removeChild(tempEl);
        convertedValue = factor * currentNumber;
      }
      decomposedValue.n = convertedValue;
      convertedValuesCache[cachedKey] = convertedValue;
    }
    decomposedValue.t === valueTypes.UNIT;
    decomposedValue.u = unit;
    return decomposedValue;
  };

  

  /** @type {EasingFunction} */
  const none = t => t;

  


  /** @type {PowerEasing} */
  const easeInPower = (p = 1.68) => t => pow(t, +p);

  /**
   * @callback EaseType
   * @param {EasingFunction} Ease
   * @return {EasingFunction}
   */

  /** @type {Record<String, EaseType>} */
  const easeTypes = {
    in: easeIn => t => easeIn(t),
    out: easeIn => t => 1 - easeIn(1 - t),
    inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,
    outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2,
  };

  /**
   * Easing functions adapted and simplified from https://robertpenner.com/easing/
   * (c) 2001 Robert Penner
   */

  const halfPI = PI / 2;
  const doublePI = PI * 2;

  /** @type {Record<String, EasingFunctionWithParams|EasingFunction>} */
  const easeInFunctions = {
    [emptyString]: easeInPower,
    Quad: easeInPower(2),
    Cubic: easeInPower(3),
    Quart: easeInPower(4),
    Quint: easeInPower(5),
    /** @type {EasingFunction} */
    Sine: t => 1 - cos(t * halfPI),
    /** @type {EasingFunction} */
    Circ: t => 1 - sqrt(1 - t * t),
    /** @type {EasingFunction} */
    Expo: t => t ? pow(2, 10 * t - 10) : 0,
    /** @type {EasingFunction} */
    Bounce: t => {
      let pow2, b = 4;
      while (t < ((pow2 = pow(2, --b)) - 1) / 11);
      return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);
    },
    /** @type {BackEasing} */
    Back: (overshoot = 1.7) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,
    /** @type {ElasticEasing} */
    Elastic: (amplitude = 1, period = .3) => {
      const a = clamp$1(+amplitude, 1, 10);
      const p = clamp$1(+period, minValue, 2);
      const s = (p / doublePI) * asin(1 / a);
      const e = doublePI / p;
      return t => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin(((1 - t) - s) * e);
    }
  };

  /**
   * @typedef  {Object} EasesFunctions
   * @property {typeof none} linear
   * @property {typeof none} none
   * @property {PowerEasing} in
   * @property {PowerEasing} out
   * @property {PowerEasing} inOut
   * @property {PowerEasing} outIn
   * @property {EasingFunction} inQuad
   * @property {EasingFunction} outQuad
   * @property {EasingFunction} inOutQuad
   * @property {EasingFunction} outInQuad
   * @property {EasingFunction} inCubic
   * @property {EasingFunction} outCubic
   * @property {EasingFunction} inOutCubic
   * @property {EasingFunction} outInCubic
   * @property {EasingFunction} inQuart
   * @property {EasingFunction} outQuart
   * @property {EasingFunction} inOutQuart
   * @property {EasingFunction} outInQuart
   * @property {EasingFunction} inQuint
   * @property {EasingFunction} outQuint
   * @property {EasingFunction} inOutQuint
   * @property {EasingFunction} outInQuint
   * @property {EasingFunction} inSine
   * @property {EasingFunction} outSine
   * @property {EasingFunction} inOutSine
   * @property {EasingFunction} outInSine
   * @property {EasingFunction} inCirc
   * @property {EasingFunction} outCirc
   * @property {EasingFunction} inOutCirc
   * @property {EasingFunction} outInCirc
   * @property {EasingFunction} inExpo
   * @property {EasingFunction} outExpo
   * @property {EasingFunction} inOutExpo
   * @property {EasingFunction} outInExpo
   * @property {EasingFunction} inBounce
   * @property {EasingFunction} outBounce
   * @property {EasingFunction} inOutBounce
   * @property {EasingFunction} outInBounce
   * @property {BackEasing} inBack
   * @property {BackEasing} outBack
   * @property {BackEasing} inOutBack
   * @property {BackEasing} outInBack
   * @property {ElasticEasing} inElastic
   * @property {ElasticEasing} outElastic
   * @property {ElasticEasing} inOutElastic
   * @property {ElasticEasing} outInElastic
   */

  const eases = (/*#__PURE__ */ (() => {
    const list = { linear: none, none: none };
    for (let type in easeTypes) {
      for (let name in easeInFunctions) {
        const easeIn = easeInFunctions[name];
        const easeType = easeTypes[type];
        list[type + name] = /** @type {EasingFunctionWithParams|EasingFunction} */(
          name === emptyString || name === 'Back' || name === 'Elastic' ?
          (a, b) => easeType(/** @type {EasingFunctionWithParams} */(easeIn)(a, b)) :
          easeType(/** @type {EasingFunction} */(easeIn))
        );
      }
    }
    return /** @type {EasesFunctions} */(list);
  })());

  /** @type {Record<String, EasingFunction>} */
  const easesLookups = { linear: none, none: none };

  /**
   * @param  {String} string
   * @return {EasingFunction}
   */
  const parseEaseString = (string) => {
    if (easesLookups[string]) return easesLookups[string];
    if (string.indexOf('(') <= -1) {
      const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');
      const parsedFn = /** @type {EasingFunction} */(hasParams ? /** @type {EasingFunctionWithParams} */(eases[string])() : eases[string]);
      return parsedFn ? easesLookups[string] = parsedFn : none;
    } else {
      const split = string.slice(0, -1).split('(');
      const parsedFn = /** @type {EasingFunctionWithParams} */(eases[split[0]]);
      return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : none;
    }
  };

  const deprecated = ['steps(', 'irregular(', 'linear(', 'cubicBezier('];

  /**
   * @param  {EasingParam} ease
   * @return {EasingFunction}
   */
  const parseEase = ease => {
    if (isStr(ease)) {
      for (let i = 0, l = deprecated.length; i < l; i++) {
        if (stringStartsWith(ease, deprecated[i])) {
          console.warn(`String syntax for \`ease: "${ease}"\` has been removed from the core and replaced by importing and passing the easing function directly: \`ease: ${ease}\``);
          return none;
        }
      }
    }
    const easeFunc = isFnc(ease) ? ease : isStr(ease) ? parseEaseString(/** @type {String} */(ease)) : none;
    return easeFunc;
  };

  

  // Defines decomposed values target objects only once and mutate their properties later to avoid GC
  // TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object
  const fromTargetObject = createDecomposedValueTargetObject();
  const toTargetObject = createDecomposedValueTargetObject();
  const inlineStylesStore = {};
  const toFunctionStore = { func: null };
  const keyframesTargetArray = [null];
  const fastSetValuesArray = [null, null];
  /** @type {TweenKeyValue} */
  const keyObjectTarget = { to: null };

  let tweenId = 0;
  let JSAnimationId = 0;
  let keyframes;
  /** @type {TweenParamsOptions & TweenValues} */
  let key;

  /**
   * @param {DurationKeyframes | PercentageKeyframes} keyframes
   * @param {AnimationParams} parameters
   * @return {AnimationParams}
   */
  const generateKeyframes = (keyframes, parameters) => {
    /** @type {AnimationParams} */
    const properties = {};
    if (isArr(keyframes)) {
      const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);
      for (let i = 0, l = propertyNames.length; i < l; i++) {
        const propName = propertyNames[i];
        const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {
          /** @type {TweenKeyValue} */
          const newKey = {};
          for (let p in key) {
            const keyValue = /** @type {TweenPropValue} */(key[p]);
            if (isKey(p)) {
              if (p === propName) {
                newKey.to = keyValue;
              }
            } else {
              newKey[p] = keyValue;
            }
          }
          return newKey;
        });
        properties[propName] = /** @type {ArraySyntaxValue} */(propArray);
      }

    } else {
      const totalDuration = /** @type {Number} */(setValue(parameters.duration, globals.defaults.duration));
      const keys = Object.keys(keyframes)
      .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })
      .sort((a, b) => a.o - b.o);
      keys.forEach(key => {
        const offset = key.o;
        const prop = key.p;
        for (let name in prop) {
          if (isKey(name)) {
            let propArray = /** @type {Array} */(properties[name]);
            if (!propArray) propArray = properties[name] = [];
            const duration = offset * totalDuration;
            let length = propArray.length;
            let prevKey = propArray[length - 1];
            const keyObj = { to: prop[name] };
            let durProgress = 0;
            for (let i = 0; i < length; i++) {
              durProgress += propArray[i].duration;
            }
            if (length === 1) {
              keyObj.from = prevKey.to;
            }
            if (prop.ease) {
              keyObj.ease = prop.ease;
            }
            keyObj.duration = duration - (length ? durProgress : 0);
            propArray.push(keyObj);
          }
        }
        return key;
      });

      for (let name in properties) {
        const propArray = /** @type {Array} */(properties[name]);
        let prevEase;
        // let durProgress = 0
        for (let i = 0, l = propArray.length; i < l; i++) {
          const prop = propArray[i];
          // Emulate WAPPI easing parameter position
          const currentEase = prop.ease;
          prop.ease = prevEase ? prevEase : undefined;
          prevEase = currentEase;
          // durProgress += prop.duration;
          // if (i === l - 1 && durProgress !== totalDuration) {
          //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })
          // }
        }
        if (!propArray[0].duration) {
          propArray.shift();
        }
      }

    }

    return properties;
  };

  class JSAnimation extends Timer {
    /**
     * @param {TargetsParam} targets
     * @param {AnimationParams} parameters
     * @param {Timeline} [parent]
     * @param {Number} [parentPosition]
     * @param {Boolean} [fastSet=false]
     * @param {Number} [index=0]
     * @param {Number} [length=0]
     */
    constructor(
      targets,
      parameters,
      parent,
      parentPosition,
      fastSet = false,
      index = 0,
      length = 0
    ) {

      super(/** @type {TimerParams & AnimationParams} */(parameters), parent, parentPosition);

      ++JSAnimationId;

      const parsedTargets = registerTargets(targets);
      const targetsLength = parsedTargets.length;

      // If the parameters object contains a "keyframes" property, convert all the keyframes values to regular properties

      const kfParams = /** @type {AnimationParams} */(parameters).keyframes;
      const params = /** @type {AnimationParams} */(kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);

      const {
        id,
        delay,
        duration,
        ease,
        playbackEase,
        modifier,
        composition,
        onRender,
      } = params;

      const animDefaults = parent ? parent.defaults : globals.defaults;
      const animEase = setValue(ease, animDefaults.ease);
      const animPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);
      const parsedAnimPlaybackEase = animPlaybackEase ? parseEase(animPlaybackEase) : null;
      const hasSpring = !isUnd(/** @type {Spring} */(animEase).ease);
      const tEasing = hasSpring ? /** @type {Spring} */(animEase).ease : setValue(ease, parsedAnimPlaybackEase ? 'linear' : animDefaults.ease);
      const tDuration = hasSpring ? /** @type {Spring} */(animEase).settlingDuration : setValue(duration, animDefaults.duration);
      const tDelay = setValue(delay, animDefaults.delay);
      const tModifier = modifier || animDefaults.modifier;
      // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation
      const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;
      // const absoluteOffsetTime = this._offset;
      const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);
      // This allows targeting the current animation in the spring onComplete callback
      if (hasSpring) /** @type {Spring} */(animEase).parent = this;

      let iterationDuration = NaN;
      let iterationDelay = NaN;
      let animationAnimationLength = 0;
      let shouldTriggerRender = 0;

      for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {

        const target = parsedTargets[targetIndex];
        const ti = index || targetIndex;
        const tl = length || targetsLength;

        let lastTransformGroupIndex = NaN;
        let lastTransformGroupLength = NaN;

        for (let p in params) {

          if (isKey(p)) {

            const tweenType = getTweenType(target, p);

            const propName = sanitizePropertyName(p, target, tweenType);

            let propValue = params[p];

            const isPropValueArray = isArr(propValue);

            if (fastSet && !isPropValueArray) {
              fastSetValuesArray[0] = propValue;
              fastSetValuesArray[1] = propValue;
              propValue = fastSetValuesArray;
            }

            // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })
            // Normalize property values to valid keyframe syntax:
            // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]
            // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];
            if (isPropValueArray) {
              const arrayLength = /** @type {Array} */(propValue).length;
              const isNotObjectValue = !isObj(propValue[0]);
              // Convert [x, y] to [{to: [x, y]}]
              if (arrayLength === 2 && isNotObjectValue) {
                keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));
                keyframesTargetArray[0] = keyObjectTarget;
                keyframes = keyframesTargetArray;
              // Convert [x, y, z] to [[x, y], z]
              } else if (arrayLength > 2 && isNotObjectValue) {
                keyframes = [];
                /** @type {Array.<Number>} */(propValue).forEach((v, i) => {
                  if (!i) {
                    fastSetValuesArray[0] = v;
                  } else if (i === 1) {
                    fastSetValuesArray[1] = v;
                    keyframes.push(fastSetValuesArray);
                  } else {
                    keyframes.push(v);
                  }
                });
              } else {
                keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);
              }
            } else {
              keyframesTargetArray[0] = propValue;
              keyframes = keyframesTargetArray;
            }

            let siblings = null;
            let prevTween = null;
            let firstTweenChangeStartTime = NaN;
            let lastTweenChangeEndTime = 0;
            let tweenIndex = 0;

            for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {

              const keyframe = keyframes[tweenIndex];

              if (isObj(keyframe)) {
                key = keyframe;
              } else {
                keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);
                key = keyObjectTarget;
              }

              toFunctionStore.func = null;

              const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);

              let tweenToValue;
              // Allows function based values to return an object syntax value ({to: v})
              if (isObj(computedToValue) && !isUnd(computedToValue.to)) {
                key = computedToValue;
                tweenToValue = computedToValue.to;
              } else {
                tweenToValue = computedToValue;
              }
              const tweenFromValue = getFunctionValue(key.from, target, ti, tl);
              const easeToParse = key.ease || tEasing;

              const easeFunctionResult = getFunctionValue(easeToParse, target, ti, tl);
              const keyEasing = isFnc(easeFunctionResult) || isStr(easeFunctionResult) ? easeFunctionResult : easeToParse;

              const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);
              const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing;
              // Calculate default individual keyframe duration by dividing the tl of keyframes
              const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).settlingDuration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);
              // Default delay value should only be applied to the first tween
              const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);
              const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);
              const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];
              // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper
              const tweenModifier = key.modifier || tModifier;
              const hasFromvalue = !isUnd(tweenFromValue);
              const hasToValue = !isUnd(tweenToValue);
              const isFromToArray = isArr(tweenToValue);
              const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);
              const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;
              // Rounding is necessary here to minimize floating point errors when working in seconds
              const absoluteStartTime = round$1(absoluteOffsetTime + tweenStartTime, 12);

              // Force a onRender callback if the animation contains at least one from value and autoplay is set to false
              if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;

              let prevSibling = prevTween;

              if (tweenComposition !== compositionTypes.none) {
                if (!siblings) siblings = getTweenSiblings(target, propName);
                let nextSibling = siblings._head;
                // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time
                while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {
                  prevSibling = nextSibling;
                  nextSibling = nextSibling._nextRep;
                  // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time
                  if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {
                    while (nextSibling) {
                      overrideTween(nextSibling);
                      // This will ends both the current while loop and the upper one once all the next sibllings have been overriden
                      nextSibling = nextSibling._nextRep;
                    }
                  }
                }
              }

              // Decompose values
              if (isFromToValue) {
                decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);
                decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);
                // Needed to force an inline style registration
                const originalValue = getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore);
                if (fromTargetObject.t === valueTypes.NUMBER) {
                  if (prevSibling) {
                    if (prevSibling._valueType === valueTypes.UNIT) {
                      fromTargetObject.t = valueTypes.UNIT;
                      fromTargetObject.u = prevSibling._unit;
                    }
                  } else {
                    decomposeRawValue(
                      originalValue,
                      decomposedOriginalValue
                    );
                    if (decomposedOriginalValue.t === valueTypes.UNIT) {
                      fromTargetObject.t = valueTypes.UNIT;
                      fromTargetObject.u = decomposedOriginalValue.u;
                    }
                  }
                }
              } else {
                if (hasToValue) {
                  decomposeRawValue(tweenToValue, toTargetObject);
                } else {
                  if (prevTween) {
                    decomposeTweenValue(prevTween, toTargetObject);
                  } else {
                    // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                    getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), toTargetObject);
                  }
                }
                if (hasFromvalue) {
                  decomposeRawValue(tweenFromValue, fromTargetObject);
                } else {
                  if (prevTween) {
                    decomposeTweenValue(prevTween, fromTargetObject);
                  } else {
                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                    // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                    getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), fromTargetObject);
                  }
                }
              }

              // Apply operators
              if (fromTargetObject.o) {
                fromTargetObject.n = getRelativeValue(
                  !prevSibling ? decomposeRawValue(
                    getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore),
                    decomposedOriginalValue
                  ).n : prevSibling._toNumber,
                  fromTargetObject.n,
                  fromTargetObject.o
                );
              }

              if (toTargetObject.o) {
                toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);
              }

              // Values omogenisation in cases of type difference between "from" and "to"
              if (fromTargetObject.t !== toTargetObject.t) {
                if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {
                  const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;
                  const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;
                  notComplexValue.t = valueTypes.COMPLEX;
                  notComplexValue.s = cloneArray(complexValue.s);
                  notComplexValue.d = complexValue.d.map(() => notComplexValue.n);
                } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {
                  const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;
                  const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;
                  notUnitValue.t = valueTypes.UNIT;
                  notUnitValue.u = unitValue.u;
                } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {
                  const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;
                  const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;
                  notColorValue.t = valueTypes.COLOR;
                  notColorValue.s = colorValue.s;
                  notColorValue.d = [0, 0, 0, 1];
                }
              }

              // Unit conversion
              if (fromTargetObject.u !== toTargetObject.u) {
                let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;
                valueToConvert = convertValueUnit(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);
                // TODO:
                // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);
              }

              // Fill in non existing complex values
              if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {
                const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;
                const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;
                // TODO: Check if n should be used instead of 0 for default complex values
                shortestValue.d = longestValue.d.map((/** @type {Number} */_, /** @type {Number} */i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);
                shortestValue.s = cloneArray(longestValue.s);
              }

              // Tween factory

              // Rounding is necessary here to minimize floating point errors when working in seconds
              const tweenUpdateDuration = round$1(+tweenDuration || minValue, 12);

              // Copy the value of the iniline style if it exist and imediatly nullify it to prevents false positive on other targets
              let inlineValue = inlineStylesStore[propName];
              if (!isNil(inlineValue)) inlineStylesStore[propName] = null;

              /** @type {Tween} */
              const tween = {
                parent: this,
                id: tweenId++,
                property: propName,
                target: target,
                _value: null,
                _func: toFunctionStore.func,
                _ease: parseEase(tweenEasing),
                _fromNumbers: cloneArray(fromTargetObject.d),
                _toNumbers: cloneArray(toTargetObject.d),
                _strings: cloneArray(toTargetObject.s),
                _fromNumber: fromTargetObject.n,
                _toNumber: toTargetObject.n,
                _numbers: cloneArray(fromTargetObject.d), // For additive tween and animatables
                _number: fromTargetObject.n, // For additive tween and animatables
                _unit: toTargetObject.u,
                _modifier: tweenModifier,
                _currentTime: 0,
                _startTime: tweenStartTime,
                _delay: +tweenDelay,
                _updateDuration: tweenUpdateDuration,
                _changeDuration: tweenUpdateDuration,
                _absoluteStartTime: absoluteStartTime,
                // NOTE: Investigate bit packing to stores ENUM / BOOL
                _tweenType: tweenType,
                _valueType: toTargetObject.t,
                _composition: tweenComposition,
                _isOverlapped: 0,
                _isOverridden: 0,
                _renderTransforms: 0,
                _inlineValue: inlineValue,
                _prevRep: null, // For replaced tween
                _nextRep: null, // For replaced tween
                _prevAdd: null, // For additive tween
                _nextAdd: null, // For additive tween
                _prev: null,
                _next: null,
              };

              if (tweenComposition !== compositionTypes.none) {
                composeTween(tween, siblings);
              }

              if (isNaN(firstTweenChangeStartTime)) {
                firstTweenChangeStartTime = tween._startTime;
              }
              // Rounding is necessary here to minimize floating point errors when working in seconds
              lastTweenChangeEndTime = round$1(tweenStartTime + tweenUpdateDuration, 12);
              prevTween = tween;
              animationAnimationLength++;

              addChild(this, tween);

            }

            // Update animation timings with the added tweens properties

            if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {
              iterationDelay = firstTweenChangeStartTime;
            }

            if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {
              iterationDuration = lastTweenChangeEndTime;
            }

            // TODO: Find a way to inline tween._renderTransforms = 1 here
            if (tweenType === tweenTypes.TRANSFORM) {
              lastTransformGroupIndex = animationAnimationLength - tweenIndex;
              lastTransformGroupLength = animationAnimationLength;
            }

          }

        }

        // Set _renderTransforms to last transform property to correctly render the transforms list
        if (!isNaN(lastTransformGroupIndex)) {
          let i = 0;
          forEachChildren(this, (/** @type {Tween} */tween) => {
            if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {
              tween._renderTransforms = 1;
              if (tween._composition === compositionTypes.blend) {
                forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {
                  if (additiveTween.id === tween.id) {
                    additiveTween._renderTransforms = 1;
                  }
                });
              }
            }
            i++;
          });
        }

      }

      if (!targetsLength) {
        console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
      }

      if (iterationDelay) {
        forEachChildren(this, (/** @type {Tween} */tween) => {
          // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too
          if (!(tween._startTime - tween._delay)) {
            tween._delay -= iterationDelay;
          }
          tween._startTime -= iterationDelay;
        });
        iterationDuration -= iterationDelay;
      } else {
        iterationDelay = 0;
      }

      // Prevents iterationDuration to be NaN if no valid animatable props have been provided
      // Prevents _iterationCount to be NaN if no valid animatable props have been provided
      if (!iterationDuration) {
        iterationDuration = minValue;
        this.iterationCount = 0;
      }
      /** @type {TargetsArray} */
      this.targets = parsedTargets;
      /** @type {String|Number} */
      this.id = !isUnd(id) ? id : JSAnimationId;
      /** @type {Number} */
      this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;
      /** @type {Callback<this>} */
      this.onRender = onRender || animDefaults.onRender;
      /** @type {EasingFunction} */
      this._ease = parsedAnimPlaybackEase;
      /** @type {Number} */
      this._delay = iterationDelay;
      // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.
      // this._delay = parent ? 0 : iterationDelay;
      // this._offset += parent ? iterationDelay : 0;
      /** @type {Number} */
      this.iterationDuration = iterationDuration;

      if (!this._autoplay && shouldTriggerRender) this.onRender(this);
    }

    /**
     * @param  {Number} newDuration
     * @return {this}
     */
    stretch(newDuration) {
      const currentDuration = this.duration;
      if (currentDuration === normalizeTime(newDuration)) return this;
      const timeScale = newDuration / currentDuration;
      // NOTE: Find a better way to handle the stretch of an animation after stretch = 0
      forEachChildren(this, (/** @type {Tween} */tween) => {
        // Rounding is necessary here to minimize floating point errors
        tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);
        tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);
        tween._currentTime *= timeScale;
        tween._startTime *= timeScale;
        tween._absoluteStartTime *= timeScale;
      });
      return super.stretch(newDuration);
    }

    /**
     * @return {this}
     */
    refresh() {
      forEachChildren(this, (/** @type {Tween} */tween) => {
        const tweenFunc = tween._func;
        if (tweenFunc) {
          const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);
          decomposeRawValue(ogValue, decomposedOriginalValue);
          // TODO: Check for from / to Array based values here,
          decomposeRawValue(tweenFunc(), toTargetObject);
          tween._fromNumbers = cloneArray(decomposedOriginalValue.d);
          tween._fromNumber = decomposedOriginalValue.n;
          tween._toNumbers = cloneArray(toTargetObject.d);
          tween._strings = cloneArray(toTargetObject.s);
          // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025
          tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;
        }
      });
      // This forces setter animations to render once
      if (this.duration === minValue) this.restart();
      return this;
    }

    /**
     * Cancel the animation and revert all the values affected by this animation to their original state
     * @return {this}
     */
    revert() {
      super.revert();
      return cleanInlineStyles(this);
    }

    /**
     * @typedef {this & {then: null}} ResolvedJSAnimation
     */

    /**
     * @param  {Callback<ResolvedJSAnimation>} [callback]
     * @return Promise<this>
     */
    then(callback) {
      return super.then(callback);
    }

  }

  /**
   * @param {TargetsParam} targets
   * @param {AnimationParams} parameters
   * @return {JSAnimation}
   */
  const animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();

  

  

  const WAAPIAnimationsLookups = {
    _head: null,
    _tail: null,
  };

  /**
   * @param {DOMTarget} $el
   * @param {String} [property]
   * @param {WAAPIAnimation} [parent]
   * @return {globalThis.Animation}
   */
  const removeWAAPIAnimation = ($el, property, parent) => {
    let nextLookup = WAAPIAnimationsLookups._head;
    let anim;
    while (nextLookup) {
      const next = nextLookup._next;
      const matchTarget = nextLookup.$el === $el;
      const matchProperty = !property || nextLookup.property === property;
      const matchParent = !parent || nextLookup.parent === parent;
      if (matchTarget && matchProperty && matchParent) {
        anim = nextLookup.animation;
        try { anim.commitStyles(); } catch {}      anim.cancel();
        removeChild(WAAPIAnimationsLookups, nextLookup);
        const lookupParent = nextLookup.parent;
        if (lookupParent) {
          lookupParent._completed++;
          if (lookupParent.animations.length === lookupParent._completed) {
            lookupParent.completed = true;
            lookupParent.paused = true;
            if (!lookupParent.muteCallbacks) {
              lookupParent.onComplete(lookupParent);
              lookupParent._resolve(lookupParent);
            }
          }
        }
      }
      nextLookup = next;
    }
    return anim;
  };

  /**
   * @param {WAAPIAnimation} parent
   * @param {DOMTarget} $el
   * @param {String} property
   * @param {PropertyIndexedKeyframes} keyframes
   * @param {KeyframeAnimationOptions} params
   * @retun {globalThis.Animation}
   */
  const addWAAPIAnimation = (parent, $el, property, keyframes, params) => {
    const animation = $el.animate(keyframes, params);
    const animTotalDuration = params.delay + (+params.duration * params.iterations);
    animation.playbackRate = parent._speed;
    if (parent.paused) animation.pause();
    if (parent.duration < animTotalDuration) {
      parent.duration = animTotalDuration;
      parent.controlAnimation = animation;
    }
    parent.animations.push(animation);
    removeWAAPIAnimation($el, property);
    addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });
    const handleRemove = () => { removeWAAPIAnimation($el, property, parent); };
    animation.oncancel = handleRemove;
    animation.onremove = handleRemove;
    if (!parent.persist) {
      animation.onfinish = handleRemove;
    }
    return animation;
  };

  

  

  /**
   * @overload
   * @param  {DOMTargetSelector} targetSelector
   * @param  {String} propName
   * @return {String}
   *
   * @overload
   * @param  {JSTargetsParam} targetSelector
   * @param  {String} propName
   * @return {Number|String}
   *
   * @overload
   * @param  {DOMTargetsParam} targetSelector
   * @param  {String} propName
   * @param  {String} unit
   * @return {String}
   *
   * @overload
   * @param  {TargetsParam} targetSelector
   * @param  {String} propName
   * @param  {Boolean} unit
   * @return {Number}
   *
   * @param  {TargetsParam} targetSelector
   * @param  {String} propName
   * @param  {String|Boolean} [unit]
   */
  function get(targetSelector, propName, unit) {
    const targets = registerTargets(targetSelector);
    if (!targets.length) return;
    const [ target ] = targets;
    const tweenType = getTweenType(target, propName);
    const normalizePropName = sanitizePropertyName(propName, target, tweenType);
    let originalValue = getOriginalAnimatableValue(target, normalizePropName);
    if (isUnd(unit)) {
      return originalValue;
    } else {
      decomposeRawValue(originalValue, decomposedOriginalValue);
      if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {
        if (unit === false) {
          return decomposedOriginalValue.n;
        } else {
          const convertedValue = convertValueUnit(/** @type {DOMTarget} */(target), decomposedOriginalValue, /** @type {String} */(unit), false);
          return `${round$1(convertedValue.n, globals.precision)}${convertedValue.u}`;
        }
      }
    }
  }

  /**
   * @param  {TargetsParam} targets
   * @param  {AnimationParams} parameters
   * @return {JSAnimation}
   */
  const set = (targets, parameters) => {
    if (isUnd(parameters)) return;
    parameters.duration = minValue;
    // Do not overrides currently active tweens by default
    parameters.composition = setValue(parameters.composition, compositionTypes.none);
    // Skip init() and force rendering by playing the animation
    return new JSAnimation(targets, parameters, null, 0, true).resume();
  };

  /**
   * @param  {TargetsParam} targets
   * @param  {Renderable|WAAPIAnimation} [renderable]
   * @param  {String} [propertyName]
   * @return {TargetsArray}
   */
  const remove = (targets, renderable, propertyName) => {
    const targetsArray = parseTargets(targets);
    for (let i = 0, l = targetsArray.length; i < l; i++) {
      removeWAAPIAnimation(
        /** @type {DOMTarget}  */(targetsArray[i]),
        propertyName,
        renderable && /** @type {WAAPIAnimation} */(renderable).controlAnimation && /** @type {WAAPIAnimation} */(renderable),
      );
    }
    removeTargetsFromRenderable(
      targetsArray,
      /** @type {Renderable} */(renderable),
      propertyName
    );
    return targetsArray;
  };

  

  

  /**
   * Timeline's children offsets positions parser
   * @param  {Timeline} timeline
   * @param  {String} timePosition
   * @return {Number}
   */
  const getPrevChildOffset = (timeline, timePosition) => {
    if (stringStartsWith(timePosition, '<')) {
      const goToPrevAnimationOffset = timePosition[1] === '<';
      const prevAnimation = /** @type {Tickable} */(timeline._tail);
      const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;
      return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;
    }
  };

  /**
   * @param  {Timeline} timeline
   * @param  {TimelinePosition} [timePosition]
   * @return {Number}
   */
  const parseTimelinePosition = (timeline, timePosition) => {
    let tlDuration = timeline.iterationDuration;
    if (tlDuration === minValue) tlDuration = 0;
    if (isUnd(timePosition)) return tlDuration;
    if (isNum(+timePosition)) return +timePosition;
    const timePosStr = /** @type {String} */(timePosition);
    const tlLabels = timeline ? timeline.labels : null;
    const hasLabels = !isNil(tlLabels);
    const prevOffset = getPrevChildOffset(timeline, timePosStr);
    const hasSibling = !isUnd(prevOffset);
    const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);
    if (matchedRelativeOperator) {
      const fullOperator = matchedRelativeOperator[0];
      const split = timePosStr.split(fullOperator);
      const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;
      const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;
      const parsedNumericalOffset = +split[1];
      return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);
    } else {
      return hasSibling ? prevOffset :
             hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] :
             tlDuration : tlDuration;
    }
  };

  

  

  /**
   * @param {Timeline} tl
   * @return {Number}
   */
  function getTimelineTotalDuration(tl) {
    return clampInfinity(((tl.iterationDuration + tl._loopDelay) * tl.iterationCount) - tl._loopDelay) || minValue;
  }

  /**
   * @overload
   * @param  {TimerParams} childParams
   * @param  {Timeline} tl
   * @param  {Number} timePosition
   * @return {Timeline}
   *
   * @overload
   * @param  {AnimationParams} childParams
   * @param  {Timeline} tl
   * @param  {Number} timePosition
   * @param  {TargetsParam} targets
   * @param  {Number} [index]
   * @param  {Number} [length]
   * @return {Timeline}
   *
   * @param  {TimerParams|AnimationParams} childParams
   * @param  {Timeline} tl
   * @param  {Number} timePosition
   * @param  {TargetsParam} [targets]
   * @param  {Number} [index]
   * @param  {Number} [length]
   */
  function addTlChild(childParams, tl, timePosition, targets, index, length) {
    const isSetter = isNum(childParams.duration) && /** @type {Number} */(childParams.duration) <= minValue;
    // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position
    const adjustedPosition = isSetter ? timePosition - minValue : timePosition;
    if (tl.composition) tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);
    const tlChild = targets ?
      new JSAnimation(targets,/** @type {AnimationParams} */(childParams), tl, adjustedPosition, false, index, length) :
      new Timer(/** @type {TimerParams} */(childParams), tl, adjustedPosition);
    if (tl.composition) tlChild.init(true);
    // TODO: Might be better to insert at a position relative to startTime?
    addChild(tl, tlChild);
    forEachChildren(tl, (/** @type {Renderable} */child) => {
      const childTLOffset = child._offset + child._delay;
      const childDur = childTLOffset + child.duration;
      if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;
    });
    tl.duration = getTimelineTotalDuration(tl);
    return tl;
  }

  let TLId = 0;

  class Timeline extends Timer {

    /**
     * @param {TimelineParams} [parameters]
     */
    constructor(parameters = {}) {
      super(/** @type {TimerParams&TimelineParams} */(parameters), null, 0);
      ++TLId;
      /** @type {String|Number} */
      this.id = !isUnd(parameters.id) ? parameters.id : TLId;
      /** @type {Number} */
      this.duration = 0; // TL duration starts at 0 and grows when adding children
      /** @type {Record<String, Number>} */
      this.labels = {};
      const defaultsParams = parameters.defaults;
      const globalDefaults = globals.defaults;
      /** @type {DefaultsParams} */
      this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;
      /** @type {Boolean} */
      this.composition = setValue(parameters.composition, true);
      /** @type {Callback<this>} */
      this.onRender = parameters.onRender || globalDefaults.onRender;
      const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);
      this._ease = tlPlaybackEase ? parseEase(tlPlaybackEase) : null;
      /** @type {Number} */
      this.iterationDuration = 0;
    }

    /**
     * @overload
     * @param {TargetsParam} a1
     * @param {AnimationParams} a2
     * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]
     * @return {this}
     *
     * @overload
     * @param {TimerParams} a1
     * @param {TimelinePosition} [a2]
     * @return {this}
     *
     * @param {TargetsParam|TimerParams} a1
     * @param {TimelinePosition|AnimationParams} a2
     * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]
     */
    add(a1, a2, a3) {
      const isAnim = isObj(a2);
      const isTimer = isObj(a1);
      if (isAnim || isTimer) {
        this._hasChildren = true;
        if (isAnim) {
          const childParams = /** @type {AnimationParams} */(a2);
          // Check for function for children stagger positions
          if (isFnc(a3)) {
            const staggeredPosition = a3;
            const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */(a1));
            // Store initial duration before adding new children that will change the duration
            const tlDuration = this.duration;
            // Store initial _iterationDuration before adding new children that will change the duration
            const tlIterationDuration = this.iterationDuration;
            // Store the original id in order to add specific indexes to the new animations ids
            const id = childParams.id;
            let i = 0;
            /** @type {Number} */
            const parsedLength = (parsedTargetsArray.length);
            parsedTargetsArray.forEach((/** @type {Target} */target) => {
              // Create a new parameter object for each staggered children
              const staggeredChildParams = { ...childParams };
              // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation
              this.duration = tlDuration;
              this.iterationDuration = tlIterationDuration;
              if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;
              addTlChild(
                staggeredChildParams,
                this,
                parseTimelinePosition(this, staggeredPosition(target, i, parsedLength, this)),
                target,
                i,
                parsedLength
              );
              i++;
            });
          } else {
            addTlChild(
              childParams,
              this,
              parseTimelinePosition(this, a3),
              /** @type {TargetsParam} */(a1),
            );
          }
        } else {
          // It's a Timer
          addTlChild(
            /** @type TimerParams */(a1),
            this,
            parseTimelinePosition(this,a2),
          );
        }
        if (this.composition) this.init(true);
        return this;
      }
    }

    /**
     * @overload
     * @param {Tickable} [synced]
     * @param {TimelinePosition} [position]
     * @return {this}
     *
     * @overload
     * @param {globalThis.Animation} [synced]
     * @param {TimelinePosition} [position]
     * @return {this}
     *
     * @overload
     * @param {WAAPIAnimation} [synced]
     * @param {TimelinePosition} [position]
     * @return {this}
     *
     * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]
     * @param {TimelinePosition} [position]
     */
    sync(synced, position) {
      if (isUnd(synced) || synced && isUnd(synced.pause)) return this;
      synced.pause();
      const duration = +(/** @type {globalThis.Animation} */(synced).effect ? /** @type {globalThis.Animation} */(synced).effect.getTiming().duration : /** @type {Tickable} */(synced).duration);
      return this.add(synced, { currentTime: [0, duration], duration, delay: 0, ease: 'linear', playbackEase: 'linear' }, position);
    }

    /**
     * @param  {TargetsParam} targets
     * @param  {AnimationParams} parameters
     * @param  {TimelinePosition} [position]
     * @return {this}
     */
    set(targets, parameters, position) {
      if (isUnd(parameters)) return this;
      parameters.duration = minValue;
      parameters.composition = compositionTypes.replace;
      return this.add(targets, parameters, position);
    }

    /**
     * @param {Callback<Timer>} callback
     * @param {TimelinePosition} [position]
     * @return {this}
     */
    call(callback, position) {
      if (isUnd(callback) || callback && !isFnc(callback)) return this;
      return this.add({ duration: 0, delay: 0, onComplete: () => callback(this) }, position);
    }

    /**
     * @param {String} labelName
     * @param {TimelinePosition} [position]
     * @return {this}
     *
     */
    label(labelName, position) {
      if (isUnd(labelName) || labelName && !isStr(labelName)) return this;
      this.labels[labelName] = parseTimelinePosition(this, position);
      return this;
    }

    /**
     * @param  {TargetsParam} targets
     * @param  {String} [propertyName]
     * @return {this}
     */
    remove(targets, propertyName) {
      removeTargetsFromRenderable(parseTargets(targets), this, propertyName);
      return this;
    }

    /**
     * @param  {Number} newDuration
     * @return {this}
     */
    stretch(newDuration) {
      const currentDuration = this.duration;
      if (currentDuration === normalizeTime(newDuration)) return this;
      const timeScale = newDuration / currentDuration;
      const labels = this.labels;
      forEachChildren(this, (/** @type {JSAnimation} */child) => child.stretch(child.duration * timeScale));
      for (let labelName in labels) labels[labelName] *= timeScale;
      return super.stretch(newDuration);
    }

    /**
     * @return {this}
     */
    refresh() {
      forEachChildren(this, (/** @type {JSAnimation} */child) => {
        if (child.refresh) child.refresh();
      });
      return this;
    }

    /**
     * @return {this}
     */
    revert() {
      super.revert();
      forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);
      return cleanInlineStyles(this);
    }

    /**
     * @typedef {this & {then: null}} ResolvedTimeline
     */

    /**
     * @param  {Callback<ResolvedTimeline>} [callback]
     * @return Promise<this>
     */
    then(callback) {
      return super.then(callback);
    }
  }

  /**
   * @param {TimelineParams} [parameters]
   * @return {Timeline}
   */
  const createTimeline = parameters => new Timeline(parameters).init();

  

  class Animatable {
    /**
     * @param {TargetsParam} targets
     * @param {AnimatableParams} parameters
     */
    constructor(targets, parameters) {
      if (scope.current) scope.current.register(this);
      const beginHandler = () => {
        if (this.callbacks.completed) this.callbacks.reset();
        this.callbacks.play();
      };
      const pauseHandler = () => {
        if (this.callbacks.completed) return;
        let paused = true;
        for (let name in this.animations) {
          const anim = this.animations[name];
          if (!anim.paused && paused) {
            paused = false;
            break;
          }
        }
        if (paused) {
          this.callbacks.complete();
        }
      };
      /** @type {AnimationParams} */
      const globalParams = {
        onBegin: beginHandler,
        onComplete: pauseHandler,
        onPause: pauseHandler,
      };
      /** @type {AnimationParams} */
      const callbacksAnimationParams = { v: 1, autoplay: false };
      const properties = {};
      this.targets = [];
      this.animations = {};
      /** @type {JSAnimation|null} */
      this.callbacks = null;
      if (isUnd(targets) || isUnd(parameters)) return;
      for (let propName in parameters) {
        const paramValue = parameters[propName];
        if (isKey(propName)) {
          properties[propName] = paramValue;
        } else if (stringStartsWith(propName, 'on')) {
          callbacksAnimationParams[propName] = paramValue;
        } else {
          globalParams[propName] = paramValue;
        }
      }
      this.callbacks = new JSAnimation({ v: 0 }, callbacksAnimationParams);
      for (let propName in properties) {
        const propValue = properties[propName];
        const isObjValue = isObj(propValue);
        /** @type {TweenParamsOptions} */
        let propParams = {};
        let to = '+=0';
        if (isObjValue) {
          const unit = propValue.unit;
          if (isStr(unit)) to += unit;
        } else {
          propParams.duration = propValue;
        }
        propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;
        const animParams = mergeObjects(globalParams, propParams);
        animParams.composition = compositionTypes.replace;
        animParams.autoplay = false;
        const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();
        if (!this.targets.length) this.targets.push(...animation.targets);
        /** @type {AnimatableProperty} */
        this[propName] = (to, duration, ease) => {
          const tween = /** @type {Tween} */(animation._head);
          if (isUnd(to) && tween) {
            const numbers = tween._numbers;
            if (numbers && numbers.length) {
              return numbers;
            } else {
              return tween._modifier(tween._number);
            }
          } else {
            forEachChildren(animation, (/** @type {Tween} */tween) => {
              if (isArr(to)) {
                for (let i = 0, l = /** @type {Array} */(to).length; i < l; i++) {
                  if (!isUnd(tween._numbers[i])) {
                    tween._fromNumbers[i] = /** @type {Number} */(tween._modifier(tween._numbers[i]));
                    tween._toNumbers[i] = to[i];
                  }
                }
              } else {
                tween._fromNumber = /** @type {Number} */(tween._modifier(tween._number));
                tween._toNumber = /** @type {Number} */(to);
              }
              if (!isUnd(ease)) tween._ease = parseEase(ease);
              tween._currentTime = 0;
            });
            if (!isUnd(duration)) animation.stretch(duration);
            animation.reset(true).resume();
            return this;
          }
        };
      }
    }

    revert() {
      for (let propName in this.animations) {
        this[propName] = noop;
        this.animations[propName].revert();
      }
      this.animations = {};
      this.targets.length = 0;
      if (this.callbacks) this.callbacks.revert();
      return this;
    }
  }

  /**
   * @param {TargetsParam} targets
   * @param {AnimatableParams} parameters
   * @return {AnimatableObject}
   */
  const createAnimatable = (targets, parameters) => /** @type {AnimatableObject} */ (new Animatable(targets, parameters));

  /**
   * Rounds a number to fixed decimal places
   * @param  {Number|String} v - Value to round
   * @param  {Number} decimalLength - Number of decimal places
   * @return {String}
   */
  const roundPad$1 = (v, decimalLength) => (+v).toFixed(decimalLength);

  /**
   * Pads the start of a value with a string
   * @param  {Number} v - Value to pad
   * @param  {Number} totalLength - Target length
   * @param  {String} padString - String to pad with
   * @return {String}
   */
  const padStart$1 = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);

  /**
   * Pads the end of a value with a string
   * @param  {Number} v - Value to pad
   * @param  {Number} totalLength - Target length
   * @param  {String} padString - String to pad with
   * @return {String}
   */
  const padEnd$1 = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);

  /**
   * Wraps a value within a range
   * @param  {Number} v - Value to wrap
   * @param  {Number} min - Minimum boundary
   * @param  {Number} max - Maximum boundary
   * @return {Number}
   */
  const wrap$1 = (v, min, max) => (((v - min) % (max - min) + (max - min)) % (max - min)) + min;

  /**
   * Maps a value from one range to another
   * @param  {Number} value - Input value
   * @param  {Number} inLow - Input range minimum
   * @param  {Number} inHigh - Input range maximum
   * @param  {Number} outLow - Output range minimum
   * @param  {Number} outHigh - Output range maximum
   * @return {Number}
   */
  const mapRange$1 = (value, inLow, inHigh, outLow, outHigh) => outLow + ((value - inLow) / (inHigh - inLow)) * (outHigh - outLow);

  /**
   * Converts degrees to radians
   * @param  {Number} degrees - Angle in degrees
   * @return {Number}
   */
  const degToRad$1 = degrees => degrees * Math.PI / 180;

  /**
   * Converts radians to degrees
   * @param  {Number} radians - Angle in radians
   * @return {Number}
   */
  const radToDeg$1 = radians => radians * 180 / Math.PI;

  /**
   * Frame rate independent damped lerp
   * Based on: https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
   *
   * @param  {Number} start - Starting value
   * @param  {Number} end - Target value
   * @param  {Number} deltaTime - Delta time in ms
   * @param  {Number} factor - Interpolation factor in the range [0, 1]
   * @return {Number} The interpolated value
   */
  const damp$1 = (start, end, deltaTime, factor) => {
    return !factor ? start : factor === 1 ? end : lerp$1(start, end, 1 - Math.exp(-factor * deltaTime * .1));
  };

  var numberImports = /*#__PURE__*/Object.freeze({
    __proto__: null,
    clamp: clamp$1,
    damp: damp$1,
    degToRad: degToRad$1,
    lerp: lerp$1,
    mapRange: mapRange$1,
    padEnd: padEnd$1,
    padStart: padStart$1,
    radToDeg: radToDeg$1,
    round: round$1,
    roundPad: roundPad$1,
    snap: snap$1,
    wrap: wrap$1
  });

  

  

  /*
   * Spring easing solver adapted from https://webkit.org/demos/spring/spring.js
   * (c) 2016 Webkit - Apple Inc
   */

  const maxSpringParamValue = K * 10;

  class Spring {
    /**
     * @param {SpringParams} [parameters]
     */
    constructor(parameters = {}) {
      const hasBounceOrDuration = !isUnd(parameters.bounce) || !isUnd(parameters.duration);
      this.timeStep = .02; // Interval fed to the solver to calculate duration
      this.restThreshold = .0005; // Values below this threshold are considered resting position
      this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold
      this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)
      this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation
      this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration
      this.bn = clamp$1(setValue(parameters.bounce, .5), -1, 1); // The bounce percentage between -1 and 1.
      this.pd = clamp$1(setValue(parameters.duration, 628), 10 * globals.timeScale, maxSpringParamValue * globals.timeScale); // The perceived duration
      this.m = clamp$1(setValue(parameters.mass, 1), 1, maxSpringParamValue);
      this.s = clamp$1(setValue(parameters.stiffness, 100), minValue, maxSpringParamValue);
      this.d = clamp$1(setValue(parameters.damping, 10), minValue, maxSpringParamValue);
      this.v = clamp$1(setValue(parameters.velocity, 0), -maxSpringParamValue, maxSpringParamValue);
      this.w0 = 0;
      this.zeta = 0;
      this.wd = 0;
      this.b = 0;
      this.completed = false;
      this.solverDuration = 0;
      this.settlingDuration = 0;
      /** @type {JSAnimation} */
      this.parent = null;
      /** @type {Callback<JSAnimation>} */
      this.onComplete = parameters.onComplete || noop;
      if (hasBounceOrDuration) this.calculateSDFromBD();
      this.compute();
      /** @type {EasingFunction} */
      this.ease = t => {
        const currentTime = t * this.settlingDuration;
        const completed = this.completed;
        const perceivedTime = this.pd;
        if (currentTime >= perceivedTime && !completed) {
          this.completed = true;
          this.onComplete(this.parent);
        }
        if (currentTime < perceivedTime && completed) {
          this.completed = false;
        }
        return t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);
      };
    }

    /** @type {EasingFunction} */
    solve(time) {
      const { zeta, w0, wd, b } = this;
      let t = time;
      if (zeta < 1) {
        // Underdamped
        t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));
      } else if (zeta === 1) {
        // Critically damped
        t = (1 + b * t) * exp(-t * w0);
      } else {
        // Overdamped
        // Using exponential instead of cosh and sinh functions to prevent Infinity
        // Original exp(-zeta * w0 * t) * (cosh(wd * t) + b * sinh(wd * t))
        t = ((1 + b) * exp((-zeta * w0 + wd) * t) + (1 - b) * exp((-zeta * w0 - wd) * t)) / 2;
      }
      return 1 - t;
    }

    calculateSDFromBD() {
      // Apple's SwiftUI perceived spring duration implementation https://developer.apple.com/videos/play/wwdc2023/10158/?time=1010
      // Equations taken from Kevin Grajeda's article https://www.kvin.me/posts/effortless-ui-spring-animations
      const pds = globals.timeScale === 1 ? this.pd / K : this.pd;
      // Mass and velocity should be set to their default values
      this.m = 1;
      this.v = 0;
      // Stiffness = (2  perceptualDuration)
      this.s = pow((2 * PI) / pds, 2);
      if (this.bn >= 0) {
        // For bounce  0 (critically damped to underdamped)
        // damping = ((1 - bounce)  4)  perceptualDuration
        this.d = ((1 - this.bn) * 4 * PI) / pds;
      } else {
        // For bounce < 0 (overdamped)
        // damping = 4  (perceptualDuration  (1 + bounce))
        // Note: (1 + bounce) is positive since bounce is negative
        this.d = (4 * PI) / (pds * (1 + this.bn));
      }
      this.s = round$1(clamp$1(this.s, minValue, maxSpringParamValue), 3);
      this.d = round$1(clamp$1(this.d, minValue, 300), 3); // Clamping to 300 is needed to prevent insane values in the solver
    }

    calculateBDFromSD() {
      // Calculate perceived duration and bounce from stiffness and damping
      // Note: We assumes m = 1 and v = 0 for these calculations
      const pds = (2 * PI) / sqrt(this.s);
      this.pd = pds * (globals.timeScale === 1 ? K : 1);
      const zeta = this.d / (2 * sqrt(this.s));
      if (zeta <= 1) {
        // Critically damped to underdamped
        this.bn = 1 - (this.d * pds) / (4 * PI);
      } else {
        // Overdamped
        this.bn = (4 * PI) / (this.d * pds) - 1;
      }
      this.bn = round$1(clamp$1(this.bn, -1, 1), 3);
      this.pd = round$1(clamp$1(this.pd, 10 * globals.timeScale, maxSpringParamValue * globals.timeScale), 3);
    }

    compute() {
      const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;
      const w0 = this.w0 = clamp$1(sqrt(s / m), minValue, K);
      const bouncedZeta = this.zeta = d / (2 * sqrt(s * m));
      // Calculate wd based on damping type
      if (bouncedZeta < 1) {
        // Underdamped
        this.wd = w0 * sqrt(1 - bouncedZeta * bouncedZeta);
        this.b = (bouncedZeta * w0 + -v) / this.wd;
      } else if (bouncedZeta === 1) {
        // Critically damped
        this.wd = 0;
        this.b = -v + w0;
      } else {
        // Overdamped
        this.wd = w0 * sqrt(bouncedZeta * bouncedZeta - 1);
        this.b = (bouncedZeta * w0 + -v) / this.wd;
      }

      let solverTime = 0;
      let restSteps = 0;
      let iterations = 0;
      while (restSteps <= maxRestSteps && iterations <= maxIterations) {
        if (abs(1 - this.solve(solverTime)) < restThreshold) {
          restSteps++;
        } else {
          restSteps = 0;
        }
        this.solverDuration = solverTime;
        solverTime += timeStep;
        iterations++;
      }
      this.settlingDuration = round$1(this.solverDuration * K, 0) * globals.timeScale;
    }

    get bounce() {
      return this.bn;
    }

    set bounce(v) {
      this.bn = clamp$1(setValue(v, 1), -1, 1);
      this.calculateSDFromBD();
      this.compute();
    }

    get duration() {
      return this.pd;
    }

    set duration(v) {
      this.pd = clamp$1(setValue(v, 1), 10 * globals.timeScale, maxSpringParamValue * globals.timeScale);
      this.calculateSDFromBD();
      this.compute();
    }

    get stiffness() {
      return this.s;
    }

    set stiffness(v) {
      this.s = clamp$1(setValue(v, 100), minValue, maxSpringParamValue);
      this.calculateBDFromSD();
      this.compute();
    }

    get damping() {
      return this.d;
    }

    set damping(v) {
      this.d = clamp$1(setValue(v, 10), minValue, maxSpringParamValue);
      this.calculateBDFromSD();
      this.compute();
    }

    get mass() {
      return this.m;
    }

    set mass(v) {
      this.m = clamp$1(setValue(v, 1), 1, maxSpringParamValue);
      this.compute();
    }

    get velocity() {
      return this.v;
    }

    set velocity(v) {
      this.v = clamp$1(setValue(v, 0), -maxSpringParamValue, maxSpringParamValue);
      this.compute();
    }
  }

  /**
   * @param {SpringParams} [parameters]
   * @returns {Spring}
   */
  const spring = (parameters) => new Spring(parameters);

  /**
   * @deprecated createSpring() is deprecated use spring() instead
   *
   * @param {SpringParams} [parameters]
   * @returns {Spring}
   */
  const createSpring = (parameters) => {
    console.warn('createSpring() is deprecated use spring() instead');
    return new Spring(parameters);
  };

  

  

  /**
   * @param {Event} e
   */
  const preventDefault = e => {
    if (e.cancelable) e.preventDefault();
  };

  class DOMProxy {
    /** @param {Object} el */
    constructor(el) {
      this.el = el;
      this.zIndex = 0;
      this.parentElement = null;
      this.classList = {
        add: noop,
        remove: noop,
      };
    }

    get x() { return this.el.x || 0 };
    set x(v) { this.el.x = v; };

    get y() { return this.el.y || 0 };
    set y(v) { this.el.y = v; };

    get width() { return this.el.width || 0 };
    set width(v) { this.el.width = v; };

    get height() { return this.el.height || 0 };
    set height(v) { this.el.height = v; };

    getBoundingClientRect() {
      return {
        top: this.y,
        right: this.x,
        bottom: this.y + this.height,
        left: this.x + this.width,
      }
    }
  }

  class Transforms {
    /**
     * @param {DOMTarget|DOMProxy} $el
     */
    constructor($el) {
      this.$el = $el;
      this.inlineTransforms = [];
      this.point = new DOMPoint();
      this.inversedMatrix = this.getMatrix().inverse();
    }

    /**
     * @param {Number} x
     * @param {Number} y
     * @return {DOMPoint}
     */
    normalizePoint(x, y) {
      this.point.x = x;
      this.point.y = y;
      return this.point.matrixTransform(this.inversedMatrix);
    }

    /**
     * @callback TraverseParentsCallback
     * @param {DOMTarget} $el
     * @param {Number} i
     */

    /**
     * @param {TraverseParentsCallback} cb
     */
    traverseUp(cb) {
      let $el = /** @type {DOMTarget|Document} */(this.$el.parentElement), i = 0;
      while ($el && $el !== doc) {
        cb(/** @type {DOMTarget} */($el), i);
        $el = /** @type {DOMTarget} */($el.parentElement);
        i++;
      }
    }

    getMatrix() {
      const matrix = new DOMMatrix();
      this.traverseUp($el => {
        const transformValue = getComputedStyle($el).transform;
        if (transformValue) {
          const elMatrix = new DOMMatrix(transformValue);
          matrix.preMultiplySelf(elMatrix);
        }
      });
      return matrix;
    }

    remove() {
      this.traverseUp(($el, i) => {
        this.inlineTransforms[i] = $el.style.transform;
        $el.style.transform = 'none';
      });
    }

    revert() {
      this.traverseUp(($el, i) => {
        const ct = this.inlineTransforms[i];
        if (ct === '') {
          $el.style.removeProperty('transform');
        } else {
          $el.style.transform = ct;
        }
      });
    }
  }

  /**
   * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams|DraggableDragThresholdParams} T
   * @param {T | ((draggable: Draggable) => T)} value
   * @param {Draggable} draggable
   * @return {T}
   */
  const parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */(value)(draggable) : /** @type {T} */(value);

  let zIndex = 0;

  class Draggable {
    /**
     * @param {TargetsParam} target
     * @param {DraggableParams} [parameters]
     */
    constructor(target, parameters = {}) {
      if (!target) return;
      if (scope.current) scope.current.register(this);
      const paramX = parameters.x;
      const paramY = parameters.y;
      const trigger = parameters.trigger;
      const modifier = parameters.modifier;
      const ease = parameters.releaseEase;
      const customEase = ease && parseEase(ease);
      const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);
      const xProp = /** @type {String} */(isObj(paramX) && !isUnd(/** @type {Object} */(paramX).mapTo) ? /** @type {Object} */(paramX).mapTo : 'translateX');
      const yProp = /** @type {String} */(isObj(paramY) && !isUnd(/** @type {Object} */(paramY).mapTo) ? /** @type {Object} */(paramY).mapTo : 'translateY');
      const container = parseDraggableFunctionParameter(parameters.container, this);
      this.containerArray = isArr(container) ? container : null;
      this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);
      this.useWin = this.$container === doc.body;
      /** @type {Window | HTMLElement} */
      this.$scrollContainer = this.useWin ? win : this.$container;
      this.$target = /** @type {HTMLElement} */(isObj(target) ? new DOMProxy(target) : parseTargets(target)[0]);
      this.$trigger = /** @type {HTMLElement} */(parseTargets(trigger ? trigger : target)[0]);
      this.fixed = get(this.$target, 'position') === 'fixed';
      // Refreshable parameters
      this.isFinePointer = true;
      /** @type {[Number, Number, Number, Number]} */
      this.containerPadding = [0, 0, 0, 0];
      /** @type {Number} */
      this.containerFriction = 0;
      /** @type {Number} */
      this.releaseContainerFriction = 0;
      /** @type {Number|Array<Number>} */
      this.snapX = 0;
      /** @type {Number|Array<Number>} */
      this.snapY = 0;
      /** @type {Number} */
      this.scrollSpeed = 0;
      /** @type {Number} */
      this.scrollThreshold = 0;
      /** @type {Number} */
      this.dragSpeed = 0;
      /** @type {Number} */
      this.dragThreshold = 3;
      /** @type {Number} */
      this.maxVelocity = 0;
      /** @type {Number} */
      this.minVelocity = 0;
      /** @type {Number} */
      this.velocityMultiplier = 0;
      /** @type {Boolean|DraggableCursorParams} */
      this.cursor = false;
      /** @type {Spring} */
      this.releaseXSpring = hasSpring ? /** @type {Spring} */(ease) : spring({
        mass: setValue(parameters.releaseMass, 1),
        stiffness: setValue(parameters.releaseStiffness, 80),
        damping: setValue(parameters.releaseDamping, 20),
      });
      /** @type {Spring} */
      this.releaseYSpring = hasSpring ? /** @type {Spring} */(ease) : spring({
        mass: setValue(parameters.releaseMass, 1),
        stiffness: setValue(parameters.releaseStiffness, 80),
        damping: setValue(parameters.releaseDamping, 20),
      });
      /** @type {EasingFunction} */
      this.releaseEase = customEase || eases.outQuint;
      /** @type {Boolean} */
      this.hasReleaseSpring = hasSpring;
      /** @type {Callback<this>} */
      this.onGrab = parameters.onGrab || noop;
      /** @type {Callback<this>} */
      this.onDrag = parameters.onDrag || noop;
      /** @type {Callback<this>} */
      this.onRelease = parameters.onRelease || noop;
      /** @type {Callback<this>} */
      this.onUpdate = parameters.onUpdate || noop;
      /** @type {Callback<this>} */
      this.onSettle = parameters.onSettle || noop;
      /** @type {Callback<this>} */
      this.onSnap = parameters.onSnap || noop;
      /** @type {Callback<this>} */
      this.onResize = parameters.onResize || noop;
      /** @type {Callback<this>} */
      this.onAfterResize = parameters.onAfterResize || noop;
      /** @type {[Number, Number]} */
      this.disabled = [0, 0];
      /** @type {AnimatableParams} */
      const animatableParams = {};
      if (modifier) animatableParams.modifier = modifier;
      if (isUnd(paramX) || paramX === true) {
        animatableParams[xProp] = 0;
      } else if (isObj(paramX)) {
        const paramXObject = /** @type {DraggableAxisParam} */(paramX);
        const animatableXParams = {};
        if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;
        if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;
        animatableParams[xProp] = animatableXParams;
      } else if (paramX === false) {
        animatableParams[xProp] = 0;
        this.disabled[0] = 1;
      }
      if (isUnd(paramY) || paramY === true) {
        animatableParams[yProp] = 0;
      } else if (isObj(paramY)) {
        const paramYObject = /** @type {DraggableAxisParam} */(paramY);
        const animatableYParams = {};
        if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;
        if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;
        animatableParams[yProp] = animatableYParams;
      } else if (paramY === false) {
        animatableParams[yProp] = 0;
        this.disabled[1] = 1;
      }
      /** @type {AnimatableObject} */
      this.animate = /** @type {AnimatableObject} */(new Animatable(this.$target, animatableParams));
      // Internal props
      this.xProp = xProp;
      this.yProp = yProp;
      this.destX = 0;
      this.destY = 0;
      this.deltaX = 0;
      this.deltaY = 0;
      this.scroll = {x: 0, y: 0};
      /** @type {[Number, Number, Number, Number]} */
      this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y
      /** @type {[Number, Number]} */
      this.snapped = [0, 0]; // x, y
      /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */
      this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2
      /** @type {[Number, Number]} */
      this.scrollView = [0, 0]; // w, h
      /** @type {[Number, Number, Number, Number]} */
      this.dragArea = [0, 0, 0, 0]; // x, y, w, h
      /** @type {[Number, Number, Number, Number]} */
      this.containerBounds = [-maxValue, maxValue, maxValue, -maxValue]; // t, r, b, l
      /** @type {[Number, Number, Number, Number]} */
      this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l
      /** @type {[Number, Number, Number, Number]} */
      this.targetBounds = [0, 0, 0, 0]; // t, r, b, l
      /** @type {[Number, Number]} */
      this.window = [0, 0]; // w, h
      /** @type {[Number, Number, Number]} */
      this.velocityStack = [0, 0, 0];
      /** @type {Number} */
      this.velocityStackIndex = 0;
      /** @type {Number} */
      this.velocityTime = now();
      /** @type {Number} */
      this.velocity = 0;
      /** @type {Number} */
      this.angle = 0;
      /** @type {JSAnimation} */
      this.cursorStyles = null;
      /** @type {JSAnimation} */
      this.triggerStyles = null;
      /** @type {JSAnimation} */
      this.bodyStyles = null;
      /** @type {JSAnimation} */
      this.targetStyles = null;
      /** @type {JSAnimation} */
      this.touchActionStyles = null;
      this.transforms = new Transforms(this.$target);
      this.overshootCoords = { x: 0, y: 0 };
      this.overshootTicker = new Timer({
        autoplay: false,
        onUpdate: () => {
          this.updated = true;
          this.manual = true;
          // Use a duration of 1 to prevent the animatable from completing immediately to prevent issues with onSettle()
          // https://github.com/juliangarnier/anime/issues/1045
          if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 1);
          if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 1);
        },
        onComplete: () => {
          this.manual = false;
          if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 0);
          if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 0);
        },
      }, null, 0).init();
      this.updateTicker = new Timer({ autoplay: false, onUpdate: () => this.update() }, null,0,).init();
      this.contained = !isUnd(container);
      this.manual = false;
      this.grabbed = false;
      this.dragged = false;
      this.updated = false;
      this.released = false;
      this.canScroll = false;
      this.enabled = false;
      this.initialized = false;
      this.activeProp = this.disabled[1] ? xProp : yProp;
      this.animate.callbacks.onRender = () => {
        const hasUpdated = this.updated;
        const hasMoved = this.grabbed && hasUpdated;
        const hasReleased = !hasMoved && this.released;
        const x = this.x;
        const y = this.y;
        const dx = x - this.coords[2];
        const dy = y - this.coords[3];
        this.deltaX = dx;
        this.deltaY = dy;
        this.coords[2] = x;
        this.coords[3] = y;
        // Check if dx or dy are not 0 to check if the draggable has actually moved
        // https://github.com/juliangarnier/anime/issues/1032
        if (hasUpdated && (dx || dy)) {
          this.onUpdate(this);
        }
        if (!hasReleased) {
          this.updated = false;
        } else {
          this.computeVelocity(dx, dy);
          this.angle = atan2(dy, dx);
        }
      };
      this.animate.callbacks.onComplete = () => {
        if ((!this.grabbed && this.released)) {
          // Set released to false before calling onSettle to avoid recursion
          this.released = false;
        }
        if (!this.manual) {
          this.deltaX = 0;
          this.deltaY = 0;
          this.velocity = 0;
          this.velocityStack[0] = 0;
          this.velocityStack[1] = 0;
          this.velocityStack[2] = 0;
          this.velocityStackIndex = 0;
          this.onSettle(this);
        }
      };
      this.resizeTicker = new Timer({
        autoplay: false,
        duration: 150 * globals.timeScale,
        onComplete: () => {
          this.onResize(this);
          this.refresh();
          this.onAfterResize(this);
        },
      }).init();
      this.parameters = parameters;
      this.resizeObserver = new ResizeObserver(() => {
        if (this.initialized) {
          this.resizeTicker.restart();
        } else {
          this.initialized = true;
        }
      });
      this.enable();
      this.refresh();
      this.resizeObserver.observe(this.$container);
      if (!isObj(target)) this.resizeObserver.observe(this.$target);
    }

    /**
     * @param  {Number} dx
     * @param  {Number} dy
     * @return {Number}
     */
    computeVelocity(dx, dy) {
      const prevTime = this.velocityTime;
      const curTime = now();
      const elapsed = curTime - prevTime;
      if (elapsed < 17) return this.velocity;
      this.velocityTime = curTime;
      const velocityStack = this.velocityStack;
      const vMul = this.velocityMultiplier;
      const minV = this.minVelocity;
      const maxV = this.maxVelocity;
      const vi = this.velocityStackIndex;
      velocityStack[vi] = round$1(clamp$1((sqrt(dx * dx + dy * dy) / elapsed) * vMul, minV, maxV), 5);
      const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);
      this.velocity = velocity;
      this.velocityStackIndex = (vi + 1) % 3;
      return velocity;
    }

    /**
     * @param {Number}  x
     * @param {Boolean} [muteUpdateCallback]
     * @return {this}
     */
    setX(x, muteUpdateCallback = false) {
      if (this.disabled[0]) return;
      const v = round$1(x, 5);
      this.overshootTicker.pause();
      this.manual = true;
      this.updated = !muteUpdateCallback;
      this.destX = v;
      this.snapped[0] = snap$1(v, this.snapX);
      this.animate[this.xProp](v, 0);
      this.manual = false;
      return this;
    }

    /**
     * @param {Number}  y
     * @param {Boolean} [muteUpdateCallback]
     * @return {this}
     */
    setY(y, muteUpdateCallback = false) {
      if (this.disabled[1]) return;
      const v = round$1(y, 5);
      this.overshootTicker.pause();
      this.manual = true;
      this.updated = !muteUpdateCallback;
      this.destY = v;
      this.snapped[1] = snap$1(v, this.snapY);
      this.animate[this.yProp](v, 0);
      this.manual = false;
      return this;
    }

    get x() {
      return round$1(/** @type {Number} */(this.animate[this.xProp]()), globals.precision);
    }

    set x(x) {
      this.setX(x, false);
    }

    get y() {
      return round$1(/** @type {Number} */(this.animate[this.yProp]()), globals.precision);
    }

    set y(y) {
      this.setY(y, false);
    }

    get progressX() {
      return mapRange$1(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);
    }

    set progressX(x) {
      this.setX(mapRange$1(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);
    }

    get progressY() {
      return mapRange$1(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);
    }

    set progressY(y) {
      this.setY(mapRange$1(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);
    }

    updateScrollCoords() {
      const sx = round$1(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);
      const sy = round$1(this.useWin ? win.scrollY : this.$container.scrollTop, 0);
      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
      const threshold = this.scrollThreshold;
      this.scroll.x = sx;
      this.scroll.y = sy;
      this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;
      this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;
      this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;
      this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;
    }

    updateBoundingValues() {
      const $container = this.$container;
      // Return early if no $container defined to prevents error when reading scrollWidth / scrollHeight
      // https://github.com/juliangarnier/anime/issues/1064
      if (!$container) return;
      const cx = this.x;
      const cy = this.y;
      const cx2 = this.coords[2];
      const cy2 =  this.coords[3];
      // Prevents interfering with the scroll area in cases the target is outside of the container
      // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates
      this.coords[2] = 0;
      this.coords[3] = 0;
      this.setX(0, true);
      this.setY(0, true);
      this.transforms.remove();
      const iw = this.window[0] = win.innerWidth;
      const ih = this.window[1] = win.innerHeight;
      const uw = this.useWin;
      const sw = $container.scrollWidth;
      const sh = $container.scrollHeight;
      const fx = this.fixed;
      const transformContainerRect = $container.getBoundingClientRect();
      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
      this.dragArea[0] = uw ? 0 : transformContainerRect.left;
      this.dragArea[1] = uw ? 0 : transformContainerRect.top;
      this.scrollView[0] = uw ? clamp$1(sw, iw, sw) : sw;
      this.scrollView[1] = uw ? clamp$1(sh, ih, sh) : sh;
      this.updateScrollCoords();
      const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();
      this.dragArea[2] = round$1(uw ? clamp$1(width, iw, iw) : width, 0);
      this.dragArea[3] = round$1(uw ? clamp$1(height, ih, ih) : height, 0);
      const containerOverflow = get($container, 'overflow');
      const visibleOverflow = containerOverflow === 'visible';
      const hiddenOverflow = containerOverflow === 'hidden';
      this.canScroll = fx ? false :
        this.contained &&
        (($container === doc.body && visibleOverflow) || (!hiddenOverflow && !visibleOverflow)) &&
        (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) &&
        (!this.containerArray || (this.containerArray && !isArr(this.containerArray)));
      if (this.contained) {
        const sx = this.scroll.x;
        const sy = this.scroll.y;
        const canScroll = this.canScroll;
        const targetRect = this.$target.getBoundingClientRect();
        const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;
        const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;
        const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;
        const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;
        this.targetBounds[0] = round$1((targetRect.top + sy) - (uw ? 0 : top), 0);
        this.targetBounds[1] = round$1((targetRect.right + sx) - (uw ? iw : right), 0);
        this.targetBounds[2] = round$1((targetRect.bottom + sy) - (uw ? ih : bottom), 0);
        this.targetBounds[3] = round$1((targetRect.left + sx) - (uw ? 0 : left), 0);
        if (this.containerArray) {
          this.containerBounds[0] = this.containerArray[0] + cpt;
          this.containerBounds[1] = this.containerArray[1] - cpr;
          this.containerBounds[2] = this.containerArray[2] - cpb;
          this.containerBounds[3] = this.containerArray[3] + cpl;
        } else {
          this.containerBounds[0] = -round$1(targetRect.top - (fx ? clamp$1(top, 0, ih) : top) + hiddenTop - cpt, 0);
          this.containerBounds[1] = -round$1(targetRect.right - (fx ? clamp$1(right, 0, iw) : right) - hiddenRight + cpr, 0);
          this.containerBounds[2] = -round$1(targetRect.bottom - (fx ? clamp$1(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);
          this.containerBounds[3] = -round$1(targetRect.left - (fx ? clamp$1(left, 0, iw) : left) + hiddenLeft - cpl, 0);
        }
      }
      this.transforms.revert();
      // Restore coordinates
      this.coords[2] = cx2;
      this.coords[3] = cy2;
      this.setX(cx, true);
      this.setY(cy, true);
    }

    /**
     * @param  {Array} bounds
     * @param  {Number} x
     * @param  {Number} y
     * @return {Number}
     */
    isOutOfBounds(bounds, x, y) {
      // Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB
      if (!this.contained) return 0;
      const [ bt, br, bb, bl ] = bounds;
      const [ dx, dy ] = this.disabled;
      const obx = !dx && x < bl || !dx && x > br;
      const oby = !dy && y < bt || !dy && y > bb;
      return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;
    }

    refresh() {
      const params = this.parameters;
      const paramX = params.x;
      const paramY = params.y;
      const container = parseDraggableFunctionParameter(params.container, this);
      const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;
      const containerPadding = /** @type {[Number, Number, Number, Number]} */(isArr(cp) ? cp : [cp, cp, cp, cp]);
      const cx = this.x;
      const cy = this.y;
      const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);
      const cursorStyles = { onHover: 'grab', onGrab: 'grabbing' };
      if (parsedCursorStyles) {
        const { onHover, onGrab } = /** @type {DraggableCursorParams} */(parsedCursorStyles);
        if (onHover) cursorStyles.onHover = onHover;
        if (onGrab) cursorStyles.onGrab = onGrab;
      }
      const parsedDragThreshold = parseDraggableFunctionParameter(params.dragThreshold, this);
      const dragThreshold = { mouse: 3, touch: 7 };
      if (isNum(parsedDragThreshold)) {
        dragThreshold.mouse = parsedDragThreshold;
        dragThreshold.touch = parsedDragThreshold;
      } else if (parsedDragThreshold) {
        const { mouse, touch } = parsedDragThreshold;
        if (!isUnd(mouse)) dragThreshold.mouse = mouse;
        if (!isUnd(touch)) dragThreshold.touch = touch;
      }
      this.containerArray = isArr(container) ? container : null;
      this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);
      this.useWin = this.$container === doc.body;
      /** @type {Window | HTMLElement} */
      this.$scrollContainer = this.useWin ? win : this.$container;
      this.isFinePointer = matchMedia('(pointer:fine)').matches;
      this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);
      this.containerFriction = clamp$1(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);
      this.releaseContainerFriction = clamp$1(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);
      this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);
      this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);
      this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);
      this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);
      this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);
      this.dragThreshold = this.isFinePointer ? dragThreshold.mouse : dragThreshold.touch;
      this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);
      this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);
      this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);
      this.cursor = parsedCursorStyles === false ? false : cursorStyles;
      this.updateBoundingValues();

      // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);
      // if (ob === 1 || ob === 3) this.progressX = px;
      // if (ob === 2 || ob === 3) this.progressY = py;

      // if (this.initialized && this.contained) {
      //   if (this.progressX !== px) this.progressX = px;
      //   if (this.progressY !== py) this.progressY = py;
      // }

      const [ bt, br, bb, bl ] = this.containerBounds;
      this.setX(clamp$1(cx, bl, br), true);
      this.setY(clamp$1(cy, bt, bb), true);
    }

    update() {
      this.updateScrollCoords();
      if (this.canScroll) {
        const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
        const [ sw, sh ] = this.scrollView;
        const daw = this.dragArea[2];
        const dah = this.dragArea[3];
        const csx = this.scroll.x;
        const csy = this.scroll.y;
        const nsw = this.$container.scrollWidth;
        const nsh = this.$container.scrollHeight;
        const csw = this.useWin ? clamp$1(nsw, this.window[0], nsw) : nsw;
        const csh = this.useWin ? clamp$1(nsh, this.window[1], nsh) : nsh;
        const swd = sw - csw;
        const shd = sh - csh;
        // Handle cases where the scrollarea dimensions changes during drag
        if (this.dragged && swd > 0) {
          this.coords[0] -= swd;
          this.scrollView[0] = csw;
        }
        if (this.dragged && shd > 0) {
          this.coords[1] -= shd;
          this.scrollView[1] = csh;
        }
        // Handle autoscroll when target is at the edges of the scroll bounds
        const s = this.scrollSpeed * 10;
        const threshold = this.scrollThreshold;
        const [ x, y ] = this.coords;
        const [ st, sr, sb, sl ] = this.scrollBounds;
        const t = round$1(clamp$1((y - st + cpt) / threshold, -1, 0) * s, 0);
        const r = round$1(clamp$1((x - sr - cpr) / threshold, 0, 1) * s, 0);
        const b = round$1(clamp$1((y - sb - cpb) / threshold, 0, 1) * s, 0);
        const l = round$1(clamp$1((x - sl + cpl) / threshold, -1, 0) * s, 0);
        if (t || b || l || r) {
          const [nx, ny] = this.disabled;
          let scrollX = csx;
          let scrollY = csy;
          if (!nx) {
            scrollX = round$1(clamp$1(csx + (l || r), 0, sw - daw), 0);
            this.coords[0] -= csx - scrollX;
          }
          if (!ny) {
            scrollY = round$1(clamp$1(csy + (t || b), 0, sh - dah), 0);
            this.coords[1] -= csy - scrollY;
          }
          // Note: Safari mobile requires to use different scroll methods depending if using the window or not
          if (this.useWin) {
            this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));
          } else {
            this.$scrollContainer.scrollTo(scrollX, scrollY);
          }
        }
      }
      const [ ct, cr, cb, cl ] = this.containerBounds;
      const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;
      this.coords[0] += (px1 - px3) * this.dragSpeed;
      this.coords[1] += (py1 - py3) * this.dragSpeed;
      this.pointer[4] = px1;
      this.pointer[5] = py1;
      const [ cx, cy ] = this.coords;
      const [ sx, sy ] = this.snapped;
      const cf = (1 - this.containerFriction) * this.dragSpeed;
      this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);
      this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);
      this.computeVelocity(px1 - px3, py1 - py3);
      this.angle = atan2(py1 - py2, px1 - px2);
      const [ nsx, nsy ] = this.snapped;
      if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {
        this.onSnap(this);
      }
    }

    stop() {
      this.updateTicker.pause();
      this.overshootTicker.pause();
      // Pauses the in bounds onRelease animations
      for (let prop in this.animate.animations) this.animate.animations[prop].pause();
      removeTargetsFromRenderable([this], null, 'x');
      removeTargetsFromRenderable([this], null, 'y');
      removeTargetsFromRenderable([this], null, 'progressX');
      removeTargetsFromRenderable([this], null, 'progressY');
      removeTargetsFromRenderable([this.scroll]); // Removes any active animations on the container scroll
      removeTargetsFromRenderable([this.overshootCoords]); // Removes active overshoot animations
      return this;
    }

    /**
     * @param {Number} [duration]
     * @param {Number} [gap]
     * @param {EasingParam} [ease]
     * @return {this}
     */
    scrollInView(duration, gap = 0, ease = eases.inOutQuad) {
      this.updateScrollCoords();
      const x = this.destX;
      const y = this.destY;
      const scroll = this.scroll;
      const scrollBounds = this.scrollBounds;
      const canScroll = this.canScroll;
      if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {
        const [ st, sr, sb, sl ] = scrollBounds;
        const t = round$1(clamp$1(y - st, -maxValue, 0), 0);
        const r = round$1(clamp$1(x - sr, 0, maxValue), 0);
        const b = round$1(clamp$1(y - sb, 0, maxValue), 0);
        const l = round$1(clamp$1(x - sl, -maxValue, 0), 0);
        new JSAnimation(scroll, {
          x: round$1(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),
          y: round$1(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),
          duration: isUnd(duration) ? 350 * globals.timeScale : duration,
          ease,
          onUpdate: () => {
            this.canScroll = false;
            this.$scrollContainer.scrollTo(scroll.x, scroll.y);
          }
        }).init().then(() => {
          this.canScroll = canScroll;
        });
      }
      return this;
    }

    handleHover() {
      if (this.isFinePointer && this.cursor && !this.cursorStyles) {
        this.cursorStyles = set(this.$trigger, {
          cursor: /** @type {DraggableCursorParams} */(this.cursor).onHover
        });
      }
    }

    /**
     * @param  {Number} [duration]
     * @param  {Number} [gap]
     * @param  {EasingParam} [ease]
     * @return {this}
     */
    animateInView(duration, gap = 0, ease = eases.inOutQuad) {
      this.stop();
      this.updateBoundingValues();
      const x = this.x;
      const y = this.y;
      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
      const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;
      const br = this.scroll.x - this.targetBounds[1] - cpr - gap;
      const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;
      const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;
      const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);
      if (ob) {
        const [ disabledX, disabledY ] = this.disabled;
        const destX = clamp$1(snap$1(x, this.snapX), bl, br);
        const destY = clamp$1(snap$1(y, this.snapY), bt, bb);
        const dur = isUnd(duration) ? 350 * globals.timeScale : duration;
        if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);
        if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);
      }
      return this;
    }

    /**
     * @param {MouseEvent|TouchEvent} e
     */
    handleDown(e) {
      const $eTarget = /** @type {HTMLElement} */(e.target);
      if (this.grabbed || /** @type {HTMLInputElement} */($eTarget).type === 'range') return;

      e.stopPropagation();

      this.grabbed = true;
      this.released = false;
      this.stop();
      this.updateBoundingValues();
      const touches = /** @type {TouchEvent} */(e).changedTouches;
      const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;
      const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;
      const { x, y } = this.transforms.normalizePoint(eventX, eventY);
      const [ ct, cr, cb, cl ] = this.containerBounds;
      const cf = (1 - this.containerFriction) * this.dragSpeed;
      const cx = this.x;
      const cy = this.y;
      this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;
      this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;
      this.pointer[0] = x;
      this.pointer[1] = y;
      this.pointer[2] = x;
      this.pointer[3] = y;
      this.pointer[4] = x;
      this.pointer[5] = y;
      this.pointer[6] = x;
      this.pointer[7] = y;
      this.deltaX = 0;
      this.deltaY = 0;
      this.velocity = 0;
      this.velocityStack[0] = 0;
      this.velocityStack[1] = 0;
      this.velocityStack[2] = 0;
      this.velocityStackIndex = 0;
      this.angle = 0;
      if (this.targetStyles) {
        this.targetStyles.revert();
        this.targetStyles = null;
      }
      const z = /** @type {Number} */(get(this.$target, 'zIndex', false));
      zIndex = (z > zIndex ? z : zIndex) + 1;
      this.targetStyles = set(this.$target, { zIndex });
      if (this.triggerStyles) {
        this.triggerStyles.revert();
        this.triggerStyles = null;
      }
      if (this.cursorStyles) {
        this.cursorStyles.revert();
        this.cursorStyles = null;
      }
      if (this.isFinePointer && this.cursor) {
        this.bodyStyles = set(doc.body, {
          cursor: /** @type {DraggableCursorParams} */(this.cursor).onGrab
        });
      }
      this.scrollInView(100, 0, eases.out(3));
      this.onGrab(this);

      doc.addEventListener('touchmove', this);
      doc.addEventListener('touchend', this);
      doc.addEventListener('touchcancel', this);
      doc.addEventListener('mousemove', this);
      doc.addEventListener('mouseup', this);
      doc.addEventListener('selectstart', this);
    }

    /**
     * @param {MouseEvent|TouchEvent} e
     */
    handleMove(e) {
      if (!this.grabbed) return;
      const touches = /** @type {TouchEvent} */(e).changedTouches;
      const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;
      const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;
      const { x, y } = this.transforms.normalizePoint(eventX, eventY);
      const movedX = x - this.pointer[6];
      const movedY = y - this.pointer[7];

      let $parent = /** @type {HTMLElement} */(e.target);
      let isAtTop = false;
      let isAtBottom = false;
      let canTouchScroll = false;

      while (touches && $parent && $parent !== this.$trigger) {
        const overflowY = get($parent, 'overflow-y');
        if (overflowY !== 'hidden' && overflowY !== 'visible') {
          const { scrollTop, scrollHeight, clientHeight } = $parent;
          if (scrollHeight > clientHeight) {
            canTouchScroll = true;
            isAtTop = scrollTop <= 3;
            isAtBottom = scrollTop >= (scrollHeight - clientHeight) - 3;
            break;
          }
        }
        $parent = $parent.parentElement;
      }

      if (canTouchScroll && ((!isAtTop && !isAtBottom) || (isAtTop && movedY < 0) || (isAtBottom && movedY > 0))) {

        this.pointer[0] = x;
        this.pointer[1] = y;
        this.pointer[2] = x;
        this.pointer[3] = y;
        this.pointer[4] = x;
        this.pointer[5] = y;
        this.pointer[6] = x;
        this.pointer[7] = y;

      } else {

        preventDefault(e);

        // Needed to prevents click on handleUp
        if (!this.triggerStyles) this.triggerStyles = set(this.$trigger, { pointerEvents: 'none' });
        // Needed to prevent page scroll while dragging on touch devvice
        this.$trigger.addEventListener('touchstart', preventDefault, { passive: false });
        this.$trigger.addEventListener('touchmove', preventDefault, { passive: false });
        this.$trigger.addEventListener('touchend', preventDefault);

        // Don't check for a miminim distance move if already dragging
        if (this.dragged || (!this.disabled[0] && abs(movedX) > this.dragThreshold) || (!this.disabled[1] && abs(movedY) > this.dragThreshold)) {
          this.updateTicker.resume();
          this.pointer[2] = this.pointer[0];
          this.pointer[3] = this.pointer[1];
          this.pointer[0] = x;
          this.pointer[1] = y;
          this.dragged = true;
          this.released = false;
          this.onDrag(this);
        }
      }
    }

    handleUp() {

      if (!this.grabbed) return;

      this.updateTicker.pause();

      if (this.triggerStyles) {
        this.triggerStyles.revert();
        this.triggerStyles = null;
      }

      if (this.bodyStyles) {
        this.bodyStyles.revert();
        this.bodyStyles = null;
      }

      const [ disabledX, disabledY ] = this.disabled;
      const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;
      const [ ct, cr, cb, cl ] = this.containerBounds;
      const [ sx, sy ] = this.snapped;
      const springX = this.releaseXSpring;
      const springY = this.releaseYSpring;
      const releaseEase = this.releaseEase;
      const hasReleaseSpring = this.hasReleaseSpring;
      const overshootCoords = this.overshootCoords;
      const cx = this.x;
      const cy = this.y;
      const pv = this.computeVelocity(px1 - px3, py1 - py3);
      const pa = this.angle = atan2(py1 - py2, px1 - px2);
      const ds = pv * 150;
      const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;
      const nx = cx + (cos(pa) * ds);
      const ny = cy + (sin(pa) * ds);
      const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;
      const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;
      const dx = this.destX = clamp$1(round$1(snap$1(bx, this.snapX), 5), cl, cr);
      const dy = this.destY = clamp$1(round$1(snap$1(by, this.snapY), 5), ct, cb);
      const ob = this.isOutOfBounds(this.containerBounds, nx, ny);

      let durationX = 0;
      let durationY = 0;
      let easeX = releaseEase;
      let easeY = releaseEase;
      let longestReleaseDuration = 0;

      overshootCoords.x = cx;
      overshootCoords.y = cy;

      if (!disabledX) {
        const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;
        const distanceX = round$1(cx - dx, 0);
        springX.velocity = disabledY && hasReleaseSpring ? distanceX ? (ds * directionX) / abs(distanceX) : 0 : pv;
        const { ease, settlingDuration, restDuration } = springX;
        durationX = cx === dx ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - (restDuration * globals.timeScale);
        if (hasReleaseSpring) easeX = ease;
        if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;
      }

      if (!disabledY) {
        const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;
        const distanceY = round$1(cy - dy, 0);
        springY.velocity = disabledX && hasReleaseSpring ? distanceY ? (ds * directionY) / abs(distanceY) : 0 : pv;
        const { ease, settlingDuration, restDuration } = springY;
        durationY = cy === dy ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - (restDuration * globals.timeScale);
        if (hasReleaseSpring) easeY = ease;
        if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;
      }

      if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {

          const composition = compositionTypes.blend;

          new JSAnimation(overshootCoords, {
            x: { to: bx, duration: durationX * .65 },
            y: { to: by, duration: durationY * .65 },
            ease: releaseEase,
            composition,
          }).init();

          new JSAnimation(overshootCoords, {
            x: { to: dx, duration: durationX },
            y: { to: dy, duration: durationY },
            ease: releaseEase,
            composition,
          }).init();

          this.overshootTicker.stretch(max(durationX, durationY)).restart();

      } else {

        if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);
        if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);

      }

      this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);

      let hasSnapped = false;

      if (dx !== sx) {
        this.snapped[0] = dx;
        if (this.snapX) hasSnapped = true;
      }

      if (dy !== sy && this.snapY) {
        this.snapped[1] = dy;
        if (this.snapY) hasSnapped = true;
      }

      if (hasSnapped) this.onSnap(this);

      this.grabbed = false;
      this.dragged = false;
      this.updated = true;
      this.released = true;

      // It's important to trigger the callback after the release animations to be able to cancel them
      this.onRelease(this);

      this.$trigger.removeEventListener('touchstart', preventDefault);
      this.$trigger.removeEventListener('touchmove', preventDefault);
      this.$trigger.removeEventListener('touchend', preventDefault);

      doc.removeEventListener('touchmove', this);
      doc.removeEventListener('touchend', this);
      doc.removeEventListener('touchcancel', this);
      doc.removeEventListener('mousemove', this);
      doc.removeEventListener('mouseup', this);
      doc.removeEventListener('selectstart', this);
    }

    reset() {
      this.stop();
      this.resizeTicker.pause();
      this.grabbed = false;
      this.dragged = false;
      this.updated = false;
      this.released = false;
      this.canScroll = false;
      this.setX(0, true);
      this.setY(0, true);
      this.coords[0] = 0;
      this.coords[1] = 0;
      this.pointer[0] = 0;
      this.pointer[1] = 0;
      this.pointer[2] = 0;
      this.pointer[3] = 0;
      this.pointer[4] = 0;
      this.pointer[5] = 0;
      this.pointer[6] = 0;
      this.pointer[7] = 0;
      this.velocity = 0;
      this.velocityStack[0] = 0;
      this.velocityStack[1] = 0;
      this.velocityStack[2] = 0;
      this.velocityStackIndex = 0;
      this.angle = 0;
      return this;
    }

    enable() {
      if (!this.enabled) {
        this.enabled = true;
        this.$target.classList.remove('is-disabled');
        this.touchActionStyles = set(this.$trigger, {
          touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'
        });
        this.$trigger.addEventListener('touchstart', this, { passive: true });
        this.$trigger.addEventListener('mousedown', this, { passive: true });
        this.$trigger.addEventListener('mouseenter', this);
      }
      return this;
    }

    disable() {
      this.enabled = false;
      this.grabbed = false;
      this.dragged = false;
      this.updated = false;
      this.released = false;
      this.canScroll = false;
      this.touchActionStyles.revert();
      if (this.cursorStyles) {
        this.cursorStyles.revert();
        this.cursorStyles = null;
      }
      if (this.triggerStyles) {
        this.triggerStyles.revert();
        this.triggerStyles = null;
      }
      if (this.bodyStyles) {
        this.bodyStyles.revert();
        this.bodyStyles = null;
      }
      if (this.targetStyles) {
        this.targetStyles.revert();
        this.targetStyles = null;
      }
      this.$target.classList.add('is-disabled');
      this.$trigger.removeEventListener('touchstart', this);
      this.$trigger.removeEventListener('mousedown', this);
      this.$trigger.removeEventListener('mouseenter', this);
      doc.removeEventListener('touchmove', this);
      doc.removeEventListener('touchend', this);
      doc.removeEventListener('touchcancel', this);
      doc.removeEventListener('mousemove', this);
      doc.removeEventListener('mouseup', this);
      doc.removeEventListener('selectstart', this);
      return this;
    }

    revert() {
      this.reset();
      this.disable();
      this.$target.classList.remove('is-disabled');
      this.updateTicker.revert();
      this.overshootTicker.revert();
      this.resizeTicker.revert();
      this.animate.revert();
      this.resizeObserver.disconnect();
      return this;
    }

    /**
     * @param {Event} e
     */
    handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.handleDown(/** @type {MouseEvent} */(e));
          break;
        case 'touchstart':
          this.handleDown(/** @type {TouchEvent} */(e));
          break;
        case 'mousemove':
          this.handleMove(/** @type {MouseEvent} */(e));
          break;
        case 'touchmove':
          this.handleMove(/** @type {TouchEvent} */(e));
          break;
        case 'mouseup':
          this.handleUp();
          break;
        case 'touchend':
          this.handleUp();
          break;
        case 'touchcancel':
          this.handleUp();
          break;
        case 'mouseenter':
          this.handleHover();
          break;
        case 'selectstart':
          preventDefault(e);
          break;
      }
    }
  }

  /**
   * @param {TargetsParam} target
   * @param {DraggableParams} [parameters]
   * @return {Draggable}
   */
  const createDraggable = (target, parameters) => new Draggable(target, parameters);

  

  /**
   * @param  {Callback<Timer>} [callback]
   * @return {Timer}
   */
  const sync = (callback = noop) => {
    return new Timer({ duration: 1 * globals.timeScale, onComplete: callback }, null, 0).resume();
  };

  /**
   * @param  {(...args: any[]) => Tickable | ((...args: any[]) => void)} constructor
   * @return {(...args: any[]) => Tickable | ((...args: any[]) => void)}
   */
  const keepTime = constructor => {
    /** @type {Tickable} */
    let tracked;
    return (...args) => {
      let currentIteration, currentIterationProgress, reversed, alternate;
      if (tracked) {
        currentIteration = tracked.currentIteration;
        currentIterationProgress = tracked.iterationProgress;
        reversed = tracked.reversed;
        alternate = tracked._alternate;
        tracked.revert();
      }
      const cleanup = constructor(...args);
      if (cleanup && !isFnc(cleanup) && cleanup.revert) tracked = cleanup;
      if (!isUnd(currentIterationProgress)) {
        /** @type {Tickable} */(tracked).currentIteration = currentIteration;
        /** @type {Tickable} */(tracked).iterationProgress = (alternate ? !(currentIteration % 2) ? reversed : !reversed : reversed) ? 1 - currentIterationProgress : currentIterationProgress;
      }
      return cleanup || noop;
    }
  };

  

  class Scope {
    /** @param {ScopeParams} [parameters] */
    constructor(parameters = {}) {
      if (scope.current) scope.current.register(this);
      const rootParam = parameters.root;
      /** @type {Document|DOMTarget} */
      let root = doc;
      if (rootParam) {
        root = /** @type {ReactRef} */(rootParam).current ||
               /** @type {AngularRef} */(rootParam).nativeElement ||
               parseTargets(/** @type {DOMTargetSelector} */(rootParam))[0] ||
               doc;
      }
      const scopeDefaults = parameters.defaults;
      const globalDefault = globals.defaults;
      const mediaQueries = parameters.mediaQueries;
      /** @type {DefaultsParams} */
      this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;
      /** @type {Document|DOMTarget} */
      this.root = root;
      /** @type {Array<ScopeConstructorCallback>} */
      this.constructors = [];
      /** @type {Array<ScopeCleanupCallback>} */
      this.revertConstructors = [];
      /** @type {Array<Revertible>} */
      this.revertibles = [];
      /** @type {Array<ScopeConstructorCallback | ((scope: this) => Tickable)>} */
      this.constructorsOnce = [];
      /** @type {Array<ScopeCleanupCallback>} */
      this.revertConstructorsOnce = [];
      /** @type {Array<Revertible>} */
      this.revertiblesOnce = [];
      /** @type {Boolean} */
      this.once = false;
      /** @type {Number} */
      this.onceIndex = 0;
      /** @type {Record<String, ScopeMethod>} */
      this.methods = {};
      /** @type {Record<String, Boolean>} */
      this.matches = {};
      /** @type {Record<String, MediaQueryList>} */
      this.mediaQueryLists = {};
      /** @type {Record<String, any>} */
      this.data = {};
      if (mediaQueries) {
        for (let mq in mediaQueries) {
          const _mq = win.matchMedia(mediaQueries[mq]);
          this.mediaQueryLists[mq] = _mq;
          _mq.addEventListener('change', this);
        }
      }
    }

    /**
     * @param {Revertible} revertible
     */
    register(revertible) {
      const store = this.once ? this.revertiblesOnce : this.revertibles;
      store.push(revertible);
    }

    /**
     * @template T
     * @param {ScopedCallback<T>} cb
     * @return {T}
     */
    execute(cb) {
      let activeScope = scope.current;
      let activeRoot = scope.root;
      let activeDefaults = globals.defaults;
      scope.current = this;
      scope.root = this.root;
      globals.defaults = this.defaults;
      const mqs = this.mediaQueryLists;
      for (let mq in mqs) this.matches[mq] = mqs[mq].matches;
      const returned = cb(this);
      scope.current = activeScope;
      scope.root = activeRoot;
      globals.defaults = activeDefaults;
      return returned;
    }

    /**
     * @return {this}
     */
    refresh() {
      this.onceIndex = 0;
      this.execute(() => {
        let i = this.revertibles.length;
        let y = this.revertConstructors.length;
        while (i--) this.revertibles[i].revert();
        while (y--) this.revertConstructors[y](this);
        this.revertibles.length = 0;
        this.revertConstructors.length = 0;
        this.constructors.forEach((/** @type {ScopeConstructorCallback} */constructor) => {
          const revertConstructor = constructor(this);
          if (isFnc(revertConstructor)) {
            this.revertConstructors.push(revertConstructor);
          }
        });
      });
      return this;
    }

    /**
     * @overload
     * @param {String} a1
     * @param {ScopeMethod} a2
     * @return {this}
     *
     * @overload
     * @param {ScopeConstructorCallback} a1
     * @return {this}
     *
     * @param {String|ScopeConstructorCallback} a1
     * @param {ScopeMethod} [a2]
     */
    add(a1, a2) {
      this.once = false;
      if (isFnc(a1)) {
        const constructor = /** @type {ScopeConstructorCallback} */(a1);
        this.constructors.push(constructor);
        this.execute(() => {
          const revertConstructor = constructor(this);
          if (isFnc(revertConstructor)) {
            this.revertConstructors.push(revertConstructor);
          }
        });
      } else {
        this.methods[/** @type {String} */(a1)] = (/** @type {any} */...args) => this.execute(() => a2(...args));
      }
      return this;
    }

    /**
     * @param {ScopeConstructorCallback} scopeConstructorCallback
     * @return {this}
     */
    addOnce(scopeConstructorCallback) {
      this.once = true;
      if (isFnc(scopeConstructorCallback)) {
        const currentIndex = this.onceIndex++;
        const tracked = this.constructorsOnce[currentIndex];
        if (tracked) return this;
        const constructor = /** @type {ScopeConstructorCallback} */(scopeConstructorCallback);
        this.constructorsOnce[currentIndex] = constructor;
        this.execute(() => {
          const revertConstructor = constructor(this);
          if (isFnc(revertConstructor)) {
            this.revertConstructorsOnce.push(revertConstructor);
          }
        });
      }
      return this;
    }

    /**
     * @param  {(scope: this) => Tickable} cb
     * @return {Tickable}
     */
    keepTime(cb) {
      this.once = true;
      const currentIndex = this.onceIndex++;
      const tracked = /** @type {(scope: this) => Tickable} */(this.constructorsOnce[currentIndex]);
      if (isFnc(tracked)) return tracked(this);
      const constructor = /** @type {(scope: this) => Tickable} */(keepTime(cb));
      this.constructorsOnce[currentIndex] = constructor;
      let trackedTickable;
      this.execute(() => {
        trackedTickable = constructor(this);
      });
      return trackedTickable;
    }

    /**
     * @param {Event} e
     */
    handleEvent(e) {
      switch (e.type) {
        case 'change':
          this.refresh();
          break;
      }
    }

    revert() {
      const revertibles = this.revertibles;
      const revertConstructors = this.revertConstructors;
      const revertiblesOnce = this.revertiblesOnce;
      const revertConstructorsOnce = this.revertConstructorsOnce;
      const mqs = this.mediaQueryLists;
      let i = revertibles.length;
      let j = revertConstructors.length;
      let k = revertiblesOnce.length;
      let l = revertConstructorsOnce.length;
      while (i--) revertibles[i].revert();
      while (j--) revertConstructors[j](this);
      while (k--) revertiblesOnce[k].revert();
      while (l--) revertConstructorsOnce[l](this);
      for (let mq in mqs) mqs[mq].removeEventListener('change', this);
      revertibles.length = 0;
      revertConstructors.length = 0;
      this.constructors.length = 0;
      revertiblesOnce.length = 0;
      revertConstructorsOnce.length = 0;
      this.constructorsOnce.length = 0;
      this.onceIndex = 0;
      this.matches = {};
      this.methods = {};
      this.mediaQueryLists = {};
      this.data = {};
    }
  }

  /**
   * @param {ScopeParams} [params]
   * @return {Scope}
   */
  const createScope = params => new Scope(params);

  

  

  

  

  /**
   * @return {Number}
   */
  const getMaxViewHeight = () => {
    const $el = doc.createElement('div');
    doc.body.appendChild($el);
    $el.style.height = '100lvh';
    const height = $el.offsetHeight;
    doc.body.removeChild($el);
    return height;
  };

  /**
   * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T
   * @param {T | ((observer: ScrollObserver) => T)} value
   * @param {ScrollObserver} scroller
   * @return {T}
   */
  const parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */(value)(scroller) : /** @type {T} */(value);

  const scrollContainers = new Map();

  class ScrollContainer {
    /**
     * @param {HTMLElement} $el
     */
    constructor($el) {
      /** @type {HTMLElement} */
      this.element = $el;
      /** @type {Boolean} */
      this.useWin = this.element === doc.body;
      /** @type {Number} */
      this.winWidth = 0;
      /** @type {Number} */
      this.winHeight = 0;
      /** @type {Number} */
      this.width = 0;
      /** @type {Number} */
      this.height = 0;
      /** @type {Number} */
      this.left = 0;
      /** @type {Number} */
      this.top = 0;
      /** @type {Number} */
      this.scale = 1;
      /** @type {Number} */
      this.zIndex = 0;
      /** @type {Number} */
      this.scrollX = 0;
      /** @type {Number} */
      this.scrollY = 0;
      /** @type {Number} */
      this.prevScrollX = 0;
      /** @type {Number} */
      this.prevScrollY = 0;
      /** @type {Number} */
      this.scrollWidth = 0;
      /** @type {Number} */
      this.scrollHeight = 0;
      /** @type {Number} */
      this.velocity = 0;
      /** @type {Boolean} */
      this.backwardX = false;
      /** @type {Boolean} */
      this.backwardY = false;
      /** @type {Timer} */
      this.scrollTicker = new Timer({
        autoplay: false,
        onBegin: () => this.dataTimer.resume(),
        onUpdate: () => {
          const backwards = this.backwardX || this.backwardY;
          forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);
        },
        onComplete: () => this.dataTimer.pause()
      }).init();
      /** @type {Timer} */
      this.dataTimer = new Timer({
        autoplay: false,
        frameRate: 30,
        onUpdate: (/** @type {Timer} */self) => {
          const dt = self.deltaTime;
          const px = this.prevScrollX;
          const py = this.prevScrollY;
          const nx = this.scrollX;
          const ny = this.scrollY;
          const dx = px - nx;
          const dy = py - ny;
          this.prevScrollX = nx;
          this.prevScrollY = ny;
          if (dx) this.backwardX = px > nx;
          if (dy) this.backwardY = py > ny;
          this.velocity = round$1(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);
        }
      }).init();
      /** @type {Timer} */
      this.resizeTicker = new Timer({
        autoplay: false,
        duration: 250 * globals.timeScale,
        onComplete: () => {
          this.updateWindowBounds();
          this.refreshScrollObservers();
          this.handleScroll();
        }
      }).init();
      /** @type {Timer} */
      this.wakeTicker = new Timer({
        autoplay: false,
        duration: 500 * globals.timeScale,
        onBegin: () => {
          this.scrollTicker.resume();
        },
        onComplete: () => {
          this.scrollTicker.pause();
        }
      }).init();
      /** @type {ScrollObserver} */
      this._head = null;
      /** @type {ScrollObserver} */
      this._tail = null;
      this.updateScrollCoords();
      this.updateWindowBounds();
      this.updateBounds();
      this.refreshScrollObservers();
      this.handleScroll();
      this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());
      this.resizeObserver.observe(this.element);
      (this.useWin ? win : this.element).addEventListener('scroll', this, false);
    }

    updateScrollCoords() {
      const useWin = this.useWin;
      const $el = this.element;
      this.scrollX = round$1(useWin ? win.scrollX : $el.scrollLeft, 0);
      this.scrollY = round$1(useWin ? win.scrollY : $el.scrollTop, 0);
    }

    updateWindowBounds() {
      this.winWidth = win.innerWidth;
      this.winHeight = getMaxViewHeight();
    }

    updateBounds() {
      const style = getComputedStyle(this.element);
      const $el = this.element;
      this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
      this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
      this.updateWindowBounds();
      let width, height;
      if (this.useWin) {
        width = this.winWidth;
        height = this.winHeight;
      } else {
        const elRect = $el.getBoundingClientRect();
        width = $el.clientWidth;
        height = $el.clientHeight;
        this.top = elRect.top;
        this.left = elRect.left;
        this.scale = elRect.width ? width / elRect.width : (elRect.height ? height / elRect.height : 1);
      }
      this.width = width;
      this.height = height;
    }

    refreshScrollObservers() {
      forEachChildren(this, (/** @type {ScrollObserver} */child) => {
        if (child._debug) {
          child.removeDebug();
        }
      });
      this.updateBounds();
      forEachChildren(this, (/** @type {ScrollObserver} */child) => {
        child.refresh();
        if (child._debug) {
          child.debug();
        }
      });
    }

    refresh() {
      this.updateWindowBounds();
      this.updateBounds();
      this.refreshScrollObservers();
      this.handleScroll();
    }

    handleScroll() {
      this.updateScrollCoords();
      this.wakeTicker.restart();
    }

    /**
     * @param {Event} e
     */
    handleEvent(e) {
      switch (e.type) {
        case 'scroll':
          this.handleScroll();
          break;
      }
    }

    revert() {
      this.scrollTicker.cancel();
      this.dataTimer.cancel();
      this.resizeTicker.cancel();
      this.wakeTicker.cancel();
      this.resizeObserver.disconnect();
      (this.useWin ? win : this.element).removeEventListener('scroll', this);
      scrollContainers.delete(this.element);
    }
  }

  /**
   * @param {TargetsParam} target
   * @return {ScrollContainer}
   */
  const registerAndGetScrollContainer = target => {
    const $el = /** @type {HTMLElement} */(target ? parseTargets(target)[0] || doc.body : doc.body);
    let scrollContainer = scrollContainers.get($el);
    if (!scrollContainer) {
      scrollContainer = new ScrollContainer($el);
      scrollContainers.set($el, scrollContainer);
    }
    return scrollContainer;
  };

  /**
   * @param {HTMLElement} $el
   * @param {Number|string} v
   * @param {Number} size
   * @param {Number} [under]
   * @param {Number} [over]
   * @return {Number}
   */
  const convertValueToPx = ($el, v, size, under, over) => {
    const clampMin = v === 'min';
    const clampMax = v === 'max';
    const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 :
                  v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' :
                  v === 'center' ? '50%' :
                  v;
    const { n, u } = decomposeRawValue(value, decomposedOriginalValue);
    let px = n;
    if (u === '%') {
      px = (n / 100) * size;
    } else if (u) {
      px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;
    }
    if (clampMax && under < 0) px += under;
    if (clampMin && over > 0) px += over;
    return px;
  };

  /**
   * @param {HTMLElement} $el
   * @param {ScrollThresholdValue} v
   * @param {Number} size
   * @param {Number} [under]
   * @param {Number} [over]
   * @return {Number}
   */
  const parseBoundValue = ($el, v, size, under, over) => {
    /** @type {Number} */
    let value;
    if (isStr(v)) {
      const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */(v));
      if (matchedOperator) {
        const splitter = matchedOperator[0];
        const operator = splitter[0];
        const splitted = /** @type {String} */(v).split(splitter);
        const clampMin = splitted[0] === 'min';
        const clampMax = splitted[0] === 'max';
        const valueAPx = convertValueToPx($el, splitted[0], size, under, over);
        const valueBPx = convertValueToPx($el, splitted[1], size, under, over);
        if (clampMin) {
          const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);
          value = min < valueAPx ? valueAPx : min;
        } else if (clampMax) {
          const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);
          value = max > valueAPx ? valueAPx : max;
        } else {
          value = getRelativeValue(valueAPx, valueBPx, operator);
        }
      } else {
        value = convertValueToPx($el, v, size, under, over);
      }
    } else {
      value = /** @type {Number} */(v);
    }
    return round$1(value, 0);
  };

  /**
   * @param {JSAnimation} linked
   * @return {HTMLElement}
   */
  const getAnimationDomTarget = linked => {
    let $linkedTarget;
    const linkedTargets = linked.targets;
    for (let i = 0, l = linkedTargets.length; i < l; i++) {
      const target = linkedTargets[i];
      if (target[isDomSymbol]) {
        $linkedTarget = /** @type {HTMLElement} */(target);
        break;
      }
    }
    return $linkedTarget;
  };

  let scrollerIndex = 0;

  const debugColors$1 = ['#FF4B4B','#FF971B','#FFC730','#F9F640','#7AFF5A','#18FF74','#17E09B','#3CFFEC','#05DBE9','#33B3F1','#638CF9','#C563FE','#FF4FCF','#F93F8A'];

  class ScrollObserver {
    /**
     * @param {ScrollObserverParams} parameters
     */
    constructor(parameters = {}) {
      if (scope.current) scope.current.register(this);
      const syncMode = setValue(parameters.sync, 'play pause');
      const ease = syncMode ? parseEase(/** @type {EasingParam} */(syncMode)) : null;
      const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);
      const isEase = syncMode && !(ease === none && !isLinear);
      const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);
      const isMethods = syncMode && (isStr(syncMode) && !isEase && !isSmooth);
      const syncMethods = isMethods ? /** @type {String} */(syncMode).split(' ').map(
        (/** @type {String} */m) => () => {
          const linked = this.linked;
          return linked && linked[m] ? linked[m]() : null;
        }
      ) : null;
      const biDirSync = isMethods && syncMethods.length > 2;
      /** @type {Number} */
      this.index = scrollerIndex++;
      /** @type {String|Number} */
      this.id = !isUnd(parameters.id) ? parameters.id : this.index;
      /** @type {ScrollContainer} */
      this.container = registerAndGetScrollContainer(parameters.container);
      /** @type {HTMLElement} */
      this.target = null;
      /** @type {Tickable|WAAPIAnimation} */
      this.linked = null;
      /** @type {Boolean} */
      this.repeat = null;
      /** @type {Boolean} */
      this.horizontal = null;
      /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
      this.enter = null;
      /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
      this.leave = null;
      /** @type {Boolean} */
      this.sync = isEase || isSmooth || !!syncMethods;
      /** @type {EasingFunction} */
      this.syncEase = isEase ? ease : null;
      /** @type {Number} */
      this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */(syncMode) : null;
      /** @type {Callback<ScrollObserver>} */
      this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;
      /** @type {Callback<ScrollObserver>} */
      this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;
      /** @type {Callback<ScrollObserver>} */
      this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;
      /** @type {Callback<ScrollObserver>} */
      this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;
      /** @type {Callback<ScrollObserver>} */
      this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;
      /** @type {Callback<ScrollObserver>} */
      this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;
      /** @type {Callback<ScrollObserver>} */
      this.onEnter = parameters.onEnter || noop;
      /** @type {Callback<ScrollObserver>} */
      this.onLeave = parameters.onLeave || noop;
      /** @type {Callback<ScrollObserver>} */
      this.onEnterForward = parameters.onEnterForward || noop;
      /** @type {Callback<ScrollObserver>} */
      this.onLeaveForward = parameters.onLeaveForward || noop;
      /** @type {Callback<ScrollObserver>} */
      this.onEnterBackward = parameters.onEnterBackward || noop;
      /** @type {Callback<ScrollObserver>} */
      this.onLeaveBackward = parameters.onLeaveBackward || noop;
      /** @type {Callback<ScrollObserver>} */
      this.onUpdate = parameters.onUpdate || noop;
      /** @type {Callback<ScrollObserver>} */
      this.onSyncComplete = parameters.onSyncComplete || noop;
      /** @type {Boolean} */
      this.reverted = false;
      /** @type {Boolean} */
      this.ready = false;
      /** @type {Boolean} */
      this.completed = false;
      /** @type {Boolean} */
      this.began = false;
      /** @type {Boolean} */
      this.isInView = false;
      /** @type {Boolean} */
      this.forceEnter = false;
      /** @type {Boolean} */
      this.hasEntered = false;
      /** @type {Number} */
      this.offset = 0;
      /** @type {Number} */
      this.offsetStart = 0;
      /** @type {Number} */
      this.offsetEnd = 0;
      /** @type {Number} */
      this.distance = 0;
      /** @type {Number} */
      this.prevProgress = 0;
      /** @type {Array} */
      this.thresholds = ['start', 'end', 'end', 'start'];
      /** @type {[Number, Number, Number, Number]} */
      this.coords = [0, 0, 0, 0];
      /** @type {JSAnimation} */
      this.debugStyles = null;
      /** @type {HTMLElement} */
      this.$debug = null;
      /** @type {ScrollObserverParams} */
      this._params = parameters;
      /** @type {Boolean} */
      this._debug = setValue(parameters.debug, false);
      /** @type {ScrollObserver} */
      this._next = null;
      /** @type {ScrollObserver} */
      this._prev = null;
      addChild(this.container, this);
      // Wait for the next frame to add to the container in order to handle calls to link()
      sync(() => {
        if (this.reverted) return;
        if (!this.target) {
          const target = /** @type {HTMLElement} */(parseTargets(parameters.target)[0]);
          this.target = target || doc.body;
          this.refresh();
        }
        if (this._debug) this.debug();
      });
    }

    /**
     * @param {Tickable|WAAPIAnimation} linked
     */
    link(linked) {
      if (linked) {
        // Make sure to pause the linked object in case it's added later
        linked.pause();
        this.linked = linked;
        // Forces WAAPI Animation to persist; otherwise, they will stop syncing on finish.
        if (!isUnd(/** @type {WAAPIAnimation} */(linked))) /** @type {WAAPIAnimation} */(linked).persist = true;
        // Try to use a target of the linked object if no target parameters specified
        if (!this._params.target) {
          /** @type {HTMLElement} */
          let $linkedTarget;
          if (!isUnd(/** @type {JSAnimation} */(linked).targets)) {
            $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(linked));
          } else {
            forEachChildren(/** @type {Timeline} */(linked), (/** @type {JSAnimation} */child) => {
              if (child.targets && !$linkedTarget) {
                $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(child));
              }
            });
          }
          // Fallback to body if no target found
          this.target = $linkedTarget || doc.body;
          this.refresh();
        }
      }
      return this;
    }

    get velocity() {
      return this.container.velocity;
    }

    get backward() {
      return this.horizontal ? this.container.backwardX : this.container.backwardY;
    }

    get scroll() {
      return this.horizontal ? this.container.scrollX : this.container.scrollY;
    }

    get progress() {
      const p = (this.scroll - this.offsetStart) / this.distance;
      return p === Infinity || isNaN(p) ? 0 : round$1(clamp$1(p, 0, 1), 6);
    }

    refresh() {
      // This flag is used to prevent running handleScroll() outside of this.refresh() with values not yet calculated
      this.ready = true;
      this.reverted = false;
      const params = this._params;
      this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);
      this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';
      this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');
      this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');
      this.updateBounds();
      this.handleScroll();
      return this;
    }

    removeDebug() {
      if (this.$debug) {
        this.$debug.parentNode.removeChild(this.$debug);
        this.$debug = null;
      }
      if (this.debugStyles) {
        this.debugStyles.revert();
        this.$debug = null;
      }
      return this;
    }

    debug() {
      this.removeDebug();
      const container = this.container;
      const isHori = this.horizontal;
      const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');
      const $debug = doc.createElement('div');
      const $thresholds = doc.createElement('div');
      const $triggers = doc.createElement('div');
      const color = debugColors$1[this.index % debugColors$1.length];
      const useWin = container.useWin;
      const containerWidth = useWin ? container.winWidth : container.width;
      const containerHeight = useWin ? container.winHeight : container.height;
      const scrollWidth = container.scrollWidth;
      const scrollHeight = container.scrollHeight;
      const size = this.container.width > 360 ? 320 : 260;
      const offLeft = isHori ? 0 : 10;
      const offTop = isHori ? 10 : 0;
      const half = isHori ? 24 : size / 2;
      const labelHeight = isHori ? half : 15;
      const labelWidth = isHori ? 60 : half;
      const labelSize = isHori ? labelWidth : labelHeight;
      const repeat = isHori ? 'repeat-x' : 'repeat-y';
      /**
       * @param {Number} v
       * @return {String}
       */
      const gradientOffset = v => isHori ? '0px '+(v)+'px' : (v)+'px'+' 2px';
      /**
       * @param {String} c
       * @return {String}
       */
      const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;
      /**
       * @param {String} p
       * @param {Number} l
       * @param {Number} t
       * @param {Number} w
       * @param {Number} h
       * @return {String}
       */
      const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;
      $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}
      pointer-events: none;
      z-index: ${this.container.zIndex++};
      display: flex;
      flex-direction: ${isHori ? 'column' : 'row'};
      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));
    `;
      $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;
      if (!$existingDebug) {
        $thresholds.style.cssText += `background:
        ${lineCSS('#FFFF')}${gradientOffset(half-10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},
        ${lineCSS('#FFF8')}${gradientOffset(half-10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};
      `;
      }
      $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;
      if (!$existingDebug) {
        $triggers.style.cssText += `background:
        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},
        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};
      `;
      }
      const labels = [' enter: ', ' leave: '];
      this.coords.forEach((v, i) => {
        const isView = i > 1;
        const value = (isView ? 0 : this.offset) + v;
        const isTail = i % 2;
        const isFirst = value < labelSize;
        const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;
        const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;
        const $label = doc.createElement('div');
        const $text = doc.createElement('div');
        const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';
        const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;
        // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;
        $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;
        $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}
        display: flex;
        flex-direction: ${isHori ? 'column' : 'row'};
        justify-content: flex-${isView ? 'start' : 'end'};
        align-items: flex-${isFlip ? 'end' : 'start'};
        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};
      `;
        $text.style.cssText = `
        overflow: hidden;
        max-width: ${(size / 2) - 10}px;
        height: ${labelHeight};
        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;
        padding: 1px;
        font-family: ui-monospace, monospace;
        font-size: 10px;
        letter-spacing: -.025em;
        line-height: 9px;
        font-weight: 600;
        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};
        white-space: pre;
        text-overflow: ellipsis;
        color: ${isTail ? color : 'rgba(0,0,0,.75)'};
        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};
        border: 2px solid ${isTail ? color : 'transparent'};
        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;
        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;
      `;
        $label.appendChild($text);
        let position = value - flipOffset + (isHori ? 1 : 0);
        $label.style[isHori ? 'left' : 'top'] = `${position}px`;
        // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';
        (isView ? $thresholds : $triggers).appendChild($label);
      });

      $debug.appendChild($thresholds);
      $debug.appendChild($triggers);
      container.element.appendChild($debug);

      if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');
      this.$debug = $debug;
      const containerPosition = get(container.element, 'position');
      if (containerPosition === 'static') {
        this.debugStyles = set(container.element, { position: 'relative '});
      }

    }

    updateBounds() {
      if (this._debug) {
        this.removeDebug();
      }
      let stickys;
      const $target = this.target;
      const container = this.container;
      const isHori = this.horizontal;
      const linked = this.linked;
      let linkedTime;
      let $el = $target;
      // let offsetX = 0;
      // let offsetY = 0;
      // let $offsetParent = $el;
      /** @type {Element} */
      if (linked) {
        linkedTime = linked.currentTime;
        linked.seek(0, true);
      }
      /* Old implementation to get offset and targetSize before fixing https://github.com/juliangarnier/anime/issues/1021
      // const isContainerStatic = get(container.element, 'position') === 'static' ? set(container.element, { position: 'relative '}) : false;
      // while ($el && $el !== container.element && $el !== doc.body) {
      //   const isSticky = get($el, 'position') === 'sticky' ?
      //                    set($el, { position: 'static' }) :
      //                    false;
      //   if ($el === $offsetParent) {
      //     offsetX += $el.offsetLeft || 0;
      //     offsetY += $el.offsetTop || 0;
      //     $offsetParent = $el.offsetParent;
      //   }
      //   $el = /** @type {HTMLElement} */($el.parentElement);
      //   if (isSticky) {
      //     if (!stickys) stickys = [];
      //     stickys.push(isSticky);
      //   }
      // }
      // if (isContainerStatic) isContainerStatic.revert();
      // const offset = isHori ? offsetX : offsetY;
      // const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;

      while ($el && $el !== container.element && $el !== doc.body) {
        const isSticky = get($el, 'position') === 'sticky' ? set($el, { position: 'static' }) : false;
        $el = $el.parentElement;
        if (isSticky) {
          if (!stickys) stickys = [];
          stickys.push(isSticky);
        }
      }
      const rect = $target.getBoundingClientRect();
      const scale = container.scale;
      const offset = (isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top) * scale;
      const targetSize = (isHori ? rect.width : rect.height) * scale;
      const containerSize = isHori ? container.width : container.height;
      const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;
      const maxScroll = scrollSize - containerSize;
      const enter = this.enter;
      const leave = this.leave;

      /** @type {ScrollThresholdValue} */
      let enterTarget = 'start';
      /** @type {ScrollThresholdValue} */
      let leaveTarget = 'end';
      /** @type {ScrollThresholdValue} */
      let enterContainer = 'end';
      /** @type {ScrollThresholdValue} */
      let leaveContainer = 'start';

      if (isStr(enter)) {
        const splitted = /** @type {String} */(enter).split(' ');
        enterContainer = splitted[0];
        enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;
      } else if (isObj(enter)) {
        const e = /** @type {ScrollThresholdParam} */(enter);
        if (!isUnd(e.container)) enterContainer = e.container;
        if (!isUnd(e.target)) enterTarget = e.target;
      } else if (isNum(enter)) {
        enterContainer = /** @type {Number} */(enter);
      }

      if (isStr(leave)) {
        const splitted = /** @type {String} */(leave).split(' ');
        leaveContainer = splitted[0];
        leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;
      } else if (isObj(leave)) {
        const t = /** @type {ScrollThresholdParam} */(leave);
        if (!isUnd(t.container)) leaveContainer = t.container;
        if (!isUnd(t.target)) leaveTarget = t.target;
      } else if (isNum(leave)) {
        leaveContainer = /** @type {Number} */(leave);
      }

      const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);
      const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);
      const under = (parsedEnterTarget + offset) - containerSize;
      const over = (parsedLeaveTarget + offset) - maxScroll;
      const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);
      const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);
      const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;
      const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;
      const scrollDelta = offsetEnd - offsetStart;
      this.offset = offset;
      this.offsetStart = offsetStart;
      this.offsetEnd = offsetEnd;
      this.distance = scrollDelta <= 0 ? 0 : scrollDelta;
      this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];
      this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];
      if (stickys) {
        stickys.forEach(sticky => sticky.revert());
      }
      if (linked) {
        linked.seek(linkedTime, true);
      }
      if (this._debug) {
        this.debug();
      }
    }

    handleScroll() {
      if (!this.ready) return;
      const linked = this.linked;
      const sync = this.sync;
      const syncEase = this.syncEase;
      const syncSmooth = this.syncSmooth;
      const shouldSeek = linked && (syncEase || syncSmooth);
      const isHori = this.horizontal;
      const container = this.container;
      const scroll = this.scroll;
      const isBefore = scroll <= this.offsetStart;
      const isAfter = scroll >= this.offsetEnd;
      const isInView = !isBefore && !isAfter;
      const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;
      const forceEnter = !this.hasEntered && isOnTheEdge;
      const $debug = this._debug && this.$debug;
      let hasUpdated = false;
      let syncCompleted = false;
      let p = this.progress;

      if (isBefore && this.began) {
        this.began = false;
      }

      if (p > 0 && !this.began) {
        this.began = true;
      }

      if (shouldSeek) {
        const lp = linked.progress;
        if (syncSmooth && isNum(syncSmooth)) {
          if (/** @type {Number} */(syncSmooth) < 1) {
            const step = 0.0001;
            const snap = lp < p && p === 1 ? step : lp > p && !p ? -step : 0;
            p = round$1(lerp$1(lp, p, lerp$1(.01, .2, /** @type {Number} */(syncSmooth))) + snap, 6);
          }
        } else if (syncEase) {
          p = syncEase(p);
        }
        hasUpdated = p !== this.prevProgress;
        syncCompleted = lp === 1;
        if (hasUpdated && !syncCompleted && (syncSmooth && lp)) {
          container.wakeTicker.restart();
        }
      }

      if ($debug) {
        const sticky = isHori ? container.scrollY : container.scrollX;
        $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';
      }

      // Trigger enter callbacks if already in view or when entering the view
      if ((isInView && !this.isInView) || (forceEnter && !this.forceEnter && !this.hasEntered)) {
        if (isInView) this.isInView = true;
        if (!this.forceEnter || !this.hasEntered) {
          if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;
          this.onSyncEnter(this);
          this.onEnter(this);
          if (this.backward) {
            this.onSyncEnterBackward(this);
            this.onEnterBackward(this);
          } else {
            this.onSyncEnterForward(this);
            this.onEnterForward(this);
          }
          this.hasEntered = true;
          if (forceEnter) this.forceEnter = true;
        } else if (isInView) {
          this.forceEnter = false;
        }
      }

      if (isInView || !isInView && this.isInView) {
        hasUpdated = true;
      }

      if (hasUpdated) {
        if (shouldSeek) linked.seek(linked.duration * p);
        this.onUpdate(this);
      }

      if (!isInView && this.isInView) {
        this.isInView = false;
        this.onSyncLeave(this);
        this.onLeave(this);
        if (this.backward) {
          this.onSyncLeaveBackward(this);
          this.onLeaveBackward(this);
        } else {
          this.onSyncLeaveForward(this);
          this.onLeaveForward(this);
        }
        if (sync && !syncSmooth) {
          syncCompleted = true;
        }
      }

      if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {
        if (sync) {
          this.onSyncComplete(this);
        }
        this.completed = true;
        if ((!this.repeat && !linked) || (!this.repeat && linked && linked.completed)) {
          this.revert();
        }
      }

      if (p < 1 && this.completed) {
        this.completed = false;
      }

      this.prevProgress = p;
    }

    revert() {
      if (this.reverted) return;
      const container = this.container;
      removeChild(container, this);
      if (!container._head) {
        container.revert();
      }
      if (this._debug) {
        this.removeDebug();
      }
      this.reverted = true;
      this.ready = false;
      return this;
    }

  }

  /**
   * @param {ScrollObserverParams} [parameters={}]
   * @return {ScrollObserver}
   */
  const onScroll = (parameters = {}) => new ScrollObserver(parameters);

  

  /**
   * Cubic Bezier solver adapted from https://github.com/gre/bezier-easing
   * (c) 2014 Gatan Renaudeau
   */

  /**
   * @param  {Number} aT
   * @param  {Number} aA1
   * @param  {Number} aA2
   * @return {Number}
   */
  const calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + (3 * aA1)) * aT;

  /**
   * @param  {Number} aX
   * @param  {Number} mX1
   * @param  {Number} mX2
   * @return {Number}
   */
  const binarySubdivide = (aX, mX1, mX2) => {
    let aA = 0, aB = 1, currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (abs(currentX) > .0000001 && ++i < 100);
    return currentT;
  };

  /**
   * @param  {Number} [mX1] The x coordinate of the first point
   * @param  {Number} [mY1] The y coordinate of the first point
   * @param  {Number} [mX2] The x coordinate of the second point
   * @param  {Number} [mY2] The y coordinate of the second point
   * @return {EasingFunction}
   */

  const cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0) => (mX1 === mY1 && mX2 === mY2) ? none :
    t => t === 0 || t === 1 ? t :
    calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);

  

  /**
   * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function
   * Only covers 'end' and 'start' jumpterms
   * @param  {Number} steps
   * @param  {Boolean} [fromStart]
   * @return {EasingFunction}
   */
  const steps = (steps = 10, fromStart) => {
    const roundMethod = fromStart ? ceil : floor;
    return t => roundMethod(clamp$1(t, 0, 1) * steps) * (1 / steps);
  };

  

  /**
   * Without parameters, the linear function creates a non-eased transition.
   * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.
   *
   * @param  {...(String|Number)} args - Points
   * @return {EasingFunction}
   */
  const linear = (...args) => {
    const argsLength = args.length;
    if (!argsLength) return none;
    const totalPoints = argsLength - 1;
    const firstArg = args[0];
    const lastArg = args[totalPoints];
    const xPoints = [0];
    const yPoints = [parseNumber(firstArg)];
    for (let i = 1; i < totalPoints; i++) {
      const arg = args[i];
      const splitValue = isStr(arg) ?
      /** @type {String} */(arg).trim().split(' ') :
      [arg];
      const value = splitValue[0];
      const percent = splitValue[1];
      xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);
      yPoints.push(parseNumber(value));
    }
    yPoints.push(parseNumber(lastArg));
    xPoints.push(1);
    return function easeLinear(t) {
      for (let i = 1, l = xPoints.length; i < l; i++) {
        const currentX = xPoints[i];
        if (t <= currentX) {
          const prevX = xPoints[i - 1];
          const prevY = yPoints[i - 1];
          return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);
        }
      }
      return yPoints[yPoints.length - 1];
    }
  };

  

  /**
   * Generate random steps
   * @param  {Number} [length] - The number of steps
   * @param  {Number} [randomness] - How strong the randomness is
   * @return {EasingFunction}
   */
  const irregular = (length = 10, randomness = 1) => {
    const values = [0];
    const total = length - 1;
    for (let i = 1; i < total; i++) {
      const previousValue = values[i - 1];
      const spacing = i / total;
      const segmentEnd = (i + 1) / total;
      const randomVariation = spacing + (segmentEnd - spacing) * Math.random();
      // Mix the even spacing and random variation based on the randomness parameter
      const randomValue = spacing * (1 - randomness) + randomVariation * randomness;
      values.push(clamp$1(randomValue, previousValue, 1));
    }
    values.push(1);
    return linear(...values);
  };

  var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Spring: Spring,
    createSpring: createSpring,
    cubicBezier: cubicBezier,
    eases: eases,
    irregular: irregular,
    linear: linear,
    spring: spring,
    steps: steps
  });

  

  

  

  /**
   * Converts an easing function into a valid CSS linear() timing function string
   * @param {EasingFunction} fn
   * @param {number} [samples=100]
   * @returns {string} CSS linear() timing function
   */
  const easingToLinear = (fn, samples = 100) => {
    const points = [];
    for (let i = 0; i <= samples; i++) points.push(round$1(fn(i / samples), 4));
    return `linear(${points.join(', ')})`;
  };

  const WAAPIEasesLookups = {};

  /**
   * @param  {EasingParam} ease
   * @return {String}
   */
  const parseWAAPIEasing = (ease) => {
    let parsedEase = WAAPIEasesLookups[ease];
    if (parsedEase) return parsedEase;
    parsedEase = 'linear';
    if (isStr(ease)) {
      if (
        stringStartsWith(ease, 'linear') ||
        stringStartsWith(ease, 'cubic-') ||
        stringStartsWith(ease, 'steps') ||
        stringStartsWith(ease, 'ease')
      ) {
        parsedEase = ease;
      } else if (stringStartsWith(ease, 'cubicB')) {
        parsedEase = toLowerCase(ease);
      } else {
        const parsed = parseEaseString(ease);
        if (isFnc(parsed)) parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);
      }
      // Only cache string based easing name, otherwise function arguments get lost
      WAAPIEasesLookups[ease] = parsedEase;
    } else if (isFnc(ease)) {
      const easing = easingToLinear(ease);
      if (easing) parsedEase = easing;
    } else if (/** @type {Spring} */(ease).ease) {
      parsedEase = easingToLinear(/** @type {Spring} */(ease).ease);
    }
    return parsedEase;
  };

  const transformsShorthands = ['x', 'y', 'z'];
  const commonDefaultPXProperties = [
    'perspective',
    'width',
    'height',
    'margin',
    'padding',
    'top',
    'right',
    'bottom',
    'left',
    'borderWidth',
    'fontSize',
    'borderRadius',
    ...transformsShorthands
  ];

  const validIndividualTransforms = /*#__PURE__*/ (() => [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))])();

  let transformsPropertiesRegistered = null;

  /**
   * @param  {String} propName
   * @param  {WAAPIKeyframeValue} value
   * @param  {DOMTarget} $el
   * @param  {Number} i
   * @param  {Number} targetsLength
   * @return {String}
   */
  const normalizeTweenValue = (propName, value, $el, i, targetsLength) => {
    // Do not try to compute strings with getFunctionValue otherwise it will convert CSS variables
    let v = isStr(value) ? value : getFunctionValue(/** @type {any} */(value), $el, i, targetsLength);
    if (!isNum(v)) return v;
    if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate')) return `${v}px`;
    if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew')) return `${v}deg`;
    return `${v}`;
  };

  /**
   * @param  {DOMTarget} $el
   * @param  {String} propName
   * @param  {WAAPIKeyframeValue} from
   * @param  {WAAPIKeyframeValue} to
   * @param  {Number} i
   * @param  {Number} targetsLength
   * @return {WAAPITweenValue}
   */
  const parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {
    /** @type {WAAPITweenValue} */
    let tweenValue = '0';
    const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];
    if (!isUnd(from)) {
      const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);
      tweenValue = [computedFrom, computedTo];
    } else {
      tweenValue = isArr(to) ? to.map((/** @type {any} */v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;
    }
    return tweenValue;
  };

  class WAAPIAnimation {
  /**
   * @param {DOMTargetsParam} targets
   * @param {WAAPIAnimationParams} params
   */
    constructor(targets, params) {

      if (scope.current) scope.current.register(this);

      // Skip the registration and fallback to no animation in case CSS.registerProperty is not supported
      if (isNil(transformsPropertiesRegistered)) {
        if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'))) {
          transformsPropertiesRegistered = false;
        } else {
          validTransforms.forEach(t => {
            const isSkew = stringStartsWith(t, 'skew');
            const isScale = stringStartsWith(t, 'scale');
            const isRotate = stringStartsWith(t, 'rotate');
            const isTranslate = stringStartsWith(t, 'translate');
            const isAngle = isRotate || isSkew;
            const syntax = isAngle ? '<angle>' : isScale ? "<number>" : isTranslate ? "<length-percentage>" : "*";
            try {
              CSS.registerProperty({
                name: '--' + t,
                syntax,
                inherits: false,
                initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0',
              });
            } catch {}        });
          transformsPropertiesRegistered = true;
        }
      }

      const parsedTargets = registerTargets(targets);
      const targetsLength = parsedTargets.length;

      if (!targetsLength) {
        console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
      }

      const autoplay = setValue(params.autoplay, globals.defaults.autoplay);
      const scroll = autoplay && /** @type {ScrollObserver} */(autoplay).link ? autoplay : false;
      const alternate = params.alternate && /** @type {Boolean} */(params.alternate) === true;
      const reversed = params.reversed && /** @type {Boolean} */(params.reversed) === true;
      const loop = setValue(params.loop, globals.defaults.loop);
      const iterations = /** @type {Number} */((loop === true || loop === Infinity) ? Infinity : isNum(loop) ? loop + 1 : 1);
      /** @type {PlaybackDirection} */
      const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';
      /** @type {FillMode} */
      const fill = 'both'; // We use 'both' here because the animation can be reversed during playback
      const timeScale = (globals.timeScale === 1 ? 1 : K);

      /** @type {DOMTargetsArray}] */
      this.targets = parsedTargets;
      /** @type {Array<globalThis.Animation>}] */
      this.animations = [];
      /** @type {globalThis.Animation}] */
      this.controlAnimation = null;
      /** @type {Callback<this>} */
      this.onComplete = params.onComplete || /** @type {Callback<WAAPIAnimation>} */(/** @type {unknown} */(globals.defaults.onComplete));
      /** @type {Number} */
      this.duration = 0;
      /** @type {Boolean} */
      this.muteCallbacks = false;
      /** @type {Boolean} */
      this.completed = false;
      /** @type {Boolean} */
      this.paused = !autoplay || scroll !== false;
      /** @type {Boolean} */
      this.reversed = reversed;
      /** @type {Boolean} */
      this.persist = setValue(params.persist, globals.defaults.persist);
      /** @type {Boolean|ScrollObserver} */
      this.autoplay = autoplay;
      /** @type {Number} */
      this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);
      /** @type {Function} */
      this._resolve = noop; // Used by .then()
      /** @type {Number} */
      this._completed = 0;
      /** @type {Array.<Object>} */
      this._inlineStyles = [];

      parsedTargets.forEach(($el, i) => {

        const cachedTransforms = $el[transformsSymbol];
        const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));
        const elStyle = $el.style;
        const inlineStyles = this._inlineStyles[i] = {};

        const easeToParse = setValue(params.ease, globals.defaults.ease);

        const easeFunctionResult = getFunctionValue(easeToParse, $el, i, targetsLength);
        const keyEasing = isFnc(easeFunctionResult) || isStr(easeFunctionResult) ? easeFunctionResult : easeToParse;

        const spring = /** @type {Spring} */(easeToParse).ease && easeToParse;
        /** @type {String} */
        const easing = parseWAAPIEasing(keyEasing);

        /** @type {Number} */
        const duration = (spring ? /** @type {Spring} */(spring).settlingDuration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;
        /** @type {Number} */
        const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;
        /** @type {CompositeOperation} */
        const composite = /** @type {CompositeOperation} */(setValue(params.composition, 'replace'));

        for (let name in params) {
          if (!isKey(name)) continue;
          /** @type {PropertyIndexedKeyframes} */
          const keyframes = {};
          /** @type {KeyframeAnimationOptions} */
          const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };
          const propertyValue = params[name];
          const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;

          const styleName = individualTransformProperty ? 'transform' : name;
          if (!inlineStyles[styleName]) {
            inlineStyles[styleName] = elStyle[styleName];
          }

          let parsedPropertyValue;
          if (isObj(propertyValue)) {
            const tweenOptions = /** @type {WAAPITweenOptions} */(propertyValue);
            const tweenOptionsEase = setValue(tweenOptions.ease, easing);
            const tweenOptionsSpring = /** @type {Spring} */(tweenOptionsEase).ease && tweenOptionsEase;
            const to = /** @type {WAAPITweenOptions} */(tweenOptions).to;
            const from = /** @type {WAAPITweenOptions} */(tweenOptions).from;
            /** @type {Number} */
            tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */(tweenOptionsSpring).settlingDuration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;
            /** @type {Number} */
            tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;
            /** @type {CompositeOperation} */
            tweenParams.composite = /** @type {CompositeOperation} */(setValue(tweenOptions.composition, composite));
            /** @type {String} */
            tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);
            parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
            if (individualTransformProperty) {
              keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
              cachedTransforms[individualTransformProperty] = parsedPropertyValue;
            } else {
              keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
            }
            addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
            if (!isUnd(from)) {
              if (!individualTransformProperty) {
                elStyle[name] = keyframes[name][0];
              } else {
                const key = `--${individualTransformProperty}`;
                elStyle.setProperty(key, keyframes[key][0]);
              }
            }
          } else {
            parsedPropertyValue = isArr(propertyValue) ?
                                  propertyValue.map((/** @type {any} */v) => normalizeTweenValue(name, v, $el, i, targetsLength)) :
                                  normalizeTweenValue(name, /** @type {any} */(propertyValue), $el, i, targetsLength);
            if (individualTransformProperty) {
              keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
              cachedTransforms[individualTransformProperty] = parsedPropertyValue;
            } else {
              keyframes[name] = parsedPropertyValue;
            }
            addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
          }
        }
        if (hasIndividualTransforms) {
          let transforms = emptyString;
          for (let t in cachedTransforms) {
            transforms += `${transformsFragmentStrings[t]}var(--${t})) `;
          }
          elStyle.transform = transforms;
        }
      });

      if (scroll) {
        /** @type {ScrollObserver} */(this.autoplay).link(this);
      }
    }

    /**
     * @callback forEachCallback
     * @param {globalThis.Animation} animation
     */

    /**
     * @param  {forEachCallback|String} callback
     * @return {this}
     */
    forEach(callback) {
      try {
        const cb = isStr(callback) ? (/** @type {globalThis.Animation} */a) => a[callback]() : callback;
        this.animations.forEach(cb);
      } catch {}    return this;
    }

    get speed() {
      return this._speed;
    }

    set speed(speed) {
      this._speed = +speed;
      this.forEach(anim => anim.playbackRate = speed);
    }

    get currentTime() {
      const controlAnimation = this.controlAnimation;
      const timeScale = globals.timeScale;
      return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;
    }

    set currentTime(time) {
      const t = time * (globals.timeScale === 1 ? 1 : K);
      this.forEach(anim => {
        // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.
        // The "paused" play state supersedes the "finished" play state; if the animation is both paused and finished, the "paused" state is the one that will be reported.
        // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event
        // This is not needed for persisting animations since they never finish.
        if (!this.persist && t >= this.duration) anim.play();
        anim.currentTime = t;
      });
    }

    get progress() {
      return this.currentTime / this.duration;
    }

    set progress(progress) {
      this.forEach(anim => anim.currentTime = progress * this.duration || 0);
    }

    resume() {
      if (!this.paused) return this;
      this.paused = false;
      // TODO: Store the current time, and seek back to the last position
      return this.forEach('play');
    }

    pause() {
      if (this.paused) return this;
      this.paused = true;
      return this.forEach('pause');
    }

    alternate() {
      this.reversed = !this.reversed;
      this.forEach('reverse');
      if (this.paused) this.forEach('pause');
      return this;
    }

    play() {
      if (this.reversed) this.alternate();
      return this.resume();
    }

    reverse() {
      if (!this.reversed) this.alternate();
      return this.resume();
    }

   /**
    * @param {Number} time
    * @param {Boolean} muteCallbacks
    */
    seek(time, muteCallbacks = false) {
      if (muteCallbacks) this.muteCallbacks = true;
      if (time < this.duration) this.completed = false;
      this.currentTime = time;
      this.muteCallbacks = false;
      if (this.paused) this.pause();
      return this;
    }

    restart() {
      this.completed = false;
      return this.seek(0, true).resume();
    }

    commitStyles() {
      return this.forEach('commitStyles');
    }

    complete() {
      return this.seek(this.duration);
    }

    cancel() {
      this.muteCallbacks = true; // This prevents triggering the onComplete callback and resolving the Promise
      this.commitStyles().forEach('cancel');
      this.animations.length = 0; // Needed to release all animations from memory
      requestAnimationFrame(() => {
        this.targets.forEach(($el) => { // Needed to avoid unecessary inline transorms
          if ($el.style.transform === 'none') $el.style.removeProperty('transform');
        });
      });
      return this;
    }

    revert() {
      // NOTE: We need a better way to revert the transforms, since right now the entire transform property value is reverted,
      // This means if you have multiple animations animating different transforms on the same target,
      // reverting one of them will also override the transform property of the other animations.
      // A better approach would be to store the original custom property values if they exist instead of the entire transform value,
      // and update the CSS variables with the orignal value
      this.cancel().targets.forEach(($el, i) => {
        const targetStyle = $el.style;
        const targetInlineStyles = this._inlineStyles[i];
        for (let name in targetInlineStyles) {
          const originalInlinedValue = targetInlineStyles[name];
          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
            targetStyle.removeProperty(toLowerCase(name));
          } else {
            $el.style[name] = originalInlinedValue;
          }
        }
        // Remove style attribute if empty
        if ($el.getAttribute('style') === emptyString) $el.removeAttribute('style');
      });
      return this;
    }

    /**
     * @typedef {this & {then: null}} ResolvedWAAPIAnimation
     */

    /**
     * @param  {Callback<ResolvedWAAPIAnimation>} [callback]
     * @return Promise<this>
     */
    then(callback = noop) {
      const then = this.then;
      const onResolve = () => {
        this.then = null;
        callback(/** @type {ResolvedWAAPIAnimation} */(this));
        this.then = then;
        this._resolve = noop;
      };
      return new Promise(r => {
        this._resolve = () => r(onResolve());
        if (this.completed) this._resolve();
        return this;
      });
    }
  }

  const waapi = {
  /**
   * @param {DOMTargetsParam} targets
   * @param {WAAPIAnimationParams} params
   * @return {WAAPIAnimation}
   */
    animate: (targets, params) => new WAAPIAnimation(targets, params),
    convertEase: easingToLinear
  };

  

  

  

  

  

  /**
   * @typedef {DOMTargetSelector|Array<DOMTargetSelector>} LayoutChildrenParam
   */

  /**
   * @typedef {Object} LayoutAnimationTimingsParams
   * @property {Number|FunctionValue} [delay]
   * @property {Number|FunctionValue} [duration]
   * @property {EasingParam|FunctionValue} [ease]
   */

  /**
   * @typedef {Record<String, Number|String|FunctionValue>} LayoutStateAnimationProperties
   */

  /**
   * @typedef {LayoutStateAnimationProperties & LayoutAnimationTimingsParams} LayoutStateParams
   */

  /**
   * @typedef {Object} LayoutSpecificAnimationParams
   * @property {Number|FunctionValue} [delay]
   * @property {Number|FunctionValue} [duration]
   * @property {EasingParam|FunctionValue} [ease]
   * @property {EasingParam} [playbackEase]
   * @property {LayoutStateParams} [swapAt]
   * @property {LayoutStateParams} [enterFrom]
   * @property {LayoutStateParams} [leaveTo]
   */

  /**
   * @typedef {LayoutSpecificAnimationParams & TimerParams & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} LayoutAnimationParams
   */

  /**
   * @typedef {Object} LayoutOptions
   * @property {LayoutChildrenParam} [children]
   * @property {Array<String>} [properties]
   */

  /**
   * @typedef {LayoutAnimationParams & LayoutOptions} AutoLayoutParams
   */

  /**
   * @typedef {Record<String, Number|String|FunctionValue> & {
   *   transform: String,
   *   x: Number,
   *   y: Number,
   *   left: Number,
   *   top: Number,
   *   clientLeft: Number,
   *   clientTop: Number,
   *   width: Number,
   *   height: Number,
   * }} LayoutNodeProperties
   */

  /**
   * @typedef {Object} LayoutNode
   * @property {String} id
   * @property {DOMTarget} $el
   * @property {Number} index
   * @property {Number} total
   * @property {Number} delay
   * @property {Number} duration
   * @property {EasingParam} ease
   * @property {DOMTarget} $measure
   * @property {LayoutSnapshot} state
   * @property {AutoLayout} layout
   * @property {LayoutNode|null} parentNode
   * @property {Boolean} isTarget
   * @property {Boolean} isEntering
   * @property {Boolean} isLeaving
   * @property {Boolean} hasTransform
   * @property {Array<String>} inlineStyles
   * @property {String|null} inlineTransforms
   * @property {String|null} inlineTransition
   * @property {Boolean} branchAdded
   * @property {Boolean} branchRemoved
   * @property {Boolean} branchNotRendered
   * @property {Boolean} sizeChanged
   * @property {Boolean} isInlined
   * @property {Boolean} hasVisibilitySwap
   * @property {Boolean} hasDisplayNone
   * @property {Boolean} hasVisibilityHidden
   * @property {String|null} measuredInlineTransform
   * @property {String|null} measuredInlineTransition
   * @property {String|null} measuredDisplay
   * @property {String|null} measuredVisibility
   * @property {String|null} measuredPosition
   * @property {Boolean} measuredHasDisplayNone
   * @property {Boolean} measuredHasVisibilityHidden
   * @property {Boolean} measuredIsVisible
   * @property {Boolean} measuredIsRemoved
   * @property {Boolean} measuredIsInsideRoot
   * @property {LayoutNodeProperties} properties
   * @property {LayoutNode|null} _head
   * @property {LayoutNode|null} _tail
   * @property {LayoutNode|null} _prev
   * @property {LayoutNode|null} _next
   */

  /**
   * @callback LayoutNodeIterator
   * @param {LayoutNode} node
   * @param {Number} index
   * @return {void}
   */

  let layoutId = 0;
  let nodeId = 0;

  /**
   * @param {DOMTarget} root
   * @param {DOMTarget} $el
   * @return {Boolean}
   */
  const isElementInRoot = (root, $el) => {
    if (!root || !$el) return false;
    return root === $el || root.contains($el);
  };

  /**
   * @param {Node} node
   * @param {'previousSibling'|'nextSibling'} direction
   * @return {Boolean}
   */
  const hasTextSibling = (node, direction) => {
    let sibling = node[direction];
    while (sibling && sibling.nodeType === Node.TEXT_NODE && !sibling.textContent.trim()) {
      sibling = sibling[direction];
    }
    return sibling && sibling.nodeType === Node.TEXT_NODE;
  };

  /**
   * @param {DOMTarget} $el
   * @return {Boolean}
   */
  const isElementSurroundedByText = $el => hasTextSibling($el, 'previousSibling') || hasTextSibling($el, 'nextSibling');

  /**
   * @param {DOMTarget|null} $el
   * @return {String|null}
   */
  const muteElementTransition = $el => {
    if (!$el) return null;
    const style = $el.style;
    const transition = style.transition || '';
    style.setProperty('transition', 'none', 'important');
    return transition;
  };

  /**
   * @param {DOMTarget|null} $el
   * @param {String|null} transition
   */
  const restoreElementTransition = ($el, transition) => {
    if (!$el) return;
    const style = $el.style;
    if (transition) {
      style.transition = transition;
    } else {
      style.removeProperty('transition');
    }
  };

  /**
   * @param {LayoutNode} node
   */
  const muteNodeTransition = node => {
    const store = node.layout.transitionMuteStore;
    const $el = node.$el;
    const $measure = node.$measure;
    if ($el && !store.has($el)) store.set($el, muteElementTransition($el));
    if ($measure && !store.has($measure)) store.set($measure, muteElementTransition($measure));
  };

  /**
   * @param {Map<DOMTarget, String|null>} store
   */
  const restoreLayoutTransition = store => {
    store.forEach((value, $el) => restoreElementTransition($el, value));
    store.clear();
  };

  const hiddenComputedStyle = /** @type {CSSStyleDeclaration} */({
    display: 'none',
    visibility: 'hidden',
    opacity: '0',
    transform: 'none',
    position: 'static',
  });

  /**
   * @param {LayoutNode|null} node
   */
  const detachNode = node => {
    if (!node) return;
    const parent = node.parentNode;
    if (!parent) return;
    if (parent._head === node) parent._head = node._next;
    if (parent._tail === node) parent._tail = node._prev;
    if (node._prev) node._prev._next = node._next;
    if (node._next) node._next._prev = node._prev;
    node._prev = null;
    node._next = null;
    node.parentNode = null;
  };

  /**
   * @param {DOMTarget} $el
   * @param {LayoutNode|null} parentNode
   * @param {LayoutSnapshot} state
   * @param {LayoutNode} recycledNode
   * @return {LayoutNode}
   */
  const createNode = ($el, parentNode, state, recycledNode) => {
    let dataId = $el.dataset.layoutId;
    if (!dataId) dataId = $el.dataset.layoutId = `node-${nodeId++}`;
    const node = recycledNode ? recycledNode : /** @type {LayoutNode} */({});
    node.$el = $el;
    node.$measure = $el;
    node.id = dataId;
    node.index = 0;
    node.total = 1;
    node.delay = 0;
    node.duration = 0;
    node.ease = null;
    node.state = state;
    node.layout = state.layout;
    node.parentNode = parentNode || null;
    node.isTarget = false;
    node.isEntering = false;
    node.isLeaving = false;
    node.isInlined = false;
    node.hasTransform = false;
    node.inlineStyles = [];
    node.inlineTransforms = null;
    node.inlineTransition = null;
    node.branchAdded = false;
    node.branchRemoved = false;
    node.branchNotRendered = false;
    node.sizeChanged = false;
    node.hasVisibilitySwap = false;
    node.hasDisplayNone = false;
    node.hasVisibilityHidden = false;
    node.measuredInlineTransform = null;
    node.measuredInlineTransition = null;
    node.measuredDisplay = null;
    node.measuredVisibility = null;
    node.measuredPosition = null;
    node.measuredHasDisplayNone = false;
    node.measuredHasVisibilityHidden = false;
    node.measuredIsVisible = false;
    node.measuredIsRemoved = false;
    node.measuredIsInsideRoot = false;
    node.properties = /** @type {LayoutNodeProperties} */({
      transform: 'none',
      x: 0,
      y: 0,
      left: 0,
      top: 0,
      clientLeft: 0,
      clientTop: 0,
      width: 0,
      height: 0,
    });
    node.layout.properties.forEach(prop => node.properties[prop] = 0);
    node._head = null;
    node._tail = null;
    node._prev = null;
    node._next = null;
    return node;
  };

  /**
   * @param {LayoutNode} node
   * @param {DOMTarget} $measure
   * @param {CSSStyleDeclaration} computedStyle
   * @param {Boolean} skipMeasurements
   * @return {LayoutNode}
   */
  const recordNodeState = (node, $measure, computedStyle, skipMeasurements) => {
    const $el = node.$el;
    const root = node.layout.root;
    const isRoot = root === $el;
    const properties = node.properties;
    const rootNode = node.state.rootNode;
    const parentNode = node.parentNode;
    const computedTransforms = computedStyle.transform;
    const inlineTransforms = $el.style.transform;
    const parentNotRendered = parentNode ? parentNode.measuredIsRemoved : false;
    const position = computedStyle.position;
    if (isRoot) node.layout.absoluteCoords = position === 'fixed' || position === 'absolute';
    node.$measure = $measure;
    node.inlineTransforms = inlineTransforms;
    node.hasTransform = computedTransforms && computedTransforms !== 'none';
    node.measuredIsInsideRoot = isElementInRoot(root, $measure);
    node.measuredInlineTransform = null;
    node.measuredDisplay = computedStyle.display;
    node.measuredVisibility = computedStyle.visibility;
    node.measuredPosition = position;
    node.measuredHasDisplayNone = computedStyle.display === 'none';
    node.measuredHasVisibilityHidden = computedStyle.visibility === 'hidden';
    node.measuredIsVisible = !(node.measuredHasDisplayNone || node.measuredHasVisibilityHidden);
    node.measuredIsRemoved = node.measuredHasDisplayNone || node.measuredHasVisibilityHidden || parentNotRendered;
    node.isInlined = node.measuredDisplay.includes('inline') && isElementSurroundedByText($el);

    // Mute transforms (and transition to avoid triggering an animation) before the position calculation
    if (node.hasTransform && !skipMeasurements) {
      const transitionMuteStore = node.layout.transitionMuteStore;
      if (!transitionMuteStore.get($el)) node.inlineTransition = muteElementTransition($el);
      if ($measure === $el) {
        $el.style.transform = 'none';
      } else {
        if (!transitionMuteStore.get($measure)) node.measuredInlineTransition = muteElementTransition($measure);
        node.measuredInlineTransform = $measure.style.transform;
        $measure.style.transform = 'none';
      }
    }

    let left = 0;
    let top = 0;
    let width = 0;
    let height = 0;

    if (!skipMeasurements) {
      const rect = $measure.getBoundingClientRect();
      left = rect.left;
      top = rect.top;
      width = rect.width;
      height = rect.height;
    }

    for (let name in properties) {
      const computedProp = name === 'transform' ? computedTransforms : computedStyle[name] || (computedStyle.getPropertyValue && computedStyle.getPropertyValue(name));
      if (!isUnd(computedProp)) properties[name] = computedProp;
    }

    properties.left = left;
    properties.top = top;
    properties.clientLeft = skipMeasurements ? 0 : $measure.clientLeft;
    properties.clientTop = skipMeasurements ? 0 : $measure.clientTop;
    // Compute local x/y relative to parent
    let absoluteLeft, absoluteTop;
    if (isRoot) {
      if (!node.layout.absoluteCoords) {
        absoluteLeft = 0;
        absoluteTop = 0;
      } else {
        absoluteLeft = left;
        absoluteTop = top;
      }
    } else {
      const p = parentNode || rootNode;
      const parentLeft = p.properties.left;
      const parentTop = p.properties.top;
      const borderLeft = p.properties.clientLeft;
      const borderTop = p.properties.clientTop;
      if (!node.layout.absoluteCoords) {
        if (p === rootNode) {
          const rootLeft = rootNode.properties.left;
          const rootTop = rootNode.properties.top;
          const rootBorderLeft = rootNode.properties.clientLeft;
          const rootBorderTop = rootNode.properties.clientTop;
          absoluteLeft = left - rootLeft - rootBorderLeft;
          absoluteTop = top - rootTop - rootBorderTop;
        } else {
          absoluteLeft = left - parentLeft - borderLeft;
          absoluteTop = top - parentTop - borderTop;
        }
      } else {
        absoluteLeft = left - parentLeft - borderLeft;
        absoluteTop = top - parentTop - borderTop;
      }
    }
    properties.x = absoluteLeft;
    properties.y = absoluteTop;
    properties.width = width;
    properties.height = height;
    return node;
  };

  /**
   * @param {LayoutNode} node
   * @param {LayoutStateAnimationProperties} [props]
   */
  const updateNodeProperties = (node, props) => {
    if (!props) return;
    for (let name in props) {
      node.properties[name] = props[name];
    }
  };

  /**
   * @param  {LayoutNode} node
   * @param  {LayoutAnimationTimingsParams} params
   */
  const updateNodeTimingParams = (node, params) => {
    const easeFunctionResult = getFunctionValue(params.ease, node.$el, node.index, node.total);
    const keyEasing = isFnc(easeFunctionResult) ? easeFunctionResult : params.ease;
    const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);
    node.ease = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing;
    node.duration = hasSpring ? /** @type {Spring} */(keyEasing).settlingDuration : getFunctionValue(params.duration, node.$el, node.index, node.total);
    node.delay = getFunctionValue(params.delay, node.$el, node.index, node.total);
  };

  /**
   * @param {LayoutNode} node
   */
  const recordNodeInlineStyles = node => {
    const style = node.$el.style;
    const stylesStore = node.inlineStyles;
    stylesStore.length = 0;
    node.layout.recordedProperties.forEach(prop => {
      stylesStore.push(prop, style[prop] || '');
    });
  };

  /**
   * @param {LayoutNode} node
   */
  const restoreNodeInlineStyles = node => {
    const style = node.$el.style;
    const stylesStore = node.inlineStyles;
    for (let i = 0, l = stylesStore.length; i < l; i += 2) {
      const property = stylesStore[i];
      const styleValue = stylesStore[i + 1];
      if (styleValue && styleValue !== '') {
        style[property] = styleValue;
      } else {
        style[property] = '';
        style.removeProperty(property);
      }
    }
  };

  /**
   * @param {LayoutNode} node
   */
  const restoreNodeTransform = node => {
    const inlineTransforms = node.inlineTransforms;
    const nodeStyle = node.$el.style;
    if (!node.hasTransform || !inlineTransforms || (node.hasTransform && nodeStyle.transform === 'none') || (inlineTransforms && inlineTransforms === 'none')) {
      nodeStyle.removeProperty('transform');
    } else if (inlineTransforms) {
      nodeStyle.transform = inlineTransforms;
    }
    const $measure = node.$measure;
    if (node.hasTransform && $measure !== node.$el) {
      const measuredStyle = $measure.style;
      const measuredInline = node.measuredInlineTransform;
      if (measuredInline && measuredInline !== '') {
        measuredStyle.transform = measuredInline;
      } else {
        measuredStyle.removeProperty('transform');
      }
    }
    node.measuredInlineTransform = null;
    if (node.inlineTransition !== null) {
      restoreElementTransition(node.$el, node.inlineTransition);
      node.inlineTransition = null;
    }
    if ($measure !== node.$el && node.measuredInlineTransition !== null) {
      restoreElementTransition($measure, node.measuredInlineTransition);
      node.measuredInlineTransition = null;
    }
  };

  /**
   * @param {LayoutNode} node
   */
  const restoreNodeVisualState = node => {
    if (node.measuredIsRemoved || node.hasVisibilitySwap) {
      node.$el.style.removeProperty('display');
      node.$el.style.removeProperty('visibility');
      if (node.hasVisibilitySwap) {
        node.$measure.style.removeProperty('display');
        node.$measure.style.removeProperty('visibility');
      }
    }
    // if (node.measuredIsRemoved) {
    node.layout.pendingRemoval.delete(node.$el);
    // }
  };

  /**
   * @param {LayoutNode} node
   * @param {LayoutNode} targetNode
   * @param {LayoutSnapshot} newState
   * @return {LayoutNode}
   */
  const cloneNodeProperties = (node, targetNode, newState) => {
    targetNode.properties = /** @type {LayoutNodeProperties} */({ ...node.properties });
    targetNode.state = newState;
    targetNode.isTarget = node.isTarget;
    targetNode.hasTransform = node.hasTransform;
    targetNode.inlineTransforms = node.inlineTransforms;
    targetNode.measuredIsVisible = node.measuredIsVisible;
    targetNode.measuredDisplay = node.measuredDisplay;
    targetNode.measuredIsRemoved = node.measuredIsRemoved;
    targetNode.measuredHasDisplayNone = node.measuredHasDisplayNone;
    targetNode.measuredHasVisibilityHidden = node.measuredHasVisibilityHidden;
    targetNode.hasDisplayNone = node.hasDisplayNone;
    targetNode.isInlined = node.isInlined;
    targetNode.hasVisibilityHidden = node.hasVisibilityHidden;
    return targetNode;
  };

  class LayoutSnapshot {
    /**
     * @param {AutoLayout} layout
     */
    constructor(layout) {
      /** @type {AutoLayout} */
      this.layout = layout;
      /** @type {LayoutNode|null} */
      this.rootNode = null;
      /** @type {Set<LayoutNode>} */
      this.rootNodes = new Set();
      /** @type {Map<String, LayoutNode>} */
      this.nodes = new Map();
      /** @type {Number} */
      this.scrollX = 0;
      /** @type {Number} */
      this.scrollY = 0;
    }

    /**
     * @return {this}
     */
    revert() {
      this.forEachNode(node => {
        this.layout.pendingRemoval.delete(node.$el);
        node.$el.removeAttribute('data-layout-id');
        node.$measure.removeAttribute('data-layout-id');
      });
      this.rootNode = null;
      this.rootNodes.clear();
      this.nodes.clear();
      return this;
    }

    /**
     * @param {DOMTarget} $el
     * @return {LayoutNode}
     */
    getNode($el) {
      if (!$el || !$el.dataset) return;
      return this.nodes.get($el.dataset.layoutId);
    }

    /**
     * @param {DOMTarget} $el
     * @param {String} prop
     * @return {Number|String}
     */
    getComputedValue($el, prop) {
      const node = this.getNode($el);
      if (!node) return;
      return /** @type {Number|String} */(node.properties[prop]);
    }

    /**
     * @param {LayoutNode|null} rootNode
     * @param {LayoutNodeIterator} cb
     */
    forEach(rootNode, cb) {
      let node = rootNode;
      let i = 0;
      while (node) {
        cb(node, i++);
        if (node._head) {
          node = node._head;
        } else if (node._next) {
          node = node._next;
        } else {
          while (node && !node._next) {
            node = node.parentNode;
          }
          if (node) node = node._next;
        }
      }
    }

    /**
     * @param {LayoutNodeIterator} cb
     */
    forEachRootNode(cb) {
      this.forEach(this.rootNode, cb);
    }

    /**
     * @param {LayoutNodeIterator} cb
     */
    forEachNode(cb) {
      for (const rootNode of this.rootNodes) {
        this.forEach(rootNode, cb);
      }
    }

    /**
     * @param {DOMTarget} $el
     * @param {LayoutNode|null} parentNode
     * @return {LayoutNode|null}
     */
    registerElement($el, parentNode) {
      if (!$el || $el.nodeType !== 1) return null;

      if (!this.layout.transitionMuteStore.has($el)) this.layout.transitionMuteStore.set($el, muteElementTransition($el));

      /** @type {Array<DOMTarget|LayoutNode|null>} */
      const stack = [$el, parentNode];
      const root = this.layout.root;
      let firstNode = null;

      while (stack.length) {
        /** @type {LayoutNode|null} */
        const $parent = /** @type {LayoutNode|null} */(stack.pop());
        /** @type {DOMTarget|null} */
        const $current = /** @type {DOMTarget|null} */(stack.pop());

        if (!$current || $current.nodeType !== 1 || isSvg($current)) continue;

        const skipMeasurements = $parent ? $parent.measuredIsRemoved : false;
        const computedStyle = skipMeasurements ? hiddenComputedStyle : getComputedStyle($current);
        const hasDisplayNone = skipMeasurements ? true : computedStyle.display === 'none';
        const hasVisibilityHidden = skipMeasurements ? true : computedStyle.visibility === 'hidden';
        const isVisible = !hasDisplayNone && !hasVisibilityHidden;
        const existingId = $current.dataset.layoutId;
        const isInsideRoot = isElementInRoot(root, $current);

        let node = existingId ? this.nodes.get(existingId) : null;

        if (node && node.$el !== $current) {
          const nodeInsideRoot = isElementInRoot(root, node.$el);
          const measuredVisible = node.measuredIsVisible;
          const shouldReassignNode = !nodeInsideRoot && (isInsideRoot || (!isInsideRoot && !measuredVisible && isVisible));
          const shouldReuseMeasurements = nodeInsideRoot && !measuredVisible && isVisible;
          // Rebind nodes that move into the root or whose detached twin just became visible
          if (shouldReassignNode) {
            detachNode(node);
            node = createNode($current, $parent, this, node);
          // for hidden element with in-root sibling, keep the hidden node but borrow measurements from its visible in-root twin element
          } else if (shouldReuseMeasurements) {
            recordNodeState(node, $current, computedStyle, skipMeasurements);
            let $child = $current.lastElementChild;
            while ($child) {
              stack.push(/** @type {DOMTarget} */($child), node);
              $child = $child.previousElementSibling;
            }
            if (!firstNode) firstNode = node;
            continue;
          // No reassignment needed so keep walking descendants under the current parent
          } else {
            let $child = $current.lastElementChild;
            while ($child) {
              stack.push(/** @type {DOMTarget} */($child), $parent);
              $child = $child.previousElementSibling;
            }
            if (!firstNode) firstNode = node;
            continue;
          }
        } else {
          node = createNode($current, $parent, this, node);
        }

        node.branchAdded = false;
        node.branchRemoved = false;
        node.branchNotRendered = false;
        node.isTarget = false;
        node.sizeChanged = false;
        node.hasVisibilityHidden = hasVisibilityHidden;
        node.hasDisplayNone = hasDisplayNone;
        node.hasVisibilitySwap = (hasVisibilityHidden && !node.measuredHasVisibilityHidden) || (hasDisplayNone && !node.measuredHasDisplayNone);

        this.nodes.set(node.id, node);

        node.parentNode = $parent || null;
        node._prev = null;
        node._next = null;

        if ($parent) {
          this.rootNodes.delete(node);
          if (!$parent._head) {
            $parent._head = node;
            $parent._tail = node;
          } else {
            $parent._tail._next = node;
            node._prev = $parent._tail;
            $parent._tail = node;
          }
        } else {
          // Each disconnected subtree becomes its own root in the snapshot graph
          this.rootNodes.add(node);
        }

        recordNodeState(node, node.$el, computedStyle, skipMeasurements);

        let $child = $current.lastElementChild;
        while ($child) {
          stack.push(/** @type {DOMTarget} */($child), node);
          $child = $child.previousElementSibling;
        }

        if (!firstNode) firstNode = node;
      }

      return firstNode;
    }

    /**
     * @param {DOMTarget} $el
     * @param {Set<DOMTarget>} candidates
     * @return {LayoutNode|null}
     */
    ensureDetachedNode($el, candidates) {
      if (!$el || $el === this.layout.root) return null;
      const existingId = $el.dataset.layoutId;
      const existingNode = existingId ? this.nodes.get(existingId) : null;
      if (existingNode && existingNode.$el === $el) return existingNode;
      let parentNode = null;
      let $ancestor = $el.parentElement;
      while ($ancestor && $ancestor !== this.layout.root) {
        if (candidates.has($ancestor)) {
          parentNode = this.ensureDetachedNode($ancestor, candidates);
          break;
        }
        $ancestor = $ancestor.parentElement;
      }
      return this.registerElement($el, parentNode);
    }

    /**
     * @return {this}
     */
    record() {
      const layout = this.layout;
      const children = layout.children;
      const root = layout.root;
      const toParse = isArr(children) ? children : [children];
      const scoped = [];
      const scopeRoot = children === '*' ? root : scope.root;

      // Mute transition and transforms of root ancestors before recording the state

      /** @type {Array<DOMTarget|String|null>} */
      const rootAncestorTransformStore = [];
      let $ancestor = root.parentElement;
      while ($ancestor && $ancestor.nodeType === 1) {
        const computedStyle = getComputedStyle($ancestor);
        if (computedStyle.transform && computedStyle.transform !== 'none') {
          const inlineTransform = $ancestor.style.transform || '';
          const inlineTransition = muteElementTransition($ancestor);
          rootAncestorTransformStore.push($ancestor, inlineTransform, inlineTransition);
          $ancestor.style.transform = 'none';
        }
        $ancestor = $ancestor.parentElement;
      }

      for (let i = 0, l = toParse.length; i < l; i++) {
        const child = toParse[i];
        scoped[i] = isStr(child) ? scopeRoot.querySelectorAll(child) : child;
      }

      const parsedChildren = registerTargets(scoped);

      this.nodes.clear();
      this.rootNodes.clear();

      const rootNode = this.registerElement(root, null);
      // Root node are always targets
      rootNode.isTarget = true;
      this.rootNode = rootNode;

      const inRootNodeIds = new Set();
      // Update index and total for inital timing calculation
      let index = 0, total = this.nodes.size;
      this.nodes.forEach((node, id) => {
        node.index = index++;
        node.total = total;
        // Track ids of nodes that belong to the current root to filter detached matches
        if (node && node.measuredIsInsideRoot) {
          inRootNodeIds.add(id);
        }
      });

      // Elements with a layout id outside the root that match the children selector
      const detachedElementsLookup = new Set();
      const orderedDetachedElements = [];

      for (let i = 0, l = parsedChildren.length; i < l; i++) {
        const $el = parsedChildren[i];
        if (!$el || $el.nodeType !== 1 || $el === root) continue;
        const insideRoot = isElementInRoot(root, $el);
        if (!insideRoot) {
          const layoutNodeId = $el.dataset.layoutId;
          if (!layoutNodeId || !inRootNodeIds.has(layoutNodeId)) continue;
        }
        if (!detachedElementsLookup.has($el)) {
          detachedElementsLookup.add($el);
          orderedDetachedElements.push($el);
        }
      }

      for (let i = 0, l = orderedDetachedElements.length; i < l; i++) {
        this.ensureDetachedNode(orderedDetachedElements[i], detachedElementsLookup);
      }

      for (let i = 0, l = parsedChildren.length; i < l; i++) {
        const $el = parsedChildren[i];
        const node = this.getNode($el);
        if (node) {
          let cur = node;
          while (cur) {
            if (cur.isTarget) break;
            cur.isTarget = true;
            cur = cur.parentNode;
          }
        }
      }

      this.scrollX = window.scrollX;
      this.scrollY = window.scrollY;

      this.forEachNode(restoreNodeTransform);

      // Restore transition and transforms of root ancestors

      for (let i = 0, l = rootAncestorTransformStore.length; i < l; i += 3) {
        const $el = /** @type {DOMTarget} */(rootAncestorTransformStore[i]);
        const inlineTransform = /** @type {String} */(rootAncestorTransformStore[i + 1]);
        const inlineTransition = /** @type {String|null} */(rootAncestorTransformStore[i + 2]);
        if (inlineTransform && inlineTransform !== '') {
          $el.style.transform = inlineTransform;
        } else {
          $el.style.removeProperty('transform');
        }
        restoreElementTransition($el, inlineTransition);
      }

      return this;
    }
  }

  /**
   * @param  {LayoutStateParams} params
   * @return {[LayoutStateAnimationProperties, LayoutAnimationTimingsParams]}
   */
  function splitPropertiesFromParams(params) {
    /** @type {LayoutStateAnimationProperties} */
    const properties = {};
    /** @type {LayoutAnimationTimingsParams} */
    const parameters = {};
    for (let name in params) {
      const value = params[name];
      const isEase = name === 'ease';
      const isTiming = name === 'duration' || name === 'delay';
      if (isTiming || isEase) {
        if (isEase) {
          parameters[name] = /** @type {EasingParam} */(value);
        } else {
          parameters[name] = /** @type {Number|FunctionValue} */(value);
        }
      } else {
        properties[name] = /** @type {Number|String} */(value);
      }
    }
    return [properties, parameters];
  }

  class AutoLayout {
    /**
     * @param {DOMTargetSelector} root
     * @param {AutoLayoutParams} [params]
     */
    constructor(root, params = {}) {
      if (scope.current) scope.current.register(this);
      const swapAtSplitParams = splitPropertiesFromParams(params.swapAt);
      const enterFromSplitParams = splitPropertiesFromParams(params.enterFrom);
      const leaveToSplitParams = splitPropertiesFromParams(params.leaveTo);
      const transitionProperties = params.properties;
      /** @type {Number|FunctionValue} */
      params.duration = setValue(params.duration, 350);
      /** @type {Number|FunctionValue} */
      params.delay = setValue(params.delay, 0);
      /** @type {EasingParam|FunctionValue} */
      params.ease = setValue(params.ease, 'inOut(3.5)');
      /** @type {AutoLayoutParams} */
      this.params = params;
      /** @type {DOMTarget} */
      this.root = /** @type {DOMTarget} */(registerTargets(root)[0]);
      /** @type {Number} */
      this.id = layoutId++;
      /** @type {LayoutChildrenParam} */
      this.children = params.children || '*';
      /** @type {Boolean} */
      this.absoluteCoords = false;
      /** @type {LayoutStateParams} */
      this.swapAtParams = mergeObjects(params.swapAt || { opacity: 0 }, { ease: 'inOut(1.75)' });
      /** @type {LayoutStateParams} */
      this.enterFromParams = params.enterFrom || { opacity: 0 };
      /** @type {LayoutStateParams} */
      this.leaveToParams = params.leaveTo || { opacity: 0 };
      /** @type {Set<String>} */
      this.properties = new Set([
        'opacity',
        'fontSize',
        'color',
        'backgroundColor',
        'borderRadius',
        'border',
        'filter',
        'clipPath',
      ]);
      if (swapAtSplitParams[0]) for (let name in swapAtSplitParams[0]) this.properties.add(name);
      if (enterFromSplitParams[0]) for (let name in enterFromSplitParams[0]) this.properties.add(name);
      if (leaveToSplitParams[0]) for (let name in leaveToSplitParams[0]) this.properties.add(name);
      if (transitionProperties) for (let i = 0, l = transitionProperties.length; i < l; i++) this.properties.add(transitionProperties[i]);
      /** @type {Set<String>} */
      this.recordedProperties = new Set([
        'display',
        'visibility',
        'translate',
        'position',
        'left',
        'top',
        'marginLeft',
        'marginTop',
        'width',
        'height',
        'maxWidth',
        'maxHeight',
        'minWidth',
        'minHeight',
      ]);
      this.properties.forEach(prop => this.recordedProperties.add(prop));
      /** @type {WeakSet<DOMTarget>} */
      this.pendingRemoval = new WeakSet();
      /** @type {Map<DOMTarget, String|null>} */
      this.transitionMuteStore = new Map();
      /** @type {LayoutSnapshot} */
      this.oldState = new LayoutSnapshot(this);
      /** @type {LayoutSnapshot} */
      this.newState = new LayoutSnapshot(this);
      /** @type {Timeline} */
      this.timeline = null;
      /** @type {WAAPIAnimation} */
      this.transformAnimation = null;
      /** @type {Array<DOMTarget>} */
      this.animating = [];
      /** @type {Array<DOMTarget>} */
      this.swapping = [];
      /** @type {Array<DOMTarget>} */
      this.leaving = [];
      /** @type {Array<DOMTarget>} */
      this.entering = [];
      // Record the current state as the old state to init the data attributes and allow imediate .animate()
      this.oldState.record();
      // And all layout transition muted during the record
      restoreLayoutTransition(this.transitionMuteStore);
    }

    /**
     * @return {this}
     */
    revert() {
      this.root.classList.remove('is-animated');
      if (this.timeline) {
        this.timeline.complete();
        this.timeline = null;
      }
      if (this.transformAnimation) {
        this.transformAnimation.complete();
        this.transformAnimation = null;
      }
      this.animating.length = this.swapping.length = this.leaving.length = this.entering.length = 0;
      this.oldState.revert();
      this.newState.revert();
      requestAnimationFrame(() => restoreLayoutTransition(this.transitionMuteStore));
      return this;
    }

    /**
     * @return {this}
     */
    record() {
      // Commit transforms before measuring
      if (this.transformAnimation) {
        this.transformAnimation.cancel();
        this.transformAnimation = null;
      }
      // Record the old state
      this.oldState.record();
      // Cancel any running timeline
      if (this.timeline) {
        this.timeline.cancel();
        this.timeline = null;
      }
      // Restore previously captured inline styles
      this.newState.forEachRootNode(restoreNodeInlineStyles);
      return this;
    }

    /**
     * @param {LayoutAnimationParams} [params]
     * @return {Timeline}
     */
    animate(params = {}) {
      /** @type { LayoutAnimationTimingsParams } */
      const animationTimings = {
        ease: setValue(params.ease, this.params.ease),
        delay: setValue(params.delay, this.params.delay),
        duration: setValue(params.duration, this.params.duration),
      };
      /** @type {TimelineParams} */
      const tlParams = {};
      const onComplete = setValue(params.onComplete, this.params.onComplete);
      const onPause = setValue(params.onPause, this.params.onPause);
      for (let name in defaults) {
        if (name !== 'ease' && name !== 'duration' && name !== 'delay') {
          if (!isUnd(params[name])) {
            tlParams[name] = params[name];
          } else if (!isUnd(this.params[name])) {
            tlParams[name] = this.params[name];
          }
        }
      }
      tlParams.onComplete = () => {
        // Make sure to call .cancel() after restoreNodeInlineStyles(node); otehrwise the commited styles get reverted
        if (this.transformAnimation) this.transformAnimation.cancel();
        newState.forEachRootNode(node => {
          restoreNodeVisualState(node);
          restoreNodeInlineStyles(node);
        });
        for (let i = 0, l = transformed.length; i < l; i++) {
          const $el = transformed[i];
          $el.style.transform = newState.getComputedValue($el, 'transform');
        }
        if (this.root.classList.contains('is-animated')) {
          this.root.classList.remove('is-animated');
          if (onComplete) onComplete(this.timeline);
        }
        // Avoid CSS transitions at the end of the animation by restoring them on the next frame
        requestAnimationFrame(() => {
          if (this.root.classList.contains('is-animated')) return;
          restoreLayoutTransition(this.transitionMuteStore);
        });
      };
      tlParams.onPause = () => {
        if (!this.root.classList.contains('is-animated')) return;
        if (this.transformAnimation) this.transformAnimation.cancel();
        newState.forEachRootNode(restoreNodeVisualState);
        this.root.classList.remove('is-animated');
        if (onComplete) onComplete(this.timeline);
        if (onPause) onPause(this.timeline);
      };
      tlParams.composition = false;

      const swapAtParams = mergeObjects(mergeObjects(params.swapAt || {}, this.swapAtParams), animationTimings);
      const enterFromParams = mergeObjects(mergeObjects(params.enterFrom || {}, this.enterFromParams), animationTimings);
      const leaveToParams = mergeObjects(mergeObjects(params.leaveTo || {}, this.leaveToParams), animationTimings);
      const [ swapAtProps, swapAtTimings ] = splitPropertiesFromParams(swapAtParams);
      const [ enterFromProps, enterFromTimings ] = splitPropertiesFromParams(enterFromParams);
      const [ leaveToProps, leaveToTimings ] = splitPropertiesFromParams(leaveToParams);

      const oldState = this.oldState;
      const newState = this.newState;
      const animating = this.animating;
      const swapping = this.swapping;
      const entering = this.entering;
      const leaving = this.leaving;
      const pendingRemoval = this.pendingRemoval;

      animating.length = swapping.length = entering.length = leaving.length = 0;

      // Mute old state CSS transitions to prevent wrong properties calculation
      oldState.forEachRootNode(muteNodeTransition);
      // Capture the new state before animation
      newState.record();
      newState.forEachRootNode(recordNodeInlineStyles);

      const targets = [];
      const animated = [];
      const transformed = [];
      const animatedSwap = [];
      const rootNode = newState.rootNode;
      const $root = rootNode.$el;

      newState.forEachRootNode(node => {

        const $el = node.$el;
        const id = node.id;
        const parent = node.parentNode;
        const parentAdded = parent ? parent.branchAdded : false;
        const parentRemoved = parent ? parent.branchRemoved : false;
        const parentNotRendered = parent ? parent.branchNotRendered : false;

        let oldStateNode = oldState.nodes.get(id);

        const hasNoOldState = !oldStateNode;

        if (hasNoOldState) {
          oldStateNode = cloneNodeProperties(node, /** @type {LayoutNode} */({}), oldState);
          oldState.nodes.set(id, oldStateNode);
          oldStateNode.measuredIsRemoved = true;
        } else if (oldStateNode.measuredIsRemoved && !node.measuredIsRemoved) {
          cloneNodeProperties(node, oldStateNode, oldState);
          oldStateNode.measuredIsRemoved = true;
        }

        const oldParentNode = oldStateNode.parentNode;
        const oldParentId = oldParentNode ? oldParentNode.id : null;
        const newParentId = parent ? parent.id : null;
        const parentChanged = oldParentId !== newParentId;
        const elementChanged = oldStateNode.$el !== node.$el;
        const wasRemovedBefore = oldStateNode.measuredIsRemoved;
        const isRemovedNow = node.measuredIsRemoved;

        // Recalculate postion relative to their parent for elements that have been moved
        if (!oldStateNode.measuredIsRemoved && !isRemovedNow && !hasNoOldState && (parentChanged || elementChanged)) {
          const oldAbsoluteLeft = oldStateNode.properties.left;
          const oldAbsoluteTop = oldStateNode.properties.top;
          const newParent = parent || newState.rootNode;
          const oldParent = newParent.id ? oldState.nodes.get(newParent.id) : null;
          const parentLeft = oldParent ? oldParent.properties.left : newParent.properties.left;
          const parentTop = oldParent ? oldParent.properties.top : newParent.properties.top;
          const borderLeft = oldParent ? oldParent.properties.clientLeft : newParent.properties.clientLeft;
          const borderTop = oldParent ? oldParent.properties.clientTop : newParent.properties.clientTop;
          oldStateNode.properties.x = oldAbsoluteLeft - parentLeft - borderLeft;
          oldStateNode.properties.y = oldAbsoluteTop - parentTop - borderTop;
        }

        if (node.hasVisibilitySwap) {
          if (node.hasVisibilityHidden) {
            node.$el.style.visibility = 'visible';
            node.$measure.style.visibility = 'hidden';
          }
          if (node.hasDisplayNone) {
            node.$el.style.display = oldStateNode.measuredDisplay || node.measuredDisplay || '';
            // Setting visibility 'hidden' instead of display none to avoid calculation issues
            node.$measure.style.visibility = 'hidden';
            // @TODO: check why setting display here can cause calculation issues
            // node.$measure.style.display = 'none';
          }
        }

        const wasPendingRemoval = pendingRemoval.has($el);
        const wasVisibleBefore = oldStateNode.measuredIsVisible;
        const isVisibleNow = node.measuredIsVisible;
        const becomeVisible = !wasVisibleBefore && isVisibleNow && !parentNotRendered;
        const topLevelAdded = !isRemovedNow && (wasRemovedBefore || wasPendingRemoval) && !parentAdded;
        const newlyRemoved = isRemovedNow && !wasRemovedBefore && !parentRemoved;
        const topLevelRemoved = newlyRemoved || isRemovedNow && wasPendingRemoval && !parentRemoved;

        node.branchAdded = parentAdded || topLevelAdded;
        node.branchRemoved = parentRemoved || topLevelRemoved;
        node.branchNotRendered = parentNotRendered || isRemovedNow;

        if (isRemovedNow && wasVisibleBefore) {
          node.$el.style.display = oldStateNode.measuredDisplay;
          node.$el.style.visibility = 'visible';
          cloneNodeProperties(oldStateNode, node, newState);
        }

        // Node is leaving
        if (newlyRemoved) {
          if (node.isTarget) {
            leaving.push($el);
            node.isLeaving = true;
          }
          pendingRemoval.add($el);
        } else if (!isRemovedNow && wasPendingRemoval) {
          pendingRemoval.delete($el);
        }

        // Node is entering
        if ((topLevelAdded && !parentNotRendered) || becomeVisible) {
          updateNodeProperties(oldStateNode, enterFromProps);
          if (node.isTarget) {
            entering.push($el);
            node.isEntering = true;
          }
        // Node is leaving
        } else if (topLevelRemoved && !parentNotRendered) {
          updateNodeProperties(node, leaveToProps);
        }

        // Node is animating
        // The animating array is used only to calculate delays and duration on root children
        if (node !== rootNode && node.isTarget && !node.isEntering && !node.isLeaving) {
          animating.push($el);
        }

        targets.push($el);

      });

      let enteringIndex = 0;
      let leavingIndex = 0;
      let animatingIndex = 0;

      newState.forEachRootNode(node => {

        const $el = node.$el;
        const parent = node.parentNode;
        const oldStateNode = oldState.nodes.get(node.id);
        const nodeProperties = node.properties;
        const oldStateNodeProperties = oldStateNode.properties;

        // Use closest animated parent index and total values so that children staggered delays are in sync with their parent
        let animatedParent = parent !== rootNode && parent;
        while (animatedParent && !animatedParent.isTarget && animatedParent !== rootNode) {
          animatedParent = animatedParent.parentNode;
        }

        const animatingTotal = animating.length;

        // Root is always animated first in sync with the first child (animating.length is the total of children)
        if (node === rootNode) {
          node.index = 0;
          node.total = animatingTotal;
          updateNodeTimingParams(node, animationTimings);
        } else if (node.isEntering) {
          node.index = animatedParent ? animatedParent.index : enteringIndex;
          node.total = animatedParent ? animatingTotal : entering.length;
          updateNodeTimingParams(node, enterFromTimings);
          enteringIndex++;
        } else if (node.isLeaving) {
          node.index = animatedParent ? animatedParent.index : leavingIndex;
          node.total = animatedParent ? animatingTotal : leaving.length;
          leavingIndex++;
          updateNodeTimingParams(node, leaveToTimings);
        } else if (node.isTarget) {
          node.index = animatingIndex++;
          node.total = animatingTotal;
          updateNodeTimingParams(node, animationTimings);
        } else {
          node.index = animatedParent ? animatedParent.index : 0;
          node.total = animatingTotal;
          updateNodeTimingParams(node, swapAtTimings);
        }

        // Make sure the old state node has its inex and total values up to date for valid "from" function values calculation
        oldStateNode.index = node.index;
        oldStateNode.total = node.total;

        // Computes all values up front so we can check for changes and we don't have to re-compute them inside the animation props
        for (let prop in nodeProperties) {
          nodeProperties[prop] = getFunctionValue(nodeProperties[prop], $el, node.index, node.total);
          oldStateNodeProperties[prop] = getFunctionValue(oldStateNodeProperties[prop], $el, oldStateNode.index, oldStateNode.total);
        }

        // Use a 1px tolerance to detect dimensions changes to prevent width / height animations on barelly visible elements
        const sizeTolerance = 1;
        const widthChanged = Math.abs(nodeProperties.width - oldStateNodeProperties.width) > sizeTolerance;
        const heightChanged = Math.abs(nodeProperties.height - oldStateNodeProperties.height) > sizeTolerance;

        node.sizeChanged = (widthChanged || heightChanged);

        // const hiddenStateChanged = (topLevelAdded || newlyRemoved) && wasRemovedBefore !== isRemovedNow;

        if (node.isTarget && (!node.measuredIsRemoved && oldStateNode.measuredIsVisible || node.measuredIsRemoved && node.measuredIsVisible)) {
          if (!node.isInlined && (nodeProperties.transform !== 'none' || oldStateNodeProperties.transform !== 'none')) {
            node.hasTransform = true;
            transformed.push($el);
          }
          for (let prop in nodeProperties) {
            // if (prop !== 'transform' && (nodeProperties[prop] !== oldStateNodeProperties[prop] || hiddenStateChanged)) {
            if (prop !== 'transform' && (nodeProperties[prop] !== oldStateNodeProperties[prop])) {
              animated.push($el);
              break;
            }
          }
        }

        if (!node.isTarget) {
          swapping.push($el);
          if (node.sizeChanged && parent && parent.isTarget && parent.sizeChanged) {
            if (!node.isInlined && swapAtProps.transform) {
              node.hasTransform = true;
              transformed.push($el);
            }
            animatedSwap.push($el);
          }
        }

      });

      const timingParams = {
        delay: (/** @type {HTMLElement} */$el) => newState.getNode($el).delay,
        duration: (/** @type {HTMLElement} */$el) => newState.getNode($el).duration,
        ease: (/** @type {HTMLElement} */$el) => newState.getNode($el).ease,
      };

      tlParams.defaults = timingParams;

      this.timeline = createTimeline(tlParams);

      // Imediatly return the timeline if no layout changes detected
      if (!animated.length && !transformed.length && !swapping.length) {
        // Make sure to restore all CSS transition if no animation
        restoreLayoutTransition(this.transitionMuteStore);
        return this.timeline.complete();
      }

      if (targets.length) {

        this.root.classList.add('is-animated');

        for (let i = 0, l = targets.length; i < l; i++) {
          const $el = targets[i];
          const id = $el.dataset.layoutId;
          const oldNode = oldState.nodes.get(id);
          const newNode = newState.nodes.get(id);
          const oldNodeState = oldNode.properties;

          // muteNodeTransition(newNode);

          // Don't animate dimensions and positions of inlined elements
          if (!newNode.isInlined) {
            // Display grid can mess with the absolute positioning, so set it to block during transition
            if (oldNode.measuredDisplay === 'grid' || newNode.measuredDisplay === 'grid') $el.style.setProperty('display', 'block', 'important');
            // All children must be in position absolute or fixed
            if ($el !== $root || this.absoluteCoords) {
              $el.style.position = this.absoluteCoords ? 'fixed' : 'absolute';
              $el.style.left = '0px';
              $el.style.top = '0px';
              $el.style.marginLeft = '0px';
              $el.style.marginTop = '0px';
              $el.style.translate = `${oldNodeState.x}px ${oldNodeState.y}px`;
            }
            if ($el === $root && newNode.measuredPosition === 'static') {
              $el.style.position = 'relative';
              // Cancel left / trop in case the static element had muted values now activated by potision relative
              $el.style.left = '0px';
              $el.style.top = '0px';
            }
            $el.style.width = `${oldNodeState.width}px`;
            $el.style.height = `${oldNodeState.height}px`;
            // Overrides user defined min and max to prevents width and height clamping
            $el.style.minWidth = `auto`;
            $el.style.minHeight = `auto`;
            $el.style.maxWidth = `none`;
            $el.style.maxHeight = `none`;
          }
        }

        // Restore the scroll position if the oldState differs from the current state
        if (oldState.scrollX !== window.scrollX || oldState.scrollY !== window.scrollY) {
          // Restoring in the next frame avoids race conditions if for example a waapi animation commit styles that affect the root height
          requestAnimationFrame(() => window.scrollTo(oldState.scrollX, oldState.scrollY));
        }

        for (let i = 0, l = animated.length; i < l; i++) {
          const $el = animated[i];
          const id = $el.dataset.layoutId;
          const oldNode = oldState.nodes.get(id);
          const newNode = newState.nodes.get(id);
          const oldNodeState = oldNode.properties;
          const newNodeState = newNode.properties;
          let nodeHasChanged = false;
          /** @type {AnimationParams} */
          const animatedProps = {
            composition: 'none',
          };
          if (!newNode.isInlined) {
            if (oldNodeState.width !== newNodeState.width) {
              animatedProps.width = [oldNodeState.width, newNodeState.width];
              nodeHasChanged = true;
            }
            if (oldNodeState.height !== newNodeState.height) {
              animatedProps.height = [oldNodeState.height, newNodeState.height];
              nodeHasChanged = true;
            }
            // If the node has transforms we handle the translate animation in wappi otherwise translate and other transforms can be out of sync
            // Always animate translate
            if (!newNode.hasTransform) {
              animatedProps.translate = [`${oldNodeState.x}px ${oldNodeState.y}px`, `${newNodeState.x}px ${newNodeState.y}px`];
              nodeHasChanged = true;
            }
          }
          this.properties.forEach(prop => {
            const oldVal = oldNodeState[prop];
            const newVal = newNodeState[prop];
            if (prop !== 'transform' && oldVal !== newVal) {
              animatedProps[prop] = [oldVal, newVal];
              nodeHasChanged = true;
            }
          });
          if (nodeHasChanged) {
            this.timeline.add($el, animatedProps, 0);
          }
        }

      }

      if (swapping.length) {

        for (let i = 0, l = swapping.length; i < l; i++) {
          const $el = swapping[i];
          const oldNode = oldState.getNode($el);
          if (!oldNode.isInlined) {
            const oldNodeProps = oldNode.properties;
            $el.style.width = `${oldNodeProps.width}px`;
            $el.style.height = `${oldNodeProps.height}px`;
            // Overrides user defined min and max to prevents width and height clamping
            $el.style.minWidth = `auto`;
            $el.style.minHeight = `auto`;
            $el.style.maxWidth = `none`;
            $el.style.maxHeight = `none`;
            $el.style.translate = `${oldNodeProps.x}px ${oldNodeProps.y}px`;
          }
          this.properties.forEach(prop => {
            if (prop !== 'transform') {
              $el.style[prop] = `${oldState.getComputedValue($el, prop)}`;
            }
          });
        }

        for (let i = 0, l = swapping.length; i < l; i++) {
          const $el = swapping[i];
          const newNode = newState.getNode($el);
          const newNodeProps = newNode.properties;
          this.timeline.call(() => {
            if (!newNode.isInlined) {
              $el.style.width = `${newNodeProps.width}px`;
              $el.style.height = `${newNodeProps.height}px`;
              // Overrides user defined min and max to prevents width and height clamping
              $el.style.minWidth = `auto`;
              $el.style.minHeight = `auto`;
              $el.style.maxWidth = `none`;
              $el.style.maxHeight = `none`;
              $el.style.translate = `${newNodeProps.x}px ${newNodeProps.y}px`;
            }
            this.properties.forEach(prop => {
              if (prop !== 'transform') {
                $el.style[prop] = `${newState.getComputedValue($el, prop)}`;
              }
            });
          }, newNode.delay + newNode.duration / 2);
        }

        if (animatedSwap.length) {
          const ease = parseEase(newState.nodes.get(animatedSwap[0].dataset.layoutId).ease);
          const inverseEased = t => 1 - ease(1 - t);
          const animatedSwapParams = /** @type {AnimationParams} */({});
          if (swapAtProps) {
            for (let prop in swapAtProps) {
              if (prop !== 'transform') {
                animatedSwapParams[prop] = [
                  { from: (/** @type {HTMLElement} */$el) => oldState.getComputedValue($el, prop), to: swapAtProps[prop] },
                  { from: swapAtProps[prop], to: (/** @type {HTMLElement} */$el) => newState.getComputedValue($el, prop), ease: inverseEased }
                ];
              }
            }
          }
          this.timeline.add(animatedSwap, animatedSwapParams, 0);
        }

      }

      const transformedLength = transformed.length;

      if (transformedLength) {
        // We only need to set the transform property here since translate is alread defined in the targets loop
        for (let i = 0; i < transformedLength; i++) {
          const $el = transformed[i];
          $el.style.translate = `${oldState.getComputedValue($el, 'x')}px ${oldState.getComputedValue($el, 'y')}px`,
          $el.style.transform = oldState.getComputedValue($el, 'transform');
          if (animatedSwap.includes($el)) {
            const node = newState.getNode($el);
            node.ease = getFunctionValue(swapAtParams.ease, $el, node.index, node.total);
            node.duration = getFunctionValue(swapAtParams.duration, $el, node.index, node.total);
          }
        }
        this.transformAnimation = waapi.animate(transformed, {
          translate: (/** @type {HTMLElement} */$el) => `${newState.getComputedValue($el, 'x')}px ${newState.getComputedValue($el, 'y')}px`,
          transform: (/** @type {HTMLElement} */$el) => {
            const newValue = newState.getComputedValue($el, 'transform');
            if (!animatedSwap.includes($el)) return newValue;
            const oldValue = oldState.getComputedValue($el, 'transform');
            const node = newState.getNode($el);
            return [oldValue, getFunctionValue(swapAtProps.transform, $el, node.index, node.total), newValue]
          },
          autoplay: false,
          persist: true,
          ...timingParams,
        });
        this.timeline.sync(this.transformAnimation, 0);
      }

      return this.timeline.init();
    }

    /**
     * @param {(layout: this) => void} callback
     * @param {LayoutAnimationParams} [params]
     * @return {Timeline}
     */
    update(callback, params = {}) {
      this.record();
      callback(this);
      return this.animate(params);
    }
  }

  /**
   * @param {DOMTargetSelector} root
   * @param {AutoLayoutParams} [params]
   * @return {AutoLayout}
   */
  const createLayout = (root, params) => new AutoLayout(root, params);

  // Chain-able utilities

  const numberUtils = numberImports; // Needed to keep the import when bundling

  const chainables = {};

  /**
   * @callback UtilityFunction
   * @param {...*} args
   * @return {Number|String}
   *
   * @param {UtilityFunction} fn
   * @param {Number} [last=0]
   * @return {function(...(Number|String)): function(Number|String): (Number|String)}
   */
  const curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);

  /**
   * @param {Function} fn
   * @return {function(...(Number|String))}
   */
  const chain = fn => {
     return (...args) => {
      const result = fn(...args);
      return new Proxy(noop, {
        apply: (_, __, [v]) => result(v),
        get: (_, prop) => chain(/**@param {...Number|String} nextArgs */(...nextArgs) => {
          const nextResult = chainables[prop](...nextArgs);
          return (/**@type {Number|String} */v) => nextResult(result(v));
        })
      });
    }
  };

  /**
   * @param {UtilityFunction} fn
   * @param {String} name
   * @param {Number} [right]
   * @return {function(...(Number|String)): UtilityFunction}
   */
  const makeChainable = (name, fn, right = 0) => {
    const chained = (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);
    if (!chainables[name]) chainables[name] = chained;
    return chained;
  };

  /**
   * @typedef {Object} ChainablesMap
   * @property {ChainedClamp} clamp
   * @property {ChainedRound} round
   * @property {ChainedSnap} snap
   * @property {ChainedWrap} wrap
   * @property {ChainedLerp} lerp
   * @property {ChainedDamp} damp
   * @property {ChainedMapRange} mapRange
   * @property {ChainedRoundPad} roundPad
   * @property {ChainedPadStart} padStart
   * @property {ChainedPadEnd} padEnd
   * @property {ChainedDegToRad} degToRad
   * @property {ChainedRadToDeg} radToDeg
   */

  /**
   * @callback ChainedUtilsResult
   * @param {Number} value - The value to process through the chained operations
   * @return {Number} The processed result
   */

  /**
   * @typedef {ChainablesMap & ChainedUtilsResult} ChainableUtil
   */

  // Chainable

  /**
   * @callback ChainedRoundPad
   * @param {Number} decimalLength - Number of decimal places
   * @return {ChainableUtil}
   */
  const roundPad = /** @type {typeof numberUtils.roundPad & ChainedRoundPad} */(makeChainable('roundPad', numberUtils.roundPad));

  /**
   * @callback ChainedPadStart
   * @param {Number} totalLength - Target length
   * @param {String} padString - String to pad with
   * @return {ChainableUtil}
   */
  const padStart = /** @type {typeof numberUtils.padStart & ChainedPadStart} */(makeChainable('padStart', numberUtils.padStart));

  /**
   * @callback ChainedPadEnd
   * @param {Number} totalLength - Target length
   * @param {String} padString - String to pad with
   * @return {ChainableUtil}
   */
  const padEnd = /** @type {typeof numberUtils.padEnd & ChainedPadEnd} */(makeChainable('padEnd', numberUtils.padEnd));

  /**
   * @callback ChainedWrap
   * @param {Number} min - Minimum boundary
   * @param {Number} max - Maximum boundary
   * @return {ChainableUtil}
   */
  const wrap = /** @type {typeof numberUtils.wrap & ChainedWrap} */(makeChainable('wrap', numberUtils.wrap));

  /**
   * @callback ChainedMapRange
   * @param {Number} inLow - Input range minimum
   * @param {Number} inHigh - Input range maximum
   * @param {Number} outLow - Output range minimum
   * @param {Number} outHigh - Output range maximum
   * @return {ChainableUtil}
   */
  const mapRange = /** @type {typeof numberUtils.mapRange & ChainedMapRange} */(makeChainable('mapRange', numberUtils.mapRange));

  /**
   * @callback ChainedDegToRad
   * @return {ChainableUtil}
   */
  const degToRad = /** @type {typeof numberUtils.degToRad & ChainedDegToRad} */(makeChainable('degToRad', numberUtils.degToRad));

  /**
   * @callback ChainedRadToDeg
   * @return {ChainableUtil}
   */
  const radToDeg = /** @type {typeof numberUtils.radToDeg & ChainedRadToDeg} */(makeChainable('radToDeg', numberUtils.radToDeg));

  /**
   * @callback ChainedSnap
   * @param {Number|Array<Number>} increment - Step size or array of snap points
   * @return {ChainableUtil}
   */
  const snap = /** @type {typeof numberUtils.snap & ChainedSnap} */(makeChainable('snap', numberUtils.snap));

  /**
   * @callback ChainedClamp
   * @param {Number} min - Minimum boundary
   * @param {Number} max - Maximum boundary
   * @return {ChainableUtil}
   */
  const clamp = /** @type {typeof numberUtils.clamp & ChainedClamp} */(makeChainable('clamp', numberUtils.clamp));

  /**
   * @callback ChainedRound
   * @param {Number} decimalLength - Number of decimal places
   * @return {ChainableUtil}
   */
  const round = /** @type {typeof numberUtils.round & ChainedRound} */(makeChainable('round', numberUtils.round));

  /**
   * @callback ChainedLerp
   * @param {Number} start - Starting value
   * @param {Number} end - Ending value
   * @return {ChainableUtil}
   */
  const lerp = /** @type {typeof numberUtils.lerp & ChainedLerp} */(makeChainable('lerp', numberUtils.lerp, 1));

  /**
   * @callback ChainedDamp
   * @param {Number} start - Starting value
   * @param {Number} end - Target value
   * @param {Number} deltaTime - Delta time in ms
   * @return {ChainableUtil}
   */
  const damp = /** @type {typeof numberUtils.damp & ChainedDamp} */(makeChainable('damp', numberUtils.damp, 1));

  /**
   * Generate a random number between optional min and max (inclusive) and decimal precision
   *
   * @callback RandomNumberGenerator
   * @param    {Number} [min=0] - The minimum value (inclusive)
   * @param    {Number} [max=1] - The maximum value (inclusive)
   * @param    {Number} [decimalLength=0] - Number of decimal places to round to
   * @return   {Number} A random number between min and max
   */

  /**
   * Generates a random number between min and max (inclusive) with optional decimal precision
   *
   * @type {RandomNumberGenerator}
   */
  const random = (min = 0, max = 1, decimalLength = 0) => {
    const m = 10 ** decimalLength;
    return Math.floor((Math.random() * (max - min + (1 / m)) + min) * m) / m;
  };

  let _seed = 0;

  /**
   * Creates a seeded pseudorandom number generator function
   *
   * @param  {Number} [seed] - The seed value for the random number generator
   * @param  {Number} [seededMin=0] - The minimum default value (inclusive) of the returned function
   * @param  {Number} [seededMax=1] - The maximum default value (inclusive) of the returned function
   * @param  {Number} [seededDecimalLength=0] - Default number of decimal places to round to of the returned function
   * @return {RandomNumberGenerator} A function to generate a random number between optional min and max (inclusive) and decimal precision
   */
  const createSeededRandom = (seed, seededMin = 0, seededMax = 1, seededDecimalLength = 0) => {
    let t = seed === undefined ? _seed++ : seed;
    return (min = seededMin, max = seededMax, decimalLength = seededDecimalLength) => {
      t += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      const m = 10 ** decimalLength;
      return Math.floor(((((t ^ t >>> 14) >>> 0) / 4294967296) * (max - min + (1 / m)) + min) * m) / m;
    }
  };

  /**
   * Picks a random element from an array or a string
   *
   * @template T
   * @param    {String|Array<T>} items - The array or string to pick from
   * @return   {String|T} A random element from the array or character from the string
   */
  const randomPick = items => items[random(0, items.length - 1)];

  /**
   * Shuffles an array in-place using the Fisher-Yates algorithm
   * Adapted from https://bost.ocks.org/mike/shuffle/
   *
   * @param  {Array} items - The array to shuffle (will be modified in-place)
   * @return {Array} The same array reference, now shuffled
   */
  const shuffle = items => {
    let m = items.length, t, i;
    while (m) { i = random(0, --m); t = items[m]; items[m] = items[i]; items[i] = t; }
    return items;
  };

  

  

  /**
   * @overload
   * @param {Number} val
   * @param {StaggerParams} [params]
   * @return {StaggerFunction<Number>}
   */
  /**
   * @overload
   * @param {String} val
   * @param {StaggerParams} [params]
   * @return {StaggerFunction<String>}
   */
  /**
   * @overload
   * @param {[Number, Number]} val
   * @param {StaggerParams} [params]
   * @return {StaggerFunction<Number>}
   */
  /**
   * @overload
   * @param {[String, String]} val
   * @param {StaggerParams} [params]
   * @return {StaggerFunction<String>}
   */
  /**
   * @param {Number|String|[Number, Number]|[String, String]} val The staggered value or range
   * @param {StaggerParams} [params] The stagger parameters
   * @return {StaggerFunction<Number|String>}
   */
  const stagger = (val, params = {}) => {
    let values = [];
    let maxValue = 0;
    const from = params.from;
    const reversed = params.reversed;
    const ease = params.ease;
    const hasEasing = !isUnd(ease);
    const hasSpring = hasEasing && !isUnd(/** @type {Spring} */(ease).ease);
    const staggerEase = hasSpring ? /** @type {Spring} */(ease).ease : hasEasing ? parseEase(ease) : null;
    const grid = params.grid;
    const axis = params.axis;
    const customTotal = params.total;
    const fromFirst = isUnd(from) || from === 0 || from === 'first';
    const fromCenter = from === 'center';
    const fromLast = from === 'last';
    const fromRandom = from === 'random';
    const isRange = isArr(val);
    const useProp = params.use;
    const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);
    const val2 = isRange ? parseNumber(val[1]) : 0;
    const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);
    const start = params.start || 0 + (isRange ? val1 : 0);
    let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;
    return (target, i, t, tl) => {
      const [ registeredTarget ] = registerTargets(target);
      const total = isUnd(customTotal) ? t : customTotal;
      const customIndex = !isUnd(useProp) ? isFnc(useProp) ? useProp(registeredTarget, i, total) : getOriginalAnimatableValue(registeredTarget, useProp) : false;
      const staggerIndex = isNum(customIndex) || isStr(customIndex) && isNum(+customIndex) ? +customIndex : i;
      if (fromCenter) fromIndex = (total - 1) / 2;
      if (fromLast) fromIndex = total - 1;
      if (!values.length) {
        for (let index = 0; index < total; index++) {
          if (!grid) {
            values.push(abs(fromIndex - index));
          } else {
            const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
            const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
            const toX = index % grid[0];
            const toY = floor(index / grid[0]);
            const distanceX = fromX - toX;
            const distanceY = fromY - toY;
            let value = sqrt(distanceX * distanceX + distanceY * distanceY);
            if (axis === 'x') value = -distanceX;
            if (axis === 'y') value = -distanceY;
            values.push(value);
          }
          maxValue = max(...values);
        }
        if (staggerEase) values = values.map(val => staggerEase(val / maxValue) * maxValue);
        if (reversed) values = values.map(val => axis ? (val < 0) ? val * -1 : -val : abs(maxValue - val));
        if (fromRandom) values = shuffle(values);
      }
      const spacing = isRange ? (val2 - val1) / maxValue : val1;
      const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */(start);
      /** @type {String|Number} */
      let output = offset + ((spacing * round$1(values[staggerIndex], 2)) || 0);
      if (params.modifier) output = params.modifier(output);
      if (unitMatch) output = `${output}${unitMatch[2]}`;
      return output;
    }
  };

  var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    $: registerTargets,
    clamp: clamp,
    cleanInlineStyles: cleanInlineStyles,
    createSeededRandom: createSeededRandom,
    damp: damp,
    degToRad: degToRad,
    get: get,
    keepTime: keepTime,
    lerp: lerp,
    mapRange: mapRange,
    padEnd: padEnd,
    padStart: padStart,
    radToDeg: radToDeg,
    random: random,
    randomPick: randomPick,
    remove: remove,
    round: round,
    roundPad: roundPad,
    set: set,
    shuffle: shuffle,
    snap: snap,
    stagger: stagger,
    sync: sync,
    wrap: wrap
  });

  

  /**
   * @param  {TargetsParam} path
   * @return {SVGGeometryElement|void}
   */
  const getPath = path => {
    const parsedTargets = parseTargets(path);
    const $parsedSvg = /** @type {SVGGeometryElement} */(parsedTargets[0]);
    if (!$parsedSvg || !isSvg($parsedSvg)) return console.warn(`${path} is not a valid SVGGeometryElement`);
    return $parsedSvg;
  };

  

  // Motion path animation

  /**
   * @param {SVGGeometryElement} $path
   * @param {Number} totalLength
   * @param {Number} progress
   * @param {Number} lookup
   * @param {Boolean} shouldClamp
   * @return {DOMPoint}
   */
  const getPathPoint = ($path, totalLength, progress, lookup, shouldClamp) => {
    const point = progress + lookup;
    const pointOnPath = shouldClamp
      ? Math.max(0, Math.min(point, totalLength)) // Clamp between 0 and totalLength
      : (point % totalLength + totalLength) % totalLength; // Wrap around
    return $path.getPointAtLength(pointOnPath);
  };

  /**
   * @param {SVGGeometryElement} $path
   * @param {String} pathProperty
   * @param {Number} [offset=0]
   * @return {FunctionValue}
   */
  const getPathProgess = ($path, pathProperty, offset = 0) => {
    return $el => {
      const totalLength = +($path.getTotalLength());
      const inSvg = $el[isSvgSymbol];
      const ctm = $path.getCTM();
      const shouldClamp = offset === 0;
      /** @type {TweenObjectValue} */
      return {
        from: 0,
        to: totalLength,
        /** @type {TweenModifier} */
        modifier: progress => {
          const offsetLength = offset * totalLength;
          const newProgress = progress + offsetLength;
          if (pathProperty === 'a') {
            const p0 = getPathPoint($path, totalLength, newProgress, -1, shouldClamp);
            const p1 = getPathPoint($path, totalLength, newProgress, 1, shouldClamp);
            return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;
          } else {
            const p = getPathPoint($path, totalLength, newProgress, 0, shouldClamp);
            return pathProperty === 'x' ?
              inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e :
              inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f
          }
        }
      }
    }
  };

  /**
   * @param {TargetsParam} path
   * @param {Number} [offset=0]
   */
  const createMotionPath = (path, offset = 0) => {
    const $path = getPath(path);
    if (!$path) return;
    return {
      translateX: getPathProgess($path, 'x', offset),
      translateY: getPathProgess($path, 'y', offset),
      rotate: getPathProgess($path, 'a', offset),
    }
  };

  

  /**
   * @param {SVGGeometryElement} [$el]
   * @return {Number}
   */
  const getScaleFactor = $el => {
    let scaleFactor = 1;
    if ($el && $el.getCTM) {
      const ctm = $el.getCTM();
      if (ctm) {
        const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);
        const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);
        scaleFactor = (scaleX + scaleY) / 2;
      }
    }
    return scaleFactor;
  };

  /**
   * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.
   * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable
   * @param {number} start - Starting position (0-1)
   * @param {number} end - Ending position (0-1)
   * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality
   */
  const createDrawableProxy = ($el, start, end) => {
    const pathLength = K;
    const computedStyles = getComputedStyle($el);
    const strokeLineCap = computedStyles.strokeLinecap;
    // @ts-ignore
    const $scalled = computedStyles.vectorEffect === 'non-scaling-stroke' ? $el : null;
    let currentCap = strokeLineCap;

    const proxy = new Proxy($el, {
      get(target, property) {
        const value = target[property];
        if (property === proxyTargetSymbol) return target;
        if (property === 'setAttribute') {
          return (...args) => {
            if (args[0] === 'draw') {
              const value = args[1];
              const values = value.split(' ');
              const v1 = +values[0];
              const v2 = +values[1];
              // TOTO: Benchmark if performing two slices is more performant than one split
              // const spaceIndex = value.indexOf(' ');
              // const v1 = round(+value.slice(0, spaceIndex), precision);
              // const v2 = round(+value.slice(spaceIndex + 1), precision);
              const scaleFactor = getScaleFactor($scalled);
              const os = v1 * -pathLength * scaleFactor;
              const d1 = (v2 * pathLength * scaleFactor) + os;
              const d2 = (pathLength * scaleFactor +
                        ((v1 === 0 && v2 === 1) || (v1 === 1 && v2 === 0) ? 0 : 10 * scaleFactor) - d1);
              if (strokeLineCap !== 'butt') {
                const newCap = v1 === v2 ? 'butt' : strokeLineCap;
                if (currentCap !== newCap) {
                  target.style.strokeLinecap = `${newCap}`;
                  currentCap = newCap;
                }
              }
              target.setAttribute('stroke-dashoffset', `${os}`);
              target.setAttribute('stroke-dasharray', `${d1} ${d2}`);
            }
            return Reflect.apply(value, target, args);
          };
        }

        if (isFnc(value)) {
          return (...args) => Reflect.apply(value, target, args);
        } else {
          return value;
        }
      }
    });

    if ($el.getAttribute('pathLength') !== `${pathLength}`) {
      $el.setAttribute('pathLength', `${pathLength}`);
      proxy.setAttribute('draw', `${start} ${end}`);
    }

    return /** @type {DrawableSVGGeometry} */(proxy);
  };

  /**
   * Creates drawable proxies for multiple SVG elements.
   * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors
   * @param {number} [start=0] - Starting position (0-1)
   * @param {number} [end=0] - Ending position (0-1)
   * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality
   */
  const createDrawable = (selector, start = 0, end = 0) => {
    const els = parseTargets(selector);
    return els.map($el => createDrawableProxy(
      /** @type {SVGGeometryElement} */($el),
      start,
      end
    ));
  };

  

  /**
   * @param  {TargetsParam} path2
   * @param  {Number} [precision]
   * @return {FunctionValue}
   */
  const morphTo = (path2, precision = .33) => ($path1) => {
    const tagName1 = ($path1.tagName || '').toLowerCase();
    if (!tagName1.match(/^(path|polygon|polyline)$/)) {
      throw new Error(`Can't morph a <${$path1.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);
    }
    const $path2 = /** @type {SVGGeometryElement} */(getPath(path2));
    if (!$path2) {
      throw new Error("Can't morph to an invalid target. 'path2' must resolve to an existing <path>, <polygon> or <polyline> SVG element.");
    }
    const tagName2 = ($path2.tagName || '').toLowerCase();
    if (!tagName2.match(/^(path|polygon|polyline)$/)) {
      throw new Error(`Can't morph a <${$path2.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);
    }
    const isPath = $path1.tagName === 'path';
    const separator = isPath ? ' ' : ',';
    const previousPoints = $path1[morphPointsSymbol];
    if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);

    let v1 = '', v2 = '';

    if (!precision) {
      v1 = $path1.getAttribute(isPath ? 'd' : 'points');
      v2 = $path2.getAttribute(isPath ? 'd' : 'points');
    } else {
      const length1 = /** @type {SVGGeometryElement} */($path1).getTotalLength();
      const length2 = $path2.getTotalLength();
      const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));
      for (let i = 0; i < maxPoints; i++) {
        const t = i / (maxPoints - 1);
        const pointOnPath1 = /** @type {SVGGeometryElement} */($path1).getPointAtLength(length1 * t);
        const pointOnPath2 = $path2.getPointAtLength(length2 * t);
        const prefix = isPath ? (i === 0 ? 'M' : 'L') : '';
        v1 += prefix + round$1(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';
        v2 += prefix + round$1(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';
      }
    }

    $path1[morphPointsSymbol] = v2;

    return [v1, v2];
  };

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createDrawable: createDrawable,
    createMotionPath: createMotionPath,
    morphTo: morphTo
  });

  

  const segmenter = (typeof Intl !== 'undefined') && Intl.Segmenter;
  const valueRgx = /\{value\}/g;
  const indexRgx = /\{i\}/g;
  const whiteSpaceGroupRgx = /(\s+)/;
  const whiteSpaceRgx = /^\s+$/;
  const lineType = 'line';
  const wordType = 'word';
  const charType = 'char';
  const dataLine = `data-line`;

  /**
   * @typedef {Object} Segment
   * @property {String} segment
   * @property {Boolean} [isWordLike]
   */

  /**
   * @typedef {Object} Segmenter
   * @property {function(String): Iterable<Segment>} segment
   */

  /** @type {Segmenter} */
  let wordSegmenter = null;
  /** @type {Segmenter} */
  let graphemeSegmenter = null;
  let $splitTemplate = null;

  /**
   * @param  {Segment} seg
   * @return {Boolean}
   */
  const isSegmentWordLike = seg => {
    return seg.isWordLike ||
           seg.segment === ' ' || // Consider spaces as words first, then handle them diffrently later
           isNum(+seg.segment);   // Safari doesn't considers numbers as words
  };

  /**
   * @param {HTMLElement} $el
   */
  const setAriaHidden = $el => $el.setAttribute('aria-hidden', 'true');

  /**
   * @param {DOMTarget} $el
   * @param {String} type
   * @return {Array<HTMLElement>}
   */
  const getAllTopLevelElements = ($el, type) => [.../** @type {*} */($el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`))];

  const debugColors = { line: '#00D672', word: '#FF4B4B', char: '#5A87FF' };

  /**
   * @param {HTMLElement} $el
   */
  const filterEmptyElements = $el => {
    if (!$el.childElementCount && !$el.textContent.trim()) {
      const $parent = $el.parentElement;
      $el.remove();
      if ($parent) filterEmptyElements($parent);
    }
  };

  /**
   * @param {HTMLElement} $el
   * @param {Number} lineIndex
   * @param {Set<HTMLElement|Node>} bin
   * @returns {Set<HTMLElement|Node>}
   */
  const filterLineElements = ($el, lineIndex, bin) => {
    const dataLineAttr = $el.getAttribute(dataLine);
    if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === 'BR') {
      bin.add($el);
      // Also remove adjacent whitespace-only text nodes
      const prev = $el.previousSibling;
      const next = $el.nextSibling;
      if (prev && prev.nodeType === 3 && whiteSpaceRgx.test(prev.textContent)) {
        bin.add(prev);
      }
      if (next && next.nodeType === 3 && whiteSpaceRgx.test(next.textContent)) {
        bin.add(next);
      }
    }
    let i = $el.childElementCount;
    while (i--) filterLineElements(/** @type {HTMLElement} */($el.children[i]), lineIndex, bin);
    return bin;
  };

  /**
   * @param  {'line'|'word'|'char'} type
   * @param  {SplitTemplateParams} params
   * @return {String}
   */
  const generateTemplate = (type, params = {}) => {
    let template = ``;
    const classString = isStr(params.class) ? ` class="${params.class}"` : '';
    const cloneType = setValue(params.clone, false);
    const wrapType = setValue(params.wrap, false);
    const overflow = wrapType ? wrapType === true ? 'clip' : wrapType : cloneType ? 'clip' : false;
    if (wrapType) template += `<span${overflow ? ` style="overflow:${overflow};"` : ''}>`;
    template += `<span${classString}${cloneType ? ` style="position:relative;"` : ''} data-${type}="{i}">`;
    if (cloneType) {
      const left = cloneType === 'left' ? '-100%' : cloneType === 'right' ? '100%' : '0';
      const top = cloneType === 'top' ? '-100%' : cloneType === 'bottom' ? '100%' : '0';
      template += `<span>{value}</span>`;
      template += `<span inert style="position:absolute;top:${top};left:${left};white-space:nowrap;">{value}</span>`;
    } else {
      template += `{value}`;
    }
    template += `</span>`;
    if (wrapType) template += `</span>`;
    return template;
  };

  /**
   * @param  {String|SplitFunctionValue} htmlTemplate
   * @param  {Array<HTMLElement>} store
   * @param  {Node|HTMLElement} node
   * @param  {DocumentFragment} $parentFragment
   * @param  {'line'|'word'|'char'} type
   * @param  {Boolean} debug
   * @param  {Number} lineIndex
   * @param  {Number} [wordIndex]
   * @param  {Number} [charIndex]
   * @return {HTMLElement}
   */
  const processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {
    const isLine = type === lineType;
    const isChar = type === charType;
    const className = `_${type}_`;
    const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;
    const displayStyle = isLine ? 'block' : 'inline-block';
    $splitTemplate.innerHTML = template
      .replace(valueRgx, `<i class="${className}"></i>`)
      .replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);
    const $content = $splitTemplate.content;
    const $highestParent = /** @type {HTMLElement} */($content.firstElementChild);
    const $split = /** @type {HTMLElement} */($content.querySelector(`[data-${type}]`)) || $highestParent;
    const $replacables = /** @type {NodeListOf<HTMLElement>} */($content.querySelectorAll(`i.${className}`));
    const replacablesLength = $replacables.length;
    if (replacablesLength) {
      $highestParent.style.display = displayStyle;
      $split.style.display = displayStyle;
      $split.setAttribute(dataLine, `${lineIndex}`);
      if (!isLine) {
        $split.setAttribute('data-word', `${wordIndex}`);
        if (isChar) $split.setAttribute('data-char', `${charIndex}`);
      }
      let i = replacablesLength;
      while (i--) {
        const $replace = $replacables[i];
        const $closestParent = $replace.parentElement;
        $closestParent.style.display = displayStyle;
        if (isLine) {
          $closestParent.innerHTML = /** @type {HTMLElement} */(node).innerHTML;
        } else {
          $closestParent.replaceChild(node.cloneNode(true), $replace);
        }
      }
      store.push($split);
      $parentFragment.appendChild($content);
    } else {
      console.warn(`The expression "{value}" is missing from the provided template.`);
    }
    if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;
    return $highestParent;
  };

  /**
   * A class that splits text into words and wraps them in span elements while preserving the original HTML structure.
   * @class
   */
  class TextSplitter {
    /**
     * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target
     * @param  {TextSplitterParams} [parameters]
     */
    constructor(target, parameters = {}) {
      // Only init segmenters when needed
      if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], { granularity: wordType }) : {
        segment: (text) => {
          const segments = [];
          const words = text.split(whiteSpaceGroupRgx);
          for (let i = 0, l = words.length; i < l; i++) {
            const segment = words[i];
            segments.push({
              segment,
              isWordLike: !whiteSpaceRgx.test(segment), // Consider non-whitespace as word-like
            });
          }
          return segments;
        }
      };
      if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], { granularity: 'grapheme' }) : {
        segment: text => [...text].map(char => ({ segment: char }))
      };
      if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement('template');
      if (scope.current) scope.current.register(this);
      const { words, chars, lines, accessible, includeSpaces, debug } = parameters;
      const $target = /** @type {HTMLElement} */((target = isArr(target) ? target[0] : target) && /** @type {Node} */(target).nodeType ? target : (getNodeList(target) || [])[0]);
      const lineParams = lines === true ? {} : lines;
      const wordParams = words === true || isUnd(words) ? {} : words;
      const charParams = chars === true ? {} : chars;
      this.debug = setValue(debug, false);
      this.includeSpaces = setValue(includeSpaces, false);
      this.accessible = setValue(accessible, true);
      this.linesOnly = lineParams && (!wordParams && !charParams);
      /** @type {String|false|SplitFunctionValue} */
      this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, /** @type {SplitTemplateParams} */(lineParams)) : lineParams;
      /** @type {String|false|SplitFunctionValue} */
      this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, /** @type {SplitTemplateParams} */(wordParams)) : wordParams;
      /** @type {String|false|SplitFunctionValue} */
      this.charTemplate = isObj(charParams) ? generateTemplate(charType, /** @type {SplitTemplateParams} */(charParams)) : charParams;
      this.$target = $target;
      this.html = $target && $target.innerHTML;
      this.lines = [];
      this.words = [];
      this.chars = [];
      this.effects = [];
      this.effectsCleanups = [];
      this.cache = null;
      this.ready = false;
      this.width = 0;
      this.resizeTimeout = null;
      const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();
      // Make sure this is declared before calling handleSplit() in case revert() is called inside an effect callback
      this.resizeObserver = new ResizeObserver(() => {
        // Use a setTimeout instead of a Timer for better tree shaking
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = setTimeout(() => {
          const currentWidth = /** @type {HTMLElement} */($target).offsetWidth;
          if (currentWidth === this.width) return;
          this.width = currentWidth;
          handleSplit();
        }, 150);
      });
      // Only declare the font ready promise when splitting by lines and not alreay split
      if (this.lineTemplate && !this.ready) {
        doc.fonts.ready.then(handleSplit);
      } else {
        handleSplit();
      }
      $target ? this.resizeObserver.observe($target) : console.warn('No Text Splitter target found.');
    }

    /**
     * @param  {(...args: any[]) => Tickable | (() => void)} effect
     * @return this
     */
    addEffect(effect) {
      if (!isFnc(effect)) return console.warn('Effect must return a function.');
      const refreshableEffect = keepTime(effect);
      this.effects.push(refreshableEffect);
      if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);
      return this;
    }

    revert() {
      clearTimeout(this.resizeTimeout);
      this.lines.length = this.words.length = this.chars.length = 0;
      this.resizeObserver.disconnect();
      // Make sure to revert the effects after disconnecting the resizeObserver to avoid triggering it in the process
      this.effectsCleanups.forEach(cleanup => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());
      this.$target.innerHTML = this.html;
      return this;
    }

    /**
     * Recursively processes a node and its children
     * @param {Node} node
     */
    splitNode(node) {
      const wordTemplate = this.wordTemplate;
      const charTemplate = this.charTemplate;
      const includeSpaces = this.includeSpaces;
      const debug = this.debug;
      const nodeType = node.nodeType;
      if (nodeType === 3) {
        const nodeText = node.nodeValue;
        // If the nodeText is only whitespace, leave it as is
        if (nodeText.trim()) {
          const tempWords = [];
          const words = this.words;
          const chars = this.chars;
          const wordSegments = wordSegmenter.segment(nodeText);
          const $wordsFragment = doc.createDocumentFragment();
          let prevSeg = null;
          for (const wordSegment of wordSegments) {
            const segment = wordSegment.segment;
            const isWordLike = isSegmentWordLike(wordSegment);
            // Determine if this segment should be a new word, first segment always becomes a new word
            if (!prevSeg || (isWordLike && (prevSeg && (isSegmentWordLike(prevSeg))))) {
              tempWords.push(segment);
            } else {
              // Only concatenate if both current and previous are non-word-like and don't contain spaces
              const lastWordIndex = tempWords.length - 1;
              const lastWord = tempWords[lastWordIndex];
              if (!whiteSpaceGroupRgx.test(lastWord) && !whiteSpaceGroupRgx.test(segment)) {
                tempWords[lastWordIndex] += segment;
              } else {
                tempWords.push(segment);
              }
            }
            prevSeg = wordSegment;
          }

          for (let i = 0, l = tempWords.length; i < l; i++) {
            const word = tempWords[i];
            if (!word.trim()) {
              // Preserve whitespace only if includeSpaces is false and if the current space is not the first node
              if (i && includeSpaces) continue;
              $wordsFragment.appendChild(doc.createTextNode(word));
            } else {
              const nextWord = tempWords[i + 1];
              const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();
              const wordToProcess = word;
              const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;
              const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + '\xa0' : word);
              if (charTemplate) {
                const charSegmentsArray = [...charSegments];
                for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {
                  const charSegment = charSegmentsArray[j];
                  const isLastChar = j === jl - 1;
                  // If this is the last character and includeSpaces is true with a following space, append the space
                  const charText = isLastChar && hasWordFollowingSpace ? charSegment.segment + '\xa0' : charSegment.segment;
                  const $charNode = doc.createTextNode(charText);
                  processHTMLTemplate(charTemplate, chars, $charNode, /** @type {DocumentFragment} */($charsFragment), charType, debug, -1, words.length, chars.length);
                }
              }
              if (wordTemplate) {
                processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);
                // Chars elements must be re-parsed in the split() method if both words and chars are parsed
              } else if (charTemplate) {
                $wordsFragment.appendChild($charsFragment);
              } else {
                $wordsFragment.appendChild(doc.createTextNode(word));
              }
              // Skip the next iteration if we included a space
              if (hasWordFollowingSpace) i++;
            }
          }
          node.parentNode.replaceChild($wordsFragment, node);
        }
      } else if (nodeType === 1) {
        // Converting to an array is necessary to work around childNodes pottential mutation
        const childNodes = /** @type {Array<Node>} */([.../** @type {*} */(node.childNodes)]);
        for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);
      }
    }

    /**
     * @param {Boolean} clearCache
     * @return {this}
     */
    split(clearCache = false) {
      const $el = this.$target;
      const isCached = !!this.cache && !clearCache;
      const lineTemplate = this.lineTemplate;
      const wordTemplate = this.wordTemplate;
      const charTemplate = this.charTemplate;
      const fontsReady = doc.fonts.status !== 'loading';
      const canSplitLines = lineTemplate && fontsReady;
      this.ready = !lineTemplate || fontsReady;
      if (canSplitLines || clearCache) {
        // No need to revert effects animations here since it's already taken care by the refreshable
        this.effectsCleanups.forEach(cleanup => isFnc(cleanup) && cleanup(this));
      }
      if (!isCached) {
        if (clearCache) {
          $el.innerHTML = this.html;
          this.words.length = this.chars.length = 0;
        }
        this.splitNode($el);
        this.cache = $el.innerHTML;
      }
      if (canSplitLines) {
        if (isCached) $el.innerHTML = this.cache;
        this.lines.length = 0;
        if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);
      }
      // Always reparse characters after a line reset or if both words and chars are activated
      if (charTemplate && (canSplitLines || wordTemplate)) {
        this.chars = getAllTopLevelElements($el, charType);
      }
      // Words are used when lines only and prioritized over chars
      const elementsArray = this.words.length ? this.words : this.chars;
      let y, linesCount = 0;
      for (let i = 0, l = elementsArray.length; i < l; i++) {
        const $el = elementsArray[i];
        const { top, height } = $el.getBoundingClientRect();
        if (!isUnd(y) && top - y > height * .5) linesCount++;
        $el.setAttribute(dataLine, `${linesCount}`);
        const nested = $el.querySelectorAll(`[${dataLine}]`);
        let c = nested.length;
        while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);
        y = top;
      }
      if (canSplitLines) {
        const linesFragment = doc.createDocumentFragment();
        const parents = new Set();
        const clones = [];
        for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {
          const $clone = /** @type {HTMLElement} */($el.cloneNode(true));
          filterLineElements($clone, lineIndex, new Set()).forEach($el => {
            const $parent = $el.parentNode;
            if ($parent) {
              if ($el.nodeType === 1) parents.add(/** @type {HTMLElement} */($parent));
              $parent.removeChild($el);
            }
          });
          clones.push($clone);
        }
        parents.forEach(filterEmptyElements);
        for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) {
          processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);
        }
        $el.innerHTML = '';
        $el.appendChild(linesFragment);
        if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);
        if (charTemplate) this.chars = getAllTopLevelElements($el, charType);
      }

      // Remove the word wrappers and clear the words array if lines split only
      if (this.linesOnly) {
        const words = this.words;
        let w = words.length;
        while (w--) {
          const $word = words[w];
          $word.replaceWith($word.textContent);
        }
        words.length = 0;
      }
      if (this.accessible && (canSplitLines || !isCached)) {
        const $accessible = doc.createElement('span');
        // Make the accessible element visually-hidden (https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html)
        $accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;
        // $accessible.setAttribute('tabindex', '-1');
        $accessible.innerHTML = this.html;
        $el.insertBefore($accessible, $el.firstChild);
        this.lines.forEach(setAriaHidden);
        this.words.forEach(setAriaHidden);
        this.chars.forEach(setAriaHidden);
      }
      this.width = /** @type {HTMLElement} */($el).offsetWidth;
      if (canSplitLines || clearCache) {
        this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));
      }
      return this;
    }

    refresh() {
      this.split(true);
    }
  }

  /**
   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target
   * @param  {TextSplitterParams} [parameters]
   * @return {TextSplitter}
   */
  const splitText = (target, parameters) => new TextSplitter(target, parameters);

  /**
   * @deprecated text.split() is deprecated, import splitText() directly, or text.splitText()
   *
   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target
   * @param  {TextSplitterParams} [parameters]
   * @return {TextSplitter}
   */
  const split = (target, parameters) => {
    console.warn('text.split() is deprecated, import splitText() directly, or text.splitText()');
    return new TextSplitter(target, parameters);
  };

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TextSplitter: TextSplitter,
    split: split,
    splitText: splitText
  });

  exports.$ = registerTargets;
  exports.Animatable = Animatable;
  exports.AutoLayout = AutoLayout;
  exports.Draggable = Draggable;
  exports.JSAnimation = JSAnimation;
  exports.Scope = Scope;
  exports.ScrollObserver = ScrollObserver;
  exports.Spring = Spring;
  exports.TextSplitter = TextSplitter;
  exports.Timeline = Timeline;
  exports.Timer = Timer;
  exports.WAAPIAnimation = WAAPIAnimation;
  exports.animate = animate;
  exports.clamp = clamp;
  exports.cleanInlineStyles = cleanInlineStyles;
  exports.createAnimatable = createAnimatable;
  exports.createDraggable = createDraggable;
  exports.createDrawable = createDrawable;
  exports.createLayout = createLayout;
  exports.createMotionPath = createMotionPath;
  exports.createScope = createScope;
  exports.createSeededRandom = createSeededRandom;
  exports.createSpring = createSpring;
  exports.createTimeline = createTimeline;
  exports.createTimer = createTimer;
  exports.cubicBezier = cubicBezier;
  exports.damp = damp;
  exports.degToRad = degToRad;
  exports.eases = eases;
  exports.easings = index$3;
  exports.engine = engine;
  exports.get = get;
  exports.irregular = irregular;
  exports.keepTime = keepTime;
  exports.lerp = lerp;
  exports.linear = linear;
  exports.mapRange = mapRange;
  exports.morphTo = morphTo;
  exports.onScroll = onScroll;
  exports.padEnd = padEnd;
  exports.padStart = padStart;
  exports.radToDeg = radToDeg;
  exports.random = random;
  exports.randomPick = randomPick;
  exports.remove = remove;
  exports.round = round;
  exports.roundPad = roundPad;
  exports.scrollContainers = scrollContainers;
  exports.set = set;
  exports.shuffle = shuffle;
  exports.snap = snap;
  exports.split = split;
  exports.splitText = splitText;
  exports.spring = spring;
  exports.stagger = stagger;
  exports.steps = steps;
  exports.svg = index$1;
  exports.sync = sync;
  exports.text = index;
  exports.utils = index$2;
  exports.waapi = waapi;
  exports.wrap = wrap;

}));


## Links discovered
- [y](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [j](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [l](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [prop](https://github.com/juliangarnier/anime/blob/master/dist/bundles/...nextArgs)

--- dist/bundles/anime.umd.min.js ---
/**
 * Anime.js - UMD minified bundle
 * @version v4.3.0
 * @license MIT
 * @copyright 2026 - Julian Garnier
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).anime={})}(this,function(t){"use strict";const e="undefined"!=typeof window,s=e?window:null,i=e?document:null,r={replace:0,none:1,blend:2},n=Symbol(),o=Symbol(),a=Symbol(),l=Symbol(),h=Symbol(),d=Symbol(),c=1e-11,u=1e12,p=1e3,m="",f=(()=>{const t=new Map;return t.set("x","translateX"),t.set("y","translateY"),t.set("z","translateZ"),t})(),g=["translateX","translateY","translateZ","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","matrix","matrix3d","perspective"],y=g.reduce((t,e)=>({...t,[e]:e+"("}),{}),v=()=>{},_=/(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i,b=/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i,T=/rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i,x=/hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i,w=/hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i,S=/[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi,$=/^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i,E=/([a-z])([A-Z])/g,k=/(\w+)(\([^)]+\)+)/g,C=/(\*=|\+=|-=)/,N=/var\(\s*(--[\w-]+)(?:\s*,\s*([^)]+))?\s*\)/,D={id:null,keyframes:null,playbackEase:null,playbackRate:1,frameRate:240,loop:0,reversed:!1,alternate:!1,autoplay:!0,persist:!1,duration:p,delay:0,loopDelay:0,ease:"out(2)",composition:r.replace,modifier:t=>t,onBegin:v,onBeforeUpdate:v,onUpdate:v,onLoop:v,onPause:v,onComplete:v,onRender:v},I={current:null,root:i},L={defaults:D,precision:4,timeScale:1,tickThreshold:200},A=e&&s.AnimeJSDevTools,B={version:"4.3.0",engine:null};e&&(s.AnimeJS||(s.AnimeJS=[]),s.AnimeJS.push(B));const R=t=>t.replace(E,"$1-$2").toLowerCase(),P=(t,e)=>0===t.indexOf(e),F=Date.now,V=Array.isArray,M=t=>t&&t.constructor===Object,O=t=>"number"==typeof t&&!isNaN(t),z=t=>"string"==typeof t,H=t=>"function"==typeof t,X=t=>void 0===t,Y=t=>X(t)||null===t,W=t=>e&&t instanceof SVGElement,U=t=>_.test(t),q=t=>P(t,"rgb")&&")"===t[t.length-1],j=t=>P(t,"hsl")&&")"===t[t.length-1],G=t=>!L.defaults.hasOwnProperty(t),Q=["opacity","rotate","overflow","color"],Z=t=>z(t)?parseFloat(t):t,J=Math.pow,K=Math.sqrt,tt=Math.sin,et=Math.cos,st=Math.abs,it=Math.exp,rt=Math.ceil,nt=Math.floor,ot=Math.asin,at=Math.max,lt=Math.atan2,ht=Math.PI,dt=Math.round,ct=(t,e,s)=>t<e?e:t>s?s:t,ut={},pt=(t,e)=>{if(e<0)return t;if(!e)return dt(t);let s=ut[e];return s||(s=ut[e]=10**e),dt(t*s)/s},mt=(t,e)=>V(e)?e.reduce((e,s)=>st(s-t)<st(e-t)?s:e):e?dt(t/e)*e:t,ft=(t,e,s)=>t+(e-t)*s,gt=t=>t===1/0?u:t===-1/0?-u:t,yt=t=>t<=c?c:gt(pt(t,11)),vt=t=>V(t)?[...t]:t,_t=(t,e)=>{const s={...t};for(let i in e){const r=t[i];s[i]=X(r)?e[i]:r}return s},bt=(t,e,s,i="_prev",r="_next")=>{let n=t._head,o=r;for(s&&(n=t._tail,o=i);n;){const t=n[o];e(n),n=t}},Tt=(t,e,s="_prev",i="_next")=>{const r=e[s],n=e[i];r?r[i]=n:t._head=n,n?n[s]=r:t._tail=r,e[s]=null,e[i]=null},xt=(t,e,s,i="_prev",r="_next")=>{let n=t._tail;for(;n&&s&&s(n,e);)n=n[i];const o=n?n[r]:t._head;n?n[r]=e:t._head=e,o?o[i]=e:t._tail=e,e[i]=n,e[r]=o},wt=(t,e,s)=>(s<0&&(s+=1),s>1&&(s-=1),s<1/6?t+6*(e-t)*s:s<.5?e:s<2/3?t+(e-t)*(2/3-s)*6:t),St=(t,e)=>X(t)?e:t,$t=(t,e,s,i,r)=>{let n;if(H(t))n=()=>{const r=t(e,s,i);return isNaN(+r)?r||0:+r};else{if(!z(t)||!P(t,"var("))return t;n=()=>{const s=t.match(N),i=s[1],r=s[2];let n=getComputedStyle(e)?.getPropertyValue(i);return n&&n.trim()!==m||!r||(n=r.trim()),n||0}}return r&&(r.func=n),n()},Et=(t,e)=>t[o]?t[a]&&((t,e)=>{if(Q.includes(e))return!1;if(t.getAttribute(e)||e in t){if("scale"===e){const e=t.parentNode;return e&&"filter"===e.tagName}return!0}})(t,e)?1:g.includes(e)||f.get(e)?3:P(e,"--")?4:e in t.style?2:e in t?0:1:0,kt=(t,e,s)=>{const i=t.style[e];i&&s&&(s[e]=i);const r=i||getComputedStyle(t[d]||t).getPropertyValue(e);return"auto"===r?"0":r},Ct=(t,e,s,i)=>{const r=X(s)?Et(t,e):s;return 0===r?t[e]||0:1===r?t.getAttribute(e):3===r?((t,e,s)=>{const i=t.style.transform;let r;if(i){const n=t[l];let o;for(;o=k.exec(i);){const t=o[1],i=o[2].slice(1,-1);n[t]=i,t===e&&(r=i,s&&(s[e]=i))}}return i&&!X(r)?r:P(e,"scale")?"1":P(e,"rotate")||P(e,"skew")?"0deg":"0px"})(t,e,i):4===r?kt(t,e,i).trimStart():kt(t,e,i)},Nt=(t,e,s)=>"-"===s?t-e:"+"===s?t+e:t*e,Dt=(t,e)=>{if(e.t=0,e.n=0,e.u=null,e.o=null,e.d=null,e.s=null,!t)return e;const s=+t;if(isNaN(s)){let s=t;"="===s[1]&&(e.o=s[0],s=s.slice(2));const n=!s.includes(" ")&&$.exec(s);if(n)return e.t=1,e.n=+n[1],e.u=n[2],e;if(e.o)return e.n=+s,e;if(U(r=s)||q(r)||j(r))return e.t=2,e.d=q(i=s)?(t=>{const e=b.exec(t)||T.exec(t),s=X(e[4])?1:+e[4];return[+e[1],+e[2],+e[3],s]})(i):U(i)?(t=>{const e=t.length,s=4===e||5===e;return[+("0x"+t[1]+t[s?1:2]),+("0x"+t[s?2:3]+t[s?2:4]),+("0x"+t[s?3:5]+t[s?3:6]),5===e||9===e?+(+("0x"+t[s?4:7]+t[s?4:8])/255).toFixed(3):1]})(i):j(i)?(t=>{const e=x.exec(t)||w.exec(t),s=+e[1]/360,i=+e[2]/100,r=+e[3]/100,n=X(e[4])?1:+e[4];let o,a,l;if(0===i)o=a=l=r;else{const t=r<.5?r*(1+i):r+i-r*i,e=2*r-t;o=pt(255*wt(e,t,s+1/3),0),a=pt(255*wt(e,t,s),0),l=pt(255*wt(e,t,s-1/3),0)}return[o,a,l,n]})(i):[0,0,0,1],e;{const t=s.match(S);return e.t=3,e.d=t?t.map(Number):[],e.s=s.split(S)||[],e}}var i,r;return e.n=s,e},It=(t,e)=>(e.t=t._valueType,e.n=t._toNumber,e.u=t._unit,e.o=null,e.d=vt(t._toNumbers),e.s=vt(t._strings),e),Lt={t:0,n:0,u:null,o:null,d:null,s:null},At=(t,e,s,i,n)=>{const o=t.parent,a=t.duration,h=t.completed,d=t.iterationDuration,u=t.iterationCount,p=t._currentIteration,f=t._loopDelay,g=t._reversed,v=t._alternate,_=t._hasChildren,b=t._delay,T=t._currentTime,x=b+d,w=e-b,S=ct(T,-b,a),$=ct(w,-b,a),E=w-T,k=$>0,C=$>=a,N=a<=c,D=2===n;let I=0,A=w,B=0;if(u>1){const e=~~($/(d+(C?0:f)));t._currentIteration=ct(e,0,u),C&&t._currentIteration--,I=t._currentIteration%2,A=$%(d+f)||0}const R=g^(v&&I),P=t._ease;let F=C?R?0:a:R?d-A:A;P&&(F=d*P(F/d)||0);const V=(o?o.backwards:w<T)?!R:!!R;if(t._currentTime=w,t._iterationTime=F,t.backwards=V,k&&!t.began?(t.began=!0,s||o&&(V||!o.began)||t.onBegin(t)):w<=0&&(t.began=!1),s||_||!k||t._currentIteration===p||t.onLoop(t),D||1===n&&(e>=b&&e<=x||e<=b&&S>b||e>=x&&S!==a)||F>=x&&S!==a||F<=b&&S>0||e<=S&&S===a&&h||C&&!h&&N){if(k&&(t.computeDeltaTime(S),s||t.onBeforeUpdate(t)),!_){const e=D||(V?-1*E:E)>=L.tickThreshold,n=t._offset+(o?o._offset:0)+b+F;let a,h,d,c,u=t._head,p=0;for(;u;){const t=u._composition,s=u._currentTime,o=u._changeDuration,f=u._absoluteStartTime+u._changeDuration,g=u._nextRep,v=u._prevRep,_=t!==r.none;if((e||(s!==o||n<=f+(g?g._delay:0))&&(0!==s||n>=u._absoluteStartTime))&&(!_||!u._isOverridden&&(!u._isOverlapped||n<=f)&&(!g||g._isOverridden||n<=g._absoluteStartTime)&&(!v||v._isOverridden||n>=v._absoluteStartTime+v._changeDuration+u._delay))){const e=u._currentTime=ct(F-u._startTime,0,o),s=u._ease(e/u._updateDuration),n=u._modifier,m=u._valueType,f=u._tweenType,g=0===f,y=0===m,v=y&&g||0===s||1===s?-1:L.precision;let b,T;if(y)b=T=n(pt(ft(u._fromNumber,u._toNumber,s),v));else if(1===m)T=n(pt(ft(u._fromNumber,u._toNumber,s),v)),b=`${T}${u._unit}`;else if(2===m){const t=u._fromNumbers,e=u._toNumbers,i=pt(ct(n(ft(t[0],e[0],s)),0,255),0),r=pt(ct(n(ft(t[1],e[1],s)),0,255),0),o=pt(ct(n(ft(t[2],e[2],s)),0,255),0),a=ct(n(pt(ft(t[3],e[3],s),v)),0,1);if(b=`rgba(${i},${r},${o},${a})`,_){const t=u._numbers;t[0]=i,t[1]=r,t[2]=o,t[3]=a}}else if(3===m){b=u._strings[0];for(let t=0,e=u._toNumbers.length;t<e;t++){const e=n(pt(ft(u._fromNumbers[t],u._toNumbers[t],s),v)),i=u._strings[t+1];b+=`${i?e+i:e}`,_&&(u._numbers[t]=e)}}if(_&&(u._number=T),i||t===r.blend)u._value=b;else{const t=u.property;a=u.target,g?a[t]=b:1===f?a.setAttribute(t,b):(h=a.style,3===f?(a!==d&&(d=a,c=a[l]),c[t]=b,p=1):2===f?h[t]=b:4===f&&h.setProperty(t,b)),k&&(B=1)}}if(p&&u._renderTransforms){let t=m;for(let e in c)t+=`${y[e]}${c[e]}) `;h.transform=t,p=0}u=u._next}!s&&B&&t.onRender(t)}!s&&k&&t.onUpdate(t)}return o&&N?!s&&(o.began&&!V&&w>0&&!h||V&&w<=c&&h)&&(t.onComplete(t),t.completed=!V):k&&C?u===1/0?t._startTime+=t.duration:t._currentIteration>=u-1&&(t.paused=!0,h||_||(t.completed=!0,s||o&&(V||!o.began)||(t.onComplete(t),t._resolve(t)))):t.completed=!1,B},Bt=(t,e,s,i,r)=>{const n=t._currentIteration;if(At(t,e,s,i,r),t._hasChildren){const o=t,a=o.backwards,l=i?e:o._iterationTime,h=F();let d=0,u=!0;if(!i&&o._currentIteration!==n){const t=o.iterationDuration;bt(o,e=>{if(a){const i=e.duration,r=e._offset+e._delay;s||!(i<=c)||r&&r+i!==t||e.onComplete(e)}else!e.completed&&!e.backwards&&e._currentTime<e.iterationDuration&&At(e,t,s,1,2),e.began=!1,e.completed=!1}),s||o.onLoop(o)}bt(o,t=>{const e=pt((l-t._offset)*t._speed,12),n=t._fps<o._fps?t.requestTick(h):r;d+=At(t,e,s,i,n),!t.completed&&u&&(u=!1)},a),!s&&d&&o.onRender(o),(u||a)&&o._currentTime>=o.duration&&(o.paused=!0,o.completed||(o.completed=!0,s||(o.onComplete(o),o._resolve(o))))}},Rt={},Pt=(t,e,s)=>{if(3===s)return f.get(t)||t;if(2===s||1===s&&W(e)&&t in e.style){const e=Rt[t];if(e)return e;{const e=t?R(t):t;return Rt[t]=e,e}}return t},Ft=t=>{if(t._hasChildren)bt(t,Ft,!0);else{const e=t;e.pause(),bt(e,t=>{const s=t.property,i=t.target;if(i[o]){const r=i.style,n=t._inlineValue,o=Y(n)||n===m;if(3===t._tweenType){const e=i[l];if(o?delete e[s]:e[s]=n,t._renderTransforms)if(Object.keys(e).length){let t=m;for(let s in e)t+=y[s]+e[s]+") ";r.transform=t}else r.removeProperty("transform")}else o?r.removeProperty(R(s)):r[s]=n;e._tail===t&&e.targets.forEach(t=>{t.getAttribute&&t.getAttribute("style")===m&&t.removeAttribute("style")})}})}return t};class Vt{constructor(t=0){this.deltaTime=0,this._currentTime=t,this._lastTickTime=t,this._startTime=t,this._lastTime=t,this._scheduledTime=0,this._frameDuration=p/240,this._fps=240,this._speed=1,this._hasChildren=!1,this._head=null,this._tail=null}get fps(){return this._fps}set fps(t){const e=this._frameDuration,s=+t,i=s<c?c:s,r=p/i;i>D.frameRate&&(D.frameRate=i),this._fps=i,this._frameDuration=r,this._scheduledTime+=r-e}get speed(){return this._speed}set speed(t){const e=+t;this._speed=e<c?c:e}requestTick(t){const e=this._scheduledTime;if(this._lastTickTime=t,t<e)return 0;const s=this._frameDuration,i=t-e;return this._scheduledTime+=i<s?s:i,1}computeDeltaTime(t){const e=t-this._lastTime;return this.deltaTime=e,this._lastTime=t,e}}const Mt={animation:null,update:v},Ot=(()=>e?requestAnimationFrame:setImmediate)(),zt=(()=>e?cancelAnimationFrame:clearImmediate)();class Ht extends Vt{constructor(t){super(t),this.useDefaultMainLoop=!0,this.pauseOnDocumentHidden=!0,this.defaults=D,this.paused=!0,this.reqId=0}update(){const t=this._currentTime=F();if(this.requestTick(t)){this.computeDeltaTime(t);const e=this._speed,s=this._fps;let i=this._head;for(;i;){const r=i._next;i.paused?(Tt(this,i),this._hasChildren=!!this._tail,i._running=!1,i.completed&&!i._cancelled&&i.cancel()):Bt(i,(t-i._startTime)*i._speed*e,0,0,i._fps<s?i.requestTick(t):1),i=r}Mt.update()}}wake(){return this.useDefaultMainLoop&&!this.reqId&&(this.requestTick(F()),this.reqId=Ot(Yt)),this}pause(){if(this.reqId)return this.paused=!0,Wt()}resume(){if(this.paused)return this.paused=!1,bt(this,t=>t.resetTime()),this.wake()}get speed(){return this._speed*(1===L.timeScale?1:p)}set speed(t){this._speed=t*L.timeScale,bt(this,t=>t.speed=t._speed)}get timeUnit(){return 1===L.timeScale?"ms":"s"}set timeUnit(t){const e="s"===t,s=e?.001:1;if(L.timeScale!==s){L.timeScale=s,L.tickThreshold=200*s;const t=e?.001:p;this.defaults.duration*=t,this._speed*=t}}get precision(){return L.precision}set precision(t){L.precision=t}}const Xt=(()=>{const t=new Ht(F());return e&&(B.engine=t,i.addEventListener("visibilitychange",()=>{t.pauseOnDocumentHidden&&(i.hidden?t.pause():t.resume())})),t})(),Yt=()=>{Xt._head?(Xt.reqId=Ot(Yt),Xt.update()):Xt.reqId=0},Wt=()=>(zt(Xt.reqId),Xt.reqId=0,Xt),Ut={_rep:new WeakMap,_add:new Map},qt=(t,e,s="_rep")=>{const i=Ut[s];let r=i.get(t);return r||(r={},i.set(t,r)),r[e]?r[e]:r[e]={_head:null,_tail:null}},jt=(t,e)=>t._isOverridden||t._absoluteStartTime>e._absoluteStartTime,Gt=t=>{t._isOverlapped=1,t._isOverridden=1,t._changeDuration=c,t._currentTime=c},Qt=(t,e)=>{const s=t._composition;if(s===r.replace){const s=t._absoluteStartTime;xt(e,t,jt,"_prevRep","_nextRep");const i=t._prevRep;if(i){const e=i.parent,r=i._absoluteStartTime+i._changeDuration;if(t.parent.id!==e.id&&e.iterationCount>1&&r+(e.duration-e.iterationDuration)>s){Gt(i);let t=i._prevRep;for(;t&&t.parent.id===e.id;)Gt(t),t=t._prevRep}const n=s-t._delay;if(r>n){const t=i._startTime,e=r-(t+i._updateDuration),s=pt(n-e-t,12);i._changeDuration=s,i._currentTime=s,i._isOverlapped=1,s<c&&Gt(i)}let o=!0;if(bt(e,t=>{t._isOverlapped||(o=!1)}),o){const t=e.parent;if(t){let s=!0;bt(t,t=>{t!==e&&bt(t,t=>{t._isOverlapped||(s=!1)})}),s&&t.cancel()}else e.cancel()}}}else if(s===r.blend){const e=qt(t.target,t.property,"_add"),s=(t=>{let e=Mt.animation;return e||(e={duration:c,computeDeltaTime:v,_offset:0,_delay:0,_head:null,_tail:null},Mt.animation=e,Mt.update=()=>{t.forEach(t=>{for(let e in t){const s=t[e],i=s._head;if(i){const t=i._valueType,e=3===t||2===t?vt(i._fromNumbers):null;let r=i._fromNumber,n=s._tail;for(;n&&n!==i;){if(e)for(let t=0,s=n._numbers.length;t<s;t++)e[t]+=n._numbers[t];else r+=n._number;n=n._prevAdd}i._toNumber=r,i._toNumbers=e}}}),At(e,1,1,0,2)}),e})(Ut._add);let i=e._head;i||(i={...t},i._composition=r.replace,i._updateDuration=c,i._startTime=0,i._numbers=vt(t._fromNumbers),i._number=0,i._next=null,i._prev=null,xt(e,i),xt(s,i));const n=t._toNumber;if(t._fromNumber=i._fromNumber-n,t._toNumber=0,t._numbers=vt(t._fromNumbers),t._number=0,i._fromNumber=n,t._toNumbers){const e=vt(t._toNumbers);e&&e.forEach((e,s)=>{t._fromNumbers[s]=i._fromNumbers[s]-e,t._toNumbers[s]=0}),i._fromNumbers=e}xt(e,t,null,"_prevAdd","_nextAdd")}return t},Zt=t=>{const e=t._composition;if(e!==r.none){const s=t.target,i=t.property,n=Ut._rep.get(s)[i];if(Tt(n,t,"_prevRep","_nextRep"),e===r.blend){const e=Ut._add,r=e.get(s);if(!r)return;const n=r[i],o=Mt.animation;Tt(n,t,"_prevAdd","_nextAdd");const a=n._head;if(a&&a===n._tail){Tt(n,a,"_prevAdd","_nextAdd"),Tt(o,a);let t=!0;for(let e in r)if(r[e]._head){t=!1;break}t&&e.delete(s)}}}return t},Jt=(t,e,s)=>{let i=!1;return bt(e,r=>{const n=r.target;if(t.includes(n)){const t=r.property,o=r._tweenType,a=Pt(s,n,o);(!a||a&&a===t)&&(r.parent._tail===r&&3===r._tweenType&&r._prev&&3===r._prev._tweenType&&(r._prev._renderTransforms=1),Tt(e,r),Zt(r),i=!0)}},!0),i},Kt=(t,e,s)=>{const i=e||Xt;let r;if(i._hasChildren){let e=0;bt(i,n=>{if(!n._hasChildren)if(r=Jt(t,n,s),r&&!n._head)n.cancel(),Tt(i,n);else{const t=n._offset+n._delay+n.duration;t>e&&(e=t)}n._head?Kt(t,n,s):n._hasChildren=!1},!0),X(i.iterationDuration)||(i.iterationDuration=e)}else r=Jt(t,i,s);r&&!i._head&&(i._hasChildren=!1,i.cancel&&i.cancel())},te=t=>(t.paused=!0,t.began=!1,t.completed=!1,t),ee=t=>t._cancelled?(t._hasChildren?bt(t,ee):bt(t,t=>{t._composition!==r.none&&Qt(t,qt(t.target,t.property))}),t._cancelled=0,t):t;let se=0;class ie extends Vt{constructor(t={},e=null,s=0){super(0),++se;const{id:i,delay:r,duration:n,reversed:o,alternate:a,loop:l,loopDelay:h,autoplay:d,frameRate:u,playbackRate:p,onComplete:m,onLoop:f,onPause:g,onBegin:y,onBeforeUpdate:_,onUpdate:b}=t;I.current&&I.current.register(this);const T=e?0:Xt._lastTickTime,x=e?e.defaults:L.defaults,w=H(r)||X(r)?x.delay:+r,S=H(n)||X(n)?1/0:+n,$=St(l,x.loop),E=St(h,x.loopDelay);let k=!0===$||$===1/0||$<0?1/0:$+1;if(A){const s=k===1/0;if(A.register(this,t,s)&&s){const t=a?2:1,s=e?A.maxNestedInfiniteLoops:A.maxInfiniteLoops;k=Math.max(s,t)}}let C=0;e?C=s:(Xt.reqId||Xt.requestTick(F()),C=(Xt._lastTickTime-Xt._startTime)*L.timeScale),this.id=X(i)?se:i,this.parent=e,this.duration=gt((S+E)*k-E)||c,this.backwards=!1,this.paused=!0,this.began=!1,this.completed=!1,this.onBegin=y||x.onBegin,this.onBeforeUpdate=_||x.onBeforeUpdate,this.onUpdate=b||x.onUpdate,this.onLoop=f||x.onLoop,this.onPause=g||x.onPause,this.onComplete=m||x.onComplete,this.iterationDuration=S,this.iterationCount=k,this._autoplay=!e&&St(d,x.autoplay),this._offset=C,this._delay=w,this._loopDelay=E,this._iterationTime=0,this._currentIteration=0,this._resolve=v,this._running=!1,this._reversed=+St(o,x.reversed),this._reverse=this._reversed,this._cancelled=0,this._alternate=St(a,x.alternate),this._prev=null,this._next=null,this._lastTickTime=T,this._startTime=T,this._lastTime=T,this._fps=St(u,x.frameRate),this._speed=St(p,x.playbackRate)}get cancelled(){return!!this._cancelled}set cancelled(t){t?this.cancel():this.reset(!0).play()}get currentTime(){return ct(pt(this._currentTime,L.precision),-this._delay,this.duration)}set currentTime(t){const e=this.paused;this.pause().seek(+t),e||this.resume()}get iterationCurrentTime(){return ct(pt(this._iterationTime,L.precision),0,this.iterationDuration)}set iterationCurrentTime(t){this.currentTime=this.iterationDuration*this._currentIteration+t}get progress(){return ct(pt(this._currentTime/this.duration,10),0,1)}set progress(t){this.currentTime=this.duration*t}get iterationProgress(){return ct(pt(this._iterationTime/this.iterationDuration,10),0,1)}set iterationProgress(t){const e=this.iterationDuration;this.currentTime=e*this._currentIteration+e*t}get currentIteration(){return this._currentIteration}set currentIteration(t){this.currentTime=this.iterationDuration*ct(+t,0,this.iterationCount-1)}get reversed(){return!!this._reversed}set reversed(t){t?this.reverse():this.play()}get speed(){return super.speed}set speed(t){super.speed=t,this.resetTime()}reset(t=!1){return ee(this),this._reversed&&!this._reverse&&(this.reversed=!1),this._iterationTime=this.iterationDuration,Bt(this,0,1,~~t,2),te(this),this._hasChildren&&bt(this,te),this}init(t=!1){this.fps=this._fps,this.speed=this._speed,!t&&this._hasChildren&&Bt(this,this.duration,1,~~t,2),this.reset(t);const e=this._autoplay;return!0===e?this.resume():e&&!X(e.linked)&&e.link(this),this}resetTime(){const t=1/(this._speed*Xt._speed);return this._startTime=F()-(this._currentTime+this._delay)*t,this}pause(){return this.paused||(this.paused=!0,this.onPause(this)),this}resume(){return this.paused?(this.paused=!1,this.duration<=c&&!this._hasChildren?Bt(this,c,0,0,2):(this._running||(xt(Xt,this),Xt._hasChildren=!0,this._running=!0),this.resetTime(),this._startTime-=12,Xt.wake()),this):this}restart(){return this.reset().resume()}seek(t,e=0,s=0){ee(this),this.completed=!1;const i=this.paused;return this.paused=!0,Bt(this,t+this._delay,~~e,~~s,1),i?this:this.resume()}alternate(){const t=this._reversed,e=this.iterationCount,s=this.iterationDuration,i=e===1/0?nt(u/s):e;return this._reversed=+(!this._alternate||i%2?!t:t),e===1/0?this.iterationProgress=this._reversed?1-this.iterationProgress:this.iterationProgress:this.seek(s*i-this._currentTime),this.resetTime(),this}play(){return this._reversed&&this.alternate(),this.resume()}reverse(){return this._reversed||this.alternate(),this.resume()}cancel(){return this._hasChildren?bt(this,t=>t.cancel(),!0):bt(this,Zt),this._cancelled=1,this.pause()}stretch(t){const e=this.duration,s=yt(t);if(e===s)return this;const i=t/e,r=t<=c;return this.duration=r?c:s,this.iterationDuration=r?c:yt(this.iterationDuration*i),this._offset*=i,this._delay*=i,this._loopDelay*=i,this}revert(){Bt(this,0,1,0,1);const t=this._autoplay;return t&&t.linked&&t.linked===this&&t.revert(),this.cancel()}complete(t=0){return this.seek(this.duration,t).cancel()}then(t=v){const e=this.then,s=()=>{this.then=null,t(this),this.then=e,this._resolve=v};return new Promise(t=>(this._resolve=()=>t(s()),this.completed&&this._resolve(),this))}}function re(t){const e=z(t)?I.root.querySelectorAll(t):t;if(e instanceof NodeList||e instanceof HTMLCollection)return e}function ne(t){if(Y(t))return[];if(!e)return V(t)&&t.flat(1/0)||[t];if(V(t)){const e=t.flat(1/0),s=[];for(let t=0,i=e.length;t<i;t++){const i=e[t];if(!Y(i)){const t=re(i);if(t)for(let e=0,i=t.length;e<i;e++){const i=t[e];if(!Y(i)){let t=!1;for(let e=0,r=s.length;e<r;e++)if(s[e]===i){t=!0;break}t||s.push(i)}}else{let t=!1;for(let e=0,r=s.length;e<r;e++)if(s[e]===i){t=!0;break}t||s.push(i)}}}return s}const s=re(t);return s?Array.from(s):[t]}function oe(t){const e=ne(t),s=e.length;if(s)for(let t=0;t<s;t++){const s=e[t];if(!s[n]){s[n]=!0;const t=W(s);(s.nodeType||t)&&(s[o]=!0,s[a]=t,s[l]={})}}return e}const ae={deg:1,rad:180/ht,turn:360},le={},he=(t,e,s,r=!1)=>{const n=e.u,o=e.n;if(1===e.t&&n===s)return e;const a=o+n+s,l=le[a];if(X(l)||r){let r;if(n in ae)r=o*ae[n]/ae[s];else{const e=100,a=t.cloneNode(),l=t.parentNode,h=l&&l!==i?l:i.body;h.appendChild(a);const d=a.style;d.width=e+n;const c=a.offsetWidth||e;d.width=e+s;const u=c/(a.offsetWidth||e);h.removeChild(a),r=u*o}e.n=r,le[a]=r}else e.n=l;return e.t,e.u=s,e},de=t=>t,ce=(t=1.68)=>e=>J(e,+t),ue={in:t=>e=>t(e),out:t=>e=>1-t(1-e),inOut:t=>e=>e<.5?t(2*e)/2:1-t(-2*e+2)/2,outIn:t=>e=>e<.5?(1-t(1-2*e))/2:(t(2*e-1)+1)/2},pe=ht/2,me=2*ht,fe={[m]:ce,Quad:ce(2),Cubic:ce(3),Quart:ce(4),Quint:ce(5),Sine:t=>1-et(t*pe),Circ:t=>1-K(1-t*t),Expo:t=>t?J(2,10*t-10):0,Bounce:t=>{let e,s=4;for(;t<((e=J(2,--s))-1)/11;);return 1/J(4,3-s)-7.5625*J((3*e-2)/22-t,2)},Back:(t=1.7)=>e=>(+t+1)*e*e*e-+t*e*e,Elastic:(t=1,e=.3)=>{const s=ct(+t,1,10),i=ct(+e,c,2),r=i/me*ot(1/s),n=me/i;return t=>0===t||1===t?t:-s*J(2,-10*(1-t))*tt((1-t-r)*n)}},ge=(()=>{const t={linear:de,none:de};for(let e in ue)for(let s in fe){const i=fe[s],r=ue[e];t[e+s]=s===m||"Back"===s||"Elastic"===s?(t,e)=>r(i(t,e)):r(i)}return t})(),ye={linear:de,none:de},ve=t=>{if(ye[t])return ye[t];if(t.indexOf("(")<=-1){const e=ue[t]||t.includes("Back")||t.includes("Elastic")?ge[t]():ge[t];return e?ye[t]=e:de}{const e=t.slice(0,-1).split("("),s=ge[e[0]];return s?ye[t]=s(...e[1].split(",")):de}},_e=["steps(","irregular(","linear(","cubicBezier("],be=t=>{if(z(t))for(let e=0,s=_e.length;e<s;e++)if(P(t,_e[e]))return console.warn(`String syntax for \`ease: "${t}"\` has been removed from the core and replaced by importing and passing the easing function directly: \`ease: ${t}\``),de;return H(t)?t:z(t)?ve(t):de},Te={t:0,n:0,u:null,o:null,d:null,s:null},xe={t:0,n:0,u:null,o:null,d:null,s:null},we={},Se={func:null},$e=[null],Ee=[null,null],ke={to:null};let Ce,Ne,De=0,Ie=0;class Le extends ie{constructor(t,e,s,i,n=!1,o=0,a=0){super(e,s,i),++Ie;const l=oe(t),h=l.length,d=e.keyframes,u=d?_t(((t,e)=>{const s={};if(V(t)){const e=[].concat(...t.map(t=>Object.keys(t))).filter(G);for(let i=0,r=e.length;i<r;i++){const r=e[i],n=t.map(t=>{const e={};for(let s in t){const i=t[s];G(s)?s===r&&(e.to=i):e[s]=i}return e});s[r]=n}}else{const i=St(e.duration,L.defaults.duration),r=Object.keys(t).map(e=>({o:parseFloat(e)/100,p:t[e]})).sort((t,e)=>t.o-e.o);r.forEach(t=>{const e=t.o,r=t.p;for(let t in r)if(G(t)){let n=s[t];n||(n=s[t]=[]);const o=e*i;let a=n.length,l=n[a-1];const h={to:r[t]};let d=0;for(let t=0;t<a;t++)d+=n[t].duration;1===a&&(h.from=l.to),r.ease&&(h.ease=r.ease),h.duration=o-(a?d:0),n.push(h)}return t});for(let t in s){const e=s[t];let i;for(let t=0,s=e.length;t<s;t++){const s=e[t],r=s.ease;s.ease=i||void 0,i=r}e[0].duration||e.shift()}}return s})(d,e),e):e,{id:m,delay:f,duration:g,ease:y,playbackEase:v,modifier:_,composition:b,onRender:T}=u,x=s?s.defaults:L.defaults,w=St(y,x.ease),S=St(v,x.playbackEase),$=S?be(S):null,E=!X(w.ease),k=E?w.ease:St(y,$?"linear":x.ease),C=E?w.settlingDuration:St(g,x.duration),N=St(f,x.delay),D=_||x.modifier,I=X(b)&&h>=p?r.none:X(b)?x.composition:b,A=this._offset+(s?s._offset:0);E&&(w.parent=this);let B=NaN,R=NaN,P=0,F=0;for(let t=0;t<h;t++){const e=l[t],i=o||t,d=a||h;let p=NaN,m=NaN;for(let t in u)if(G(t)){const o=Et(e,t),a=Pt(t,e,o);let l=u[t];const h=V(l);if(n&&!h&&(Ee[0]=l,Ee[1]=l,l=Ee),h){const t=l.length,e=!M(l[0]);2===t&&e?(ke.to=l,$e[0]=ke,Ce=$e):t>2&&e?(Ce=[],l.forEach((t,e)=>{e?1===e?(Ee[1]=t,Ce.push(Ee)):Ce.push(t):Ee[0]=t})):Ce=l}else $e[0]=l,Ce=$e;let f=null,g=null,y=NaN,v=0,_=0;for(let t=Ce.length;_<t;_++){const n=Ce[_];M(n)?Ne=n:(ke.to=n,Ne=ke),Se.func=null;const l=$t(Ne.to,e,i,d,Se);let h;M(l)&&!X(l.to)?(Ne=l,h=l.to):h=l;const u=$t(Ne.from,e,i,d),p=Ne.ease||k,m=$t(p,e,i,d),b=H(m)||z(m)?m:p,T=!X(b)&&!X(b.ease),x=T?b.ease:b,w=T?b.settlingDuration:$t(St(Ne.duration,t>1?$t(C,e,i,d)/t:C),e,i,d),S=$t(St(Ne.delay,_?0:N),e,i,d),$=$t(St(Ne.composition,I),e,i,d),E=O($)?$:r[$],L=Ne.modifier||D,B=!X(u),R=!X(h),W=V(h),U=W||B&&R,q=g?v+S:S,j=pt(A+q,12);F||!B&&!W||(F=1);let G=g;if(E!==r.none){f||(f=qt(e,a));let t=f._head;for(;t&&!t._isOverridden&&t._absoluteStartTime<=j;)if(G=t,t=t._nextRep,t&&t._absoluteStartTime>=j)for(;t;)Gt(t),t=t._nextRep}if(U){Dt(W?$t(h[0],e,i,d):u,Te),Dt(W?$t(h[1],e,i,d,Se):h,xe);const t=Ct(e,a,o,we);0===Te.t&&(G?1===G._valueType&&(Te.t=1,Te.u=G._unit):(Dt(t,Lt),1===Lt.t&&(Te.t=1,Te.u=Lt.u)))}else R?Dt(h,xe):g?It(g,xe):Dt(s&&G&&G.parent.parent===s?G._value:Ct(e,a,o,we),xe),B?Dt(u,Te):g?It(g,Te):Dt(s&&G&&G.parent.parent===s?G._value:Ct(e,a,o,we),Te);if(Te.o&&(Te.n=Nt(G?G._toNumber:Dt(Ct(e,a,o,we),Lt).n,Te.n,Te.o)),xe.o&&(xe.n=Nt(Te.n,xe.n,xe.o)),Te.t!==xe.t)if(3===Te.t||3===xe.t){const t=3===Te.t?Te:xe,e=3===Te.t?xe:Te;e.t=3,e.s=vt(t.s),e.d=t.d.map(()=>e.n)}else if(1===Te.t||1===xe.t){const t=1===Te.t?Te:xe,e=1===Te.t?xe:Te;e.t=1,e.u=t.u}else if(2===Te.t||2===xe.t){const t=2===Te.t?Te:xe,e=2===Te.t?xe:Te;e.t=2,e.s=t.s,e.d=[0,0,0,1]}if(Te.u!==xe.u){let t=xe.u?Te:xe;t=he(e,t,xe.u?xe.u:Te.u,!1)}if(xe.d&&Te.d&&xe.d.length!==Te.d.length){const t=Te.d.length>xe.d.length?Te:xe,e=t===Te?xe:Te;e.d=t.d.map((t,s)=>X(e.d[s])?0:e.d[s]),e.s=vt(t.s)}const Q=pt(+w||c,12);let Z=we[a];Y(Z)||(we[a]=null);const J={parent:this,id:De++,property:a,target:e,_value:null,_func:Se.func,_ease:be(x),_fromNumbers:vt(Te.d),_toNumbers:vt(xe.d),_strings:vt(xe.s),_fromNumber:Te.n,_toNumber:xe.n,_numbers:vt(Te.d),_number:Te.n,_unit:xe.u,_modifier:L,_currentTime:0,_startTime:q,_delay:+S,_updateDuration:Q,_changeDuration:Q,_absoluteStartTime:j,_tweenType:o,_valueType:xe.t,_composition:E,_isOverlapped:0,_isOverridden:0,_renderTransforms:0,_inlineValue:Z,_prevRep:null,_nextRep:null,_prevAdd:null,_nextAdd:null,_prev:null,_next:null};E!==r.none&&Qt(J,f),isNaN(y)&&(y=J._startTime),v=pt(q+Q,12),g=J,P++,xt(this,J)}(isNaN(R)||y<R)&&(R=y),(isNaN(B)||v>B)&&(B=v),3===o&&(p=P-_,m=P)}if(!isNaN(p)){let t=0;bt(this,e=>{t>=p&&t<m&&(e._renderTransforms=1,e._composition===r.blend&&bt(Mt.animation,t=>{t.id===e.id&&(t._renderTransforms=1)})),t++})}}h||console.warn("No target found. Make sure the element you're trying to animate is accessible before creating your animation."),R?(bt(this,t=>{t._startTime-t._delay||(t._delay-=R),t._startTime-=R}),B-=R):R=0,B||(B=c,this.iterationCount=0),this.targets=l,this.id=X(m)?Ie:m,this.duration=B===c?c:gt((B+this._loopDelay)*this.iterationCount-this._loopDelay)||c,this.onRender=T||x.onRender,this._ease=$,this._delay=R,this.iterationDuration=B,!this._autoplay&&F&&this.onRender(this)}stretch(t){const e=this.duration;if(e===yt(t))return this;const s=t/e;return bt(this,t=>{t._updateDuration=yt(t._updateDuration*s),t._changeDuration=yt(t._changeDuration*s),t._currentTime*=s,t._startTime*=s,t._absoluteStartTime*=s}),super.stretch(t)}refresh(){return bt(this,t=>{const e=t._func;if(e){const s=Ct(t.target,t.property,t._tweenType);Dt(s,Lt),Dt(e(),xe),t._fromNumbers=vt(Lt.d),t._fromNumber=Lt.n,t._toNumbers=vt(xe.d),t._strings=vt(xe.s),t._toNumber=xe.o?Nt(Lt.n,xe.n,xe.o):xe.n}}),this.duration===c&&this.restart(),this}revert(){return super.revert(),Ft(this)}then(t){return super.then(t)}}const Ae={_head:null,_tail:null},Be=(t,e,s)=>{let i,r=Ae._head;for(;r;){const n=r._next,o=r.$el===t,a=!e||r.property===e,l=!s||r.parent===s;if(o&&a&&l){i=r.animation;try{i.commitStyles()}catch{}i.cancel(),Tt(Ae,r);const t=r.parent;t&&(t._completed++,t.animations.length===t._completed&&(t.completed=!0,t.paused=!0,t.muteCallbacks||(t.onComplete(t),t._resolve(t))))}r=n}return i},Re=(t,e,s,i,r)=>{const n=e.animate(i,r),o=r.delay+ +r.duration*r.iterations;n.playbackRate=t._speed,t.paused&&n.pause(),t.duration<o&&(t.duration=o,t.controlAnimation=n),t.animations.push(n),Be(e,s),xt(Ae,{parent:t,animation:n,$el:e,property:s,_next:null,_prev:null});const a=()=>{Be(e,s,t)};return n.oncancel=a,n.onremove=a,t.persist||(n.onfinish=a),n};function Pe(t,e,s){const i=oe(t);if(!i.length)return;const[r]=i,n=Et(r,e),o=Pt(e,r,n);let a=Ct(r,o);if(X(s))return a;if(Dt(a,Lt),0===Lt.t||1===Lt.t){if(!1===s)return Lt.n;{const t=he(r,Lt,s,!1);return`${pt(t.n,L.precision)}${t.u}`}}}const Fe=(t,e)=>{if(!X(e))return e.duration=c,e.composition=St(e.composition,r.none),new Le(t,e,null,0,!0).resume()},Ve=(t,e,s)=>{const i=ne(t);for(let t=0,r=i.length;t<r;t++)Be(i[t],s,e&&e.controlAnimation&&e);return Kt(i,e,s),i},Me=(t,e)=>{let s=t.iterationDuration;if(s===c&&(s=0),X(e))return s;if(O(+e))return+e;const i=e,r=t?t.labels:null,n=!Y(r),o=((t,e)=>{if(P(e,"<")){const s="<"===e[1],i=t._tail,r=i?i._offset+i._delay:0;return s?r:r+i.duration}})(t,i),a=!X(o),l=C.exec(i);if(l){const t=l[0],e=i.split(t),h=n&&e[0]?r[e[0]]:s,d=a?o:n?h:s,c=+e[1];return Nt(d,c,t[0])}return a?o:n?X(r[i])?s:r[i]:s};function Oe(t,e,s,i,r,n){const o=O(t.duration)&&t.duration<=c?s-c:s;e.composition&&Bt(e,o,1,1,1);const a=i?new Le(i,t,e,o,!1,r,n):new ie(t,e,o);return e.composition&&a.init(!0),xt(e,a),bt(e,t=>{const s=t._offset+t._delay+t.duration;s>e.iterationDuration&&(e.iterationDuration=s)}),e.duration=function(t){return gt((t.iterationDuration+t._loopDelay)*t.iterationCount-t._loopDelay)||c}(e),e}let ze=0;class He extends ie{constructor(t={}){super(t,null,0),++ze,this.id=X(t.id)?ze:t.id,this.duration=0,this.labels={};const e=t.defaults,s=L.defaults;this.defaults=e?_t(e,s):s,this.composition=St(t.composition,!0),this.onRender=t.onRender||s.onRender;const i=St(t.playbackEase,s.playbackEase);this._ease=i?be(i):null,this.iterationDuration=0}add(t,e,s){const i=M(e),r=M(t);if(i||r){if(this._hasChildren=!0,i){const i=e;if(H(s)){const e=s,r=ne(t),n=this.duration,o=this.iterationDuration,a=i.id;let l=0;const h=r.length;r.forEach(t=>{const s={...i};this.duration=n,this.iterationDuration=o,X(a)||(s.id=a+"-"+l),Oe(s,this,Me(this,e(t,l,h,this)),t,l,h),l++})}else Oe(i,this,Me(this,s),t)}else Oe(t,this,Me(this,e));return this.composition&&this.init(!0),this}}sync(t,e){if(X(t)||t&&X(t.pause))return this;t.pause();const s=+(t.effect?t.effect.getTiming().duration:t.duration);return this.add(t,{currentTime:[0,s],duration:s,delay:0,ease:"linear",playbackEase:"linear"},e)}set(t,e,s){return X(e)?this:(e.duration=c,e.composition=r.replace,this.add(t,e,s))}call(t,e){return X(t)||t&&!H(t)?this:this.add({duration:0,delay:0,onComplete:()=>t(this)},e)}label(t,e){return X(t)||t&&!z(t)||(this.labels[t]=Me(this,e)),this}remove(t,e){return Kt(ne(t),this,e),this}stretch(t){const e=this.duration;if(e===yt(t))return this;const s=t/e,i=this.labels;bt(this,t=>t.stretch(t.duration*s));for(let t in i)i[t]*=s;return super.stretch(t)}refresh(){return bt(this,t=>{t.refresh&&t.refresh()}),this}revert(){return super.revert(),bt(this,t=>t.revert,!0),Ft(this)}then(t){return super.then(t)}}const Xe=t=>new He(t).init();class Ye{constructor(t,e){I.current&&I.current.register(this);const s=()=>{if(this.callbacks.completed)return;let t=!0;for(let e in this.animations)if(!this.animations[e].paused&&t){t=!1;break}t&&this.callbacks.complete()},i={onBegin:()=>{this.callbacks.completed&&this.callbacks.reset(),this.callbacks.play()},onComplete:s,onPause:s},n={v:1,autoplay:!1},o={};if(this.targets=[],this.animations={},this.callbacks=null,!X(t)&&!X(e)){for(let t in e){const s=e[t];G(t)?o[t]=s:P(t,"on")?n[t]=s:i[t]=s}this.callbacks=new Le({v:0},n);for(let e in o){const s=o[e],n=M(s);let a={},l="+=0";if(n){const t=s.unit;z(t)&&(l+=t)}else a.duration=s;a[e]=n?_t({to:l},s):l;const h=_t(i,a);h.composition=r.replace,h.autoplay=!1;const d=this.animations[e]=new Le(t,h,null,0,!1).init();this.targets.length||this.targets.push(...d.targets),this[e]=(t,e,s)=>{const i=d._head;if(X(t)&&i){const t=i._numbers;return t&&t.length?t:i._modifier(i._number)}return bt(d,e=>{if(V(t))for(let s=0,i=t.length;s<i;s++)X(e._numbers[s])||(e._fromNumbers[s]=e._modifier(e._numbers[s]),e._toNumbers[s]=t[s]);else e._fromNumber=e._modifier(e._number),e._toNumber=t;X(s)||(e._ease=be(s)),e._currentTime=0}),X(e)||d.stretch(e),d.reset(!0).resume(),this}}}}revert(){for(let t in this.animations)this[t]=v,this.animations[t].revert();return this.animations={},this.targets.length=0,this.callbacks&&this.callbacks.revert(),this}}const We=(t,e,s,i,r)=>i+(t-e)/(s-e)*(r-i);var Ue=Object.freeze({__proto__:null,clamp:ct,damp:(t,e,s,i)=>i?1===i?e:ft(t,e,1-Math.exp(-i*s*.1)):t,degToRad:t=>t*Math.PI/180,lerp:ft,mapRange:We,padEnd:(t,e,s)=>`${t}`.padEnd(e,s),padStart:(t,e,s)=>`${t}`.padStart(e,s),radToDeg:t=>180*t/Math.PI,round:pt,roundPad:(t,e)=>(+t).toFixed(e),snap:mt,wrap:(t,e,s)=>((t-e)%(s-e)+(s-e))%(s-e)+e});const qe=10*p;class je{constructor(t={}){const e=!X(t.bounce)||!X(t.duration);this.timeStep=.02,this.restThreshold=5e-4,this.restDuration=200,this.maxDuration=6e4,this.maxRestSteps=this.restDuration/this.timeStep/p,this.maxIterations=this.maxDuration/this.timeStep/p,this.bn=ct(St(t.bounce,.5),-1,1),this.pd=ct(St(t.duration,628),10*L.timeScale,qe*L.timeScale),this.m=ct(St(t.mass,1),1,qe),this.s=ct(St(t.stiffness,100),c,qe),this.d=ct(St(t.damping,10),c,qe),this.v=ct(St(t.velocity,0),-1e4,qe),this.w0=0,this.zeta=0,this.wd=0,this.b=0,this.completed=!1,this.solverDuration=0,this.settlingDuration=0,this.parent=null,this.onComplete=t.onComplete||v,e&&this.calculateSDFromBD(),this.compute(),this.ease=t=>{const e=t*this.settlingDuration,s=this.completed,i=this.pd;return e>=i&&!s&&(this.completed=!0,this.onComplete(this.parent)),e<i&&s&&(this.completed=!1),0===t||1===t?t:this.solve(t*this.solverDuration)}}solve(t){const{zeta:e,w0:s,wd:i,b:r}=this;let n=t;return n=e<1?it(-n*e*s)*(1*et(i*n)+r*tt(i*n)):1===e?(1+r*n)*it(-n*s):((1+r)*it((-e*s+i)*n)+(1-r)*it((-e*s-i)*n))/2,1-n}calculateSDFromBD(){const t=1===L.timeScale?this.pd/p:this.pd;this.m=1,this.v=0,this.s=J(2*ht/t,2),this.bn>=0?this.d=4*(1-this.bn)*ht/t:this.d=4*ht/(t*(1+this.bn)),this.s=pt(ct(this.s,c,qe),3),this.d=pt(ct(this.d,c,300),3)}calculateBDFromSD(){const t=2*ht/K(this.s);this.pd=t*(1===L.timeScale?p:1);const e=this.d/(2*K(this.s));this.bn=e<=1?1-this.d*t/(4*ht):4*ht/(this.d*t)-1,this.bn=pt(ct(this.bn,-1,1),3),this.pd=pt(ct(this.pd,10*L.timeScale,qe*L.timeScale),3)}compute(){const{maxRestSteps:t,maxIterations:e,restThreshold:s,timeStep:i,m:r,d:n,s:o,v:a}=this,l=this.w0=ct(K(o/r),c,p),h=this.zeta=n/(2*K(o*r));h<1?(this.wd=l*K(1-h*h),this.b=(h*l-a)/this.wd):1===h?(this.wd=0,this.b=-a+l):(this.wd=l*K(h*h-1),this.b=(h*l-a)/this.wd);let d=0,u=0,m=0;for(;u<=t&&m<=e;)st(1-this.solve(d))<s?u++:u=0,this.solverDuration=d,d+=i,m++;this.settlingDuration=pt(this.solverDuration*p,0)*L.timeScale}get bounce(){return this.bn}set bounce(t){this.bn=ct(St(t,1),-1,1),this.calculateSDFromBD(),this.compute()}get duration(){return this.pd}set duration(t){this.pd=ct(St(t,1),10*L.timeScale,qe*L.timeScale),this.calculateSDFromBD(),this.compute()}get stiffness(){return this.s}set stiffness(t){this.s=ct(St(t,100),c,qe),this.calculateBDFromSD(),this.compute()}get damping(){return this.d}set damping(t){this.d=ct(St(t,10),c,qe),this.calculateBDFromSD(),this.compute()}get mass(){return this.m}set mass(t){this.m=ct(St(t,1),1,qe),this.compute()}get velocity(){return this.v}set velocity(t){this.v=ct(St(t,0),-1e4,qe),this.compute()}}const Ge=t=>new je(t),Qe=t=>(console.warn("createSpring() is deprecated use spring() instead"),new je(t)),Ze=t=>{t.cancelable&&t.preventDefault()};class Je{constructor(t){this.el=t,this.zIndex=0,this.parentElement=null,this.classList={add:v,remove:v}}get x(){return this.el.x||0}set x(t){this.el.x=t}get y(){return this.el.y||0}set y(t){this.el.y=t}get width(){return this.el.width||0}set width(t){this.el.width=t}get height(){return this.el.height||0}set height(t){this.el.height=t}getBoundingClientRect(){return{top:this.y,right:this.x,bottom:this.y+this.height,left:this.x+this.width}}}class Ke{constructor(t){this.$el=t,this.inlineTransforms=[],this.point=new DOMPoint,this.inversedMatrix=this.getMatrix().inverse()}normalizePoint(t,e){return this.point.x=t,this.point.y=e,this.point.matrixTransform(this.inversedMatrix)}traverseUp(t){let e=this.$el.parentElement,s=0;for(;e&&e!==i;)t(e,s),e=e.parentElement,s++}getMatrix(){const t=new DOMMatrix;return this.traverseUp(e=>{const s=getComputedStyle(e).transform;if(s){const e=new DOMMatrix(s);t.preMultiplySelf(e)}}),t}remove(){this.traverseUp((t,e)=>{this.inlineTransforms[e]=t.style.transform,t.style.transform="none"})}revert(){this.traverseUp((t,e)=>{const s=this.inlineTransforms[e];""===s?t.style.removeProperty("transform"):t.style.transform=s})}}const ts=(t,e)=>t&&H(t)?t(e):t;let es=0;class ss{constructor(t,e={}){if(!t)return;I.current&&I.current.register(this);const r=e.x,n=e.y,o=e.trigger,a=e.modifier,l=e.releaseEase,h=l&&be(l),d=!X(l)&&!X(l.ease),c=M(r)&&!X(r.mapTo)?r.mapTo:"translateX",p=M(n)&&!X(n.mapTo)?n.mapTo:"translateY",m=ts(e.container,this);this.containerArray=V(m)?m:null,this.$container=m&&!this.containerArray?ne(m)[0]:i.body,this.useWin=this.$container===i.body,this.$scrollContainer=this.useWin?s:this.$container,this.$target=M(t)?new Je(t):ne(t)[0],this.$trigger=ne(o||t)[0],this.fixed="fixed"===Pe(this.$target,"position"),this.isFinePointer=!0,this.containerPadding=[0,0,0,0],this.containerFriction=0,this.releaseContainerFriction=0,this.snapX=0,this.snapY=0,this.scrollSpeed=0,this.scrollThreshold=0,this.dragSpeed=0,this.dragThreshold=3,this.maxVelocity=0,this.minVelocity=0,this.velocityMultiplier=0,this.cursor=!1,this.releaseXSpring=d?l:Ge({mass:St(e.releaseMass,1),stiffness:St(e.releaseStiffness,80),damping:St(e.releaseDamping,20)}),this.releaseYSpring=d?l:Ge({mass:St(e.releaseMass,1),stiffness:St(e.releaseStiffness,80),damping:St(e.releaseDamping,20)}),this.releaseEase=h||ge.outQuint,this.hasReleaseSpring=d,this.onGrab=e.onGrab||v,this.onDrag=e.onDrag||v,this.onRelease=e.onRelease||v,this.onUpdate=e.onUpdate||v,this.onSettle=e.onSettle||v,this.onSnap=e.onSnap||v,this.onResize=e.onResize||v,this.onAfterResize=e.onAfterResize||v,this.disabled=[0,0];const f={};if(a&&(f.modifier=a),X(r)||!0===r)f[c]=0;else if(M(r)){const t=r,e={};t.modifier&&(e.modifier=t.modifier),t.composition&&(e.composition=t.composition),f[c]=e}else!1===r&&(f[c]=0,this.disabled[0]=1);if(X(n)||!0===n)f[p]=0;else if(M(n)){const t=n,e={};t.modifier&&(e.modifier=t.modifier),t.composition&&(e.composition=t.composition),f[p]=e}else!1===n&&(f[p]=0,this.disabled[1]=1);this.animate=new Ye(this.$target,f),this.xProp=c,this.yProp=p,this.destX=0,this.destY=0,this.deltaX=0,this.deltaY=0,this.scroll={x:0,y:0},this.coords=[this.x,this.y,0,0],this.snapped=[0,0],this.pointer=[0,0,0,0,0,0,0,0],this.scrollView=[0,0],this.dragArea=[0,0,0,0],this.containerBounds=[-u,u,u,-u],this.scrollBounds=[0,0,0,0],this.targetBounds=[0,0,0,0],this.window=[0,0],this.velocityStack=[0,0,0],this.velocityStackIndex=0,this.velocityTime=F(),this.velocity=0,this.angle=0,this.cursorStyles=null,this.triggerStyles=null,this.bodyStyles=null,this.targetStyles=null,this.touchActionStyles=null,this.transforms=new Ke(this.$target),this.overshootCoords={x:0,y:0},this.overshootTicker=new ie({autoplay:!1,onUpdate:()=>{this.updated=!0,this.manual=!0,this.disabled[0]||this.animate[this.xProp](this.overshootCoords.x,1),this.disabled[1]||this.animate[this.yProp](this.overshootCoords.y,1)},onComplete:()=>{this.manual=!1,this.disabled[0]||this.animate[this.xProp](this.overshootCoords.x,0),this.disabled[1]||this.animate[this.yProp](this.overshootCoords.y,0)}},null,0).init(),this.updateTicker=new ie({autoplay:!1,onUpdate:()=>this.update()},null,0).init(),this.contained=!X(m),this.manual=!1,this.grabbed=!1,this.dragged=!1,this.updated=!1,this.released=!1,this.canScroll=!1,this.enabled=!1,this.initialized=!1,this.activeProp=this.disabled[1]?c:p,this.animate.callbacks.onRender=()=>{const t=this.updated,e=!(this.grabbed&&t)&&this.released,s=this.x,i=this.y,r=s-this.coords[2],n=i-this.coords[3];this.deltaX=r,this.deltaY=n,this.coords[2]=s,this.coords[3]=i,t&&(r||n)&&this.onUpdate(this),e?(this.computeVelocity(r,n),this.angle=lt(n,r)):this.updated=!1},this.animate.callbacks.onComplete=()=>{!this.grabbed&&this.released&&(this.released=!1),this.manual||(this.deltaX=0,this.deltaY=0,this.velocity=0,this.velocityStack[0]=0,this.velocityStack[1]=0,this.velocityStack[2]=0,this.velocityStackIndex=0,this.onSettle(this))},this.resizeTicker=new ie({autoplay:!1,duration:150*L.timeScale,onComplete:()=>{this.onResize(this),this.refresh(),this.onAfterResize(this)}}).init(),this.parameters=e,this.resizeObserver=new ResizeObserver(()=>{this.initialized?this.resizeTicker.restart():this.initialized=!0}),this.enable(),this.refresh(),this.resizeObserver.observe(this.$container),M(t)||this.resizeObserver.observe(this.$target)}computeVelocity(t,e){const s=this.velocityTime,i=F(),r=i-s;if(r<17)return this.velocity;this.velocityTime=i;const n=this.velocityStack,o=this.velocityMultiplier,a=this.minVelocity,l=this.maxVelocity,h=this.velocityStackIndex;n[h]=pt(ct(K(t*t+e*e)/r*o,a,l),5);const d=at(n[0],n[1],n[2]);return this.velocity=d,this.velocityStackIndex=(h+1)%3,d}setX(t,e=!1){if(this.disabled[0])return;const s=pt(t,5);return this.overshootTicker.pause(),this.manual=!0,this.updated=!e,this.destX=s,this.snapped[0]=mt(s,this.snapX),this.animate[this.xProp](s,0),this.manual=!1,this}setY(t,e=!1){if(this.disabled[1])return;const s=pt(t,5);return this.overshootTicker.pause(),this.manual=!0,this.updated=!e,this.destY=s,this.snapped[1]=mt(s,this.snapY),this.animate[this.yProp](s,0),this.manual=!1,this}get x(){return pt(this.animate[this.xProp](),L.precision)}set x(t){this.setX(t,!1)}get y(){return pt(this.animate[this.yProp](),L.precision)}set y(t){this.setY(t,!1)}get progressX(){return We(this.x,this.containerBounds[3],this.containerBounds[1],0,1)}set progressX(t){this.setX(We(t,0,1,this.containerBounds[3],this.containerBounds[1]),!1)}get progressY(){return We(this.y,this.containerBounds[0],this.containerBounds[2],0,1)}set progressY(t){this.setY(We(t,0,1,this.containerBounds[0],this.containerBounds[2]),!1)}updateScrollCoords(){const t=pt(this.useWin?s.scrollX:this.$container.scrollLeft,0),e=pt(this.useWin?s.scrollY:this.$container.scrollTop,0),[i,r,n,o]=this.containerPadding,a=this.scrollThreshold;this.scroll.x=t,this.scroll.y=e,this.scrollBounds[0]=e-this.targetBounds[0]+i-a,this.scrollBounds[1]=t-this.targetBounds[1]-r+a,this.scrollBounds[2]=e-this.targetBounds[2]-n+a,this.scrollBounds[3]=t-this.targetBounds[3]+o-a}updateBoundingValues(){const t=this.$container;if(!t)return;const e=this.x,r=this.y,n=this.coords[2],o=this.coords[3];this.coords[2]=0,this.coords[3]=0,this.setX(0,!0),this.setY(0,!0),this.transforms.remove();const a=this.window[0]=s.innerWidth,l=this.window[1]=s.innerHeight,h=this.useWin,d=t.scrollWidth,c=t.scrollHeight,u=this.fixed,p=t.getBoundingClientRect(),[m,f,g,y]=this.containerPadding;this.dragArea[0]=h?0:p.left,this.dragArea[1]=h?0:p.top,this.scrollView[0]=h?ct(d,a,d):d,this.scrollView[1]=h?ct(c,l,c):c,this.updateScrollCoords();const{width:v,height:_,left:b,top:T,right:x,bottom:w}=t.getBoundingClientRect();this.dragArea[2]=pt(h?ct(v,a,a):v,0),this.dragArea[3]=pt(h?ct(_,l,l):_,0);const S=Pe(t,"overflow"),$="visible"===S,E="hidden"===S;if(this.canScroll=!u&&this.contained&&(t===i.body&&$||!E&&!$)&&(d>this.dragArea[2]+y-f||c>this.dragArea[3]+m-g)&&(!this.containerArray||this.containerArray&&!V(this.containerArray)),this.contained){const e=this.scroll.x,s=this.scroll.y,i=this.canScroll,r=this.$target.getBoundingClientRect(),n=i?h?0:t.scrollLeft:0,o=i?h?0:t.scrollTop:0,d=i?this.scrollView[0]-n-v:0,c=i?this.scrollView[1]-o-_:0;this.targetBounds[0]=pt(r.top+s-(h?0:T),0),this.targetBounds[1]=pt(r.right+e-(h?a:x),0),this.targetBounds[2]=pt(r.bottom+s-(h?l:w),0),this.targetBounds[3]=pt(r.left+e-(h?0:b),0),this.containerArray?(this.containerBounds[0]=this.containerArray[0]+m,this.containerBounds[1]=this.containerArray[1]-f,this.containerBounds[2]=this.containerArray[2]-g,this.containerBounds[3]=this.containerArray[3]+y):(this.containerBounds[0]=-pt(r.top-(u?ct(T,0,l):T)+o-m,0),this.containerBounds[1]=-pt(r.right-(u?ct(x,0,a):x)-d+f,0),this.containerBounds[2]=-pt(r.bottom-(u?ct(w,0,l):w)-c+g,0),this.containerBounds[3]=-pt(r.left-(u?ct(b,0,a):b)+n-y,0))}this.transforms.revert(),this.coords[2]=n,this.coords[3]=o,this.setX(e,!0),this.setY(r,!0)}isOutOfBounds(t,e,s){if(!this.contained)return 0;const[i,r,n,o]=t,[a,l]=this.disabled,h=!a&&e<o||!a&&e>r,d=!l&&s<i||!l&&s>n;return h&&!d?1:!h&&d?2:h&&d?3:0}refresh(){const t=this.parameters,e=t.x,r=t.y,n=ts(t.container,this),o=ts(t.containerPadding,this)||0,a=V(o)?o:[o,o,o,o],l=this.x,h=this.y,d=ts(t.cursor,this),c={onHover:"grab",onGrab:"grabbing"};if(d){const{onHover:t,onGrab:e}=d;t&&(c.onHover=t),e&&(c.onGrab=e)}const u=ts(t.dragThreshold,this),p={mouse:3,touch:7};if(O(u))p.mouse=u,p.touch=u;else if(u){const{mouse:t,touch:e}=u;X(t)||(p.mouse=t),X(e)||(p.touch=e)}this.containerArray=V(n)?n:null,this.$container=n&&!this.containerArray?ne(n)[0]:i.body,this.useWin=this.$container===i.body,this.$scrollContainer=this.useWin?s:this.$container,this.isFinePointer=matchMedia("(pointer:fine)").matches,this.containerPadding=St(a,[0,0,0,0]),this.containerFriction=ct(St(ts(t.containerFriction,this),.8),0,1),this.releaseContainerFriction=ct(St(ts(t.releaseContainerFriction,this),this.containerFriction),0,1),this.snapX=ts(M(e)&&!X(e.snap)?e.snap:t.snap,this),this.snapY=ts(M(r)&&!X(r.snap)?r.snap:t.snap,this),this.scrollSpeed=St(ts(t.scrollSpeed,this),1.5),this.scrollThreshold=St(ts(t.scrollThreshold,this),20),this.dragSpeed=St(ts(t.dragSpeed,this),1),this.dragThreshold=this.isFinePointer?p.mouse:p.touch,this.minVelocity=St(ts(t.minVelocity,this),0),this.maxVelocity=St(ts(t.maxVelocity,this),50),this.velocityMultiplier=St(ts(t.velocityMultiplier,this),1),this.cursor=!1!==d&&c,this.updateBoundingValues();const[m,f,g,y]=this.containerBounds;this.setX(ct(l,y,f),!0),this.setY(ct(h,m,g),!0)}update(){if(this.updateScrollCoords(),this.canScroll){const[t,e,s,i]=this.containerPadding,[r,n]=this.scrollView,o=this.dragArea[2],a=this.dragArea[3],l=this.scroll.x,h=this.scroll.y,d=this.$container.scrollWidth,c=this.$container.scrollHeight,u=this.useWin?ct(d,this.window[0],d):d,p=this.useWin?ct(c,this.window[1],c):c,m=r-u,f=n-p;this.dragged&&m>0&&(this.coords[0]-=m,this.scrollView[0]=u),this.dragged&&f>0&&(this.coords[1]-=f,this.scrollView[1]=p);const g=10*this.scrollSpeed,y=this.scrollThreshold,[v,_]=this.coords,[b,T,x,w]=this.scrollBounds,S=pt(ct((_-b+t)/y,-1,0)*g,0),$=pt(ct((v-T-e)/y,0,1)*g,0),E=pt(ct((_-x-s)/y,0,1)*g,0),k=pt(ct((v-w+i)/y,-1,0)*g,0);if(S||E||k||$){const[t,e]=this.disabled;let s=l,i=h;t||(s=pt(ct(l+(k||$),0,r-o),0),this.coords[0]-=l-s),e||(i=pt(ct(h+(S||E),0,n-a),0),this.coords[1]-=h-i),this.useWin?this.$scrollContainer.scrollBy(-(l-s),-(h-i)):this.$scrollContainer.scrollTo(s,i)}}const[t,e,s,i]=this.containerBounds,[r,n,o,a,l,h]=this.pointer;this.coords[0]+=(r-l)*this.dragSpeed,this.coords[1]+=(n-h)*this.dragSpeed,this.pointer[4]=r,this.pointer[5]=n;const[d,c]=this.coords,[u,p]=this.snapped,m=(1-this.containerFriction)*this.dragSpeed;this.setX(d>e?e+(d-e)*m:d<i?i+(d-i)*m:d,!1),this.setY(c>s?s+(c-s)*m:c<t?t+(c-t)*m:c,!1),this.computeVelocity(r-l,n-h),this.angle=lt(n-a,r-o);const[f,g]=this.snapped;(f!==u&&this.snapX||g!==p&&this.snapY)&&this.onSnap(this)}stop(){this.updateTicker.pause(),this.overshootTicker.pause();for(let t in this.animate.animations)this.animate.animations[t].pause();return Kt([this],null,"x"),Kt([this],null,"y"),Kt([this],null,"progressX"),Kt([this],null,"progressY"),Kt([this.scroll]),Kt([this.overshootCoords]),this}scrollInView(t,e=0,s=ge.inOutQuad){this.updateScrollCoords();const i=this.destX,r=this.destY,n=this.scroll,o=this.scrollBounds,a=this.canScroll;if(!this.containerArray&&this.isOutOfBounds(o,i,r)){const[l,h,d,c]=o,p=pt(ct(r-l,-u,0),0),m=pt(ct(i-h,0,u),0),f=pt(ct(r-d,0,u),0),g=pt(ct(i-c,-u,0),0);new Le(n,{x:pt(n.x+(g?g-e:m?m+e:0),0),y:pt(n.y+(p?p-e:f?f+e:0),0),duration:X(t)?350*L.timeScale:t,ease:s,onUpdate:()=>{this.canScroll=!1,this.$scrollContainer.scrollTo(n.x,n.y)}}).init().then(()=>{this.canScroll=a})}return this}handleHover(){this.isFinePointer&&this.cursor&&!this.cursorStyles&&(this.cursorStyles=Fe(this.$trigger,{cursor:this.cursor.onHover}))}animateInView(t,e=0,s=ge.inOutQuad){this.stop(),this.updateBoundingValues();const i=this.x,r=this.y,[n,o,a,l]=this.containerPadding,h=this.scroll.y-this.targetBounds[0]+n+e,d=this.scroll.x-this.targetBounds[1]-o-e,c=this.scroll.y-this.targetBounds[2]-a-e,u=this.scroll.x-this.targetBounds[3]+l+e,p=this.isOutOfBounds([h,d,c,u],i,r);if(p){const[e,n]=this.disabled,o=ct(mt(i,this.snapX),u,d),a=ct(mt(r,this.snapY),h,c),l=X(t)?350*L.timeScale:t;e||1!==p&&3!==p||this.animate[this.xProp](o,l,s),n||2!==p&&3!==p||this.animate[this.yProp](a,l,s)}return this}handleDown(t){const e=t.target;if(this.grabbed||"range"===e.type)return;t.stopPropagation(),this.grabbed=!0,this.released=!1,this.stop(),this.updateBoundingValues();const s=t.changedTouches,r=s?s[0].clientX:t.clientX,n=s?s[0].clientY:t.clientY,{x:o,y:a}=this.transforms.normalizePoint(r,n),[l,h,d,c]=this.containerBounds,u=(1-this.containerFriction)*this.dragSpeed,p=this.x,m=this.y;this.coords[0]=this.coords[2]=u?p>h?h+(p-h)/u:p<c?c+(p-c)/u:p:p,this.coords[1]=this.coords[3]=u?m>d?d+(m-d)/u:m<l?l+(m-l)/u:m:m,this.pointer[0]=o,this.pointer[1]=a,this.pointer[2]=o,this.pointer[3]=a,this.pointer[4]=o,this.pointer[5]=a,this.pointer[6]=o,this.pointer[7]=a,this.deltaX=0,this.deltaY=0,this.velocity=0,this.velocityStack[0]=0,this.velocityStack[1]=0,this.velocityStack[2]=0,this.velocityStackIndex=0,this.angle=0,this.targetStyles&&(this.targetStyles.revert(),this.targetStyles=null);const f=Pe(this.$target,"zIndex",!1);es=(f>es?f:es)+1,this.targetStyles=Fe(this.$target,{zIndex:es}),this.triggerStyles&&(this.triggerStyles.revert(),this.triggerStyles=null),this.cursorStyles&&(this.cursorStyles.revert(),this.cursorStyles=null),this.isFinePointer&&this.cursor&&(this.bodyStyles=Fe(i.body,{cursor:this.cursor.onGrab})),this.scrollInView(100,0,ge.out(3)),this.onGrab(this),i.addEventListener("touchmove",this),i.addEventListener("touchend",this),i.addEventListener("touchcancel",this),i.addEventListener("mousemove",this),i.addEventListener("mouseup",this),i.addEventListener("selectstart",this)}handleMove(t){if(!this.grabbed)return;const e=t.changedTouches,s=e?e[0].clientX:t.clientX,i=e?e[0].clientY:t.clientY,{x:r,y:n}=this.transforms.normalizePoint(s,i),o=r-this.pointer[6],a=n-this.pointer[7];let l=t.target,h=!1,d=!1,c=!1;for(;e&&l&&l!==this.$trigger;){const t=Pe(l,"overflow-y");if("hidden"!==t&&"visible"!==t){const{scrollTop:t,scrollHeight:e,clientHeight:s}=l;if(e>s){c=!0,h=t<=3,d=t>=e-s-3;break}}l=l.parentElement}c&&(!h&&!d||h&&a<0||d&&a>0)?(this.pointer[0]=r,this.pointer[1]=n,this.pointer[2]=r,this.pointer[3]=n,this.pointer[4]=r,this.pointer[5]=n,this.pointer[6]=r,this.pointer[7]=n):(Ze(t),this.triggerStyles||(this.triggerStyles=Fe(this.$trigger,{pointerEvents:"none"})),this.$trigger.addEventListener("touchstart",Ze,{passive:!1}),this.$trigger.addEventListener("touchmove",Ze,{passive:!1}),this.$trigger.addEventListener("touchend",Ze),(this.dragged||!this.disabled[0]&&st(o)>this.dragThreshold||!this.disabled[1]&&st(a)>this.dragThreshold)&&(this.updateTicker.resume(),this.pointer[2]=this.pointer[0],this.pointer[3]=this.pointer[1],this.pointer[0]=r,this.pointer[1]=n,this.dragged=!0,this.released=!1,this.onDrag(this)))}handleUp(){if(!this.grabbed)return;this.updateTicker.pause(),this.triggerStyles&&(this.triggerStyles.revert(),this.triggerStyles=null),this.bodyStyles&&(this.bodyStyles.revert(),this.bodyStyles=null);const[t,e]=this.disabled,[s,n,o,a,l,h]=this.pointer,[d,c,u,p]=this.containerBounds,[m,f]=this.snapped,g=this.releaseXSpring,y=this.releaseYSpring,v=this.releaseEase,_=this.hasReleaseSpring,b=this.overshootCoords,T=this.x,x=this.y,w=this.computeVelocity(s-l,n-h),S=this.angle=lt(n-a,s-o),$=150*w,E=(1-this.releaseContainerFriction)*this.dragSpeed,k=T+et(S)*$,C=x+tt(S)*$,N=k>c?c+(k-c)*E:k<p?p+(k-p)*E:k,D=C>u?u+(C-u)*E:C<d?d+(C-d)*E:C,I=this.destX=ct(pt(mt(N,this.snapX),5),p,c),A=this.destY=ct(pt(mt(D,this.snapY),5),d,u),B=this.isOutOfBounds(this.containerBounds,k,C);let R=0,P=0,F=v,V=v,M=0;if(b.x=T,b.y=x,!t){const t=I===c?T>c?-1:1:T<p?-1:1,s=pt(T-I,0);g.velocity=e&&_?s?$*t/st(s):0:w;const{ease:i,settlingDuration:r,restDuration:n}=g;R=T===I?0:_?r:r-n*L.timeScale,_&&(F=i),R>M&&(M=R)}if(!e){const e=A===u?x>u?-1:1:x<d?-1:1,s=pt(x-A,0);y.velocity=t&&_?s?$*e/st(s):0:w;const{ease:i,settlingDuration:r,restDuration:n}=y;P=x===A?0:_?r:r-n*L.timeScale,_&&(V=i),P>M&&(M=P)}if(!_&&B&&E&&(R||P)){const t=r.blend;new Le(b,{x:{to:N,duration:.65*R},y:{to:D,duration:.65*P},ease:v,composition:t}).init(),new Le(b,{x:{to:I,duration:R},y:{to:A,duration:P},ease:v,composition:t}).init(),this.overshootTicker.stretch(at(R,P)).restart()}else t||this.animate[this.xProp](I,R,F),e||this.animate[this.yProp](A,P,V);this.scrollInView(M,this.scrollThreshold,v);let O=!1;I!==m&&(this.snapped[0]=I,this.snapX&&(O=!0)),A!==f&&this.snapY&&(this.snapped[1]=A,this.snapY&&(O=!0)),O&&this.onSnap(this),this.grabbed=!1,this.dragged=!1,this.updated=!0,this.released=!0,this.onRelease(this),this.$trigger.removeEventListener("touchstart",Ze),this.$trigger.removeEventListener("touchmove",Ze),this.$trigger.removeEventListener("touchend",Ze),i.removeEventListener("touchmove",this),i.removeEventListener("touchend",this),i.removeEventListener("touchcancel",this),i.removeEventListener("mousemove",this),i.removeEventListener("mouseup",this),i.removeEventListener("selectstart",this)}reset(){return this.stop(),this.resizeTicker.pause(),this.grabbed=!1,this.dragged=!1,this.updated=!1,this.released=!1,this.canScroll=!1,this.setX(0,!0),this.setY(0,!0),this.coords[0]=0,this.coords[1]=0,this.pointer[0]=0,this.pointer[1]=0,this.pointer[2]=0,this.pointer[3]=0,this.pointer[4]=0,this.pointer[5]=0,this.pointer[6]=0,this.pointer[7]=0,this.velocity=0,this.velocityStack[0]=0,this.velocityStack[1]=0,this.velocityStack[2]=0,this.velocityStackIndex=0,this.angle=0,this}enable(){return this.enabled||(this.enabled=!0,this.$target.classList.remove("is-disabled"),this.touchActionStyles=Fe(this.$trigger,{touchAction:this.disabled[0]?"pan-x":this.disabled[1]?"pan-y":"none"}),this.$trigger.addEventListener("touchstart",this,{passive:!0}),this.$trigger.addEventListener("mousedown",this,{passive:!0}),this.$trigger.addEventListener("mouseenter",this)),this}disable(){return this.enabled=!1,this.grabbed=!1,this.dragged=!1,this.updated=!1,this.released=!1,this.canScroll=!1,this.touchActionStyles.revert(),this.cursorStyles&&(this.cursorStyles.revert(),this.cursorStyles=null),this.triggerStyles&&(this.triggerStyles.revert(),this.triggerStyles=null),this.bodyStyles&&(this.bodyStyles.revert(),this.bodyStyles=null),this.targetStyles&&(this.targetStyles.revert(),this.targetStyles=null),this.$target.classList.add("is-disabled"),this.$trigger.removeEventListener("touchstart",this),this.$trigger.removeEventListener("mousedown",this),this.$trigger.removeEventListener("mouseenter",this),i.removeEventListener("touchmove",this),i.removeEventListener("touchend",this),i.removeEventListener("touchcancel",this),i.removeEventListener("mousemove",this),i.removeEventListener("mouseup",this),i.removeEventListener("selectstart",this),this}revert(){return this.reset(),this.disable(),this.$target.classList.remove("is-disabled"),this.updateTicker.revert(),this.overshootTicker.revert(),this.resizeTicker.revert(),this.animate.revert(),this.resizeObserver.disconnect(),this}handleEvent(t){switch(t.type){case"mousedown":case"touchstart":this.handleDown(t);break;case"mousemove":case"touchmove":this.handleMove(t);break;case"mouseup":case"touchend":case"touchcancel":this.handleUp();break;case"mouseenter":this.handleHover();break;case"selectstart":Ze(t)}}}const is=(t=v)=>new ie({duration:1*L.timeScale,onComplete:t},null,0).resume(),rs=t=>{let e;return(...s)=>{let i,r,n,o;e&&(i=e.currentIteration,r=e.iterationProgress,n=e.reversed,o=e._alternate,e.revert());const a=t(...s);return a&&!H(a)&&a.revert&&(e=a),X(r)||(e.currentIteration=i,e.iterationProgress=(o&&i%2?!n:n)?1-r:r),a||v}};class ns{constructor(t={}){I.current&&I.current.register(this);const e=t.root;let r=i;e&&(r=e.current||e.nativeElement||ne(e)[0]||i);const n=t.defaults,o=L.defaults,a=t.mediaQueries;if(this.defaults=n?_t(n,o):o,this.root=r,this.constructors=[],this.revertConstructors=[],this.revertibles=[],this.constructorsOnce=[],this.revertConstructorsOnce=[],this.revertiblesOnce=[],this.once=!1,this.onceIndex=0,this.methods={},this.matches={},this.mediaQueryLists={},this.data={},a)for(let t in a){const e=s.matchMedia(a[t]);this.mediaQueryLists[t]=e,e.addEventListener("change",this)}}register(t){(this.once?this.revertiblesOnce:this.revertibles).push(t)}execute(t){let e=I.current,s=I.root,i=L.defaults;I.current=this,I.root=this.root,L.defaults=this.defaults;const r=this.mediaQueryLists;for(let t in r)this.matches[t]=r[t].matches;const n=t(this);return I.current=e,I.root=s,L.defaults=i,n}refresh(){return this.onceIndex=0,this.execute(()=>{let t=this.revertibles.length,e=this.revertConstructors.length;for(;t--;)this.revertibles[t].revert();for(;e--;)this.revertConstructors[e](this);this.revertibles.length=0,this.revertConstructors.length=0,this.constructors.forEach(t=>{const e=t(this);H(e)&&this.revertConstructors.push(e)})}),this}add(t,e){if(this.once=!1,H(t)){const e=t;this.constructors.push(e),this.execute(()=>{const t=e(this);H(t)&&this.revertConstructors.push(t)})}else this.methods[t]=(...t)=>this.execute(()=>e(...t));return this}addOnce(t){if(this.once=!0,H(t)){const e=this.onceIndex++;if(this.constructorsOnce[e])return this;const s=t;this.constructorsOnce[e]=s,this.execute(()=>{const t=s(this);H(t)&&this.revertConstructorsOnce.push(t)})}return this}keepTime(t){this.once=!0;const e=this.onceIndex++,s=this.constructorsOnce[e];if(H(s))return s(this);const i=rs(t);let r;return this.constructorsOnce[e]=i,this.execute(()=>{r=i(this)}),r}handleEvent(t){"change"===t.type&&this.refresh()}revert(){const t=this.revertibles,e=this.revertConstructors,s=this.revertiblesOnce,i=this.revertConstructorsOnce,r=this.mediaQueryLists;let n=t.length,o=e.length,a=s.length,l=i.length;for(;n--;)t[n].revert();for(;o--;)e[o](this);for(;a--;)s[a].revert();for(;l--;)i[l](this);for(let t in r)r[t].removeEventListener("change",this);t.length=0,e.length=0,this.constructors.length=0,s.length=0,i.length=0,this.constructorsOnce.length=0,this.onceIndex=0,this.matches={},this.methods={},this.mediaQueryLists={},this.data={}}}const os=(t,e)=>t&&H(t)?t(e):t,as=new Map;class ls{constructor(t){this.element=t,this.useWin=this.element===i.body,this.winWidth=0,this.winHeight=0,this.width=0,this.height=0,this.left=0,this.top=0,this.scale=1,this.zIndex=0,this.scrollX=0,this.scrollY=0,this.prevScrollX=0,this.prevScrollY=0,this.scrollWidth=0,this.scrollHeight=0,this.velocity=0,this.backwardX=!1,this.backwardY=!1,this.scrollTicker=new ie({autoplay:!1,onBegin:()=>this.dataTimer.resume(),onUpdate:()=>{const t=this.backwardX||this.backwardY;bt(this,t=>t.handleScroll(),t)},onComplete:()=>this.dataTimer.pause()}).init(),this.dataTimer=new ie({autoplay:!1,frameRate:30,onUpdate:t=>{const e=t.deltaTime,s=this.prevScrollX,i=this.prevScrollY,r=this.scrollX,n=this.scrollY,o=s-r,a=i-n;this.prevScrollX=r,this.prevScrollY=n,o&&(this.backwardX=s>r),a&&(this.backwardY=i>n),this.velocity=pt(e>0?Math.sqrt(o*o+a*a)/e:0,5)}}).init(),this.resizeTicker=new ie({autoplay:!1,duration:250*L.timeScale,onComplete:()=>{this.updateWindowBounds(),this.refreshScrollObservers(),this.handleScroll()}}).init(),this.wakeTicker=new ie({autoplay:!1,duration:500*L.timeScale,onBegin:()=>{this.scrollTicker.resume()},onComplete:()=>{this.scrollTicker.pause()}}).init(),this._head=null,this._tail=null,this.updateScrollCoords(),this.updateWindowBounds(),this.updateBounds(),this.refreshScrollObservers(),this.handleScroll(),this.resizeObserver=new ResizeObserver(()=>this.resizeTicker.restart()),this.resizeObserver.observe(this.element),(this.useWin?s:this.element).addEventListener("scroll",this,!1)}updateScrollCoords(){const t=this.useWin,e=this.element;this.scrollX=pt(t?s.scrollX:e.scrollLeft,0),this.scrollY=pt(t?s.scrollY:e.scrollTop,0)}updateWindowBounds(){this.winWidth=s.innerWidth,this.winHeight=(()=>{const t=i.createElement("div");i.body.appendChild(t),t.style.height="100lvh";const e=t.offsetHeight;return i.body.removeChild(t),e})()}updateBounds(){const t=getComputedStyle(this.element),e=this.element;let s,i;if(this.scrollWidth=e.scrollWidth+parseFloat(t.marginLeft)+parseFloat(t.marginRight),this.scrollHeight=e.scrollHeight+parseFloat(t.marginTop)+parseFloat(t.marginBottom),this.updateWindowBounds(),this.useWin)s=this.winWidth,i=this.winHeight;else{const t=e.getBoundingClientRect();s=e.clientWidth,i=e.clientHeight,this.top=t.top,this.left=t.left,this.scale=t.width?s/t.width:t.height?i/t.height:1}this.width=s,this.height=i}refreshScrollObservers(){bt(this,t=>{t._debug&&t.removeDebug()}),this.updateBounds(),bt(this,t=>{t.refresh(),t._debug&&t.debug()})}refresh(){this.updateWindowBounds(),this.updateBounds(),this.refreshScrollObservers(),this.handleScroll()}handleScroll(){this.updateScrollCoords(),this.wakeTicker.restart()}handleEvent(t){"scroll"===t.type&&this.handleScroll()}revert(){this.scrollTicker.cancel(),this.dataTimer.cancel(),this.resizeTicker.cancel(),this.wakeTicker.cancel(),this.resizeObserver.disconnect(),(this.useWin?s:this.element).removeEventListener("scroll",this),as.delete(this.element)}}const hs=(t,e,s,i,r)=>{const n="min"===e,o="max"===e,a="top"===e||"left"===e||"start"===e||n?0:"bottom"===e||"right"===e||"end"===e||o?"100%":"center"===e?"50%":e,{n:l,u:h}=Dt(a,Lt);let d=l;return"%"===h?d=l/100*s:h&&(d=he(t,Lt,"px",!0).n),o&&i<0&&(d+=i),n&&r>0&&(d+=r),d},ds=(t,e,s,i,r)=>{let n;if(z(e)){const o=C.exec(e);if(o){const a=o[0],l=a[0],h=e.split(a),d="min"===h[0],c="max"===h[0],u=hs(t,h[0],s,i,r),p=hs(t,h[1],s,i,r);if(d){const e=Nt(hs(t,"min",s),p,l);n=e<u?u:e}else if(c){const e=Nt(hs(t,"max",s),p,l);n=e>u?u:e}else n=Nt(u,p,l)}else n=hs(t,e,s,i,r)}else n=e;return pt(n,0)},cs=t=>{let e;const s=t.targets;for(let t=0,i=s.length;t<i;t++){const i=s[t];if(i[o]){e=i;break}}return e};let us=0;const ps=["#FF4B4B","#FF971B","#FFC730","#F9F640","#7AFF5A","#18FF74","#17E09B","#3CFFEC","#05DBE9","#33B3F1","#638CF9","#C563FE","#FF4FCF","#F93F8A"];class ms{constructor(t={}){I.current&&I.current.register(this);const e=St(t.sync,"play pause"),s=e?be(e):null,r=e&&("linear"===e||e===de),n=e&&!(s===de&&!r),o=e&&(O(e)||!0===e||r),a=e&&z(e)&&!n&&!o,l=a?e.split(" ").map(t=>()=>{const e=this.linked;return e&&e[t]?e[t]():null}):null,h=a&&l.length>2;this.index=us++,this.id=X(t.id)?this.index:t.id,this.container=(t=>{const e=t&&ne(t)[0]||i.body;let s=as.get(e);return s||(s=new ls(e),as.set(e,s)),s})(t.container),this.target=null,this.linked=null,this.repeat=null,this.horizontal=null,this.enter=null,this.leave=null,this.sync=n||o||!!l,this.syncEase=n?s:null,this.syncSmooth=o?!0===e||r?1:e:null,this.onSyncEnter=l&&!h&&l[0]?l[0]:v,this.onSyncLeave=l&&!h&&l[1]?l[1]:v,this.onSyncEnterForward=l&&h&&l[0]?l[0]:v,this.onSyncLeaveForward=l&&h&&l[1]?l[1]:v,this.onSyncEnterBackward=l&&h&&l[2]?l[2]:v,this.onSyncLeaveBackward=l&&h&&l[3]?l[3]:v,this.onEnter=t.onEnter||v,this.onLeave=t.onLeave||v,this.onEnterForward=t.onEnterForward||v,this.onLeaveForward=t.onLeaveForward||v,this.onEnterBackward=t.onEnterBackward||v,this.onLeaveBackward=t.onLeaveBackward||v,this.onUpdate=t.onUpdate||v,this.onSyncComplete=t.onSyncComplete||v,this.reverted=!1,this.ready=!1,this.completed=!1,this.began=!1,this.isInView=!1,this.forceEnter=!1,this.hasEntered=!1,this.offset=0,this.offsetStart=0,this.offsetEnd=0,this.distance=0,this.prevProgress=0,this.thresholds=["start","end","end","start"],this.coords=[0,0,0,0],this.debugStyles=null,this.$debug=null,this._params=t,this._debug=St(t.debug,!1),this._next=null,this._prev=null,xt(this.container,this),is(()=>{if(!this.reverted){if(!this.target){const e=ne(t.target)[0];this.target=e||i.body,this.refresh()}this._debug&&this.debug()}})}link(t){if(t&&(t.pause(),this.linked=t,X(t)||(t.persist=!0),!this._params.target)){let e;X(t.targets)?bt(t,t=>{t.targets&&!e&&(e=cs(t))}):e=cs(t),this.target=e||i.body,this.refresh()}return this}get velocity(){return this.container.velocity}get backward(){return this.horizontal?this.container.backwardX:this.container.backwardY}get scroll(){return this.horizontal?this.container.scrollX:this.container.scrollY}get progress(){const t=(this.scroll-this.offsetStart)/this.distance;return t===1/0||isNaN(t)?0:pt(ct(t,0,1),6)}refresh(){this.ready=!0,this.reverted=!1;const t=this._params;return this.repeat=St(os(t.repeat,this),!0),this.horizontal="x"===St(os(t.axis,this),"y"),this.enter=St(os(t.enter,this),"end start"),this.leave=St(os(t.leave,this),"start end"),this.updateBounds(),this.handleScroll(),this}removeDebug(){return this.$debug&&(this.$debug.parentNode.removeChild(this.$debug),this.$debug=null),this.debugStyles&&(this.debugStyles.revert(),this.$debug=null),this}debug(){this.removeDebug();const t=this.container,e=this.horizontal,s=t.element.querySelector(":scope > .animejs-onscroll-debug"),r=i.createElement("div"),n=i.createElement("div"),o=i.createElement("div"),a=ps[this.index%ps.length],l=t.useWin,h=l?t.winWidth:t.width,d=l?t.winHeight:t.height,c=t.scrollWidth,u=t.scrollHeight,p=this.container.width>360?320:260,m=e?0:10,f=e?10:0,g=e?24:p/2,y=e?g:15,v=e?60:g,_=e?v:y,b=e?"repeat-x":"repeat-y",T=t=>e?"0px "+t+"px":t+"px 2px",x=t=>`linear-gradient(${e?90:0}deg, ${t} 2px, transparent 1px)`,w=(t,e,s,i,r)=>`position:${t};left:${e}px;top:${s}px;width:${i}px;height:${r}px;`;r.style.cssText=`${w("absolute",m,f,e?c:p,e?p:u)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${e?"column":"row"};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `,n.style.cssText=`${w("sticky",0,0,e?h:g,e?g:d)}`,s||(n.style.cssText+=`background:\n        ${x("#FFFF")}${T(g-10)} / 100px 100px ${b},\n        ${x("#FFF8")}${T(g-10)} / 10px 10px ${b};\n      `),o.style.cssText=`${w("relative",0,0,e?c:g,e?g:u)}`,s||(o.style.cssText+=`background:\n        ${x("#FFFF")}${T(0)} / ${e?"100px 10px":"10px 100px"} ${b},\n        ${x("#FFF8")}${T(0)} / ${e?"10px 0px":"0px 10px"} ${b};\n      `);const S=[" enter: "," leave: "];this.coords.forEach((t,s)=>{const r=s>1,l=(r?0:this.offset)+t,m=s%2,f=l<_,g=l>(r?e?h:d:e?c:u)-_,b=(r?m&&!f:!m&&!f)||g,T=i.createElement("div"),x=i.createElement("div"),$=e?b?"right":"left":b?"bottom":"top",E=b?(e?v:y)+(r?e?-1:g?0:-2:e?-1:-2):e?1:0;x.innerHTML=`${this.id}${S[m]}${this.thresholds[s]}`,T.style.cssText=`${w("absolute",0,0,v,y)}\n        display: flex;\n        flex-direction: ${e?"column":"row"};\n        justify-content: flex-${r?"start":"end"};\n        align-items: flex-${b?"end":"start"};\n        border-${$}: 2px solid ${a};\n      `,x.style.cssText=`\n        overflow: hidden;\n        max-width: ${p/2-10}px;\n        height: ${y};\n        margin-${e?b?"right":"left":b?"bottom":"top"}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${e&&b||!e&&!r?"right":"left"};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${m?a:"rgba(0,0,0,.75)"};\n        background-color: ${m?"rgba(0,0,0,.65)":a};\n        border: 2px solid ${m?a:"transparent"};\n        border-${e?b?"top-left":"top-right":b?"top-left":"bottom-left"}-radius: 5px;\n        border-${e?b?"bottom-left":"bottom-right":b?"top-right":"bottom-right"}-radius: 5px;\n      `,T.appendChild(x);let k=l-E+(e?1:0);T.style[e?"left":"top"]=`${k}px`,(r?n:o).appendChild(T)}),r.appendChild(n),r.appendChild(o),t.element.appendChild(r),s||r.classList.add("animejs-onscroll-debug"),this.$debug=r,"static"===Pe(t.element,"position")&&(this.debugStyles=Fe(t.element,{position:"relative "}))}updateBounds(){let t;this._debug&&this.removeDebug();const e=this.target,s=this.container,r=this.horizontal,n=this.linked;let o,a=e;for(n&&(o=n.currentTime,n.seek(0,!0)),a.parentElement;a&&a!==s.element&&a!==i.body;){const e="sticky"===Pe(a,"position")&&Fe(a,{position:"static"});a=a.parentElement,e&&(t||(t=[]),t.push(e))}const l=e.getBoundingClientRect(),h=s.scale,d=(r?l.left+s.scrollX-s.left:l.top+s.scrollY-s.top)*h,c=(r?l.width:l.height)*h,u=r?s.width:s.height,p=(r?s.scrollWidth:s.scrollHeight)-u,m=this.enter,f=this.leave;let g="start",y="end",v="end",_="start";if(z(m)){const t=m.split(" ");v=t[0],g=t.length>1?t[1]:g}else if(M(m)){const t=m;X(t.container)||(v=t.container),X(t.target)||(g=t.target)}else O(m)&&(v=m);if(z(f)){const t=f.split(" ");_=t[0],y=t.length>1?t[1]:y}else if(M(f)){const t=f;X(t.container)||(_=t.container),X(t.target)||(y=t.target)}else O(f)&&(_=f);const b=ds(e,g,c),T=ds(e,y,c),x=b+d-u,w=T+d-p,S=ds(e,v,u,x,w),$=ds(e,_,u,x,w),E=b+d-S,k=T+d-$,C=k-E;this.offset=d,this.offsetStart=E,this.offsetEnd=k,this.distance=C<=0?0:C,this.thresholds=[g,y,v,_],this.coords=[b,T,S,$],t&&t.forEach(t=>t.revert()),n&&n.seek(o,!0),this._debug&&this.debug()}handleScroll(){if(!this.ready)return;const t=this.linked,e=this.sync,s=this.syncEase,i=this.syncSmooth,r=t&&(s||i),n=this.horizontal,o=this.container,a=this.scroll,l=a<=this.offsetStart,h=a>=this.offsetEnd,d=!l&&!h,c=a===this.offsetStart||a===this.offsetEnd,u=!this.hasEntered&&c,p=this._debug&&this.$debug;let m=!1,f=!1,g=this.progress;if(l&&this.began&&(this.began=!1),g>0&&!this.began&&(this.began=!0),r){const e=t.progress;if(i&&O(i)){if(i<1){const t=1e-4,s=e<g&&1===g?t:e>g&&!g?-t:0;g=pt(ft(e,g,ft(.01,.2,i))+s,6)}}else s&&(g=s(g));m=g!==this.prevProgress,f=1===e,m&&!f&&i&&e&&o.wakeTicker.restart()}if(p){const t=n?o.scrollY:o.scrollX;p.style[n?"top":"left"]=t+10+"px"}(d&&!this.isInView||u&&!this.forceEnter&&!this.hasEntered)&&(d&&(this.isInView=!0),this.forceEnter&&this.hasEntered?d&&(this.forceEnter=!1):(p&&d&&(p.style.zIndex=""+this.container.zIndex++),this.onSyncEnter(this),this.onEnter(this),this.backward?(this.onSyncEnterBackward(this),this.onEnterBackward(this)):(this.onSyncEnterForward(this),this.onEnterForward(this)),this.hasEntered=!0,u&&(this.forceEnter=!0))),(d||!d&&this.isInView)&&(m=!0),m&&(r&&t.seek(t.duration*g),this.onUpdate(this)),!d&&this.isInView&&(this.isInView=!1,this.onSyncLeave(this),this.onLeave(this),this.backward?(this.onSyncLeaveBackward(this),this.onLeaveBackward(this)):(this.onSyncLeaveForward(this),this.onLeaveForward(this)),e&&!i&&(f=!0)),g>=1&&this.began&&!this.completed&&(e&&f||!e)&&(e&&this.onSyncComplete(this),this.completed=!0,(!this.repeat&&!t||!this.repeat&&t&&t.completed)&&this.revert()),g<1&&this.completed&&(this.completed=!1),this.prevProgress=g}revert(){if(this.reverted)return;const t=this.container;return Tt(t,this),t._head||t.revert(),this._debug&&this.removeDebug(),this.reverted=!0,this.ready=!1,this}}const fs=(t,e,s)=>(((1-3*s+3*e)*t+(3*s-6*e))*t+3*e)*t,gs=(t=.5,e=0,s=.5,i=1)=>t===e&&s===i?de:r=>0===r||1===r?r:fs(((t,e,s)=>{let i,r,n=0,o=1,a=0;do{r=n+(o-n)/2,i=fs(r,e,s)-t,i>0?o=r:n=r}while(st(i)>1e-7&&++a<100);return r})(r,t,s),e,i),ys=(t=10,e)=>{const s=e?rt:nt;return e=>s(ct(e,0,1)*t)*(1/t)},vs=(...t)=>{const e=t.length;if(!e)return de;const s=e-1,i=t[0],r=t[s],n=[0],o=[Z(i)];for(let e=1;e<s;e++){const i=t[e],r=z(i)?i.trim().split(" "):[i],a=r[0],l=r[1];n.push(X(l)?e/s:Z(l)/100),o.push(Z(a))}return o.push(Z(r)),n.push(1),function(t){for(let e=1,s=n.length;e<s;e++){const s=n[e];if(t<=s){const i=n[e-1],r=o[e-1];return r+(o[e]-r)*(t-i)/(s-i)}}return o[o.length-1]}},_s=(t=10,e=1)=>{const s=[0],i=t-1;for(let t=1;t<i;t++){const r=s[t-1],n=t/i,o=n*(1-e)+(n+((t+1)/i-n)*Math.random())*e;s.push(ct(o,r,1))}return s.push(1),vs(...s)};var bs=Object.freeze({__proto__:null,Spring:je,createSpring:Qe,cubicBezier:gs,eases:ge,irregular:_s,linear:vs,spring:Ge,steps:ys});const Ts=(t,e=100)=>{const s=[];for(let i=0;i<=e;i++)s.push(pt(t(i/e),4));return`linear(${s.join(", ")})`},xs={},ws=t=>{let e=xs[t];if(e)return e;if(e="linear",z(t)){if(P(t,"linear")||P(t,"cubic-")||P(t,"steps")||P(t,"ease"))e=t;else if(P(t,"cubicB"))e=R(t);else{const s=ve(t);H(s)&&(e=s===de?"linear":Ts(s))}xs[t]=e}else if(H(t)){const s=Ts(t);s&&(e=s)}else t.ease&&(e=Ts(t.ease));return e},Ss=["x","y","z"],$s=["perspective","width","height","margin","padding","top","right","bottom","left","borderWidth","fontSize","borderRadius",...Ss],Es=(()=>[...Ss,...g.filter(t=>["X","Y","Z"].some(e=>t.endsWith(e)))])();let ks=null;const Cs=(t,e,s,i,r)=>{let n=z(e)?e:$t(e,s,i,r);return O(n)?$s.includes(t)||P(t,"translate")?`${n}px`:P(t,"rotate")||P(t,"skew")?`${n}deg`:`${n}`:n},Ns=(t,e,s,i,r,n)=>{let o="0";const a=X(i)?getComputedStyle(t)[e]:Cs(e,i,t,r,n);return o=X(s)?V(i)?i.map(s=>Cs(e,s,t,r,n)):a:[Cs(e,s,t,r,n),a],o};class Ds{constructor(t,s){I.current&&I.current.register(this),Y(ks)&&(!e||!X(CSS)&&Object.hasOwnProperty.call(CSS,"registerProperty")?(g.forEach(t=>{const e=P(t,"skew"),s=P(t,"scale"),i=P(t,"rotate"),r=P(t,"translate"),n=i||e,o=n?"<angle>":s?"<number>":r?"<length-percentage>":"*";try{CSS.registerProperty({name:"--"+t,syntax:o,inherits:!1,initialValue:r?"0px":n?"0deg":s?"1":"0"})}catch{}}),ks=!0):ks=!1);const i=oe(t),r=i.length;r||console.warn("No target found. Make sure the element you're trying to animate is accessible before creating your animation.");const n=St(s.autoplay,L.defaults.autoplay),o=!(!n||!n.link)&&n,a=s.alternate&&!0===s.alternate,h=s.reversed&&!0===s.reversed,d=St(s.loop,L.defaults.loop),c=!0===d||d===1/0?1/0:O(d)?d+1:1,u=a?h?"alternate-reverse":"alternate":h?"reverse":"normal",_=1===L.timeScale?1:p;this.targets=i,this.animations=[],this.controlAnimation=null,this.onComplete=s.onComplete||L.defaults.onComplete,this.duration=0,this.muteCallbacks=!1,this.completed=!1,this.paused=!n||!1!==o,this.reversed=h,this.persist=St(s.persist,L.defaults.persist),this.autoplay=n,this._speed=St(s.playbackRate,L.defaults.playbackRate),this._resolve=v,this._completed=0,this._inlineStyles=[],i.forEach((t,e)=>{const i=t[l],n=Es.some(t=>s.hasOwnProperty(t)),o=t.style,a=this._inlineStyles[e]={},h=St(s.ease,L.defaults.ease),d=$t(h,t,e,r),p=H(d)||z(d)?d:h,v=h.ease&&h,b=ws(p),T=(v?v.settlingDuration:$t(St(s.duration,L.defaults.duration),t,e,r))*_,x=$t(St(s.delay,L.defaults.delay),t,e,r)*_,w=St(s.composition,"replace");for(let l in s){if(!G(l))continue;const h={},d={iterations:c,direction:u,fill:"both",easing:b,duration:T,delay:x,composite:w},p=s[l],m=!!n&&(g.includes(l)?l:f.get(l)),y=m?"transform":l;let v;if(a[y]||(a[y]=o[y]),M(p)){const s=p,n=St(s.ease,b),a=n.ease&&n,c=s.to,u=s.from;if(d.duration=(a?a.settlingDuration:$t(St(s.duration,T),t,e,r))*_,d.delay=$t(St(s.delay,x),t,e,r)*_,d.composite=St(s.composition,w),d.easing=ws(n),v=Ns(t,l,u,c,e,r),m?(h[`--${m}`]=v,i[m]=v):h[l]=Ns(t,l,u,c,e,r),Re(this,t,l,h,d),!X(u))if(m){const t=`--${m}`;o.setProperty(t,h[t][0])}else o[l]=h[l][0]}else v=V(p)?p.map(s=>Cs(l,s,t,e,r)):Cs(l,p,t,e,r),m?(h[`--${m}`]=v,i[m]=v):h[l]=v,Re(this,t,l,h,d)}if(n){let t=m;for(let e in i)t+=`${y[e]}var(--${e})) `;o.transform=t}}),o&&this.autoplay.link(this)}forEach(t){try{const e=z(t)?e=>e[t]():t;this.animations.forEach(e)}catch{}return this}get speed(){return this._speed}set speed(t){this._speed=+t,this.forEach(e=>e.playbackRate=t)}get currentTime(){const t=this.controlAnimation,e=L.timeScale;return this.completed?this.duration:t?+t.currentTime*(1===e?1:e):0}set currentTime(t){const e=t*(1===L.timeScale?1:p);this.forEach(t=>{!this.persist&&e>=this.duration&&t.play(),t.currentTime=e})}get progress(){return this.currentTime/this.duration}set progress(t){this.forEach(e=>e.currentTime=t*this.duration||0)}resume(){return this.paused?(this.paused=!1,this.forEach("play")):this}pause(){return this.paused?this:(this.paused=!0,this.forEach("pause"))}alternate(){return this.reversed=!this.reversed,this.forEach("reverse"),this.paused&&this.forEach("pause"),this}play(){return this.reversed&&this.alternate(),this.resume()}reverse(){return this.reversed||this.alternate(),this.resume()}seek(t,e=!1){return e&&(this.muteCallbacks=!0),t<this.duration&&(this.completed=!1),this.currentTime=t,this.muteCallbacks=!1,this.paused&&this.pause(),this}restart(){return this.completed=!1,this.seek(0,!0).resume()}commitStyles(){return this.forEach("commitStyles")}complete(){return this.seek(this.duration)}cancel(){return this.muteCallbacks=!0,this.commitStyles().forEach("cancel"),this.animations.length=0,requestAnimationFrame(()=>{this.targets.forEach(t=>{"none"===t.style.transform&&t.style.removeProperty("transform")})}),this}revert(){return this.cancel().targets.forEach((t,e)=>{const s=t.style,i=this._inlineStyles[e];for(let e in i){const r=i[e];X(r)||r===m?s.removeProperty(R(e)):t.style[e]=r}t.getAttribute("style")===m&&t.removeAttribute("style")}),this}then(t=v){const e=this.then,s=()=>{this.then=null,t(this),this.then=e,this._resolve=v};return new Promise(t=>(this._resolve=()=>t(s()),this.completed&&this._resolve(),this))}}const Is={animate:(t,e)=>new Ds(t,e),convertEase:Ts};let Ls=0,As=0;const Bs=(t,e)=>!(!t||!e)&&(t===e||t.contains(e)),Rs=(t,e)=>{let s=t[e];for(;s&&s.nodeType===Node.TEXT_NODE&&!s.textContent.trim();)s=s[e];return s&&s.nodeType===Node.TEXT_NODE},Ps=t=>{if(!t)return null;const e=t.style,s=e.transition||"";return e.setProperty("transition","none","important"),s},Fs=(t,e)=>{if(!t)return;const s=t.style;e?s.transition=e:s.removeProperty("transition")},Vs=t=>{const e=t.layout.transitionMuteStore,s=t.$el,i=t.$measure;s&&!e.has(s)&&e.set(s,Ps(s)),i&&!e.has(i)&&e.set(i,Ps(i))},Ms=t=>{t.forEach((t,e)=>Fs(e,t)),t.clear()},Os={display:"none",visibility:"hidden",opacity:"0",transform:"none",position:"static"},zs=t=>{if(!t)return;const e=t.parentNode;e&&(e._head===t&&(e._head=t._next),e._tail===t&&(e._tail=t._prev),t._prev&&(t._prev._next=t._next),t._next&&(t._next._prev=t._prev),t._prev=null,t._next=null,t.parentNode=null)},Hs=(t,e,s,i)=>{let r=t.dataset.layoutId;r||(r=t.dataset.layoutId="node-"+As++);const n=i||{};return n.$el=t,n.$measure=t,n.id=r,n.index=0,n.total=1,n.delay=0,n.duration=0,n.ease=null,n.state=s,n.layout=s.layout,n.parentNode=e||null,n.isTarget=!1,n.isEntering=!1,n.isLeaving=!1,n.isInlined=!1,n.hasTransform=!1,n.inlineStyles=[],n.inlineTransforms=null,n.inlineTransition=null,n.branchAdded=!1,n.branchRemoved=!1,n.branchNotRendered=!1,n.sizeChanged=!1,n.hasVisibilitySwap=!1,n.hasDisplayNone=!1,n.hasVisibilityHidden=!1,n.measuredInlineTransform=null,n.measuredInlineTransition=null,n.measuredDisplay=null,n.measuredVisibility=null,n.measuredPosition=null,n.measuredHasDisplayNone=!1,n.measuredHasVisibilityHidden=!1,n.measuredIsVisible=!1,n.measuredIsRemoved=!1,n.measuredIsInsideRoot=!1,n.properties={transform:"none",x:0,y:0,left:0,top:0,clientLeft:0,clientTop:0,width:0,height:0},n.layout.properties.forEach(t=>n.properties[t]=0),n._head=null,n._tail=null,n._prev=null,n._next=null,n},Xs=(t,e,s,i)=>{const r=t.$el,n=t.layout.root,o=n===r,a=t.properties,l=t.state.rootNode,h=t.parentNode,d=s.transform,c=r.style.transform,u=!!h&&h.measuredIsRemoved,p=s.position;if(o&&(t.layout.absoluteCoords="fixed"===p||"absolute"===p),t.$measure=e,t.inlineTransforms=c,t.hasTransform=d&&"none"!==d,t.measuredIsInsideRoot=Bs(n,e),t.measuredInlineTransform=null,t.measuredDisplay=s.display,t.measuredVisibility=s.visibility,t.measuredPosition=p,t.measuredHasDisplayNone="none"===s.display,t.measuredHasVisibilityHidden="hidden"===s.visibility,t.measuredIsVisible=!(t.measuredHasDisplayNone||t.measuredHasVisibilityHidden),t.measuredIsRemoved=t.measuredHasDisplayNone||t.measuredHasVisibilityHidden||u,t.isInlined=t.measuredDisplay.includes("inline")&&(t=>Rs(t,"previousSibling")||Rs(t,"nextSibling"))(r),t.hasTransform&&!i){const s=t.layout.transitionMuteStore;s.get(r)||(t.inlineTransition=Ps(r)),e===r?r.style.transform="none":(s.get(e)||(t.measuredInlineTransition=Ps(e)),t.measuredInlineTransform=e.style.transform,e.style.transform="none")}let m,f,g=0,y=0,v=0,_=0;if(!i){const t=e.getBoundingClientRect();g=t.left,y=t.top,v=t.width,_=t.height}for(let t in a){const e="transform"===t?d:s[t]||s.getPropertyValue&&s.getPropertyValue(t);X(e)||(a[t]=e)}if(a.left=g,a.top=y,a.clientLeft=i?0:e.clientLeft,a.clientTop=i?0:e.clientTop,o)t.layout.absoluteCoords?(m=g,f=y):(m=0,f=0);else{const e=h||l,s=e.properties.left,i=e.properties.top,r=e.properties.clientLeft,n=e.properties.clientTop;if(t.layout.absoluteCoords)m=g-s-r,f=y-i-n;else if(e===l){const t=l.properties.left,e=l.properties.top;m=g-t-l.properties.clientLeft,f=y-e-l.properties.clientTop}else m=g-s-r,f=y-i-n}return a.x=m,a.y=f,a.width=v,a.height=_,t},Ys=(t,e)=>{if(e)for(let s in e)t.properties[s]=e[s]},Ws=(t,e)=>{const s=$t(e.ease,t.$el,t.index,t.total),i=H(s)?s:e.ease,r=!X(i)&&!X(i.ease);t.ease=r?i.ease:i,t.duration=r?i.settlingDuration:$t(e.duration,t.$el,t.index,t.total),t.delay=$t(e.delay,t.$el,t.index,t.total)},Us=t=>{const e=t.$el.style,s=t.inlineStyles;s.length=0,t.layout.recordedProperties.forEach(t=>{s.push(t,e[t]||"")})},qs=t=>{const e=t.$el.style,s=t.inlineStyles;for(let t=0,i=s.length;t<i;t+=2){const i=s[t],r=s[t+1];r&&""!==r?e[i]=r:(e[i]="",e.removeProperty(i))}},js=t=>{const e=t.inlineTransforms,s=t.$el.style;!t.hasTransform||!e||t.hasTransform&&"none"===s.transform||e&&"none"===e?s.removeProperty("transform"):e&&(s.transform=e);const i=t.$measure;if(t.hasTransform&&i!==t.$el){const e=i.style,s=t.measuredInlineTransform;s&&""!==s?e.transform=s:e.removeProperty("transform")}t.measuredInlineTransform=null,null!==t.inlineTransition&&(Fs(t.$el,t.inlineTransition),t.inlineTransition=null),i!==t.$el&&null!==t.measuredInlineTransition&&(Fs(i,t.measuredInlineTransition),t.measuredInlineTransition=null)},Gs=t=>{(t.measuredIsRemoved||t.hasVisibilitySwap)&&(t.$el.style.removeProperty("display"),t.$el.style.removeProperty("visibility"),t.hasVisibilitySwap&&(t.$measure.style.removeProperty("display"),t.$measure.style.removeProperty("visibility"))),t.layout.pendingRemoval.delete(t.$el)},Qs=(t,e,s)=>(e.properties={...t.properties},e.state=s,e.isTarget=t.isTarget,e.hasTransform=t.hasTransform,e.inlineTransforms=t.inlineTransforms,e.measuredIsVisible=t.measuredIsVisible,e.measuredDisplay=t.measuredDisplay,e.measuredIsRemoved=t.measuredIsRemoved,e.measuredHasDisplayNone=t.measuredHasDisplayNone,e.measuredHasVisibilityHidden=t.measuredHasVisibilityHidden,e.hasDisplayNone=t.hasDisplayNone,e.isInlined=t.isInlined,e.hasVisibilityHidden=t.hasVisibilityHidden,e);class Zs{constructor(t){this.layout=t,this.rootNode=null,this.rootNodes=new Set,this.nodes=new Map,this.scrollX=0,this.scrollY=0}revert(){return this.forEachNode(t=>{this.layout.pendingRemoval.delete(t.$el),t.$el.removeAttribute("data-layout-id"),t.$measure.removeAttribute("data-layout-id")}),this.rootNode=null,this.rootNodes.clear(),this.nodes.clear(),this}getNode(t){if(t&&t.dataset)return this.nodes.get(t.dataset.layoutId)}getComputedValue(t,e){const s=this.getNode(t);if(s)return s.properties[e]}forEach(t,e){let s=t,i=0;for(;s;)if(e(s,i++),s._head)s=s._head;else if(s._next)s=s._next;else{for(;s&&!s._next;)s=s.parentNode;s&&(s=s._next)}}forEachRootNode(t){this.forEach(this.rootNode,t)}forEachNode(t){for(const e of this.rootNodes)this.forEach(e,t)}registerElement(t,e){if(!t||1!==t.nodeType)return null;this.layout.transitionMuteStore.has(t)||this.layout.transitionMuteStore.set(t,Ps(t));const s=[t,e],i=this.layout.root;let r=null;for(;s.length;){const t=s.pop(),e=s.pop();if(!e||1!==e.nodeType||W(e))continue;const n=!!t&&t.measuredIsRemoved,o=n?Os:getComputedStyle(e),a=!!n||"none"===o.display,l=!!n||"hidden"===o.visibility,h=!a&&!l,d=e.dataset.layoutId,c=Bs(i,e);let u=d?this.nodes.get(d):null;if(u&&u.$el!==e){const a=Bs(i,u.$el),l=u.measuredIsVisible;if(a||!c&&(c||l||!h)){if(a&&!l&&h){Xs(u,e,o,n);let t=e.lastElementChild;for(;t;)s.push(t,u),t=t.previousElementSibling;r||(r=u);continue}{let i=e.lastElementChild;for(;i;)s.push(i,t),i=i.previousElementSibling;r||(r=u);continue}}zs(u),u=Hs(e,t,this,u)}else u=Hs(e,t,this,u);u.branchAdded=!1,u.branchRemoved=!1,u.branchNotRendered=!1,u.isTarget=!1,u.sizeChanged=!1,u.hasVisibilityHidden=l,u.hasDisplayNone=a,u.hasVisibilitySwap=l&&!u.measuredHasVisibilityHidden||a&&!u.measuredHasDisplayNone,this.nodes.set(u.id,u),u.parentNode=t||null,u._prev=null,u._next=null,t?(this.rootNodes.delete(u),t._head?(t._tail._next=u,u._prev=t._tail,t._tail=u):(t._head=u,t._tail=u)):this.rootNodes.add(u),Xs(u,u.$el,o,n);let p=e.lastElementChild;for(;p;)s.push(p,u),p=p.previousElementSibling;r||(r=u)}return r}ensureDetachedNode(t,e){if(!t||t===this.layout.root)return null;const s=t.dataset.layoutId,i=s?this.nodes.get(s):null;if(i&&i.$el===t)return i;let r=null,n=t.parentElement;for(;n&&n!==this.layout.root;){if(e.has(n)){r=this.ensureDetachedNode(n,e);break}n=n.parentElement}return this.registerElement(t,r)}record(){const t=this.layout,e=t.children,s=t.root,i=V(e)?e:[e],r=[],n="*"===e?s:I.root,o=[];let a=s.parentElement;for(;a&&1===a.nodeType;){const t=getComputedStyle(a);if(t.transform&&"none"!==t.transform){const t=a.style.transform||"",e=Ps(a);o.push(a,t,e),a.style.transform="none"}a=a.parentElement}for(let t=0,e=i.length;t<e;t++){const e=i[t];r[t]=z(e)?n.querySelectorAll(e):e}const l=oe(r);this.nodes.clear(),this.rootNodes.clear();const h=this.registerElement(s,null);h.isTarget=!0,this.rootNode=h;const d=new Set;let c=0,u=this.nodes.size;this.nodes.forEach((t,e)=>{t.index=c++,t.total=u,t&&t.measuredIsInsideRoot&&d.add(e)});const p=new Set,m=[];for(let t=0,e=l.length;t<e;t++){const e=l[t];if(e&&1===e.nodeType&&e!==s){if(!Bs(s,e)){const t=e.dataset.layoutId;if(!t||!d.has(t))continue}p.has(e)||(p.add(e),m.push(e))}}for(let t=0,e=m.length;t<e;t++)this.ensureDetachedNode(m[t],p);for(let t=0,e=l.length;t<e;t++){const e=l[t],s=this.getNode(e);if(s){let t=s;for(;t&&!t.isTarget;)t.isTarget=!0,t=t.parentNode}}this.scrollX=window.scrollX,this.scrollY=window.scrollY,this.forEachNode(js);for(let t=0,e=o.length;t<e;t+=3){const e=o[t],s=o[t+1],i=o[t+2];s&&""!==s?e.style.transform=s:e.style.removeProperty("transform"),Fs(e,i)}return this}}function Js(t){const e={},s={};for(let i in t){const r=t[i];"duration"===i||"delay"===i||"ease"===i?s[i]=r:e[i]=r}return[e,s]}class Ks{constructor(t,e={}){I.current&&I.current.register(this);const s=Js(e.swapAt),i=Js(e.enterFrom),r=Js(e.leaveTo),n=e.properties;if(e.duration=St(e.duration,350),e.delay=St(e.delay,0),e.ease=St(e.ease,"inOut(3.5)"),this.params=e,this.root=oe(t)[0],this.id=Ls++,this.children=e.children||"*",this.absoluteCoords=!1,this.swapAtParams=_t(e.swapAt||{opacity:0},{ease:"inOut(1.75)"}),this.enterFromParams=e.enterFrom||{opacity:0},this.leaveToParams=e.leaveTo||{opacity:0},this.properties=new Set(["opacity","fontSize","color","backgroundColor","borderRadius","border","filter","clipPath"]),s[0])for(let t in s[0])this.properties.add(t);if(i[0])for(let t in i[0])this.properties.add(t);if(r[0])for(let t in r[0])this.properties.add(t);if(n)for(let t=0,e=n.length;t<e;t++)this.properties.add(n[t]);this.recordedProperties=new Set(["display","visibility","translate","position","left","top","marginLeft","marginTop","width","height","maxWidth","maxHeight","minWidth","minHeight"]),this.properties.forEach(t=>this.recordedProperties.add(t)),this.pendingRemoval=new WeakSet,this.transitionMuteStore=new Map,this.oldState=new Zs(this),this.newState=new Zs(this),this.timeline=null,this.transformAnimation=null,this.animating=[],this.swapping=[],this.leaving=[],this.entering=[],this.oldState.record(),Ms(this.transitionMuteStore)}revert(){return this.root.classList.remove("is-animated"),this.timeline&&(this.timeline.complete(),this.timeline=null),this.transformAnimation&&(this.transformAnimation.complete(),this.transformAnimation=null),this.animating.length=this.swapping.length=this.leaving.length=this.entering.length=0,this.oldState.revert(),this.newState.revert(),requestAnimationFrame(()=>Ms(this.transitionMuteStore)),this}record(){return this.transformAnimation&&(this.transformAnimation.cancel(),this.transformAnimation=null),this.oldState.record(),this.timeline&&(this.timeline.cancel(),this.timeline=null),this.newState.forEachRootNode(qs),this}animate(t={}){const e={ease:St(t.ease,this.params.ease),delay:St(t.delay,this.params.delay),duration:St(t.duration,this.params.duration)},s={},i=St(t.onComplete,this.params.onComplete),r=St(t.onPause,this.params.onPause);for(let e in D)"ease"!==e&&"duration"!==e&&"delay"!==e&&(X(t[e])?X(this.params[e])||(s[e]=this.params[e]):s[e]=t[e]);s.onComplete=()=>{this.transformAnimation&&this.transformAnimation.cancel(),f.forEachRootNode(t=>{Gs(t),qs(t)});for(let t=0,e=w.length;t<e;t++){const e=w[t];e.style.transform=f.getComputedValue(e,"transform")}this.root.classList.contains("is-animated")&&(this.root.classList.remove("is-animated"),i&&i(this.timeline)),requestAnimationFrame(()=>{this.root.classList.contains("is-animated")||Ms(this.transitionMuteStore)})},s.onPause=()=>{this.root.classList.contains("is-animated")&&(this.transformAnimation&&this.transformAnimation.cancel(),f.forEachRootNode(Gs),this.root.classList.remove("is-animated"),i&&i(this.timeline),r&&r(this.timeline))},s.composition=!1;const n=_t(_t(t.swapAt||{},this.swapAtParams),e),o=_t(_t(t.enterFrom||{},this.enterFromParams),e),a=_t(_t(t.leaveTo||{},this.leaveToParams),e),[l,h]=Js(n),[d,c]=Js(o),[u,p]=Js(a),m=this.oldState,f=this.newState,g=this.animating,y=this.swapping,v=this.entering,_=this.leaving,b=this.pendingRemoval;g.length=y.length=v.length=_.length=0,m.forEachRootNode(Vs),f.record(),f.forEachRootNode(Us);const T=[],x=[],w=[],S=[],$=f.rootNode,E=$.$el;f.forEachRootNode(t=>{const e=t.$el,s=t.id,i=t.parentNode,r=!!i&&i.branchAdded,n=!!i&&i.branchRemoved,o=!!i&&i.branchNotRendered;let a=m.nodes.get(s);const l=!a;l?(a=Qs(t,{},m),m.nodes.set(s,a),a.measuredIsRemoved=!0):a.measuredIsRemoved&&!t.measuredIsRemoved&&(Qs(t,a,m),a.measuredIsRemoved=!0);const h=a.parentNode,c=(h?h.id:null)!==(i?i.id:null),p=a.$el!==t.$el,y=a.measuredIsRemoved,x=t.measuredIsRemoved;if(!a.measuredIsRemoved&&!x&&!l&&(c||p)){const t=a.properties.left,e=a.properties.top,s=i||f.rootNode,r=s.id?m.nodes.get(s.id):null,n=r?r.properties.left:s.properties.left,o=r?r.properties.top:s.properties.top,l=r?r.properties.clientLeft:s.properties.clientLeft,h=r?r.properties.clientTop:s.properties.clientTop;a.properties.x=t-n-l,a.properties.y=e-o-h}t.hasVisibilitySwap&&(t.hasVisibilityHidden&&(t.$el.style.visibility="visible",t.$measure.style.visibility="hidden"),t.hasDisplayNone&&(t.$el.style.display=a.measuredDisplay||t.measuredDisplay||"",t.$measure.style.visibility="hidden"));const w=b.has(e),S=a.measuredIsVisible,E=t.measuredIsVisible,k=!S&&E&&!o,C=!x&&(y||w)&&!r,N=x&&!y&&!n,D=N||x&&w&&!n;t.branchAdded=r||C,t.branchRemoved=n||D,t.branchNotRendered=o||x,x&&S&&(t.$el.style.display=a.measuredDisplay,t.$el.style.visibility="visible",Qs(a,t,f)),N?(t.isTarget&&(_.push(e),t.isLeaving=!0),b.add(e)):!x&&w&&b.delete(e),C&&!o||k?(Ys(a,d),t.isTarget&&(v.push(e),t.isEntering=!0)):D&&!o&&Ys(t,u),t===$||!t.isTarget||t.isEntering||t.isLeaving||g.push(e),T.push(e)});let k=0,C=0,N=0;f.forEachRootNode(t=>{const s=t.$el,i=t.parentNode,r=m.nodes.get(t.id),n=t.properties,o=r.properties;let a=i!==$&&i;for(;a&&!a.isTarget&&a!==$;)a=a.parentNode;const d=g.length;t===$?(t.index=0,t.total=d,Ws(t,e)):t.isEntering?(t.index=a?a.index:k,t.total=a?d:v.length,Ws(t,c),k++):t.isLeaving?(t.index=a?a.index:C,t.total=a?d:_.length,C++,Ws(t,p)):t.isTarget?(t.index=N++,t.total=d,Ws(t,e)):(t.index=a?a.index:0,t.total=d,Ws(t,h)),r.index=t.index,r.total=t.total;for(let e in n)n[e]=$t(n[e],s,t.index,t.total),o[e]=$t(o[e],s,r.index,r.total);const u=Math.abs(n.width-o.width)>1,f=Math.abs(n.height-o.height)>1;if(t.sizeChanged=u||f,t.isTarget&&(!t.measuredIsRemoved&&r.measuredIsVisible||t.measuredIsRemoved&&t.measuredIsVisible)){t.isInlined||"none"===n.transform&&"none"===o.transform||(t.hasTransform=!0,w.push(s));for(let t in n)if("transform"!==t&&n[t]!==o[t]){x.push(s);break}}t.isTarget||(y.push(s),t.sizeChanged&&i&&i.isTarget&&i.sizeChanged&&(!t.isInlined&&l.transform&&(t.hasTransform=!0,w.push(s)),S.push(s)))});const I={delay:t=>f.getNode(t).delay,duration:t=>f.getNode(t).duration,ease:t=>f.getNode(t).ease};if(s.defaults=I,this.timeline=Xe(s),!x.length&&!w.length&&!y.length)return Ms(this.transitionMuteStore),this.timeline.complete();if(T.length){this.root.classList.add("is-animated");for(let t=0,e=T.length;t<e;t++){const e=T[t],s=e.dataset.layoutId,i=m.nodes.get(s),r=f.nodes.get(s),n=i.properties;r.isInlined||("grid"!==i.measuredDisplay&&"grid"!==r.measuredDisplay||e.style.setProperty("display","block","important"),(e!==E||this.absoluteCoords)&&(e.style.position=this.absoluteCoords?"fixed":"absolute",e.style.left="0px",e.style.top="0px",e.style.marginLeft="0px",e.style.marginTop="0px",e.style.translate=`${n.x}px ${n.y}px`),e===E&&"static"===r.measuredPosition&&(e.style.position="relative",e.style.left="0px",e.style.top="0px"),e.style.width=`${n.width}px`,e.style.height=`${n.height}px`,e.style.minWidth="auto",e.style.minHeight="auto",e.style.maxWidth="none",e.style.maxHeight="none")}m.scrollX===window.scrollX&&m.scrollY===window.scrollY||requestAnimationFrame(()=>window.scrollTo(m.scrollX,m.scrollY));for(let t=0,e=x.length;t<e;t++){const e=x[t],s=e.dataset.layoutId,i=m.nodes.get(s),r=f.nodes.get(s),n=i.properties,o=r.properties;let a=!1;const l={composition:"none"};r.isInlined||(n.width!==o.width&&(l.width=[n.width,o.width],a=!0),n.height!==o.height&&(l.height=[n.height,o.height],a=!0),r.hasTransform||(l.translate=[`${n.x}px ${n.y}px`,`${o.x}px ${o.y}px`],a=!0)),this.properties.forEach(t=>{const e=n[t],s=o[t];"transform"!==t&&e!==s&&(l[t]=[e,s],a=!0)}),a&&this.timeline.add(e,l,0)}}if(y.length){for(let t=0,e=y.length;t<e;t++){const e=y[t],s=m.getNode(e);if(!s.isInlined){const t=s.properties;e.style.width=`${t.width}px`,e.style.height=`${t.height}px`,e.style.minWidth="auto",e.style.minHeight="auto",e.style.maxWidth="none",e.style.maxHeight="none",e.style.translate=`${t.x}px ${t.y}px`}this.properties.forEach(t=>{"transform"!==t&&(e.style[t]=`${m.getComputedValue(e,t)}`)})}for(let t=0,e=y.length;t<e;t++){const e=y[t],s=f.getNode(e),i=s.properties;this.timeline.call(()=>{s.isInlined||(e.style.width=`${i.width}px`,e.style.height=`${i.height}px`,e.style.minWidth="auto",e.style.minHeight="auto",e.style.maxWidth="none",e.style.maxHeight="none",e.style.translate=`${i.x}px ${i.y}px`),this.properties.forEach(t=>{"transform"!==t&&(e.style[t]=`${f.getComputedValue(e,t)}`)})},s.delay+s.duration/2)}if(S.length){const t=be(f.nodes.get(S[0].dataset.layoutId).ease),e=e=>1-t(1-e),s={};if(l)for(let t in l)"transform"!==t&&(s[t]=[{from:e=>m.getComputedValue(e,t),to:l[t]},{from:l[t],to:e=>f.getComputedValue(e,t),ease:e}]);this.timeline.add(S,s,0)}}const L=w.length;if(L){for(let t=0;t<L;t++){const e=w[t];if(e.style.translate=`${m.getComputedValue(e,"x")}px ${m.getComputedValue(e,"y")}px`,e.style.transform=m.getComputedValue(e,"transform"),S.includes(e)){const t=f.getNode(e);t.ease=$t(n.ease,e,t.index,t.total),t.duration=$t(n.duration,e,t.index,t.total)}}this.transformAnimation=Is.animate(w,{translate:t=>`${f.getComputedValue(t,"x")}px ${f.getComputedValue(t,"y")}px`,transform:t=>{const e=f.getComputedValue(t,"transform");if(!S.includes(t))return e;const s=m.getComputedValue(t,"transform"),i=f.getNode(t);return[s,$t(l.transform,t,i.index,i.total),e]},autoplay:!1,persist:!0,...I}),this.timeline.sync(this.transformAnimation,0)}return this.timeline.init()}update(t,e={}){return this.record(),t(this),this.animate(e)}}const ti=Ue,ei={},si=t=>(...e)=>{const s=t(...e);return new Proxy(v,{apply:(t,e,[i])=>s(i),get:(t,e)=>si((...t)=>{const i=ei[e](...t);return t=>i(s(t))})})},ii=(t,e,s=0)=>{const i=(...t)=>(t.length<e.length?si(((t,e=0)=>(...s)=>e?e=>t(...s,e):e=>t(e,...s))(e,s)):e)(...t);return ei[t]||(ei[t]=i),i},ri=ii("roundPad",ti.roundPad),ni=ii("padStart",ti.padStart),oi=ii("padEnd",ti.padEnd),ai=ii("wrap",ti.wrap),li=ii("mapRange",ti.mapRange),hi=ii("degToRad",ti.degToRad),di=ii("radToDeg",ti.radToDeg),ci=ii("snap",ti.snap),ui=ii("clamp",ti.clamp),pi=ii("round",ti.round),mi=ii("lerp",ti.lerp,1),fi=ii("damp",ti.damp,1),gi=(t=0,e=1,s=0)=>{const i=10**s;return Math.floor((Math.random()*(e-t+1/i)+t)*i)/i};let yi=0;const vi=(t,e=0,s=1,i=0)=>{let r=void 0===t?yi++:t;return(t=e,n=s,o=i)=>{r+=1831565813,r=Math.imul(r^r>>>15,1|r),r^=r+Math.imul(r^r>>>7,61|r);const a=10**o;return Math.floor((((r^r>>>14)>>>0)/4294967296*(n-t+1/a)+t)*a)/a}},_i=t=>t[gi(0,t.length-1)],bi=t=>{let e,s,i=t.length;for(;i;)s=gi(0,--i),e=t[i],t[i]=t[s],t[s]=e;return t},Ti=(t,e={})=>{let s=[],i=0;const r=e.from,n=e.reversed,o=e.ease,a=!X(o),l=a&&!X(o.ease)?o.ease:a?be(o):null,h=e.grid,d=e.axis,c=e.total,u=X(r)||0===r||"first"===r,p="center"===r,f="last"===r,g="random"===r,y=V(t),v=e.use,_=Z(y?t[0]:t),b=y?Z(t[1]):0,T=$.exec((y?t[1]:t)+m),x=e.start||0+(y?_:0);let w=u?0:O(r)?r:0;return(t,r,o,a)=>{const[u]=oe(t),m=X(c)?o:c,S=!X(v)&&(H(v)?v(u,r,m):Ct(u,v)),$=O(S)||z(S)&&O(+S)?+S:r;if(p&&(w=(m-1)/2),f&&(w=m-1),!s.length){for(let t=0;t<m;t++){if(h){const e=p?(h[0]-1)/2:w%h[0],i=p?(h[1]-1)/2:nt(w/h[0]),r=e-t%h[0],n=i-nt(t/h[0]);let o=K(r*r+n*n);"x"===d&&(o=-r),"y"===d&&(o=-n),s.push(o)}else s.push(st(w-t));i=at(...s)}l&&(s=s.map(t=>l(t/i)*i)),n&&(s=s.map(t=>d?t<0?-1*t:-t:st(i-t))),g&&(s=bi(s))}const E=y?(b-_)/i:_;let k=(a?Me(a,X(e.start)?a.iterationDuration:x):x)+(E*pt(s[$],2)||0);return e.modifier&&(k=e.modifier(k)),T&&(k=`${k}${T[2]}`),k}};var xi=Object.freeze({__proto__:null,$:oe,clamp:ui,cleanInlineStyles:Ft,createSeededRandom:vi,damp:fi,degToRad:hi,get:Pe,keepTime:rs,lerp:mi,mapRange:li,padEnd:oi,padStart:ni,radToDeg:di,random:gi,randomPick:_i,remove:Ve,round:pi,roundPad:ri,set:Fe,shuffle:bi,snap:ci,stagger:Ti,sync:is,wrap:ai});const wi=t=>{const e=ne(t)[0];return e&&W(e)?e:console.warn(`${t} is not a valid SVGGeometryElement`)},Si=(t,e,s,i,r)=>{const n=s+i,o=r?Math.max(0,Math.min(n,e)):(n%e+e)%e;return t.getPointAtLength(o)},$i=(t,e,s=0)=>i=>{const r=+t.getTotalLength(),n=i[a],o=t.getCTM(),l=0===s;return{from:0,to:r,modifier:i=>{const a=i+s*r;if("a"===e){const e=Si(t,r,a,-1,l),s=Si(t,r,a,1,l);return 180*lt(s.y-e.y,s.x-e.x)/ht}{const s=Si(t,r,a,0,l);return"x"===e?n||!o?s.x:s.x*o.a+s.y*o.c+o.e:n||!o?s.y:s.x*o.b+s.y*o.d+o.f}}}},Ei=(t,e=0)=>{const s=wi(t);if(s)return{translateX:$i(s,"x",e),translateY:$i(s,"y",e),rotate:$i(s,"a",e)}},ki=(t,e=0,s=0)=>ne(t).map(t=>((t,e,s)=>{const i=p,r=getComputedStyle(t),n=r.strokeLinecap,o="non-scaling-stroke"===r.vectorEffect?t:null;let a=n;const l=new Proxy(t,{get(t,e){const s=t[e];return e===d?t:"setAttribute"===e?(...e)=>{if("draw"===e[0]){const s=e[1].split(" "),r=+s[0],l=+s[1],h=(t=>{let e=1;if(t&&t.getCTM){const s=t.getCTM();s&&(e=(K(s.a*s.a+s.b*s.b)+K(s.c*s.c+s.d*s.d))/2)}return e})(o),d=-1e3*r*h,c=l*i*h+d,u=i*h+(0===r&&1===l||1===r&&0===l?0:10*h)-c;if("butt"!==n){const e=r===l?"butt":n;a!==e&&(t.style.strokeLinecap=`${e}`,a=e)}t.setAttribute("stroke-dashoffset",`${d}`),t.setAttribute("stroke-dasharray",`${c} ${u}`)}return Reflect.apply(s,t,e)}:H(s)?(...e)=>Reflect.apply(s,t,e):s}});return"1000"!==t.getAttribute("pathLength")&&(t.setAttribute("pathLength","1000"),l.setAttribute("draw",`${e} ${s}`)),l})(t,e,s)),Ci=(t,e=.33)=>s=>{if(!(s.tagName||"").toLowerCase().match(/^(path|polygon|polyline)$/))throw new Error(`Can't morph a <${s.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);const i=wi(t);if(!i)throw new Error("Can't morph to an invalid target. 'path2' must resolve to an existing <path>, <polygon> or <polyline> SVG element.");if(!(i.tagName||"").toLowerCase().match(/^(path|polygon|polyline)$/))throw new Error(`Can't morph a <${i.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);const r="path"===s.tagName,n=r?" ":",",o=s[h];o&&s.setAttribute(r?"d":"points",o);let a="",l="";if(e){const t=s.getTotalLength(),o=i.getTotalLength(),h=Math.max(Math.ceil(t*e),Math.ceil(o*e));for(let e=0;e<h;e++){const d=e/(h-1),c=s.getPointAtLength(t*d),u=i.getPointAtLength(o*d),p=r?0===e?"M":"L":"";a+=p+pt(c.x,3)+n+c.y+" ",l+=p+pt(u.x,3)+n+u.y+" "}}else a=s.getAttribute(r?"d":"points"),l=i.getAttribute(r?"d":"points");return s[h]=l,[a,l]};var Ni=Object.freeze({__proto__:null,createDrawable:ki,createMotionPath:Ei,morphTo:Ci});const Di="undefined"!=typeof Intl&&Intl.Segmenter,Ii=/\{value\}/g,Li=/\{i\}/g,Ai=/(\s+)/,Bi=/^\s+$/,Ri="line",Pi="word",Fi="char",Vi="data-line";let Mi=null,Oi=null,zi=null;const Hi=t=>t.isWordLike||" "===t.segment||O(+t.segment),Xi=t=>t.setAttribute("aria-hidden","true"),Yi=(t,e)=>[...t.querySelectorAll(`[data-${e}]:not([data-${e}] [data-${e}])`)],Wi={line:"#00D672",word:"#FF4B4B",char:"#5A87FF"},Ui=t=>{if(!t.childElementCount&&!t.textContent.trim()){const e=t.parentElement;t.remove(),e&&Ui(e)}},qi=(t,e,s)=>{const i=t.getAttribute(Vi);if(null!==i&&+i!==e||"BR"===t.tagName){s.add(t);const e=t.previousSibling,i=t.nextSibling;e&&3===e.nodeType&&Bi.test(e.textContent)&&s.add(e),i&&3===i.nodeType&&Bi.test(i.textContent)&&s.add(i)}let r=t.childElementCount;for(;r--;)qi(t.children[r],e,s);return s},ji=(t,e={})=>{let s="";const i=z(e.class)?` class="${e.class}"`:"",r=St(e.clone,!1),n=St(e.wrap,!1),o=n?!0===n?"clip":n:!!r&&"clip";return n&&(s+=`<span${o?` style="overflow:${o};"`:""}>`),s+=`<span${i}${r?' style="position:relative;"':""} data-${t}="{i}">`,r?(s+="<span>{value}</span>",s+=`<span inert style="position:absolute;top:${"top"===r?"-100%":"bottom"===r?"100%":"0"};left:${"left"===r?"-100%":"right"===r?"100%":"0"};white-space:nowrap;">{value}</span>`):s+="{value}",s+="</span>",n&&(s+="</span>"),s},Gi=(t,e,s,i,r,n,o,a,l)=>{const h=r===Ri,d=r===Fi,c=`_${r}_`,u=H(t)?t(s):t,p=h?"block":"inline-block";zi.innerHTML=u.replace(Ii,`<i class="${c}"></i>`).replace(Li,`${d?l:h?o:a}`);const m=zi.content,f=m.firstElementChild,g=m.querySelector(`[data-${r}]`)||f,y=m.querySelectorAll(`i.${c}`),v=y.length;if(v){f.style.display=p,g.style.display=p,g.setAttribute(Vi,`${o}`),h||(g.setAttribute("data-word",`${a}`),d&&g.setAttribute("data-char",`${l}`));let t=v;for(;t--;){const e=y[t],i=e.parentElement;i.style.display=p,h?i.innerHTML=s.innerHTML:i.replaceChild(s.cloneNode(!0),e)}e.push(g),i.appendChild(m)}else console.warn('The expression "{value}" is missing from the provided template.');return n&&(f.style.outline=`1px dotted ${Wi[r]}`),f};class Qi{constructor(t,s={}){Mi||(Mi=Di?new Di([],{granularity:Pi}):{segment:t=>{const e=[],s=t.split(Ai);for(let t=0,i=s.length;t<i;t++){const i=s[t];e.push({segment:i,isWordLike:!Bi.test(i)})}return e}}),Oi||(Oi=Di?new Di([],{granularity:"grapheme"}):{segment:t=>[...t].map(t=>({segment:t}))}),!zi&&e&&(zi=i.createElement("template")),I.current&&I.current.register(this);const{words:r,chars:n,lines:o,accessible:a,includeSpaces:l,debug:h}=s,d=(t=V(t)?t[0]:t)&&t.nodeType?t:(re(t)||[])[0],c=!0===o?{}:o,u=!0===r||X(r)?{}:r,p=!0===n?{}:n;this.debug=St(h,!1),this.includeSpaces=St(l,!1),this.accessible=St(a,!0),this.linesOnly=c&&!u&&!p,this.lineTemplate=M(c)?ji(Ri,c):c,this.wordTemplate=M(u)||this.linesOnly?ji(Pi,u):u,this.charTemplate=M(p)?ji(Fi,p):p,this.$target=d,this.html=d&&d.innerHTML,this.lines=[],this.words=[],this.chars=[],this.effects=[],this.effectsCleanups=[],this.cache=null,this.ready=!1,this.width=0,this.resizeTimeout=null;const m=()=>this.html&&(c||u||p)&&this.split();this.resizeObserver=new ResizeObserver(()=>{clearTimeout(this.resizeTimeout),this.resizeTimeout=setTimeout(()=>{const t=d.offsetWidth;t!==this.width&&(this.width=t,m())},150)}),this.lineTemplate&&!this.ready?i.fonts.ready.then(m):m(),d?this.resizeObserver.observe(d):console.warn("No Text Splitter target found.")}addEffect(t){if(!H(t))return console.warn("Effect must return a function.");const e=rs(t);return this.effects.push(e),this.ready&&(this.effectsCleanups[this.effects.length-1]=e(this)),this}revert(){return clearTimeout(this.resizeTimeout),this.lines.length=this.words.length=this.chars.length=0,this.resizeObserver.disconnect(),this.effectsCleanups.forEach(t=>H(t)?t(this):t.revert&&t.revert()),this.$target.innerHTML=this.html,this}splitNode(t){const e=this.wordTemplate,s=this.charTemplate,r=this.includeSpaces,n=this.debug,o=t.nodeType;if(3===o){const o=t.nodeValue;if(o.trim()){const a=[],l=this.words,h=this.chars,d=Mi.segment(o),c=i.createDocumentFragment();let u=null;for(const t of d){const e=t.segment,s=Hi(t);if(!u||s&&u&&Hi(u))a.push(e);else{const t=a.length-1,s=a[t];Ai.test(s)||Ai.test(e)?a.push(e):a[t]+=e}u=t}for(let t=0,o=a.length;t<o;t++){const o=a[t];if(o.trim()){const d=a[t+1],u=r&&d&&!d.trim(),p=o,m=s?Oi.segment(p):null,f=s?i.createDocumentFragment():i.createTextNode(u?o+"":o);if(s){const t=[...m];for(let e=0,r=t.length;e<r;e++){const o=t[e],a=e===r-1&&u?o.segment+"":o.segment,d=i.createTextNode(a);Gi(s,h,d,f,Fi,n,-1,l.length,h.length)}}e?Gi(e,l,f,c,Pi,n,-1,l.length,h.length):s?c.appendChild(f):c.appendChild(i.createTextNode(o)),u&&t++}else{if(t&&r)continue;c.appendChild(i.createTextNode(o))}}t.parentNode.replaceChild(c,t)}}else if(1===o){const e=[...t.childNodes];for(let t=0,s=e.length;t<s;t++)this.splitNode(e[t])}}split(t=!1){const e=this.$target,s=!!this.cache&&!t,r=this.lineTemplate,n=this.wordTemplate,o=this.charTemplate,a="loading"!==i.fonts.status,l=r&&a;this.ready=!r||a,(l||t)&&this.effectsCleanups.forEach(t=>H(t)&&t(this)),s||(t&&(e.innerHTML=this.html,this.words.length=this.chars.length=0),this.splitNode(e),this.cache=e.innerHTML),l&&(s&&(e.innerHTML=this.cache),this.lines.length=0,n&&(this.words=Yi(e,Pi))),o&&(l||n)&&(this.chars=Yi(e,Fi));const h=this.words.length?this.words:this.chars;let d,c=0;for(let t=0,e=h.length;t<e;t++){const e=h[t],{top:s,height:i}=e.getBoundingClientRect();!X(d)&&s-d>.5*i&&c++,e.setAttribute(Vi,`${c}`);const r=e.querySelectorAll(`[${Vi}]`);let n=r.length;for(;n--;)r[n].setAttribute(Vi,`${c}`);d=s}if(l){const t=i.createDocumentFragment(),s=new Set,a=[];for(let t=0;t<c+1;t++){const i=e.cloneNode(!0);qi(i,t,new Set).forEach(t=>{const e=t.parentNode;e&&(1===t.nodeType&&s.add(e),e.removeChild(t))}),a.push(i)}s.forEach(Ui);for(let e=0,s=a.length;e<s;e++)Gi(r,this.lines,a[e],t,Ri,this.debug,e);e.innerHTML="",e.appendChild(t),n&&(this.words=Yi(e,Pi)),o&&(this.chars=Yi(e,Fi))}if(this.linesOnly){const t=this.words;let e=t.length;for(;e--;){const s=t[e];s.replaceWith(s.textContent)}t.length=0}if(this.accessible&&(l||!s)){const t=i.createElement("span");t.style.cssText="position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;",t.innerHTML=this.html,e.insertBefore(t,e.firstChild),this.lines.forEach(Xi),this.words.forEach(Xi),this.chars.forEach(Xi)}return this.width=e.offsetWidth,(l||t)&&this.effects.forEach((t,e)=>this.effectsCleanups[e]=t(this)),this}refresh(){this.split(!0)}}const Zi=(t,e)=>new Qi(t,e),Ji=(t,e)=>(console.warn("text.split() is deprecated, import splitText() directly, or text.splitText()"),new Qi(t,e));var Ki=Object.freeze({__proto__:null,TextSplitter:Qi,split:Ji,splitText:Zi});t.$=oe,t.Animatable=Ye,t.AutoLayout=Ks,t.Draggable=ss,t.JSAnimation=Le,t.Scope=ns,t.ScrollObserver=ms,t.Spring=je,t.TextSplitter=Qi,t.Timeline=He,t.Timer=ie,t.WAAPIAnimation=Ds,t.animate=(t,e)=>new Le(t,e,null,0,!1).init(),t.clamp=ui,t.cleanInlineStyles=Ft,t.createAnimatable=(t,e)=>new Ye(t,e),t.createDraggable=(t,e)=>new ss(t,e),t.createDrawable=ki,t.createLayout=(t,e)=>new Ks(t,e),t.createMotionPath=Ei,t.createScope=t=>new ns(t),t.createSeededRandom=vi,t.createSpring=Qe,t.createTimeline=Xe,t.createTimer=t=>new ie(t,null,0).init(),t.cubicBezier=gs,t.damp=fi,t.degToRad=hi,t.eases=ge,t.easings=bs,t.engine=Xt,t.get=Pe,t.irregular=_s,t.keepTime=rs,t.lerp=mi,t.linear=vs,t.mapRange=li,t.morphTo=Ci,t.onScroll=(t={})=>new ms(t),t.padEnd=oi,t.padStart=ni,t.radToDeg=di,t.random=gi,t.randomPick=_i,t.remove=Ve,t.round=pi,t.roundPad=ri,t.scrollContainers=as,t.set=Fe,t.shuffle=bi,t.snap=ci,t.split=Ji,t.splitText=Zi,t.spring=Ge,t.stagger=Ti,t.steps=ys,t.svg=Ni,t.sync=is,t.text=Ki,t.utils=xi,t.waapi=Is,t.wrap=ai});


## Links discovered
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.overshootCoords.x,1)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.overshootCoords.y,1)
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.overshootCoords.x,0)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.overshootCoords.y,0)
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/s,0.md)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/s,0.md)
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/o,l,s.md)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/a,l,s.md)
- [this.xProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/I,R,F.md)
- [this.yProp](https://github.com/juliangarnier/anime/blob/master/dist/bundles/A,P,V.md)
- [e](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [o](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [l](https://github.com/juliangarnier/anime/blob/master/dist/bundles/this.md)
- [e](https://github.com/juliangarnier/anime/blob/master/dist/bundles/...t)

--- src/index.js ---
export * from './timer/index.js';
export * from './animation/index.js';
export * from './timeline/index.js';
export * from './animatable/index.js';
export * from './draggable/index.js';
export * from './scope/index.js';
export * from './events/index.js';
export * from './engine/index.js';
export * from './easings/index.js';
export * from './layout/index.js';
export * as easings from './easings/index.js';
export * from './utils/index.js';
export * as utils from './utils/index.js';
export * from './svg/index.js';
export * as svg from './svg/index.js';
export * from './text/index.js';
export * as text from './text/index.js';
export * from './waapi/index.js';
export * from './types/index.js';

--- src/animation/additive.js ---
import {
  minValue,
  noop,
  valueTypes,
  tickModes,
} from '../core/consts.js';

import {
  cloneArray,
} from '../core/helpers.js';

import {
  render,
} from '../core/render.js';

export const additive = {
  animation: null,
  update: noop,
}

/**
 * @import {
 *   Tween,
 *   TweenAdditiveLookups,
 * } from '../types/index.js'
 */

/**
 * @typedef AdditiveAnimation
 * @property {Number} duration
 * @property {Number} _offset
 * @property {Number} _delay
 * @property {Tween} _head
 * @property {Tween} _tail
 */

/**
 * @param  {TweenAdditiveLookups} lookups
 * @return {AdditiveAnimation}
 */
export const addAdditiveAnimation = lookups => {
  let animation = additive.animation;
  if (!animation) {
    animation = {
      duration: minValue,
      computeDeltaTime: noop,
      _offset: 0,
      _delay: 0,
      _head: null,
      _tail: null,
    }
    additive.animation = animation;
    additive.update = () => {
      lookups.forEach(propertyAnimation => {
        for (let propertyName in propertyAnimation) {
          const tweens = propertyAnimation[propertyName];
          const lookupTween = tweens._head;
          if (lookupTween) {
            const valueType = lookupTween._valueType;
            const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;
            let additiveValue = lookupTween._fromNumber;
            let tween = tweens._tail;
            while (tween && tween !== lookupTween) {
              if (additiveValues) {
                for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];
              } else {
                additiveValue += tween._number;
              }
              tween = tween._prevAdd;
            }
            lookupTween._toNumber = additiveValue;
            lookupTween._toNumbers = additiveValues;
          }
        }
      });
      // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop
      render(animation, 1, 1, 0, tickModes.FORCE);
    }
  }
  return animation;
}


--- src/animatable/animatable.js ---
import {
  compositionTypes,
  noop
} from '../core/consts.js';

import {
  scope,
} from '../core/globals.js';

import {
  isKey,
  isObj,
  isStr,
  isUnd,
  mergeObjects,
  forEachChildren,
  isArr,
  stringStartsWith,
} from '../core/helpers.js';

import {
  JSAnimation,
} from '../animation/animation.js';

import {
  parseEase,
} from '../easings/eases/parser.js';

/**
 * @import {
 * TargetsParam,
 * AnimatableParams,
 * AnimationParams,
 * TweenParamsOptions,
 * Tween,
 * AnimatableProperty,
 * AnimatableObject,
 * } from '../types/index.js';
 */

export class Animatable {
  /**
   * @param {TargetsParam} targets
   * @param {AnimatableParams} parameters
   */
  constructor(targets, parameters) {
    if (scope.current) scope.current.register(this);
    const beginHandler = () => {
      if (this.callbacks.completed) this.callbacks.reset();
      this.callbacks.play();
    };
    const pauseHandler = () => {
      if (this.callbacks.completed) return;
      let paused = true;
      for (let name in this.animations) {
        const anim = this.animations[name];
        if (!anim.paused && paused) {
          paused = false;
          break;
        }
      }
      if (paused) {
        this.callbacks.complete();
      }
    };
    /** @type {AnimationParams} */
    const globalParams = {
      onBegin: beginHandler,
      onComplete: pauseHandler,
      onPause: pauseHandler,
    };
    /** @type {AnimationParams} */
    const callbacksAnimationParams = { v: 1, autoplay: false };
    const properties = {};
    this.targets = [];
    this.animations = {};
    /** @type {JSAnimation|null} */
    this.callbacks = null;
    if (isUnd(targets) || isUnd(parameters)) return;
    for (let propName in parameters) {
      const paramValue = parameters[propName];
      if (isKey(propName)) {
        properties[propName] = paramValue;
      } else if (stringStartsWith(propName, 'on')) {
        callbacksAnimationParams[propName] = paramValue;
      } else {
        globalParams[propName] = paramValue;
      }
    }
    this.callbacks = new JSAnimation({ v: 0 }, callbacksAnimationParams);
    for (let propName in properties) {
      const propValue = properties[propName];
      const isObjValue = isObj(propValue);
      /** @type {TweenParamsOptions} */
      let propParams = {};
      let to = '+=0';
      if (isObjValue) {
        const unit = propValue.unit;
        if (isStr(unit)) to += unit;
      } else {
        propParams.duration = propValue;
      }
      propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;
      const animParams = mergeObjects(globalParams, propParams);
      animParams.composition = compositionTypes.replace;
      animParams.autoplay = false;
      const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();
      if (!this.targets.length) this.targets.push(...animation.targets);
      /** @type {AnimatableProperty} */
      this[propName] = (to, duration, ease) => {
        const tween = /** @type {Tween} */(animation._head);
        if (isUnd(to) && tween) {
          const numbers = tween._numbers;
          if (numbers && numbers.length) {
            return numbers;
          } else {
            return tween._modifier(tween._number);
          }
        } else {
          forEachChildren(animation, (/** @type {Tween} */tween) => {
            if (isArr(to)) {
              for (let i = 0, l = /** @type {Array} */(to).length; i < l; i++) {
                if (!isUnd(tween._numbers[i])) {
                  tween._fromNumbers[i] = /** @type {Number} */(tween._modifier(tween._numbers[i]));
                  tween._toNumbers[i] = to[i];
                }
              }
            } else {
              tween._fromNumber = /** @type {Number} */(tween._modifier(tween._number));
              tween._toNumber = /** @type {Number} */(to);
            }
            if (!isUnd(ease)) tween._ease = parseEase(ease);
            tween._currentTime = 0;
          });
          if (!isUnd(duration)) animation.stretch(duration);
          animation.reset(true).resume();
          return this;
        }
      };
    }
  }

  revert() {
    for (let propName in this.animations) {
      this[propName] = noop;
      this.animations[propName].revert();
    }
    this.animations = {};
    this.targets.length = 0;
    if (this.callbacks) this.callbacks.revert();
    return this;
  }
}

/**
 * @param {TargetsParam} targets
 * @param {AnimatableParams} parameters
 * @return {AnimatableObject}
 */
export const createAnimatable = (targets, parameters) => /** @type {AnimatableObject} */ (new Animatable(targets, parameters));


--- src/animation/animation.js ---
import {
  K,
  minValue,
  tweenTypes,
  valueTypes,
  compositionTypes,
} from '../core/consts.js';

import {
  mergeObjects,
  cloneArray,
  isArr,
  isObj,
  isUnd,
  isKey,
  addChild,
  forEachChildren,
  clampInfinity,
  normalizeTime,
  isNum,
  round,
  isNil,
  isFnc,
  isStr,
} from '../core/helpers.js';

import {
  globals,
} from '../core/globals.js';

import {
  registerTargets,
} from '../core/targets.js';

import {
  getRelativeValue,
  getFunctionValue,
  getOriginalAnimatableValue,
  getTweenType,
  setValue,
  decomposeRawValue,
  decomposeTweenValue,
  decomposedOriginalValue,
  createDecomposedValueTargetObject,
} from '../core/values.js';

import {
  sanitizePropertyName,
  cleanInlineStyles,
} from '../core/styles.js';

import {
  convertValueUnit,
} from '../core/units.js';

import {
  parseEase,
} from '../easings/eases/parser.js';

import {
  Timer,
} from '../timer/timer.js';

import {
  composeTween,
  getTweenSiblings,
  overrideTween,
} from './composition.js';

import {
  additive,
} from './additive.js';

/**
 * @import {
 *   Tween,
 *   TweenKeyValue,
 *   TweenParamsOptions,
 *   TweenValues,
 *   DurationKeyframes,
 *   PercentageKeyframes,
 *   AnimationParams,
 *   TweenPropValue,
 *   ArraySyntaxValue,
 *   TargetsParam,
 *   TimerParams,
 *   TweenParamValue,
 *   DOMTarget,
 *   TargetsArray,
 *   Callback,
 *   EasingFunction,
 * } from '../types/index.js'
 *
 * @import {
 *   Timeline,
 * } from '../timeline/timeline.js'
 *
 * @import {
 *   Spring,
 * } from '../easings/spring/index.js'
 */

// Defines decomposed values target objects only once and mutate their properties later to avoid GC
// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object
const fromTargetObject = createDecomposedValueTargetObject();
const toTargetObject = createDecomposedValueTargetObject();
const inlineStylesStore = {};
const toFunctionStore = { func: null };
const keyframesTargetArray = [null];
const fastSetValuesArray = [null, null];
/** @type {TweenKeyValue} */
const keyObjectTarget = { to: null };

let tweenId = 0;
let JSAnimationId = 0;
let keyframes;
/** @type {TweenParamsOptions & TweenValues} */
let key;

/**
 * @param {DurationKeyframes | PercentageKeyframes} keyframes
 * @param {AnimationParams} parameters
 * @return {AnimationParams}
 */
const generateKeyframes = (keyframes, parameters) => {
  /** @type {AnimationParams} */
  const properties = {};
  if (isArr(keyframes)) {
    const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);
    for (let i = 0, l = propertyNames.length; i < l; i++) {
      const propName = propertyNames[i];
      const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {
        /** @type {TweenKeyValue} */
        const newKey = {};
        for (let p in key) {
          const keyValue = /** @type {TweenPropValue} */(key[p]);
          if (isKey(p)) {
            if (p === propName) {
              newKey.to = keyValue;
            }
          } else {
            newKey[p] = keyValue;
          }
        }
        return newKey;
      });
      properties[propName] = /** @type {ArraySyntaxValue} */(propArray);
    }

  } else {
    const totalDuration = /** @type {Number} */(setValue(parameters.duration, globals.defaults.duration));
    const keys = Object.keys(keyframes)
    .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })
    .sort((a, b) => a.o - b.o);
    keys.forEach(key => {
      const offset = key.o;
      const prop = key.p;
      for (let name in prop) {
        if (isKey(name)) {
          let propArray = /** @type {Array} */(properties[name]);
          if (!propArray) propArray = properties[name] = [];
          const duration = offset * totalDuration;
          let length = propArray.length;
          let prevKey = propArray[length - 1];
          const keyObj = { to: prop[name] };
          let durProgress = 0;
          for (let i = 0; i < length; i++) {
            durProgress += propArray[i].duration;
          }
          if (length === 1) {
            keyObj.from = prevKey.to;
          }
          if (prop.ease) {
            keyObj.ease = prop.ease;
          }
          keyObj.duration = duration - (length ? durProgress : 0);
          propArray.push(keyObj);
        }
      }
      return key;
    });

    for (let name in properties) {
      const propArray = /** @type {Array} */(properties[name]);
      let prevEase;
      // let durProgress = 0
      for (let i = 0, l = propArray.length; i < l; i++) {
        const prop = propArray[i];
        // Emulate WAPPI easing parameter position
        const currentEase = prop.ease;
        prop.ease = prevEase ? prevEase : undefined;
        prevEase = currentEase;
        // durProgress += prop.duration;
        // if (i === l - 1 && durProgress !== totalDuration) {
        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })
        // }
      }
      if (!propArray[0].duration) {
        propArray.shift();
      }
    }

  }

  return properties;
}

export class JSAnimation extends Timer {
  /**
   * @param {TargetsParam} targets
   * @param {AnimationParams} parameters
   * @param {Timeline} [parent]
   * @param {Number} [parentPosition]
   * @param {Boolean} [fastSet=false]
   * @param {Number} [index=0]
   * @param {Number} [length=0]
   */
  constructor(
    targets,
    parameters,
    parent,
    parentPosition,
    fastSet = false,
    index = 0,
    length = 0
  ) {

    super(/** @type {TimerParams & AnimationParams} */(parameters), parent, parentPosition);

    ++JSAnimationId;

    const parsedTargets = registerTargets(targets);
    const targetsLength = parsedTargets.length;

    // If the parameters object contains a "keyframes" property, convert all the keyframes values to regular properties

    const kfParams = /** @type {AnimationParams} */(parameters).keyframes;
    const params = /** @type {AnimationParams} */(kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);

    const {
      id,
      delay,
      duration,
      ease,
      playbackEase,
      modifier,
      composition,
      onRender,
    } = params;

    const animDefaults = parent ? parent.defaults : globals.defaults;
    const animEase = setValue(ease, animDefaults.ease);
    const animPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);
    const parsedAnimPlaybackEase = animPlaybackEase ? parseEase(animPlaybackEase) : null;
    const hasSpring = !isUnd(/** @type {Spring} */(animEase).ease);
    const tEasing = hasSpring ? /** @type {Spring} */(animEase).ease : setValue(ease, parsedAnimPlaybackEase ? 'linear' : animDefaults.ease);
    const tDuration = hasSpring ? /** @type {Spring} */(animEase).settlingDuration : setValue(duration, animDefaults.duration);
    const tDelay = setValue(delay, animDefaults.delay);
    const tModifier = modifier || animDefaults.modifier;
    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation
    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;
    // const absoluteOffsetTime = this._offset;
    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);
    // This allows targeting the current animation in the spring onComplete callback
    if (hasSpring) /** @type {Spring} */(animEase).parent = this;

    let iterationDuration = NaN;
    let iterationDelay = NaN;
    let animationAnimationLength = 0;
    let shouldTriggerRender = 0;

    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {

      const target = parsedTargets[targetIndex];
      const ti = index || targetIndex;
      const tl = length || targetsLength;

      let lastTransformGroupIndex = NaN;
      let lastTransformGroupLength = NaN;

      for (let p in params) {

        if (isKey(p)) {

          const tweenType = getTweenType(target, p);

          const propName = sanitizePropertyName(p, target, tweenType);

          let propValue = params[p];

          const isPropValueArray = isArr(propValue);

          if (fastSet && !isPropValueArray) {
            fastSetValuesArray[0] = propValue;
            fastSetValuesArray[1] = propValue;
            propValue = fastSetValuesArray;
          }

          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })
          // Normalize property values to valid keyframe syntax:
          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]
          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];
          if (isPropValueArray) {
            const arrayLength = /** @type {Array} */(propValue).length;
            const isNotObjectValue = !isObj(propValue[0]);
            // Convert [x, y] to [{to: [x, y]}]
            if (arrayLength === 2 && isNotObjectValue) {
              keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));
              keyframesTargetArray[0] = keyObjectTarget;
              keyframes = keyframesTargetArray;
            // Convert [x, y, z] to [[x, y], z]
            } else if (arrayLength > 2 && isNotObjectValue) {
              keyframes = [];
              /** @type {Array.<Number>} */(propValue).forEach((v, i) => {
                if (!i) {
                  fastSetValuesArray[0] = v;
                } else if (i === 1) {
                  fastSetValuesArray[1] = v;
                  keyframes.push(fastSetValuesArray);
                } else {
                  keyframes.push(v);
                }
              });
            } else {
              keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);
            }
          } else {
            keyframesTargetArray[0] = propValue;
            keyframes = keyframesTargetArray;
          }

          let siblings = null;
          let prevTween = null;
          let firstTweenChangeStartTime = NaN;
          let lastTweenChangeEndTime = 0;
          let tweenIndex = 0;

          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {

            const keyframe = keyframes[tweenIndex];

            if (isObj(keyframe)) {
              key = keyframe;
            } else {
              keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);
              key = keyObjectTarget;
            }

            toFunctionStore.func = null;

            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);

            let tweenToValue;
            // Allows function based values to return an object syntax value ({to: v})
            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {
              key = computedToValue;
              tweenToValue = computedToValue.to;
            } else {
              tweenToValue = computedToValue;
            }
            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);
            const easeToParse = key.ease || tEasing;

            const easeFunctionResult = getFunctionValue(easeToParse, target, ti, tl);
            const keyEasing = isFnc(easeFunctionResult) || isStr(easeFunctionResult) ? easeFunctionResult : easeToParse;

            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);
            const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing;
            // Calculate default individual keyframe duration by dividing the tl of keyframes
            const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).settlingDuration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);
            // Default delay value should only be applied to the first tween
            const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);
            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);
            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];
            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper
            const tweenModifier = key.modifier || tModifier;
            const hasFromvalue = !isUnd(tweenFromValue);
            const hasToValue = !isUnd(tweenToValue);
            const isFromToArray = isArr(tweenToValue);
            const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);
            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;
            // Rounding is necessary here to minimize floating point errors when working in seconds
            const absoluteStartTime = round(absoluteOffsetTime + tweenStartTime, 12);

            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false
            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;

            let prevSibling = prevTween;

            if (tweenComposition !== compositionTypes.none) {
              if (!siblings) siblings = getTweenSiblings(target, propName);
              let nextSibling = siblings._head;
              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time
              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {
                prevSibling = nextSibling;
                nextSibling = nextSibling._nextRep;
                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time
                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {
                  while (nextSibling) {
                    overrideTween(nextSibling);
                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden
                    nextSibling = nextSibling._nextRep;
                  }
                }
              }
            }

            // Decompose values
            if (isFromToValue) {
              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);
              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);
              // Needed to force an inline style registration
              const originalValue = getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore);
              if (fromTargetObject.t === valueTypes.NUMBER) {
                if (prevSibling) {
                  if (prevSibling._valueType === valueTypes.UNIT) {
                    fromTargetObject.t = valueTypes.UNIT;
                    fromTargetObject.u = prevSibling._unit;
                  }
                } else {
                  decomposeRawValue(
                    originalValue,
                    decomposedOriginalValue
                  );
                  if (decomposedOriginalValue.t === valueTypes.UNIT) {
                    fromTargetObject.t = valueTypes.UNIT;
                    fromTargetObject.u = decomposedOriginalValue.u;
                  }
                }
              }
            } else {
              if (hasToValue) {
                decomposeRawValue(tweenToValue, toTargetObject);
              } else {
                if (prevTween) {
                  decomposeTweenValue(prevTween, toTargetObject);
                } else {
                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), toTargetObject);
                }
              }
              if (hasFromvalue) {
                decomposeRawValue(tweenFromValue, fromTargetObject);
              } else {
                if (prevTween) {
                  decomposeTweenValue(prevTween, fromTargetObject);
                } else {
                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), fromTargetObject);
                }
              }
            }

            // Apply operators
            if (fromTargetObject.o) {
              fromTargetObject.n = getRelativeValue(
                !prevSibling ? decomposeRawValue(
                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore),
                  decomposedOriginalValue
                ).n : prevSibling._toNumber,
                fromTargetObject.n,
                fromTargetObject.o
              );
            }

            if (toTargetObject.o) {
              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);
            }

            // Values omogenisation in cases of type difference between "from" and "to"
            if (fromTargetObject.t !== toTargetObject.t) {
              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {
                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;
                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;
                notComplexValue.t = valueTypes.COMPLEX;
                notComplexValue.s = cloneArray(complexValue.s);
                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);
              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {
                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;
                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;
                notUnitValue.t = valueTypes.UNIT;
                notUnitValue.u = unitValue.u;
              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {
                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;
                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;
                notColorValue.t = valueTypes.COLOR;
                notColorValue.s = colorValue.s;
                notColorValue.d = [0, 0, 0, 1];
              }
            }

            // Unit conversion
            if (fromTargetObject.u !== toTargetObject.u) {
              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;
              valueToConvert = convertValueUnit(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);
              // TODO:
              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);
            }

            // Fill in non existing complex values
            if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {
              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;
              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;
              // TODO: Check if n should be used instead of 0 for default complex values
              shortestValue.d = longestValue.d.map((/** @type {Number} */_, /** @type {Number} */i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);
              shortestValue.s = cloneArray(longestValue.s);
            }

            // Tween factory

            // Rounding is necessary here to minimize floating point errors when working in seconds
            const tweenUpdateDuration = round(+tweenDuration || minValue, 12);

            // Copy the value of the iniline style if it exist and imediatly nullify it to prevents false positive on other targets
            let inlineValue = inlineStylesStore[propName];
            if (!isNil(inlineValue)) inlineStylesStore[propName] = null;

            /** @type {Tween} */
            const tween = {
              parent: this,
              id: tweenId++,
              property: propName,
              target: target,
              _value: null,
              _func: toFunctionStore.func,
              _ease: parseEase(tweenEasing),
              _fromNumbers: cloneArray(fromTargetObject.d),
              _toNumbers: cloneArray(toTargetObject.d),
              _strings: cloneArray(toTargetObject.s),
              _fromNumber: fromTargetObject.n,
              _toNumber: toTargetObject.n,
              _numbers: cloneArray(fromTargetObject.d), // For additive tween and animatables
              _number: fromTargetObject.n, // For additive tween and animatables
              _unit: toTargetObject.u,
              _modifier: tweenModifier,
              _currentTime: 0,
              _startTime: tweenStartTime,
              _delay: +tweenDelay,
              _updateDuration: tweenUpdateDuration,
              _changeDuration: tweenUpdateDuration,
              _absoluteStartTime: absoluteStartTime,
              // NOTE: Investigate bit packing to stores ENUM / BOOL
              _tweenType: tweenType,
              _valueType: toTargetObject.t,
              _composition: tweenComposition,
              _isOverlapped: 0,
              _isOverridden: 0,
              _renderTransforms: 0,
              _inlineValue: inlineValue,
              _prevRep: null, // For replaced tween
              _nextRep: null, // For replaced tween
              _prevAdd: null, // For additive tween
              _nextAdd: null, // For additive tween
              _prev: null,
              _next: null,
            }

            if (tweenComposition !== compositionTypes.none) {
              composeTween(tween, siblings);
            }

            if (isNaN(firstTweenChangeStartTime)) {
              firstTweenChangeStartTime = tween._startTime;
            }
            // Rounding is necessary here to minimize floating point errors when working in seconds
            lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);
            prevTween = tween;
            animationAnimationLength++;

            addChild(this, tween);

          }

          // Update animation timings with the added tweens properties

          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {
            iterationDelay = firstTweenChangeStartTime;
          }

          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {
            iterationDuration = lastTweenChangeEndTime;
          }

          // TODO: Find a way to inline tween._renderTransforms = 1 here
          if (tweenType === tweenTypes.TRANSFORM) {
            lastTransformGroupIndex = animationAnimationLength - tweenIndex;
            lastTransformGroupLength = animationAnimationLength;
          }

        }

      }

      // Set _renderTransforms to last transform property to correctly render the transforms list
      if (!isNaN(lastTransformGroupIndex)) {
        let i = 0;
        forEachChildren(this, (/** @type {Tween} */tween) => {
          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {
            tween._renderTransforms = 1;
            if (tween._composition === compositionTypes.blend) {
              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {
                if (additiveTween.id === tween.id) {
                  additiveTween._renderTransforms = 1;
                }
              });
            }
          }
          i++;
        });
      }

    }

    if (!targetsLength) {
      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
    }

    if (iterationDelay) {
      forEachChildren(this, (/** @type {Tween} */tween) => {
        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too
        if (!(tween._startTime - tween._delay)) {
          tween._delay -= iterationDelay;
        }
        tween._startTime -= iterationDelay;
      });
      iterationDuration -= iterationDelay;
    } else {
      iterationDelay = 0;
    }

    // Prevents iterationDuration to be NaN if no valid animatable props have been provided
    // Prevents _iterationCount to be NaN if no valid animatable props have been provided
    if (!iterationDuration) {
      iterationDuration = minValue;
      this.iterationCount = 0;
    }
    /** @type {TargetsArray} */
    this.targets = parsedTargets;
    /** @type {String|Number} */
    this.id = !isUnd(id) ? id : JSAnimationId;
    /** @type {Number} */
    this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;
    /** @type {Callback<this>} */
    this.onRender = onRender || animDefaults.onRender;
    /** @type {EasingFunction} */
    this._ease = parsedAnimPlaybackEase;
    /** @type {Number} */
    this._delay = iterationDelay;
    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.
    // this._delay = parent ? 0 : iterationDelay;
    // this._offset += parent ? iterationDelay : 0;
    /** @type {Number} */
    this.iterationDuration = iterationDuration;

    if (!this._autoplay && shouldTriggerRender) this.onRender(this);
  }

  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    if (currentDuration === normalizeTime(newDuration)) return this;
    const timeScale = newDuration / currentDuration;
    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0
    forEachChildren(this, (/** @type {Tween} */tween) => {
      // Rounding is necessary here to minimize floating point errors
      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);
      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);
      tween._currentTime *= timeScale;
      tween._startTime *= timeScale;
      tween._absoluteStartTime *= timeScale;
    });
    return super.stretch(newDuration);
  }

  /**
   * @return {this}
   */
  refresh() {
    forEachChildren(this, (/** @type {Tween} */tween) => {
      const tweenFunc = tween._func;
      if (tweenFunc) {
        const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);
        decomposeRawValue(ogValue, decomposedOriginalValue);
        // TODO: Check for from / to Array based values here,
        decomposeRawValue(tweenFunc(), toTargetObject);
        tween._fromNumbers = cloneArray(decomposedOriginalValue.d);
        tween._fromNumber = decomposedOriginalValue.n;
        tween._toNumbers = cloneArray(toTargetObject.d);
        tween._strings = cloneArray(toTargetObject.s);
        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025
        tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;
      }
    });
    // This forces setter animations to render once
    if (this.duration === minValue) this.restart();
    return this;
  }

  /**
   * Cancel the animation and revert all the values affected by this animation to their original state
   * @return {this}
   */
  revert() {
    super.revert();
    return cleanInlineStyles(this);
  }

  /**
   * @typedef {this & {then: null}} ResolvedJSAnimation
   */

  /**
   * @param  {Callback<ResolvedJSAnimation>} [callback]
   * @return Promise<this>
   */
  then(callback) {
    return super.then(callback);
  }

}

/**
 * @param {TargetsParam} targets
 * @param {AnimationParams} parameters
 * @return {JSAnimation}
 */
export const animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();


--- src/utils/chainable.js ---
import {
  noop,
} from '../core/consts.js';

import * as numberImports from './number.js';

// Chain-able utilities

const numberUtils = numberImports; // Needed to keep the import when bundling

const chainables = {};

/**
 * @callback UtilityFunction
 * @param {...*} args
 * @return {Number|String}
 *
 * @param {UtilityFunction} fn
 * @param {Number} [last=0]
 * @return {function(...(Number|String)): function(Number|String): (Number|String)}
 */
const curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);

/**
 * @param {Function} fn
 * @return {function(...(Number|String))}
 */
const chain = fn => {
   return (...args) => {
    const result = fn(...args);
    return new Proxy(noop, {
      apply: (_, __, [v]) => result(v),
      get: (_, prop) => chain(/**@param {...Number|String} nextArgs */(...nextArgs) => {
        const nextResult = chainables[prop](...nextArgs);
        return (/**@type {Number|String} */v) => nextResult(result(v));
      })
    });
  }
}

/**
 * @param {UtilityFunction} fn
 * @param {String} name
 * @param {Number} [right]
 * @return {function(...(Number|String)): UtilityFunction}
 */
const makeChainable = (name, fn, right = 0) => {
  const chained = (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);
  if (!chainables[name]) chainables[name] = chained;
  return chained;
}

/**
 * @typedef {Object} ChainablesMap
 * @property {ChainedClamp} clamp
 * @property {ChainedRound} round
 * @property {ChainedSnap} snap
 * @property {ChainedWrap} wrap
 * @property {ChainedLerp} lerp
 * @property {ChainedDamp} damp
 * @property {ChainedMapRange} mapRange
 * @property {ChainedRoundPad} roundPad
 * @property {ChainedPadStart} padStart
 * @property {ChainedPadEnd} padEnd
 * @property {ChainedDegToRad} degToRad
 * @property {ChainedRadToDeg} radToDeg
 */

/**
 * @callback ChainedUtilsResult
 * @param {Number} value - The value to process through the chained operations
 * @return {Number} The processed result
 */

/**
 * @typedef {ChainablesMap & ChainedUtilsResult} ChainableUtil
 */

// Chainable

/**
 * @callback ChainedRoundPad
 * @param {Number} decimalLength - Number of decimal places
 * @return {ChainableUtil}
 */
export const roundPad = /** @type {typeof numberUtils.roundPad & ChainedRoundPad} */(makeChainable('roundPad', numberUtils.roundPad));

/**
 * @callback ChainedPadStart
 * @param {Number} totalLength - Target length
 * @param {String} padString - String to pad with
 * @return {ChainableUtil}
 */
export const padStart = /** @type {typeof numberUtils.padStart & ChainedPadStart} */(makeChainable('padStart', numberUtils.padStart));

/**
 * @callback ChainedPadEnd
 * @param {Number} totalLength - Target length
 * @param {String} padString - String to pad with
 * @return {ChainableUtil}
 */
export const padEnd = /** @type {typeof numberUtils.padEnd & ChainedPadEnd} */(makeChainable('padEnd', numberUtils.padEnd));

/**
 * @callback ChainedWrap
 * @param {Number} min - Minimum boundary
 * @param {Number} max - Maximum boundary
 * @return {ChainableUtil}
 */
export const wrap = /** @type {typeof numberUtils.wrap & ChainedWrap} */(makeChainable('wrap', numberUtils.wrap));

/**
 * @callback ChainedMapRange
 * @param {Number} inLow - Input range minimum
 * @param {Number} inHigh - Input range maximum
 * @param {Number} outLow - Output range minimum
 * @param {Number} outHigh - Output range maximum
 * @return {ChainableUtil}
 */
export const mapRange = /** @type {typeof numberUtils.mapRange & ChainedMapRange} */(makeChainable('mapRange', numberUtils.mapRange));

/**
 * @callback ChainedDegToRad
 * @return {ChainableUtil}
 */
export const degToRad = /** @type {typeof numberUtils.degToRad & ChainedDegToRad} */(makeChainable('degToRad', numberUtils.degToRad));

/**
 * @callback ChainedRadToDeg
 * @return {ChainableUtil}
 */
export const radToDeg = /** @type {typeof numberUtils.radToDeg & ChainedRadToDeg} */(makeChainable('radToDeg', numberUtils.radToDeg));

/**
 * @callback ChainedSnap
 * @param {Number|Array<Number>} increment - Step size or array of snap points
 * @return {ChainableUtil}
 */
export const snap = /** @type {typeof numberUtils.snap & ChainedSnap} */(makeChainable('snap', numberUtils.snap));

/**
 * @callback ChainedClamp
 * @param {Number} min - Minimum boundary
 * @param {Number} max - Maximum boundary
 * @return {ChainableUtil}
 */
export const clamp = /** @type {typeof numberUtils.clamp & ChainedClamp} */(makeChainable('clamp', numberUtils.clamp));

/**
 * @callback ChainedRound
 * @param {Number} decimalLength - Number of decimal places
 * @return {ChainableUtil}
 */
export const round = /** @type {typeof numberUtils.round & ChainedRound} */(makeChainable('round', numberUtils.round));

/**
 * @callback ChainedLerp
 * @param {Number} start - Starting value
 * @param {Number} end - Ending value
 * @return {ChainableUtil}
 */
export const lerp = /** @type {typeof numberUtils.lerp & ChainedLerp} */(makeChainable('lerp', numberUtils.lerp, 1));

/**
 * @callback ChainedDamp
 * @param {Number} start - Starting value
 * @param {Number} end - Target value
 * @param {Number} deltaTime - Delta time in ms
 * @return {ChainableUtil}
 */
export const damp = /** @type {typeof numberUtils.damp & ChainedDamp} */(makeChainable('damp', numberUtils.damp, 1));


## Links discovered
- [prop](https://github.com/juliangarnier/anime/blob/master/src/utils/...nextArgs)

--- src/core/clock.js ---
import {
  K,
  maxFps,
  minValue,
  tickModes,
} from './consts.js';

import {
  defaults,
} from './globals.js';

/**
 * @import {
 *   Tickable,
 *   Tween,
 * } from '../types/index.js'
*/

/*
 * Base class to control framerate and playback rate.
 * Inherited by Engine, Timer, Animation and Timeline.
 */
export class Clock {

  /** @param {Number} [initTime] */
  constructor(initTime = 0) {
    /** @type {Number} */
    this.deltaTime = 0;
    /** @type {Number} */
    this._currentTime = initTime;
    /** @type {Number} */
    this._lastTickTime = initTime;
    /** @type {Number} */
    this._startTime = initTime;
    /** @type {Number} */
    this._lastTime = initTime;
    /** @type {Number} */
    this._scheduledTime = 0;
    /** @type {Number} */
    this._frameDuration = K / maxFps;
    /** @type {Number} */
    this._fps = maxFps;
    /** @type {Number} */
    this._speed = 1;
    /** @type {Boolean} */
    this._hasChildren = false;
    /** @type {Tickable|Tween} */
    this._head = null;
    /** @type {Tickable|Tween} */
    this._tail = null;
  }

  get fps() {
    return this._fps;
  }

  set fps(frameRate) {
    const previousFrameDuration = this._frameDuration;
    const fr = +frameRate;
    const fps = fr < minValue ? minValue : fr;
    const frameDuration = K / fps;
    if (fps > defaults.frameRate) defaults.frameRate = fps;
    this._fps = fps;
    this._frameDuration = frameDuration;
    this._scheduledTime += frameDuration - previousFrameDuration;
  }

  get speed() {
    return this._speed;
  }

  set speed(playbackRate) {
    const pbr = +playbackRate;
    this._speed = pbr < minValue ? minValue : pbr;
  }

  /**
   * @param  {Number} time
   * @return {tickModes}
   */
  requestTick(time) {
    const scheduledTime = this._scheduledTime;
    this._lastTickTime = time;
    // If the current time is lower than the scheduled time
    // this means not enough time has passed to hit one frameDuration
    // so skip that frame
    if (time < scheduledTime) return tickModes.NONE;
    const frameDuration = this._frameDuration;
    const frameDelta = time - scheduledTime;
    // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.
    // Skips ahead if the actual elapsed time is higher.
    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;
    return tickModes.AUTO;
  }

  /**
   * @param  {Number} time
   * @return {Number}
   */
  computeDeltaTime(time) {
    const delta = time - this._lastTime;
    this.deltaTime = delta;
    this._lastTime = time;
    return delta;
  }

}


--- src/core/colors.js ---
import {
  rgbExecRgx,
  rgbaExecRgx,
  hslExecRgx,
  hslaExecRgx,
} from './consts.js';

import {
  round,
  isRgb,
  isHex,
  isHsl,
  isUnd,
} from './helpers.js';

/**
 * @import {
 *   ColorArray,
 * } from '../types/index.js'
*/

/**
 * RGB / RGBA Color value string -> RGBA values array
 * @param  {String} rgbValue
 * @return {ColorArray}
 */
const rgbToRgba = rgbValue => {
  const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);
  const a = !isUnd(rgba[4]) ? +rgba[4] : 1;
  return [
    +rgba[1],
    +rgba[2],
    +rgba[3],
    a
  ]
}

/**
 * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array
 * @param  {String} hexValue
 * @return {ColorArray}
 */
const hexToRgba = hexValue => {
  const hexLength = hexValue.length;
  const isShort = hexLength === 4 || hexLength === 5;
  return [
    +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),
    +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),
    +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),
    ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)
  ]
}

/**
 * @param  {Number} p
 * @param  {Number} q
 * @param  {Number} t
 * @return {Number}
 */
const hue2rgb = (p, q, t) => {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  return t < 1 / 6 ? p + (q - p) * 6 * t :
         t < 1 / 2 ? q :
         t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :
         p;
}

/**
 * HSL / HSLA Color value string -> RGBA values array
 * @param  {String} hslValue
 * @return {ColorArray}
 */
const hslToRgba = hslValue => {
  const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);
  const h = +hsla[1] / 360;
  const s = +hsla[2] / 100;
  const l = +hsla[3] / 100;
  const a = !isUnd(hsla[4]) ? +hsla[4] : 1;
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const q = l < .5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);
    g = round(hue2rgb(p, q, h) * 255, 0);
    b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);
  }
  return [r, g, b, a];
}

/**
 * All in one color converter that converts a color string value into an array of RGBA values
 * @param  {String} colorString
 * @return {ColorArray}
 */
export const convertColorStringValuesToRgbaArray = colorString => {
  return isRgb(colorString) ? rgbToRgba(colorString) :
         isHex(colorString) ? hexToRgba(colorString) :
         isHsl(colorString) ? hslToRgba(colorString) :
         [0, 0, 0, 1];
}


--- src/animation/composition.js ---
import {
  compositionTypes,
  minValue,
  tweenTypes,
} from '../core/consts.js';

import {
  cloneArray,
  addChild,
  removeChild,
  forEachChildren,
  round,
  isUnd,
} from '../core/helpers.js';

import {
  sanitizePropertyName,
} from '../core/styles.js';

import {
  engine,
} from '../engine/engine.js';

import {
  additive,
  addAdditiveAnimation,
} from './additive.js';

/**
 * @import {
 *   TweenReplaceLookups,
 *   TweenAdditiveLookups,
 *   TweenPropertySiblings,
 *   Tween,
 *   Target,
 *   TargetsArray,
 *   Renderable,
 * } from '../types/index.js'
 *
 * @import {
 *   JSAnimation,
 * } from '../animation/animation.js'
*/

const lookups = {
  /** @type {TweenReplaceLookups} */
  _rep: new WeakMap(),
  /** @type {TweenAdditiveLookups} */
  _add: new Map(),
}

/**
 * @param  {Target} target
 * @param  {String} property
 * @param  {String} lookup
 * @return {TweenPropertySiblings}
 */
export const getTweenSiblings = (target, property, lookup = '_rep') => {
  const lookupMap = lookups[lookup];
  let targetLookup = lookupMap.get(target);
  if (!targetLookup) {
    targetLookup = {};
    lookupMap.set(target, targetLookup);
  }
  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {
    _head: null,
    _tail: null,
  }
}

/**
 * @param  {Tween} p
 * @param  {Tween} c
 * @return {Number|Boolean}
 */
const addTweenSortMethod = (p, c) => {
  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;
}

/**
 * @param {Tween} tween
 */
export const overrideTween = tween => {
  tween._isOverlapped = 1;
  tween._isOverridden = 1;
  tween._changeDuration = minValue;
  tween._currentTime = minValue;
}

/**
 * @param  {Tween} tween
 * @param  {TweenPropertySiblings} siblings
 * @return {Tween}
 */
export const composeTween = (tween, siblings) => {

  const tweenCompositionType = tween._composition;

  // Handle replaced tweens

  if (tweenCompositionType === compositionTypes.replace) {

    const tweenAbsStartTime = tween._absoluteStartTime;

    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');

    const prevSibling = tween._prevRep;

    // Update the previous siblings for composition replace tweens

    if (prevSibling) {

      const prevParent = prevSibling.parent;
      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;

      // Handle looped animations tween

      if (
        // Check if the previous tween is from a different animation
        tween.parent.id !== prevParent.id &&
        // Check if the animation has loops
        prevParent.iterationCount> 1 &&
        // Check if _absoluteChangeEndTime of last loop overlaps the current tween
        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime
      ) {

        // TODO: Find a way to only override the iterations overlapping with the tween
        overrideTween(prevSibling);

        let prevPrevSibling = prevSibling._prevRep;

        // If the tween was part of a set of keyframes, override its siblings
        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {
          overrideTween(prevPrevSibling);
          prevPrevSibling = prevPrevSibling._prevRep;
        }

      }

      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;

      if (prevAbsEndTime > absoluteUpdateStartTime) {

        const prevChangeStartTime = prevSibling._startTime;
        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);
        // Rounding is necessary here to minimize floating point errors when working in seconds
        const updatedPrevChangeDuration = round(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);

        prevSibling._changeDuration = updatedPrevChangeDuration;
        prevSibling._currentTime = updatedPrevChangeDuration;
        prevSibling._isOverlapped = 1;

        // Override the previous tween if its new _changeDuration is lower than minValue
        // TODO: See if it's even neceseeary to test against minValue, checking for 0 might be enough
        if (updatedPrevChangeDuration < minValue) {
          overrideTween(prevSibling);
        }
      }

      // Pause (and cancel) the parent if it only contains overlapped tweens

      let pausePrevParentAnimation = true;

      forEachChildren(prevParent, (/** @type Tween */t) => {
        if (!t._isOverlapped) pausePrevParentAnimation = false;
      });

      if (pausePrevParentAnimation) {
        const prevParentTL = prevParent.parent;
        if (prevParentTL) {
          let pausePrevParentTL = true;
          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {
            if (a !== prevParent) {
              forEachChildren(a, (/** @type Tween */t) => {
                if (!t._isOverlapped) pausePrevParentTL = false;
              });
            }
          });
          if (pausePrevParentTL) {
            prevParentTL.cancel();
          }
        } else {
          prevParent.cancel();
          // Previously, calling .cancel() on a timeline child would affect the render order of other children
          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop
          // This is no longer needed since timeline tween composition is now handled separately
          // Keeping this here for reference
          // prevParent.completed = true;
          // prevParent.pause();
        }
      }

    }

    // let nextSibling = tween._nextRep;

    // // All the next siblings are automatically overridden

    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {
    //   while (nextSibling) {
    //     overrideTween(nextSibling);
    //     nextSibling = nextSibling._nextRep;
    //   }
    // }

    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {
    //   while (nextSibling) {
    //     overrideTween(nextSibling);
    //     console.log(tween.id, nextSibling.id);
    //     nextSibling = nextSibling._nextRep;
    //   }
    // }

  // Handle additive tweens composition

  } else if (tweenCompositionType === compositionTypes.blend) {

    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');
    const additiveAnimation = addAdditiveAnimation(lookups._add);

    let lookupTween = additiveTweenSiblings._head;

    if (!lookupTween) {
      lookupTween = { ...tween };
      lookupTween._composition = compositionTypes.replace;
      lookupTween._updateDuration = minValue;
      lookupTween._startTime = 0;
      lookupTween._numbers = cloneArray(tween._fromNumbers);
      lookupTween._number = 0;
      lookupTween._next = null;
      lookupTween._prev = null;
      addChild(additiveTweenSiblings, lookupTween);
      addChild(additiveAnimation, lookupTween);
    }

    // Convert the values of TO to FROM and set TO to 0

    const toNumber = tween._toNumber;
    tween._fromNumber = lookupTween._fromNumber - toNumber;
    tween._toNumber = 0;
    tween._numbers = cloneArray(tween._fromNumbers);
    tween._number = 0;
    lookupTween._fromNumber = toNumber;

    if (tween._toNumbers) {
      const toNumbers = cloneArray(tween._toNumbers);
      if (toNumbers) {
        toNumbers.forEach((value, i) => {
          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;
          tween._toNumbers[i] = 0;
        });
      }
      lookupTween._fromNumbers = toNumbers;
    }

    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');

  }

  return tween;

}

/**
 * @param  {Tween} tween
 * @return {Tween}
 */
export const removeTweenSliblings = tween => {
  const tweenComposition = tween._composition;
  if (tweenComposition !== compositionTypes.none) {
    const tweenTarget = tween.target;
    const tweenProperty = tween.property;
    const replaceTweensLookup = lookups._rep;
    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);
    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];
    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');
    if (tweenComposition === compositionTypes.blend) {
      const addTweensLookup = lookups._add;
      const addTargetProps = addTweensLookup.get(tweenTarget);
      if (!addTargetProps) return;
      const additiveTweenSiblings = addTargetProps[tweenProperty];
      const additiveAnimation = additive.animation;
      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');
      // If only one tween is left in the additive lookup, it's the tween lookup
      const lookupTween = additiveTweenSiblings._head;
      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {
        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');
        removeChild(additiveAnimation, lookupTween);
        let shouldClean = true;
        for (let prop in addTargetProps) {
          if (addTargetProps[prop]._head) {
            shouldClean = false;
            break;
          }
        }
        if (shouldClean) {
          addTweensLookup.delete(tweenTarget);
        }
      }
    }
  }
  return tween;
}

/**
 * @param  {TargetsArray} targetsArray
 * @param  {JSAnimation} animation
 * @param  {String} [propertyName]
 * @return {Boolean}
 */
const removeTargetsFromJSAnimation = (targetsArray, animation, propertyName) => {
  let tweensMatchesTargets = false;
  forEachChildren(animation, (/**@type {Tween} */tween) => {
    const tweenTarget = tween.target;
    if (targetsArray.includes(tweenTarget)) {
      const tweenName = tween.property;
      const tweenType = tween._tweenType;
      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);
      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {
        // Make sure to flag the previous CSS transform tween to renderTransform
        if (tween.parent._tail === tween &&
            tween._tweenType === tweenTypes.TRANSFORM &&
            tween._prev &&
            tween._prev._tweenType === tweenTypes.TRANSFORM
        ) {
          tween._prev._renderTransforms = 1;
        }
        // Removes the tween from the selected animation
        removeChild(animation, tween);
        // Detach the tween from its siblings to make sure blended tweens are correctlly removed
        removeTweenSliblings(tween);
        tweensMatchesTargets = true;
      }
    }
  }, true);
  return tweensMatchesTargets;
}

/**
 * @param  {TargetsArray} targetsArray
 * @param  {Renderable} [renderable]
 * @param  {String} [propertyName]
 */
export const removeTargetsFromRenderable = (targetsArray, renderable, propertyName) => {
  const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : engine);
  let removeMatches;
  if (parent._hasChildren) {
    let iterationDuration = 0;
    forEachChildren(parent, (/** @type {Renderable} */child) => {
      if (!child._hasChildren) {
        removeMatches = removeTargetsFromJSAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);
        // Remove the child from its parent if no tweens and no children left after the removal
        if (removeMatches && !child._head) {
          child.cancel();
          removeChild(parent, child);
        } else {
          // Calculate the new iterationDuration value to handle onComplete with last child in render()
          const childTLOffset = child._offset + child._delay;
          const childDur = childTLOffset + child.duration;
          if (childDur > iterationDuration) {
            iterationDuration = childDur;
          }
        }
      }
      // Make sure to also remove engine's children targets
      // NOTE: Avoid recursion?
      if (child._head) {
        removeTargetsFromRenderable(targetsArray, child, propertyName);
      } else {
        child._hasChildren = false;
      }
    }, true);
    // Update iterationDuration value to handle onComplete with last child in render()
    if (!isUnd(/** @type {Renderable} */(parent).iterationDuration)) {
      /** @type {Renderable} */(parent).iterationDuration = iterationDuration;
    }
  } else {
    removeMatches = removeTargetsFromJSAnimation(
      targetsArray,
      /** @type {JSAnimation} */(parent),
      propertyName
    );
  }
  if (removeMatches && !parent._head) {
    parent._hasChildren = false;
    // Cancel the parent if there are no tweens and no children left after the removal
    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself
    if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();
  }
}


--- src/core/consts.js ---
// Environments

// TODO: Do we need to check if we're running inside a worker ?
export const isBrowser = typeof window !== 'undefined';

/** @typedef {Window & {AnimeJS: Array} & {AnimeJSDevTools: any}|null} AnimeJSWindow

/** @type {AnimeJSWindow} */
export const win = isBrowser ? /** @type {AnimeJSWindow} */(/** @type {unknown} */(window)) : null;

/** @type {Document|null} */
export const doc = isBrowser ? document : null;

// Enums

/** @enum {Number} */
export const tweenTypes = {
  OBJECT: 0,
  ATTRIBUTE: 1,
  CSS: 2,
  TRANSFORM: 3,
  CSS_VAR: 4,
}

/** @enum {Number} */
export const valueTypes = {
  NUMBER: 0,
  UNIT: 1,
  COLOR: 2,
  COMPLEX: 3,
}

/** @enum {Number} */
export const tickModes = {
  NONE: 0,
  AUTO: 1,
  FORCE: 2,
}

/** @enum {Number} */
export const compositionTypes = {
  replace: 0,
  none: 1,
  blend: 2,
}

// Cache symbols

export const isRegisteredTargetSymbol = Symbol();
export const isDomSymbol = Symbol();
export const isSvgSymbol = Symbol();
export const transformsSymbol = Symbol();
export const morphPointsSymbol = Symbol();
export const proxyTargetSymbol = Symbol();

// Numbers

export const minValue = 1e-11;
export const maxValue = 1e12;
export const K = 1e3;
export const maxFps = 240;

// Strings

export const emptyString = '';
export const cssVarPrefix = 'var(';

export const shortTransforms = /*#__PURE__*/ (() => {
  const map = new Map();
  map.set('x', 'translateX');
  map.set('y', 'translateY');
  map.set('z', 'translateZ');
  return map;
})();

export const validTransforms = [
  'translateX',
  'translateY',
  'translateZ',
  'rotate',
  'rotateX',
  'rotateY',
  'rotateZ',
  'scale',
  'scaleX',
  'scaleY',
  'scaleZ',
  'skew',
  'skewX',
  'skewY',
  'matrix',
  'matrix3d',
  'perspective',
];

export const transformsFragmentStrings = /*#__PURE__*/ validTransforms.reduce((a, v) => ({...a, [v]: v + '('}), {});

// Functions

/** @return {void} */
export const noop = () => {};

// Regex

export const hexTestRgx = /(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;
export const rgbExecRgx = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i
export const rgbaExecRgx = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i
export const hslExecRgx = /hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;
export const hslaExecRgx = /hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
// export const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g;
export const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi;
// export const unitsExecRgx = /^([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)+([a-z]+|%)$/i;
export const unitsExecRgx = /^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i
export const lowerCaseRgx = /([a-z])([A-Z])/g;
export const transformsExecRgx = /(\w+)(\([^)]+\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()
export const relativeValuesExecRgx = /(\*=|\+=|-=)/;
export const cssVariableMatchRgx = /var\(\s*(--[\w-]+)(?:\s*,\s*([^)]+))?\s*\)/;


--- src/draggable/draggable.js ---
import {
  scope,
  globals,
} from '../core/globals.js';

import {
  win,
  doc,
  maxValue,
  noop,
  compositionTypes,
} from '../core/consts.js';

import {
  parseTargets,
} from '../core/targets.js';

import {
  snap,
  clamp,
  round,
  isObj,
  isUnd,
  isArr,
  isFnc,
  sqrt,
  max,
  atan2,
  cos,
  sin,
  abs,
  now,
  isNum,
} from '../core/helpers.js';

import {
  setValue,
} from '../core/values.js';

import {
  mapRange,
} from '../utils/number.js';

import {
  Timer,
} from '../timer/timer.js';

import {
  JSAnimation,
} from '../animation/animation.js';

import {
  removeTargetsFromRenderable,
} from '../animation/composition.js';

import {
  Animatable,
} from '../animatable/animatable.js';

import {
  eases,
  parseEase,
} from '../easings/eases/parser.js';

import {
  spring,
} from '../easings/spring/index.js';

import {
  get,
  set,
} from '../utils/target.js';

/**
 * @import {
 *   DOMTarget,
 *   DOMTargetSelector,
 *   DraggableCursorParams,
 *   DraggableDragThresholdParams,
 *   TargetsParam,
 *   DraggableParams,
 *   EasingFunction,
 *   Callback,
 *   AnimatableParams,
 *   DraggableAxisParam,
 *   AnimatableObject,
 *   EasingParam,
 * } from '../types/index.js'
*/

/**
 * @import {
 *   Spring,
 * } from '../easings/spring/index.js'
*/

/**
 * @param {Event} e
 */
const preventDefault = e => {
  if (e.cancelable) e.preventDefault();
}

class DOMProxy {
  /** @param {Object} el */
  constructor(el) {
    this.el = el;
    this.zIndex = 0;
    this.parentElement = null;
    this.classList = {
      add: noop,
      remove: noop,
    }
  }

  get x() { return this.el.x || 0 };
  set x(v) { this.el.x = v };

  get y() { return this.el.y || 0 };
  set y(v) { this.el.y = v };

  get width() { return this.el.width || 0 };
  set width(v) { this.el.width = v };

  get height() { return this.el.height || 0 };
  set height(v) { this.el.height = v };

  getBoundingClientRect() {
    return {
      top: this.y,
      right: this.x,
      bottom: this.y + this.height,
      left: this.x + this.width,
    }
  }
}

class Transforms {
  /**
   * @param {DOMTarget|DOMProxy} $el
   */
  constructor($el) {
    this.$el = $el;
    this.inlineTransforms = [];
    this.point = new DOMPoint();
    this.inversedMatrix = this.getMatrix().inverse();
  }

  /**
   * @param {Number} x
   * @param {Number} y
   * @return {DOMPoint}
   */
  normalizePoint(x, y) {
    this.point.x = x;
    this.point.y = y;
    return this.point.matrixTransform(this.inversedMatrix);
  }

  /**
   * @callback TraverseParentsCallback
   * @param {DOMTarget} $el
   * @param {Number} i
   */

  /**
   * @param {TraverseParentsCallback} cb
   */
  traverseUp(cb) {
    let $el = /** @type {DOMTarget|Document} */(this.$el.parentElement), i = 0;
    while ($el && $el !== doc) {
      cb(/** @type {DOMTarget} */($el), i);
      $el = /** @type {DOMTarget} */($el.parentElement);
      i++;
    }
  }

  getMatrix() {
    const matrix = new DOMMatrix();
    this.traverseUp($el => {
      const transformValue = getComputedStyle($el).transform;
      if (transformValue) {
        const elMatrix = new DOMMatrix(transformValue);
        matrix.preMultiplySelf(elMatrix);
      }
    });
    return matrix;
  }

  remove() {
    this.traverseUp(($el, i) => {
      this.inlineTransforms[i] = $el.style.transform;
      $el.style.transform = 'none';
    });
  }

  revert() {
    this.traverseUp(($el, i) => {
      const ct = this.inlineTransforms[i];
      if (ct === '') {
        $el.style.removeProperty('transform');
      } else {
        $el.style.transform = ct;
      }
    });
  }
}

/**
 * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams|DraggableDragThresholdParams} T
 * @param {T | ((draggable: Draggable) => T)} value
 * @param {Draggable} draggable
 * @return {T}
 */
const parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */(value)(draggable) : /** @type {T} */(value);

let zIndex = 0;

export class Draggable {
  /**
   * @param {TargetsParam} target
   * @param {DraggableParams} [parameters]
   */
  constructor(target, parameters = {}) {
    if (!target) return;
    if (scope.current) scope.current.register(this);
    const paramX = parameters.x;
    const paramY = parameters.y;
    const trigger = parameters.trigger;
    const modifier = parameters.modifier;
    const ease = parameters.releaseEase;
    const customEase = ease && parseEase(ease);
    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);
    const xProp = /** @type {String} */(isObj(paramX) && !isUnd(/** @type {Object} */(paramX).mapTo) ? /** @type {Object} */(paramX).mapTo : 'translateX');
    const yProp = /** @type {String} */(isObj(paramY) && !isUnd(/** @type {Object} */(paramY).mapTo) ? /** @type {Object} */(paramY).mapTo : 'translateY');
    const container = parseDraggableFunctionParameter(parameters.container, this);
    this.containerArray = isArr(container) ? container : null;
    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);
    this.useWin = this.$container === doc.body;
    /** @type {Window | HTMLElement} */
    this.$scrollContainer = this.useWin ? win : this.$container;
    this.$target = /** @type {HTMLElement} */(isObj(target) ? new DOMProxy(target) : parseTargets(target)[0]);
    this.$trigger = /** @type {HTMLElement} */(parseTargets(trigger ? trigger : target)[0]);
    this.fixed = get(this.$target, 'position') === 'fixed';
    // Refreshable parameters
    this.isFinePointer = true;
    /** @type {[Number, Number, Number, Number]} */
    this.containerPadding = [0, 0, 0, 0];
    /** @type {Number} */
    this.containerFriction = 0;
    /** @type {Number} */
    this.releaseContainerFriction = 0;
    /** @type {Number|Array<Number>} */
    this.snapX = 0;
    /** @type {Number|Array<Number>} */
    this.snapY = 0;
    /** @type {Number} */
    this.scrollSpeed = 0;
    /** @type {Number} */
    this.scrollThreshold = 0;
    /** @type {Number} */
    this.dragSpeed = 0;
    /** @type {Number} */
    this.dragThreshold = 3;
    /** @type {Number} */
    this.maxVelocity = 0;
    /** @type {Number} */
    this.minVelocity = 0;
    /** @type {Number} */
    this.velocityMultiplier = 0;
    /** @type {Boolean|DraggableCursorParams} */
    this.cursor = false;
    /** @type {Spring} */
    this.releaseXSpring = hasSpring ? /** @type {Spring} */(ease) : spring({
      mass: setValue(parameters.releaseMass, 1),
      stiffness: setValue(parameters.releaseStiffness, 80),
      damping: setValue(parameters.releaseDamping, 20),
    });
    /** @type {Spring} */
    this.releaseYSpring = hasSpring ? /** @type {Spring} */(ease) : spring({
      mass: setValue(parameters.releaseMass, 1),
      stiffness: setValue(parameters.releaseStiffness, 80),
      damping: setValue(parameters.releaseDamping, 20),
    });
    /** @type {EasingFunction} */
    this.releaseEase = customEase || eases.outQuint;
    /** @type {Boolean} */
    this.hasReleaseSpring = hasSpring;
    /** @type {Callback<this>} */
    this.onGrab = parameters.onGrab || noop;
    /** @type {Callback<this>} */
    this.onDrag = parameters.onDrag || noop;
    /** @type {Callback<this>} */
    this.onRelease = parameters.onRelease || noop;
    /** @type {Callback<this>} */
    this.onUpdate = parameters.onUpdate || noop;
    /** @type {Callback<this>} */
    this.onSettle = parameters.onSettle || noop;
    /** @type {Callback<this>} */
    this.onSnap = parameters.onSnap || noop;
    /** @type {Callback<this>} */
    this.onResize = parameters.onResize || noop;
    /** @type {Callback<this>} */
    this.onAfterResize = parameters.onAfterResize || noop;
    /** @type {[Number, Number]} */
    this.disabled = [0, 0];
    /** @type {AnimatableParams} */
    const animatableParams = {};
    if (modifier) animatableParams.modifier = modifier;
    if (isUnd(paramX) || paramX === true) {
      animatableParams[xProp] = 0;
    } else if (isObj(paramX)) {
      const paramXObject = /** @type {DraggableAxisParam} */(paramX);
      const animatableXParams = {};
      if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;
      if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;
      animatableParams[xProp] = animatableXParams;
    } else if (paramX === false) {
      animatableParams[xProp] = 0;
      this.disabled[0] = 1;
    }
    if (isUnd(paramY) || paramY === true) {
      animatableParams[yProp] = 0;
    } else if (isObj(paramY)) {
      const paramYObject = /** @type {DraggableAxisParam} */(paramY);
      const animatableYParams = {};
      if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;
      if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;
      animatableParams[yProp] = animatableYParams;
    } else if (paramY === false) {
      animatableParams[yProp] = 0;
      this.disabled[1] = 1;
    }
    /** @type {AnimatableObject} */
    this.animate = /** @type {AnimatableObject} */(new Animatable(this.$target, animatableParams));
    // Internal props
    this.xProp = xProp;
    this.yProp = yProp;
    this.destX = 0;
    this.destY = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.scroll = {x: 0, y: 0};
    /** @type {[Number, Number, Number, Number]} */
    this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y
    /** @type {[Number, Number]} */
    this.snapped = [0, 0]; // x, y
    /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */
    this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2
    /** @type {[Number, Number]} */
    this.scrollView = [0, 0]; // w, h
    /** @type {[Number, Number, Number, Number]} */
    this.dragArea = [0, 0, 0, 0]; // x, y, w, h
    /** @type {[Number, Number, Number, Number]} */
    this.containerBounds = [-maxValue, maxValue, maxValue, -maxValue]; // t, r, b, l
    /** @type {[Number, Number, Number, Number]} */
    this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l
    /** @type {[Number, Number, Number, Number]} */
    this.targetBounds = [0, 0, 0, 0]; // t, r, b, l
    /** @type {[Number, Number]} */
    this.window = [0, 0]; // w, h
    /** @type {[Number, Number, Number]} */
    this.velocityStack = [0, 0, 0];
    /** @type {Number} */
    this.velocityStackIndex = 0;
    /** @type {Number} */
    this.velocityTime = now();
    /** @type {Number} */
    this.velocity = 0;
    /** @type {Number} */
    this.angle = 0;
    /** @type {JSAnimation} */
    this.cursorStyles = null;
    /** @type {JSAnimation} */
    this.triggerStyles = null;
    /** @type {JSAnimation} */
    this.bodyStyles = null;
    /** @type {JSAnimation} */
    this.targetStyles = null;
    /** @type {JSAnimation} */
    this.touchActionStyles = null;
    this.transforms = new Transforms(this.$target);
    this.overshootCoords = { x: 0, y: 0 };
    this.overshootTicker = new Timer({
      autoplay: false,
      onUpdate: () => {
        this.updated = true;
        this.manual = true;
        // Use a duration of 1 to prevent the animatable from completing immediately to prevent issues with onSettle()
        // https://github.com/juliangarnier/anime/issues/1045
        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 1);
        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 1);
      },
      onComplete: () => {
        this.manual = false;
        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 0);
        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 0);
      },
    }, null, 0).init();
    this.updateTicker = new Timer({ autoplay: false, onUpdate: () => this.update() }, null,0,).init();
    this.contained = !isUnd(container);
    this.manual = false;
    this.grabbed = false;
    this.dragged = false;
    this.updated = false;
    this.released = false;
    this.canScroll = false;
    this.enabled = false;
    this.initialized = false;
    this.activeProp = this.disabled[1] ? xProp : yProp;
    this.animate.callbacks.onRender = () => {
      const hasUpdated = this.updated;
      const hasMoved = this.grabbed && hasUpdated;
      const hasReleased = !hasMoved && this.released;
      const x = this.x;
      const y = this.y;
      const dx = x - this.coords[2];
      const dy = y - this.coords[3];
      this.deltaX = dx;
      this.deltaY = dy;
      this.coords[2] = x;
      this.coords[3] = y;
      // Check if dx or dy are not 0 to check if the draggable has actually moved
      // https://github.com/juliangarnier/anime/issues/1032
      if (hasUpdated && (dx || dy)) {
        this.onUpdate(this);
      }
      if (!hasReleased) {
        this.updated = false;
      } else {
        this.computeVelocity(dx, dy);
        this.angle = atan2(dy, dx);
      }
    }
    this.animate.callbacks.onComplete = () => {
      if ((!this.grabbed && this.released)) {
        // Set released to false before calling onSettle to avoid recursion
        this.released = false;
      }
      if (!this.manual) {
        this.deltaX = 0;
        this.deltaY = 0;
        this.velocity = 0;
        this.velocityStack[0] = 0;
        this.velocityStack[1] = 0;
        this.velocityStack[2] = 0;
        this.velocityStackIndex = 0;
        this.onSettle(this);
      }
    };
    this.resizeTicker = new Timer({
      autoplay: false,
      duration: 150 * globals.timeScale,
      onComplete: () => {
        this.onResize(this);
        this.refresh();
        this.onAfterResize(this);
      },
    }).init();
    this.parameters = parameters;
    this.resizeObserver = new ResizeObserver(() => {
      if (this.initialized) {
        this.resizeTicker.restart();
      } else {
        this.initialized = true;
      }
    });
    this.enable();
    this.refresh();
    this.resizeObserver.observe(this.$container);
    if (!isObj(target)) this.resizeObserver.observe(this.$target);
  }

  /**
   * @param  {Number} dx
   * @param  {Number} dy
   * @return {Number}
   */
  computeVelocity(dx, dy) {
    const prevTime = this.velocityTime;
    const curTime = now();
    const elapsed = curTime - prevTime;
    if (elapsed < 17) return this.velocity;
    this.velocityTime = curTime;
    const velocityStack = this.velocityStack;
    const vMul = this.velocityMultiplier;
    const minV = this.minVelocity;
    const maxV = this.maxVelocity;
    const vi = this.velocityStackIndex;
    velocityStack[vi] = round(clamp((sqrt(dx * dx + dy * dy) / elapsed) * vMul, minV, maxV), 5);
    const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);
    this.velocity = velocity;
    this.velocityStackIndex = (vi + 1) % 3;
    return velocity;
  }

  /**
   * @param {Number}  x
   * @param {Boolean} [muteUpdateCallback]
   * @return {this}
   */
  setX(x, muteUpdateCallback = false) {
    if (this.disabled[0]) return;
    const v = round(x, 5);
    this.overshootTicker.pause();
    this.manual = true;
    this.updated = !muteUpdateCallback;
    this.destX = v;
    this.snapped[0] = snap(v, this.snapX);
    this.animate[this.xProp](v, 0);
    this.manual = false;
    return this;
  }

  /**
   * @param {Number}  y
   * @param {Boolean} [muteUpdateCallback]
   * @return {this}
   */
  setY(y, muteUpdateCallback = false) {
    if (this.disabled[1]) return;
    const v = round(y, 5);
    this.overshootTicker.pause();
    this.manual = true;
    this.updated = !muteUpdateCallback;
    this.destY = v;
    this.snapped[1] = snap(v, this.snapY);
    this.animate[this.yProp](v, 0);
    this.manual = false;
    return this;
  }

  get x() {
    return round(/** @type {Number} */(this.animate[this.xProp]()), globals.precision);
  }

  set x(x) {
    this.setX(x, false);
  }

  get y() {
    return round(/** @type {Number} */(this.animate[this.yProp]()), globals.precision);
  }

  set y(y) {
    this.setY(y, false);
  }

  get progressX() {
    return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);
  }

  set progressX(x) {
    this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);
  }

  get progressY() {
    return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);
  }

  set progressY(y) {
    this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);
  }

  updateScrollCoords() {
    const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);
    const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);
    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
    const threshold = this.scrollThreshold;
    this.scroll.x = sx;
    this.scroll.y = sy;
    this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;
    this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;
    this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;
    this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;
  }

  updateBoundingValues() {
    const $container = this.$container;
    // Return early if no $container defined to prevents error when reading scrollWidth / scrollHeight
    // https://github.com/juliangarnier/anime/issues/1064
    if (!$container) return;
    const cx = this.x;
    const cy = this.y;
    const cx2 = this.coords[2];
    const cy2 =  this.coords[3];
    // Prevents interfering with the scroll area in cases the target is outside of the container
    // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates
    this.coords[2] = 0;
    this.coords[3] = 0;
    this.setX(0, true);
    this.setY(0, true);
    this.transforms.remove();
    const iw = this.window[0] = win.innerWidth;
    const ih = this.window[1] = win.innerHeight;
    const uw = this.useWin;
    const sw = $container.scrollWidth;
    const sh = $container.scrollHeight;
    const fx = this.fixed;
    const transformContainerRect = $container.getBoundingClientRect();
    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
    this.dragArea[0] = uw ? 0 : transformContainerRect.left;
    this.dragArea[1] = uw ? 0 : transformContainerRect.top;
    this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;
    this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;
    this.updateScrollCoords();
    const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();
    this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);
    this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);
    const containerOverflow = get($container, 'overflow');
    const visibleOverflow = containerOverflow === 'visible';
    const hiddenOverflow = containerOverflow === 'hidden';
    this.canScroll = fx ? false :
      this.contained &&
      (($container === doc.body && visibleOverflow) || (!hiddenOverflow && !visibleOverflow)) &&
      (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) &&
      (!this.containerArray || (this.containerArray && !isArr(this.containerArray)));
    if (this.contained) {
      const sx = this.scroll.x;
      const sy = this.scroll.y;
      const canScroll = this.canScroll;
      const targetRect = this.$target.getBoundingClientRect();
      const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;
      const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;
      const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;
      const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;
      this.targetBounds[0] = round((targetRect.top + sy) - (uw ? 0 : top), 0);
      this.targetBounds[1] = round((targetRect.right + sx) - (uw ? iw : right), 0);
      this.targetBounds[2] = round((targetRect.bottom + sy) - (uw ? ih : bottom), 0);
      this.targetBounds[3] = round((targetRect.left + sx) - (uw ? 0 : left), 0);
      if (this.containerArray) {
        this.containerBounds[0] = this.containerArray[0] + cpt;
        this.containerBounds[1] = this.containerArray[1] - cpr;
        this.containerBounds[2] = this.containerArray[2] - cpb;
        this.containerBounds[3] = this.containerArray[3] + cpl;
      } else {
        this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);
        this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);
        this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);
        this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);
      }
    }
    this.transforms.revert();
    // Restore coordinates
    this.coords[2] = cx2;
    this.coords[3] = cy2;
    this.setX(cx, true);
    this.setY(cy, true);
  }

  /**
   * @param  {Array} bounds
   * @param  {Number} x
   * @param  {Number} y
   * @return {Number}
   */
  isOutOfBounds(bounds, x, y) {
    // Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB
    if (!this.contained) return 0;
    const [ bt, br, bb, bl ] = bounds;
    const [ dx, dy ] = this.disabled;
    const obx = !dx && x < bl || !dx && x > br;
    const oby = !dy && y < bt || !dy && y > bb;
    return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;
  }

  refresh() {
    const params = this.parameters;
    const paramX = params.x;
    const paramY = params.y;
    const container = parseDraggableFunctionParameter(params.container, this);
    const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;
    const containerPadding = /** @type {[Number, Number, Number, Number]} */(isArr(cp) ? cp : [cp, cp, cp, cp]);
    const cx = this.x;
    const cy = this.y;
    const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);
    const cursorStyles = { onHover: 'grab', onGrab: 'grabbing' };
    if (parsedCursorStyles) {
      const { onHover, onGrab } = /** @type {DraggableCursorParams} */(parsedCursorStyles);
      if (onHover) cursorStyles.onHover = onHover;
      if (onGrab) cursorStyles.onGrab = onGrab;
    }
    const parsedDragThreshold = parseDraggableFunctionParameter(params.dragThreshold, this);
    const dragThreshold = { mouse: 3, touch: 7 };
    if (isNum(parsedDragThreshold)) {
      dragThreshold.mouse = parsedDragThreshold;
      dragThreshold.touch = parsedDragThreshold;
    } else if (parsedDragThreshold) {
      const { mouse, touch } = parsedDragThreshold;
      if (!isUnd(mouse)) dragThreshold.mouse = mouse;
      if (!isUnd(touch)) dragThreshold.touch = touch;
    }
    this.containerArray = isArr(container) ? container : null;
    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);
    this.useWin = this.$container === doc.body;
    /** @type {Window | HTMLElement} */
    this.$scrollContainer = this.useWin ? win : this.$container;
    this.isFinePointer = matchMedia('(pointer:fine)').matches;
    this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);
    this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);
    this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);
    this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);
    this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);
    this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);
    this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);
    this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);
    this.dragThreshold = this.isFinePointer ? dragThreshold.mouse : dragThreshold.touch;
    this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);
    this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);
    this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);
    this.cursor = parsedCursorStyles === false ? false : cursorStyles;
    this.updateBoundingValues();

    // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);
    // if (ob === 1 || ob === 3) this.progressX = px;
    // if (ob === 2 || ob === 3) this.progressY = py;

    // if (this.initialized && this.contained) {
    //   if (this.progressX !== px) this.progressX = px;
    //   if (this.progressY !== py) this.progressY = py;
    // }

    const [ bt, br, bb, bl ] = this.containerBounds;
    this.setX(clamp(cx, bl, br), true);
    this.setY(clamp(cy, bt, bb), true);
  }

  update() {
    this.updateScrollCoords();
    if (this.canScroll) {
      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
      const [ sw, sh ] = this.scrollView;
      const daw = this.dragArea[2];
      const dah = this.dragArea[3];
      const csx = this.scroll.x;
      const csy = this.scroll.y;
      const nsw = this.$container.scrollWidth;
      const nsh = this.$container.scrollHeight;
      const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;
      const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;
      const swd = sw - csw;
      const shd = sh - csh;
      // Handle cases where the scrollarea dimensions changes during drag
      if (this.dragged && swd > 0) {
        this.coords[0] -= swd;
        this.scrollView[0] = csw;
      }
      if (this.dragged && shd > 0) {
        this.coords[1] -= shd;
        this.scrollView[1] = csh;
      }
      // Handle autoscroll when target is at the edges of the scroll bounds
      const s = this.scrollSpeed * 10;
      const threshold = this.scrollThreshold;
      const [ x, y ] = this.coords;
      const [ st, sr, sb, sl ] = this.scrollBounds;
      const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);
      const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);
      const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);
      const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);
      if (t || b || l || r) {
        const [nx, ny] = this.disabled;
        let scrollX = csx;
        let scrollY = csy;
        if (!nx) {
          scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);
          this.coords[0] -= csx - scrollX;
        }
        if (!ny) {
          scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);
          this.coords[1] -= csy - scrollY;
        }
        // Note: Safari mobile requires to use different scroll methods depending if using the window or not
        if (this.useWin) {
          this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));
        } else {
          this.$scrollContainer.scrollTo(scrollX, scrollY);
        }
      }
    }
    const [ ct, cr, cb, cl ] = this.containerBounds;
    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;
    this.coords[0] += (px1 - px3) * this.dragSpeed;
    this.coords[1] += (py1 - py3) * this.dragSpeed;
    this.pointer[4] = px1;
    this.pointer[5] = py1;
    const [ cx, cy ] = this.coords;
    const [ sx, sy ] = this.snapped;
    const cf = (1 - this.containerFriction) * this.dragSpeed;
    this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);
    this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);
    this.computeVelocity(px1 - px3, py1 - py3);
    this.angle = atan2(py1 - py2, px1 - px2);
    const [ nsx, nsy ] = this.snapped;
    if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {
      this.onSnap(this);
    }
  }

  stop() {
    this.updateTicker.pause();
    this.overshootTicker.pause();
    // Pauses the in bounds onRelease animations
    for (let prop in this.animate.animations) this.animate.animations[prop].pause();
    removeTargetsFromRenderable([this], null, 'x');
    removeTargetsFromRenderable([this], null, 'y');
    removeTargetsFromRenderable([this], null, 'progressX');
    removeTargetsFromRenderable([this], null, 'progressY');
    removeTargetsFromRenderable([this.scroll]); // Removes any active animations on the container scroll
    removeTargetsFromRenderable([this.overshootCoords]); // Removes active overshoot animations
    return this;
  }

  /**
   * @param {Number} [duration]
   * @param {Number} [gap]
   * @param {EasingParam} [ease]
   * @return {this}
   */
  scrollInView(duration, gap = 0, ease = eases.inOutQuad) {
    this.updateScrollCoords();
    const x = this.destX;
    const y = this.destY;
    const scroll = this.scroll;
    const scrollBounds = this.scrollBounds;
    const canScroll = this.canScroll;
    if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {
      const [ st, sr, sb, sl ] = scrollBounds;
      const t = round(clamp(y - st, -maxValue, 0), 0);
      const r = round(clamp(x - sr, 0, maxValue), 0);
      const b = round(clamp(y - sb, 0, maxValue), 0);
      const l = round(clamp(x - sl, -maxValue, 0), 0);
      new JSAnimation(scroll, {
        x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),
        y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),
        duration: isUnd(duration) ? 350 * globals.timeScale : duration,
        ease,
        onUpdate: () => {
          this.canScroll = false;
          this.$scrollContainer.scrollTo(scroll.x, scroll.y);
        }
      }).init().then(() => {
        this.canScroll = canScroll;
      })
    }
    return this;
  }

  handleHover() {
    if (this.isFinePointer && this.cursor && !this.cursorStyles) {
      this.cursorStyles = set(this.$trigger, {
        cursor: /** @type {DraggableCursorParams} */(this.cursor).onHover
      });
    }
  }

  /**
   * @param  {Number} [duration]
   * @param  {Number} [gap]
   * @param  {EasingParam} [ease]
   * @return {this}
   */
  animateInView(duration, gap = 0, ease = eases.inOutQuad) {
    this.stop();
    this.updateBoundingValues();
    const x = this.x;
    const y = this.y;
    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
    const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;
    const br = this.scroll.x - this.targetBounds[1] - cpr - gap;
    const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;
    const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;
    const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);
    if (ob) {
      const [ disabledX, disabledY ] = this.disabled;
      const destX = clamp(snap(x, this.snapX), bl, br);
      const destY = clamp(snap(y, this.snapY), bt, bb);
      const dur = isUnd(duration) ? 350 * globals.timeScale : duration;
      if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);
      if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);
    }
    return this;
  }

  /**
   * @param {MouseEvent|TouchEvent} e
   */
  handleDown(e) {
    const $eTarget = /** @type {HTMLElement} */(e.target);
    if (this.grabbed || /** @type {HTMLInputElement} */($eTarget).type === 'range') return;

    e.stopPropagation();

    this.grabbed = true;
    this.released = false;
    this.stop();
    this.updateBoundingValues();
    const touches = /** @type {TouchEvent} */(e).changedTouches;
    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;
    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;
    const { x, y } = this.transforms.normalizePoint(eventX, eventY);
    const [ ct, cr, cb, cl ] = this.containerBounds;
    const cf = (1 - this.containerFriction) * this.dragSpeed;
    const cx = this.x;
    const cy = this.y;
    this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;
    this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;
    this.pointer[0] = x;
    this.pointer[1] = y;
    this.pointer[2] = x;
    this.pointer[3] = y;
    this.pointer[4] = x;
    this.pointer[5] = y;
    this.pointer[6] = x;
    this.pointer[7] = y;
    this.deltaX = 0;
    this.deltaY = 0;
    this.velocity = 0;
    this.velocityStack[0] = 0;
    this.velocityStack[1] = 0;
    this.velocityStack[2] = 0;
    this.velocityStackIndex = 0;
    this.angle = 0;
    if (this.targetStyles) {
      this.targetStyles.revert();
      this.targetStyles = null;
    }
    const z = /** @type {Number} */(get(this.$target, 'zIndex', false));
    zIndex = (z > zIndex ? z : zIndex) + 1;
    this.targetStyles = set(this.$target, { zIndex });
    if (this.triggerStyles) {
      this.triggerStyles.revert();
      this.triggerStyles = null;
    }
    if (this.cursorStyles) {
      this.cursorStyles.revert();
      this.cursorStyles = null;
    }
    if (this.isFinePointer && this.cursor) {
      this.bodyStyles = set(doc.body, {
        cursor: /** @type {DraggableCursorParams} */(this.cursor).onGrab
      });
    }
    this.scrollInView(100, 0, eases.out(3));
    this.onGrab(this);

    doc.addEventListener('touchmove', this);
    doc.addEventListener('touchend', this);
    doc.addEventListener('touchcancel', this);
    doc.addEventListener('mousemove', this);
    doc.addEventListener('mouseup', this);
    doc.addEventListener('selectstart', this);
  }

  /**
   * @param {MouseEvent|TouchEvent} e
   */
  handleMove(e) {
    if (!this.grabbed) return;
    const touches = /** @type {TouchEvent} */(e).changedTouches;
    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;
    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;
    const { x, y } = this.transforms.normalizePoint(eventX, eventY)
    const movedX = x - this.pointer[6];
    const movedY = y - this.pointer[7];

    let $parent = /** @type {HTMLElement} */(e.target);
    let isAtTop = false;
    let isAtBottom = false;
    let canTouchScroll = false;

    while (touches && $parent && $parent !== this.$trigger) {
      const overflowY = get($parent, 'overflow-y');
      if (overflowY !== 'hidden' && overflowY !== 'visible') {
        const { scrollTop, scrollHeight, clientHeight } = $parent;
        if (scrollHeight > clientHeight) {
          canTouchScroll = true;
          isAtTop = scrollTop <= 3;
          isAtBottom = scrollTop >= (scrollHeight - clientHeight) - 3;
          break;
        }
      }
      $parent = $parent.parentElement;
    }

    if (canTouchScroll && ((!isAtTop && !isAtBottom) || (isAtTop && movedY < 0) || (isAtBottom && movedY > 0))) {

      this.pointer[0] = x;
      this.pointer[1] = y;
      this.pointer[2] = x;
      this.pointer[3] = y;
      this.pointer[4] = x;
      this.pointer[5] = y;
      this.pointer[6] = x;
      this.pointer[7] = y;

    } else {

      preventDefault(e);

      // Needed to prevents click on handleUp
      if (!this.triggerStyles) this.triggerStyles = set(this.$trigger, { pointerEvents: 'none' });
      // Needed to prevent page scroll while dragging on touch devvice
      this.$trigger.addEventListener('touchstart', preventDefault, { passive: false });
      this.$trigger.addEventListener('touchmove', preventDefault, { passive: false });
      this.$trigger.addEventListener('touchend', preventDefault);

      // Don't check for a miminim distance move if already dragging
      if (this.dragged || (!this.disabled[0] && abs(movedX) > this.dragThreshold) || (!this.disabled[1] && abs(movedY) > this.dragThreshold)) {
        this.updateTicker.resume();
        this.pointer[2] = this.pointer[0];
        this.pointer[3] = this.pointer[1];
        this.pointer[0] = x;
        this.pointer[1] = y;
        this.dragged = true;
        this.released = false;
        this.onDrag(this);
      }
    }
  }

  handleUp() {

    if (!this.grabbed) return;

    this.updateTicker.pause();

    if (this.triggerStyles) {
      this.triggerStyles.revert();
      this.triggerStyles = null;
    }

    if (this.bodyStyles) {
      this.bodyStyles.revert();
      this.bodyStyles = null;
    }

    const [ disabledX, disabledY ] = this.disabled;
    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;
    const [ ct, cr, cb, cl ] = this.containerBounds;
    const [ sx, sy ] = this.snapped;
    const springX = this.releaseXSpring;
    const springY = this.releaseYSpring;
    const releaseEase = this.releaseEase;
    const hasReleaseSpring = this.hasReleaseSpring;
    const overshootCoords = this.overshootCoords;
    const cx = this.x;
    const cy = this.y;
    const pv = this.computeVelocity(px1 - px3, py1 - py3);
    const pa = this.angle = atan2(py1 - py2, px1 - px2);
    const ds = pv * 150;
    const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;
    const nx = cx + (cos(pa) * ds);
    const ny = cy + (sin(pa) * ds);
    const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;
    const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;
    const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);
    const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);
    const ob = this.isOutOfBounds(this.containerBounds, nx, ny);

    let durationX = 0;
    let durationY = 0;
    let easeX = releaseEase;
    let easeY = releaseEase;
    let longestReleaseDuration = 0;

    overshootCoords.x = cx;
    overshootCoords.y = cy;

    if (!disabledX) {
      const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;
      const distanceX = round(cx - dx, 0);
      springX.velocity = disabledY && hasReleaseSpring ? distanceX ? (ds * directionX) / abs(distanceX) : 0 : pv;
      const { ease, settlingDuration, restDuration } = springX;
      durationX = cx === dx ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - (restDuration * globals.timeScale);
      if (hasReleaseSpring) easeX = ease;
      if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;
    }

    if (!disabledY) {
      const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;
      const distanceY = round(cy - dy, 0);
      springY.velocity = disabledX && hasReleaseSpring ? distanceY ? (ds * directionY) / abs(distanceY) : 0 : pv;
      const { ease, settlingDuration, restDuration } = springY;
      durationY = cy === dy ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - (restDuration * globals.timeScale);
      if (hasReleaseSpring) easeY = ease;
      if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;
    }

    if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {

        const composition = compositionTypes.blend;

        new JSAnimation(overshootCoords, {
          x: { to: bx, duration: durationX * .65 },
          y: { to: by, duration: durationY * .65 },
          ease: releaseEase,
          composition,
        }).init();

        new JSAnimation(overshootCoords, {
          x: { to: dx, duration: durationX },
          y: { to: dy, duration: durationY },
          ease: releaseEase,
          composition,
        }).init();

        this.overshootTicker.stretch(max(durationX, durationY)).restart();

    } else {

      if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);
      if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);

    }

    this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);

    let hasSnapped = false;

    if (dx !== sx) {
      this.snapped[0] = dx;
      if (this.snapX) hasSnapped = true;
    }

    if (dy !== sy && this.snapY) {
      this.snapped[1] = dy;
      if (this.snapY) hasSnapped = true;
    }

    if (hasSnapped) this.onSnap(this);

    this.grabbed = false;
    this.dragged = false;
    this.updated = true;
    this.released = true;

    // It's important to trigger the callback after the release animations to be able to cancel them
    this.onRelease(this);

    this.$trigger.removeEventListener('touchstart', preventDefault);
    this.$trigger.removeEventListener('touchmove', preventDefault);
    this.$trigger.removeEventListener('touchend', preventDefault);

    doc.removeEventListener('touchmove', this);
    doc.removeEventListener('touchend', this);
    doc.removeEventListener('touchcancel', this);
    doc.removeEventListener('mousemove', this);
    doc.removeEventListener('mouseup', this);
    doc.removeEventListener('selectstart', this);
  }

  reset() {
    this.stop();
    this.resizeTicker.pause();
    this.grabbed = false;
    this.dragged = false;
    this.updated = false;
    this.released = false;
    this.canScroll = false;
    this.setX(0, true);
    this.setY(0, true);
    this.coords[0] = 0;
    this.coords[1] = 0;
    this.pointer[0] = 0;
    this.pointer[1] = 0;
    this.pointer[2] = 0;
    this.pointer[3] = 0;
    this.pointer[4] = 0;
    this.pointer[5] = 0;
    this.pointer[6] = 0;
    this.pointer[7] = 0;
    this.velocity = 0;
    this.velocityStack[0] = 0;
    this.velocityStack[1] = 0;
    this.velocityStack[2] = 0;
    this.velocityStackIndex = 0;
    this.angle = 0;
    return this;
  }

  enable() {
    if (!this.enabled) {
      this.enabled = true;
      this.$target.classList.remove('is-disabled');
      this.touchActionStyles = set(this.$trigger, {
        touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'
      });
      this.$trigger.addEventListener('touchstart', this, { passive: true });
      this.$trigger.addEventListener('mousedown', this, { passive: true });
      this.$trigger.addEventListener('mouseenter', this);
    }
    return this;
  }

  disable() {
    this.enabled = false;
    this.grabbed = false;
    this.dragged = false;
    this.updated = false;
    this.released = false;
    this.canScroll = false;
    this.touchActionStyles.revert();
    if (this.cursorStyles) {
      this.cursorStyles.revert();
      this.cursorStyles = null;
    }
    if (this.triggerStyles) {
      this.triggerStyles.revert();
      this.triggerStyles = null;
    }
    if (this.bodyStyles) {
      this.bodyStyles.revert();
      this.bodyStyles = null;
    }
    if (this.targetStyles) {
      this.targetStyles.revert();
      this.targetStyles = null;
    }
    this.$target.classList.add('is-disabled');
    this.$trigger.removeEventListener('touchstart', this);
    this.$trigger.removeEventListener('mousedown', this);
    this.$trigger.removeEventListener('mouseenter', this);
    doc.removeEventListener('touchmove', this);
    doc.removeEventListener('touchend', this);
    doc.removeEventListener('touchcancel', this);
    doc.removeEventListener('mousemove', this);
    doc.removeEventListener('mouseup', this);
    doc.removeEventListener('selectstart', this);
    return this;
  }

  revert() {
    this.reset();
    this.disable();
    this.$target.classList.remove('is-disabled');
    this.updateTicker.revert();
    this.overshootTicker.revert();
    this.resizeTicker.revert();
    this.animate.revert();
    this.resizeObserver.disconnect();
    return this;
  }

  /**
   * @param {Event} e
   */
  handleEvent(e) {
    switch (e.type) {
      case 'mousedown':
        this.handleDown(/** @type {MouseEvent} */(e));
        break;
      case 'touchstart':
        this.handleDown(/** @type {TouchEvent} */(e));
        break;
      case 'mousemove':
        this.handleMove(/** @type {MouseEvent} */(e));
        break;
      case 'touchmove':
        this.handleMove(/** @type {TouchEvent} */(e));
        break;
      case 'mouseup':
        this.handleUp();
        break;
      case 'touchend':
        this.handleUp();
        break;
      case 'touchcancel':
        this.handleUp();
        break;
      case 'mouseenter':
        this.handleHover();
        break;
      case 'selectstart':
        preventDefault(e);
        break;
    }
  }
}

/**
 * @param {TargetsParam} target
 * @param {DraggableParams} [parameters]
 * @return {Draggable}
 */
export const createDraggable = (target, parameters) => new Draggable(target, parameters);


--- tests/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Anime.js tests</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../node_modules/mocha/mocha.css" />
    <link rel="icon" href="./assets/favicon.png?v=5">
    <style>
      @font-face {
        font-family: "Altinn";
        src: url(./assets/Altinn-DINExp.woff2) format("woff2");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }
      :root {
        --color-white: #F6F4F2; /* White */
        --color-black: #2E2C2C; /* Black */
        --color-red: #FF4B4B;/* red: */
        --color-orange: #FF8F42;/* orange: */
        --color-lightorange: #FFC730;/* lightorange: */
        --color-yellow: #F6FF56;/* yellow: */
        --color-citrus: #A4FF4F;/* citrus: */
        --color-green: #18FF74;/* green: */
        --color-darkgreen: #00D672;/* darkgreen: */
        --color-turquoise: #3CFFEC;/* turquoise: */
        --color-blue: #61C3FF;/* blue: */
        --color-kingblue: #5A87FF;/* kingblue: */
        --color-lavender: #8453E3;/* lavender: */
        --color-purple: #C26EFF;/* purple: */
        --color-pink: #FB89FB;/* pink: */
        --width: 100px;
        --mocha-test-pass-color: var(--color-green);
        --mocha-test-fail-color: var(--color-red);
        --mocha-stats-em-color: var(--color-white);
      }
      *, *:before, *:after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        border: 0;
      }
      html,
      body {
        font-family: "Altinn";
        font-size: 16px;
        background-color: var(--color-black);
        color: var(--color-white);
      }
      body {
        padding-top: 40px;
      }
      /* Mocha styles */
      #open-in-popup {
        position: fixed;
        top: 0;
        right: 0;
        z-index: 1;
        width: 40px;
        height: 40px;
        background-color: transparent;
        color: var(--color-white);
        border-radius: 50%;
        cursor: pointer;
        opacity: .65;
      }
      #open-in-popup:before,
      #open-in-popup:after {
        content: "";
        position: absolute;
        width: 12px;
        height: 12px;
        border: 1px solid var(--color-white);
      }
      #open-in-popup:before {
        left: 12px;
        top: 14px;
      }
      #open-in-popup:after {
        left: 16px;
        top: 10px;
      }
      #open-in-popup:hover {
        opacity: 1;
      }
      #mocha {
        font-family: inherit;
        position: relative;
        right: 0;
        z-index: 1;
        width: 100%;
        margin: 0 0 0 auto;
        padding: 0 1rem 1rem 1rem;
      }
      #mocha em {
        font-style: normal;
      }
      #mocha-stats {
        top: 0;
        left: 0;
        right: 0;
        width: 100%;
        padding: 9px 44px 10px 10px!important;
        background-color: var(--color-black);
      }
      #mocha-stats .progress-contain {
        float: none;
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
      }
      #mocha-stats .progress-element {
        visibility: visible;
        top: 0;
        left: 0;
        width: 100%;
        height: 1px;
        color: var(--color-white);
        accent-color: currentColor;
        background-color: rgba(255,255,255, .1);
      }
      #mocha-stats.pass .progress-element,
      #mocha-stats.pass .progress-text {
        color: var(--color-green);
      }
      #mocha-stats.fail .progress-element,
      #mocha-stats.fail .progress-text {
        color: var(--color-red);
      }
      #mocha-stats .progress-element::-webkit-progress-bar {
        background: transparent;
      }
      #mocha-stats .progress-element::-webkit-progress-value {
        background: currentColor;
      }
      #mocha-stats .progress-ring {
        display: none;
      }
      #mocha-stats .progress-text {
        position: absolute;
        right: 39px;
        top: -27px;
      }
      #mocha-stats li {
        padding: 0 10px 0 0;
        margin: 0;
      }
      #mocha-stats li.result {
        color: var(--mocha-test-pass-color);
        position: absolute;
        right: 90px;
        padding: 0;
      }
      #mocha .suite {
        margin-left: 0;
      }
      #mocha .test {
        margin-left: 0;
      }
      #mocha .suite h1 {
        margin-top: 15px;
        margin-bottom: 5px;
        font-size: 1rem;
        text-transform: uppercase;
      }
      #mocha .test h2 {
        padding-right: 20px;
        padding-left: 14px;
      }
      #mocha .test.fail pre,
      #mocha-stats .duration em { color: var(--color-white); }
      #mocha-stats .passes em,
      #mocha .test.pass::before { color: var(--color-green); }
      #mocha .test.pass.medium .duration { background: var(--color-citrus); color: var(--color-black); }
      #mocha-stats .failures em,
      #mocha .test.fail,
      #mocha .test pre.error,
      #mocha .test.fail::before { color: var(--color-red); }
      #mocha .test.pass.slow .duration { background: var(--color-red); }
      #mocha .test a.replay { color: var(--color-black); }
      #mocha .test pre {
        box-shadow: none;
        padding: 8px 12px;
        background-color: rgba(0,0,0,.2);
        border: 1px solid rgba(0,0,0,.2);
        border-radius: 3px;
        width: 100%;
        max-width: 100%;
        margin-left: 0px;
        margin-right: 0px;
      }
      /* Tests specific styles */
      #tests {
        opacity: .0001;
        position: absolute;
        display: flex;
        flex-wrap: wrap;
        z-index: 0;
        left: 0;
        top: 0;
        width: 100%;
        padding: 10px;
      }
      #tests .target-class {
        width: 1rem;
        height: 1rem;
        background-color: var(--color-darkgreen);
        border: 1px solid var(--color-black);
      }
      #tests .css-properties,
      #tests .with-inline-transforms {
        width: 150px;
        height: 1rem;
        font-size: 2rem;
        background-color: var(--color-citrus);
        border: 1px solid var(--color-black);
      }
      #tests .test {
        position: relative;
        width: 100%;
        margin: .5rem;
        border: 1px solid var(--color-darkgreen);
      }
      #tests .small-test {
        width: calc(50% - 1rem);
      }
      #tests svg {
        position: relative;
        width: 100%;
      }
      #tests svg path {
        stroke-linecap: round;
      }
      #tests img {
        vertical-align: middle;
      }
      #input-number {
        font-size: 2rem;
        vertical-align: middle;
        background: transparent;
        border: none;
        color: var(--color-citrus);
      }
      #tests #square {
        position: absolute;
        left: 0;
        top: 0;
        width: 1rem;
        height: 1rem;
        margin-left: -.5rem;
        margin-top: -.5rem;
        background-color: white;
      }
      #tests #stagger div {
        width: 1rem;
        height: 1rem;
        background-color: var(--color-citrus);
        border: 1px solid var(--color-black);
      }
      #tests #grid {
        display: flex;
        flex-wrap: wrap;
      }
      #tests #grid div {
        width: 20%;
        height: 1.675rem;
        background-color: var(--color-darkgreen);
        border: 1px solid var(--color-black);
      }
      @media (min-width: 600px) {
        #mocha,
        #tests {
          width: 50%;
        }
        #tests {
          opacity: 1;
          top: 40px;
        }
      }
   </style>
  </head>
  <body>
    <div id="tests"></div>
    <div id="mocha"></div>
    <button id="open-in-popup"></button>
    <script src="../dist/bundles/anime.umd.min.js"></script>
    <script type="module" src="../tests/setup.js"></script>
    <script type="module" src="../tests/run.js"></script>
    <script type="text/javascript">
      const popupWindowTitle = 'Anime.js tests terminal';
      const openInPopupButtonEl = document.querySelector('#open-in-popup');
      if (window.document.title === popupWindowTitle) {
        openInPopupButtonEl.style.display = 'none';
      } else {
        openInPopupButtonEl.onclick = () => { window.open(location.href, popupWindowTitle, 'width=478,height=592,top=0,left=0'); }
      }
    </script>
  </body>
</html>


--- tests/playground/keyframes/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Keyframes</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>

    :root {
      --test: 2em;
      --from: calc(100px - var(--test));
      --to: calc(100px + var(--test));
    }

    body {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .playground {
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
    }

    .square {
      --d: 4rem;
      position: relative;
      width: var(--d);
      height: var(--d);
      margin-top: calc(var(--d) * -.5);
      margin-left: calc(var(--d) * -.5);
      border-radius: calc(var(--d) * .125);
      margin: 2px;
      cursor: pointer;
      font-size: 100px;
    }

    @keyframes css {
      0%   { left: 0rem; top: 0rem; }
      30%  { left: 0rem; top: -2.5rem; rotate: 45deg; animation-timing-function: ease-out }
      40%  { left: 17rem; top: -2.5rem; }
      50%  { left: 17rem; top: 2.5rem; rotate: 90deg; }
      70%  { left: 0rem; top: 2.5rem; }
      100% { left: 0rem; top: 0rem; rotate: 180deg; }
    }

    .css {
      background-color: var(--yellow);
    }

    .css.is-animated {
      animation: css 4s linear forwards infinite;
    }

    .waapi {
      background-color: var(--orange-1);
    }

    .anime {
      background-color: var(--red);
    }
  </style>
</head>
<body>
  <div class="playground">
    <div class="square css"></div>
    <div class="square waapi"></div>
    <div class="square anime"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/layout/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Layout tests / anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      width: 100%;
      min-height: 100lvh;
      padding-bottom: 28rem;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      position: sticky;
      z-index: 1000;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      padding: .5rem;
      background-color: var(--bg-1);
      border-bottom: 1px solid var(--bg-4);
    }
    #controls button {
      width: 20%;
      flex-grow: 1;
      flex-shrink: 0;
      height: 4ch;
      min-width: 0;
      margin: .5ch;
      background-color: var(--fg-1);
      color: var(--bg-2);
    }
    #controls button.is-active {
      background-color: var(--fg-1);
      color: var(--bg-3);
    }
    .tests {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      width: 100%;
    }
    .test {
      position: relative;
      display: flex;
      align-items: stretch;
      justify-content: center;
      flex-direction: column;
      width: 100%;
      border: 1px solid var(--white-5);
      margin-right: -1px;
      margin-top: -1px;
      padding: 3rem 1rem 1rem 1rem;
      background: var(--bg-1);
    }
    @media (min-width: 740px) {
      .test {
        width: 50%;
      }
      .double-container {
        width: 100%;
      }
    }
    @media (min-width: 1024px) {
      .test {
        width: 33.333333%;
      }
      .double-container {
        width: 100%;
      }
    }
    @media (min-width: 1600px) {
      .test {
        width: 25%;
      }
      .double-container {
        width: 50%;
      }
    }
    .test-header {
      overflow: hidden;
      display: flex;
      justify-content: space-between;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: .5rem;
    }
    .test-header button {
      padding: 0 .5rem;
    }
    .fixed-height{
      height: 18rem;
    }
    .demo {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      container-type: inline-size;
      padding: 0;
      width: 100%;
    }
    .demo:has(.sticky) {
      align-items: flex-start;
      height: 100%;
    }
    .container {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: nowrap;
      top: 1.5rem;
      gap: .5rem;
      padding: .5rem;
      width: 100cqw;
      margin-left: 1rem;
      margin-right: 1rem;
      background-color: var(--bg-2);
      border: 1px dotted var(--white-2);
    }
    .double-container .container {
      width: 50cqw;
      margin-left: 0rem;
      margin-right: 0rem;
    }
    .display-none {
      display: none;
    }
    .relative {
      position: relative;
      top: 0rem;
    }
    .static {
      position: static;
      top: 2.5rem;
    }
    .absolute {
      position: absolute;
      top: 2.5rem;
    }
    .fixed {
      position: fixed;
      top: auto;
      bottom: 0;
    }
    .sticky {
      position: sticky;
      top: 3.5rem;
    }
    .vertical {
      flex-direction: column;
    }
    .vertical.reverse {
      flex-direction: column-reverse;
    }
    .horizontal {
      flex-direction: row;
    }
    .target-container .child {
      display: none;
    }
    .child {
      border: 1px dashed var(--white-3);
      width: 100%;
      padding: .5rem;
      border-radius: 1rem;
      background-color: var(--bg-4);
      transition: all 1s ease-out;
    }
    .child > span {
      background: var(--white-2);
      color: var(--bg-2);
    }
    .sub-child {
      border: 1px solid var(--white-4);
      margin-top: .5rem;
      padding: .5rem;
      border-radius: .5rem;
      background-color: var(--bg-5);
    }
    .sub-child > span {
      background: var(--white-2);
      color: var(--bg-2);
    }
    #layout-id .child-b,
    #layout-id .vertical .child-a {
      visibility: hidden;
    }
    #layout-id .vertical .child-b {
      visibility: visible;
    }
    #simple-fixed-root {
      position: relative;
      z-index: 10;
    }
    #specific-properties .vertical .child {
      color: var(--red-1);
      border-radius: .5rem;
    }
    #specific-properties .vertical .child > span {
      background-color: var(--red-1);
    }
    #specific-properties .vertical .sub-child {
      color: var(--orange-1);
      border-radius: .25rem;
    }
    #specific-properties .vertical .sub-child > span {
      background-color: var(--orange-1);
    }
    #simple-fixed-root {
      position: fixed;
      z-index: 11;
      bottom: 0;
      right: 0;
      height: 14rem;
    }
    #swap-outside-fixed-root {
      z-index: 10;
    }
    #swap-outside-fixed-root .container-b {
      position: fixed;
      top: inherit;
      bottom: 2rem;
      left: 2rem;
      background: transparent;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="animate-all">animate all</button>
    <button id="revert-all">revert all</button>
  </div>
  <div class="tests">

    <div id="simple-absolute-root" class="test fixed-height">
      <div class="test-header">
        <h2>Simple absolute root</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container absolute vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>

    <div id="simple-sticky-root" class="test fixed-height">
      <div class="test-header">
        <h2>Simple sticky root</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container sticky vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>

    <div id="simple-fixed-root" class="test fixed-height">
      <div class="test-header">
        <h2>Simple fixed root</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container fixed vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>

    <div id="simple-relative-root" class="test fixed-height">
      <div class="test-header">
        <h2>Simple relative root</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container relative vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>

    <div id="simple-static-root" class="test fixed-height">
      <div class="test-header">
        <h2>Simple static root</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container static vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="specific-children" class="test fixed-height">
      <div class="test-header">
        <h2>Specific children</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="specific-properties" class="test fixed-height">
      <div class="test-header">
        <h2>Specific properties</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="hide-display-none" class="test fixed-height">
      <div class="test-header">
        <h2>Remove with "display: none"</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="hide-visibility-hidden" class="test fixed-height">
      <div class="test-header">
        <h2>Remove with "visibility: hidden"</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="frozen-properties" class="test fixed-height">
      <div class="test-header">
        <h2>Custom frozen properties</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="removed-properties" class="test fixed-height">
      <div class="test-header">
        <h2>Custom removed properties</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="added-properties" class="test fixed-height">
      <div class="test-header">
        <h2>Added properties</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="custom-timings" class="test fixed-height">
      <div class="test-header">
        <h2>Custom timings</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="spring-ease" class="test fixed-height">
      <div class="test-header">
        <h2>Spring ease</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="layout-id" class="test fixed-height">
      <div class="test-header">
        <h2>Swap elements with id</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child child-a" data-layout-id="test-id-1">A direct <span data-layout-id="test-id-2">child</span> element. <div class="sub-child" data-layout-id="test-id-3"> And a <span data-layout-id="test-id-4">sub child</span> element</div></div>
          <div class="child child-b" data-layout-id="test-id-1">A direct <span data-layout-id="test-id-2">child</span> element. <div class="sub-child" data-layout-id="test-id-3"> And a <span data-layout-id="test-id-4">sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="swap-outside-fixed-root" class="test fixed-height">
      <div class="test-header">
        <h2>Swap element outside fixed root</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container container-a">
          <div class="child" data-layout-id="c">A direct <span data-layout-id="c-1">child</span> element. <div class="sub-child" data-layout-id="c-2"> And a <span data-layout-id="c-3">sub child</span> element</div></div>
          <div class="child" data-layout-id="d">A direct <span data-layout-id="d-1">child</span> element. <div class="sub-child" data-layout-id="d-2"> And a <span data-layout-id="d-3">sub child</span> element</div></div>
        </div>
        <div class="container container-b target-container">
          <div class="child" data-layout-id="c">A direct <span data-layout-id="c-1">child</span> element. <div class="sub-child" data-layout-id="c-2"> And a <span data-layout-id="c-3">sub child</span> element</div></div>
          <div class="child" data-layout-id="d">A direct <span data-layout-id="d-1">child</span> element. <div class="sub-child" data-layout-id="d-2"> And a <span data-layout-id="d-3">sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="stagger-timings" class="test fixed-height">
      <div class="test-header">
        <h2>Stagger timings</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical reverse">
          <div class="child child-animated"><div>anim</div></div>
          <div class="child child-removed"><div>rem</div></div>
          <div class="child child-added" style="display: none"><div>add</div></div>
          <div class="child child-animated"><div>anim</div></div>
          <div class="child child-removed"><div>rem</div></div>
          <div class="child child-added" style="display: none"><div>add</div></div>
          <div class="child child-animated"><div>anim</div></div>
          <div class="child child-removed"><div>rem</div></div>
          <div class="child child-added" style="display: none"><div>add</div></div>
        </div>
      </div>
    </div>
    <div id="stagger-values" class="test fixed-height">
      <div class="test-header">
        <h2>Stagger values</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical reverse">
          <div class="child child-animated"><div>anim</div></div>
          <div class="child child-removed"><div>rem</div></div>
          <div class="child child-added" style="display: none"><div>add</div></div>
          <div class="child child-animated"><div>anim</div></div>
          <div class="child child-removed"><div>rem</div></div>
          <div class="child child-added" style="display: none"><div>add</div></div>
          <div class="child child-animated"><div>anim</div></div>
          <div class="child child-removed"><div>rem</div></div>
          <div class="child child-added" style="display: none"><div>add</div></div>
        </div>
      </div>
    </div>
    <div id="transformed-parent" class="test fixed-height">
      <div class="test-header">
        <h2>Transformed parent</h2>
        <button>Animate</button>
      </div>
      <div class="demo" style="transform: rotate(20deg) scale(.87); perspective: 1000px;">
        <div class="container vertical reverse" style="transform: rotateX(-40deg); transform-style: preserve-3d;">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
      </div>
    </div>
    <div id="swap-inside-root" class="test fixed-height double-container">
      <div class="test-header">
        <h2>Swap element inside root</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container vertical">
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
          <div class="child">A direct <span>child</span> element. <div class="sub-child"> And a <span>sub child</span> element</div></div>
        </div>
        <div class="container vertical"></div>
      </div>
    </div>
    <div id="swap-outside-root" class="test fixed-height double-container">
      <div class="test-header">
        <h2>Swap element outside root</h2>
        <button>Animate</button>
      </div>
      <div class="demo">
        <div class="container container-a">
          <div class="child" data-layout-id="a">A direct <span data-layout-id="a-1">child</span> element. <div class="sub-child" data-layout-id="a-2"> And a <span data-layout-id="a-3">sub child</span> element</div></div>
          <div class="child" data-layout-id="b">A direct <span data-layout-id="b-1">child</span> element. <div class="sub-child" data-layout-id="b-2"> And a <span data-layout-id="b-3">sub child</span> element</div></div>
        </div>
        <div class="container container-b target-container">
          <div class="child" data-layout-id="a">A direct <span data-layout-id="a-1">child</span> element. <div class="sub-child" data-layout-id="a-2"> And a <span data-layout-id="a-3">sub child</span> element</div></div>
          <div class="child" data-layout-id="b">A direct <span data-layout-id="b-1">child</span> element. <div class="sub-child" data-layout-id="b-2"> And a <span data-layout-id="b-3">sub child</span> element</div></div>
        </div>
      </div>
    </div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/lerp/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Lerp tests / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      flex-direction: column;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: .5rem;
      padding: 1rem;
    }

    .square {
      width: 100px;
      height: 100px;
      background: var(--red);
      border-radius: 1rem;
      padding: 1rem;
    }

    .button {
      border-radius: 1rem;
      padding: 1rem;
    }

  </style>
</head>
<body>
  <div class="container">
    <h2>input</h2>
    <div class="square input"></div>
  </div>
  <div class="container">
    <h2>lerped</h2>
    <div class="square lerped"></div>
  </div>
  <div class="container">
    <h2>damped</h2>
    <div class="square damped"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/playback/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Playback tests / anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    #animation {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      max-width: 32rem;
    }
    .square {
      position: relative;
      width: 5rem;
      height: 5rem;
      background-color: currentColor;
    }
    #controls-panel {
      position: fixed;
      top: 2rem;
      left: 2rem;
    }
  </style>
</head>
<body>
  <div id="controls-panel">
    <fieldset>
      <legend>Engine</legend>
      <label for="engine-frameRate">Frame rate</label>
      <input type="range" id="engine-frameRate" name="engine-frameRate" value="60" min="0" max="120" step="1">
      <input type="text" id="engine-fps" value="60">
      <br>
      <label for="engine-playbackRate">Playback rate</label>
      <input type="range" id="engine-playbackRate" name="engine-playbackRate" value="1" min="0" max="2" step=".0001">
      <input type="text" id="engine-speed" value="1">
      <br>
    </fieldset>
    <fieldset>
      <legend>Animation</legend>
      <label for="animation-frameRate">Frame rate</label>
      <input type="range" id="animation-frameRate" name="animation-frameRate" value="60" min="0" max="120" step="1">
      <input type="text" id="animation-fps" value="60">
      <br>
      <label for="animation-playbackRate">Playback rate</label>
      <input type="range" id="animation-playbackRate" name="animation-playbackRate" value="1" min="0" max="2" step=".01">
      <input type="text" id="animation-speed" value="1">
      <br>
      <label for="animation-time-drift">Time drift</label>
      <input type="text" id="animation-time-drift" value="0">
      <br>
      <label for="animation-reversed">Reversed</label>
      <input type="text" id="animation-reversed" value="false">
      <br>
    </fieldset>
  </div>
  <div id="animation">
    <div class="square red"></div>
    <div class="square red"></div>
    <div class="square red"></div>
    <div class="square red"></div>
    <div class="square red"></div>
    <div class="square red"></div>
    <div class="square red"></div>
    <div class="square red"></div>
    <div class="square red"></div>
    <div class="square red"></div>
    <div class="square red"></div>
  </div>
  <fieldset>
    <label for="animation-currentTime">Current time</label>
    <input type="range" id="animation-progress" name="animation-progress" value="0" min="0" max="1" step=".0001">
    <input type="text" id="animation-currentTime" value="0">
    <input type="button" id="animation-play" value="play">
    <input type="button" id="animation-reverse" value="reverse">
    <input type="button" id="animation-resume" value="resume">
    <input type="button" id="animation-alternate" value="alternate">
    <input type="button" id="animation-pause" value="pause">
  </fieldset>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/sandbox/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Sandbox / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body{
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      height: 100lvh;
      background: black;
    }

    div {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 300px;
      height: 100px;
      background: red;
      font-size: 64px;
    }

    @keyframes x-animation {
      to { margin-left: 90%; }
    }

    .css.animate {
      animation: x-animation 1s linear forwards infinite;
    }
  </style>
</head>
<body>
  <div class="css">css</div>
  <div class="anim">anime.js</div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/scope/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Scope / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      flex-direction: column;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: .5rem;
      padding: 1rem;
    }

    .square {
      width: 100px;
      height: 100px;
      background: var(--red);
      border-radius: 1rem;
      padding: 1rem;
    }

  </style>
</head>
<body>
  <div class="container">
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
  </div>
  <div class="container scoped">
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
  </div>
  <div class="container">
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/svg-motion-path/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>SVG motion path responsive tests / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    h2 {
      margin-bottom: 20px;
    }
    .container {
      position: relative;
      margin-bottom: 20px;
    }
    .container > svg {
      width: 100%;
      box-shadow: 0px 0px 1px 1px red;
      overflow: visible;
    }
    .dom-el {
      position: absolute;
      top: -1rem;
      left: -1rem;
      width: 2rem;
      height: 2rem;
      color: var(--red);
      border: 2px solid currentColor;
    }
    .rect-el {
      stroke: var(--green-1);
    }
  </style>
</head>
<body>
<h2>No specified width</h2>
<div class="container no-specified-width">
  <svg viewBox="0 0 256 112">
    <path id="noSpecifiedWidth" fill="none" stroke="#FFF" d="M8,56 C8,33.90861 25.90861,16 48,16 C70.09139,16 88,33.90861 88,56 C88,78.09139 105.90861,92 128,92 C150.09139,92 160,72 160,56 C160,40 148,24 128,24 C108,24 96,40 96,56 C96,72 105.90861,92 128,92 C154,93 168,78 168,56 C168,33.90861 185.90861,16 208,16 C230.09139,16 248,33.90861 248,56 C248,78.09139 230.09139,96 208,96 L48,96 C25.90861,96 8,78.09139 8,56 Z"/>
    <rect class="rect-el" fill="none" stroke-width="2" x="-10" y="-10" width="20" height="20"/>
  </svg>
  <div class="dom-el"></div>
</div>
<h2>Specified width</h2>
<div class="container specified-width">
  <svg viewBox="0 0 256 112" width="200" height="200">
    <path id="specifiedWidth" fill="none" stroke="#FFF" d="M8,56 C8,33.90861 25.90861,16 48,16 C70.09139,16 88,33.90861 88,56 C88,78.09139 105.90861,92 128,92 C150.09139,92 160,72 160,56 C160,40 148,24 128,24 C108,24 96,40 96,56 C96,72 105.90861,92 128,92 C154,93 168,78 168,56 C168,33.90861 185.90861,16 208,16 C230.09139,16 248,33.90861 248,56 C248,78.09139 230.09139,96 208,96 L48,96 C25.90861,96 8,78.09139 8,56 Z"/>
    <rect class="rect-el" fill="none" stroke-width="2" x="-10" y="-10" width="20" height="20"/>
  </svg>
  <div class="dom-el"></div>
</div>
<h2>preserveAspectRatio with specified width</h2>
<div class="container preserveAspectRatio">
  <svg viewBox="0 0 256 112" width="200" height="200" preserveAspectRatio="xMidYMid slice">
    <path id="preserveAspectRatio" fill="none" stroke="#FFF" d="M8,56 C8,33.90861 25.90861,16 48,16 C70.09139,16 88,33.90861 88,56 C88,78.09139 105.90861,92 128,92 C150.09139,92 160,72 160,56 C160,40 148,24 128,24 C108,24 96,40 96,56 C96,72 105.90861,92 128,92 C154,93 168,78 168,56 C168,33.90861 185.90861,16 208,16 C230.09139,16 248,33.90861 248,56 C248,78.09139 230.09139,96 208,96 L48,96 C25.90861,96 8,78.09139 8,56 Z"/>
    <rect class="rect-el" fill="none" stroke-width="2" x="-10" y="-10" width="20" height="20"/>
  </svg>
  <div class="dom-el"></div>
</div>

</div>
<script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/timekeeper/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Timekeeper / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      flex-direction: column;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      flex-direction: column;
      align-items: center;
      gap: .5rem;
      padding: 1rem;
    }
    .is-min-m .container {
      flex-direction: row;
    }
    .square {
      width: 100px;
      height: 100px;
      background: var(--red);
      border-radius: 1rem;
      padding: 1rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>


--- tests/playground/tl-seek-test/index.html ---
<!DOCTYPE html>
<html>
<head>
  <title>Stress test / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      overflow: hidden;
      position: absolute;
      width: 100%;
      height: 100dvh;
    }
    div {
      width: 1em;
      height: 1em;
      margin: -.5em 0 0 -.5em;
      font-size: 20px;
      border-radius: 1em;
      background-color: currentColor;
    }
  </style>
</head>
<body>
  <script type="module" src="./index.js"></script>
</body>
</html>

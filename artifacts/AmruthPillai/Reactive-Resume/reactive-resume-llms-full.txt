# llms-full (private-aware)
> Built from GitHub files and website pages. Large files may be truncated.

--- docs/getting-started/index.mdx ---
---
title: "Introduction"
description: "Welcome to the documentation for Reactive Resume, a free and open-source resume builder that simplifies the process of creating, updating, and sharing your resume."
---

<Frame>
  <img src="/images/getting-started/banner.webp" alt="Reactive Resume Banner"  />
</Frame>

## What is Reactive Resume?

**Reactive Resume** is a free and open-source resume builder designed to simplify the process of creating, updating, and sharing your professional resume. Built with privacy as a core principle, it gives you complete control over your data while providing a powerful, modern experience.

<CardGroup cols={2}>
  <Card title="Privacy First" icon="shield-check">
    Your data stays yours. No tracking, no ads, and complete transparency with our open-source codebase.
  </Card>
  <Card title="Beautiful Templates" icon="palette">
    Choose from professionally designed templates that make your resume stand out from the crowd.
  </Card>
  <Card title="Real-time Preview" icon="eye">
    See changes instantly as you type. What you see is exactly what you'll get when you export.
  </Card>
  <Card title="Export Anywhere" icon="file-export">
    Download your resume as PDF, share it via a unique link, or print it directly from your browser.
  </Card>
</CardGroup>

## Key Features

<Frame>
  <img src="/images/getting-started/infographic.webp" alt="An infographic of the major features of Reactive Resume" />
</Frame>

<AccordionGroup>
  <Accordion title="Completely Free & Open Source" icon="code-branch">
    Reactive Resume is licensed under MIT. You can use it for free, modify it, and even host your own instance. The entire codebase is available on [GitHub](https://github.com/amruthpillai/reactive-resume).
  </Accordion>
  
  <Accordion title="Multiple Templates" icon="grid-2">
    Choose from a variety of professionally designed templates including Azurill, Bronzor, Chikorita, Ditto, Gengar, Glalie, Kakuna, Lapras, Leafish, Onyx, Pikachu, and Rhyhorn - each with unique layouts and styles.
  </Accordion>
  
  <Accordion title="Rich Text Editor" icon="text">
    Format your content with bold, italic, links, lists, and more using our intuitive rich text editor powered by Tiptap.
  </Accordion>
  
  <Accordion title="Multi-language Support" icon="globe">
    Reactive Resume supports multiple languages, making it accessible to users worldwide. Contribute translations to help us reach more people.
  </Accordion>
  
  <Accordion title="Dark Mode" icon="moon">
    Work comfortably in any lighting condition with built-in dark mode support that's easy on your eyes.
  </Accordion>
  
  <Accordion title="Self-hosting Ready" icon="server">
    Deploy your own instance of Reactive Resume using Docker. Keep complete control over your data and infrastructure.
  </Accordion>
</AccordionGroup>

## Getting Started

Whether you want to use our hosted version or run your own instance, Reactive Resume has got you covered.

<CardGroup cols={2}>
  <Card
    title="Quickstart"
    icon="rocket"
    href="/getting-started/quickstart"
  >
    Get up and running in minutes with our hosted version or deploy your own instance.
  </Card>
  <Card
    title="Development Setup"
    icon="code"
    href="/contributing/development"
  >
    Set up a local development environment to contribute or customize Reactive Resume.
  </Card>
</CardGroup>

## Tech Stack

Reactive Resume is built with modern web technologies:

| Category          | Technology |
|-------------------|------------|
| Framework         | TanStack Start (React 19, Vite) |
| Runtime           | Node.js |
| Language          | TypeScript |
| Database          | PostgreSQL with Drizzle ORM |
| API               | ORPC (Type-safe RPC) |
| Auth              | Better Auth |
| Styling           | Tailwind CSS |
| UI Components     | Radix UI |
| State Management  | Zustand + TanStack Query |

## Community & Support

<CardGroup cols={2}>
  <Card title="GitHub" icon="github" href="https://github.com/amruthpillai/reactive-resume">
    Star the repo, report issues, and contribute to the project.
  </Card>
  <Card title="Reddit" icon="reddit" href="https://reddit.com/r/reactiveresume">
    Join our Reddit community to get help and connect with other users.
  </Card>
  <Card title="Discord" icon="discord" href="https://discord.gg/aSyA5ZSxpb">
    Join our Discord server to get help and connect with other users.
  </Card>
  <Card title="Sponsor" icon="heart" href="https://opencollective.com/reactive-resume">
    Support the development and long-term sustainability of Reactive Resume.
  </Card>
</CardGroup>

<Note>
  **Need help?** Feel free to reach out via [email](mailto:hello@amruthpillai.com) or open an issue on GitHub.
</Note>


## Links discovered
- [GitHub](https://github.com/amruthpillai/reactive-resume)

--- docs/getting-started/quickstart.mdx ---
---
title: "Quickstart"
description: "Get started with Reactive Resume in minutes — use our hosted version or deploy your own instance"
---

## Options

Reactive Resume offers flexibility in how you want to use it. Choose the option that best fits your needs:

<CardGroup cols={2}>
  <Card title="Use the Cloud Version" icon="cloud" href="#use-the-cloud-version">
    The fastest way to get started. **Recommended for most users.**
  </Card>
  <Card title="Self-Host with Docker" icon="docker" href="#self-host-with-docker">
    Deploy your own instance with complete control. **Requires some technical knowledge.**
  </Card>
</CardGroup>

---

## Using the Cloud Version

The easiest way to use Reactive Resume is through our cloud version at [rxresu.me](https://rxresu.me). **This service is completely free and will always remain free.**

<Steps>
  <Step title="Create an Account">
    Visit [rxresu.me](https://rxresu.me) and sign up for free using your email, or sign in with your GitHub or Google account.
  </Step>
  
  <Step title="Create Your First Resume">
    Click the **Create Resume** button on your dashboard. Give your resume a name and select a template to get started.
  </Step>
  
  <Step title="Fill in Your Details">
    Use our intuitive builder to add your:
    - Personal information
    - Work experience
    - Education
    - Skills
    - Projects
    - And more...
  </Step>
  
  <Step title="Export & Share">
    When you're ready, export your resume as a PDF or share it via a unique public link.
  </Step>
</Steps>

<Tip>
  Your resume updates in real-time as you type. The preview panel shows exactly how your final PDF will look.
</Tip>

---

## Self-Host with Docker

For users who prefer complete control over their data, you can deploy Reactive Resume on your own infrastructure using Docker.

### Prerequisites

Before you begin, ensure you have the following installed:

- [Docker](https://docs.docker.com/get-docker/) (v20.10 or higher)
- [Docker Compose](https://docs.docker.com/compose/install/) (v2.0 or higher)

<Info>
  There is <strong>no difference in features</strong> between the cloud-hosted version and the self-hosted option. Both provide the same privacy, customization, and functionality. Choose whichever deployment type suits your needs!
</Info>


### Quick Deployment

<Steps>
  <Step title="Clone the Repository">
    ```bash
    git clone https://github.com/amruthpillai/reactive-resume.git
    cd Reactive-Resume
    ```
  </Step>
  
  <Step title="Configure Environment Variables">
    Create a `.env` file in the root directory with the following variables:
    
    ```bash
    # Application
    APP_URL=http://localhost:3000
    
    # Database
    DATABASE_URL=postgresql://postgres:postgres@postgres:5432/postgres
    
    # Authentication (generate a secure secret)
    AUTH_SECRET=your-secure-secret-key-here
    
    # Storage (S3-compatible)
    S3_ACCESS_KEY_ID=seaweedfs
    S3_SECRET_ACCESS_KEY=seaweedfs
    S3_ENDPOINT=http://seaweedfs:8333
    S3_BUCKET=reactive-resume
    S3_FORCE_PATH_STYLE=true
    ```
    
    <Warning>
      For production deployments, always use strong, unique values for `AUTH_SECRET` and database credentials.
    </Warning>
  </Step>
  
  <Step title="Start the Services">
    ```bash
    docker compose up -d
    ```
    
    This will start:
    - **PostgreSQL** — Database for storing user data and resumes
    - **SeaweedFS** — S3-compatible storage for file uploads
    - **Printer** — PDF and screenshot generation service (browserless/chromium)
    - **Reactive Resume** — The main application
  </Step>
  
  <Step title="Access Your Instance">
    Once all services are running, access your Reactive Resume instance at:
    
    ```
    http://localhost:3000
    ```
  </Step>
</Steps>

### Docker Compose Services

Here's what each service in the stack does:

| Service | Port | Description |
|---------|------|-------------|
| `postgres` | 5432 | PostgreSQL database for storing all application data |
| `seaweedfs` | 8333 | S3-compatible object storage for file uploads |
| `printer` | 4000 | Headless Chromium service for PDF and screenshot generation |
| `app` | 3000 | The main Reactive Resume application |

### Health Checks

All services include built-in health checks. You can verify everything is running correctly:

```bash
docker compose ps
```

You should see all services with a `healthy` status.

---

## Environment Variables Reference

Here's a complete list of environment variables you can configure:

### Required Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `DATABASE_URL` | PostgreSQL connection string | `postgresql://user:pass@host:5432/db` |
| `AUTH_SECRET` | Secret key for authentication | Generate with `openssl rand -base64 32` |
| `APP_URL` | Public URL of your Application | `https://rxresu.me` |
| `PRINTER_ENDPOINT` | URL of the printer service | `http://printer:3000` |

### Optional Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `PRINTER_APP_URL` | Public URL for the printer to access the Application | — |
| `GOOGLE_CLIENT_ID` | Google OAuth Client ID | — |
| `GOOGLE_CLIENT_SECRET` | Google OAuth Client Secret | — |
| `GITHUB_CLIENT_ID` | GitHub OAuth Client ID | — |
| `GITHUB_CLIENT_SECRET` | GitHub OAuth Client Secret | — |
| `OAUTH_PROVIDER_NAME` | Custom OAuth Provider Name | — |
| `OAUTH_CLIENT_ID` | Custom OAuth Client ID | — |
| `OAUTH_CLIENT_SECRET` | Custom OAuth Client Secret | — |
| `OAUTH_DISCOVERY_URL` | OIDC Discovery URL (use this OR manual URLs below) | — |
| `OAUTH_AUTHORIZATION_URL` | OAuth Authorization URL (manual config) | — |
| `OAUTH_TOKEN_URL` | OAuth Token URL (manual config) | — |
| `OAUTH_USER_INFO_URL` | OAuth User Info URL (manual config) | — |
| `OAUTH_SCOPES` | OAuth Scopes (space-separated) | `openid profile email` |
| `SMTP_HOST` | SMTP Server Host (for email features) | — |
| `SMTP_PORT` | SMTP Server Port | `587` |
| `SMTP_USER` | SMTP Username | — |
| `SMTP_PASS` | SMTP Password | — |
| `SMTP_FROM` | Default FROM address for emails | — |
| `SMTP_SECURE` | Use secure SMTP connection (`true` or `false`) | `false` |
| `S3_ACCESS_KEY_ID` | S3 Access Key | — |
| `S3_SECRET_ACCESS_KEY` | S3 Secret Key | — |
| `S3_REGION` | S3 Region | `us-east-1` |
| `S3_ENDPOINT` | S3-compatible Endpoint URL | — |
| `S3_BUCKET` | S3 Bucket Name | — |
| `S3_FORCE_PATH_STYLE` | Use path-style URLs for S3 (set `true` for MinIO/SeaweedFS) | `false` |
| `FLAG_DEBUG_PRINTER` | Used for debugging the printer route | `false` |
| `FLAG_DISABLE_SIGNUPS` | Disables new user signups | `false` |
| `FLAG_DISABLE_EMAIL_AUTH` | Disables email/password login (SSO only) | `false` |
| `FLAG_DISABLE_IMAGE_PROCESSING` | Disables image processing | `false` |

> **Note:** Some variables are only required for using related features (OAuth, SMTP, S3, etc.) and can be left unset if unused.

<Note>
  **Hybrid Setup Note**: The `PRINTER_APP_URL` variable is required when running Reactive Resume outside of Docker while the printer service is running inside Docker. In this scenario, the printer needs to reach your local app to render resumes for PDF generation. Since Docker containers cannot access `localhost` on your host machine directly, you must set `PRINTER_APP_URL` to `http://host.docker.internal:3000`. This special hostname allows Docker containers to communicate with services running on your host machine.
</Note>

<Note>
  **Alternative Printer Options**: If you don't want to use browserless, you can use any headless Chrome/Chromium instance with its remote debugging port open. For example, run `chromium --remote-debugging-port=9222` and point `PRINTER_ENDPOINT` to that instance.
</Note>

---

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Development Setup"
    icon="code"
    href="/contributing/development"
  >
    Set up a development environment to contribute or customize Reactive Resume.
  </Card>
  <Card
    title="Project Architecture"
    icon="folder-open"
    href="/contributing/architecture"
  >
    Learn about the project structure and architecture.
  </Card>
</CardGroup>

<Note>
  **Having trouble?** Check our [GitHub Issues](https://github.com/amruthpillai/reactive-resume/issues) or reach out via [email](mailto:hello@amruthpillai.com).
</Note>


## Links discovered
- [rxresu.me](https://rxresu.me)
- [Docker](https://docs.docker.com/get-docker/)
- [Docker Compose](https://docs.docker.com/compose/install/)
- [GitHub Issues](https://github.com/amruthpillai/reactive-resume/issues)

--- docs/self-hosting/examples.mdx ---
---
title: "Docker Compose Examples"
description: "A collection of Docker Compose examples for different deployment scenarios. If you have a different setup that works for you, please share it by opening a pull request on GitHub."
---

## Overview

Every self-hosted setup is unique. You might be running on a single VPS, a Kubernetes cluster, behind Cloudflare Tunnel, or using a specific reverse proxy like Traefik or nginx. This page provides real-world Docker Compose configurations for various deployment scenarios to help you get started faster.

These examples go beyond the basic setup in the [Self-Hosting with Docker](/self-hosting/docker) guide, showing production-ready configurations with reverse proxies, SSL termination, and other common patterns.

<Info>
  **Help others by sharing your setup!** If you have a working configuration that isn't covered here, I'd love to include it. Simply [open a pull request](https://github.com/amruthpillai/reactive-resume) with your example added to this page. Your contribution helps the community and makes self-hosting easier for everyone.
</Info>

---

## Docker with Traefik

This example uses [Traefik](https://traefik.io/) as a reverse proxy with automatic SSL certificate management via Let's Encrypt. Only the Reactive Resume app is exposed through Traefik—Postgres and the printer remain on an internal network.

<Tip>
  Traefik automatically discovers services via Docker labels and handles SSL certificates, making it ideal for setups where you want minimal configuration.
</Tip>

```yaml compose-traefik.yml lines expandable
services:
  traefik:
    image: traefik:v3.2
    restart: unless-stopped
    command:
      - "--api.dashboard=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik_letsencrypt:/letsencrypt
    networks:
      - reactive_resume_network
    labels:
      - "traefik.enable=true"
      # Dashboard (optional, remove if not needed)
      - "traefik.http.routers.traefik.rule=Host(`traefik.${DOMAIN}`)"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.routers.traefik.tls.certresolver=letsencrypt"
      - "traefik.http.routers.traefik.service=api@internal"
      - "traefik.http.routers.traefik.middlewares=auth"
      - "traefik.http.middlewares.auth.basicauth.users=${TRAEFIK_DASHBOARD_AUTH}"

  postgres:
    image: postgres:latest
    restart: unless-stopped
    environment:
      - POSTGRES_DB=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql
    networks:
      - reactive_resume_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  printer:
    image: ghcr.io/browserless/chromium:latest
    restart: unless-stopped
    environment:
      - QUEUED=10
      - HEALTH=true
      - CONCURRENT=5
      # Optional: Set a token for authentication
      # - TOKEN=your-secret-token
    networks:
      - reactive_resume_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/pressure?token=your-secret-token"]
      interval: 30s
      timeout: 10s
      retries: 3

  reactive_resume:
    image: amruthpillai/reactive-resume:latest
    restart: unless-stopped
    environment:
      - APP_URL=https://resume.${DOMAIN}
      - PRINTER_APP_URL=http://reactive_resume:3000
      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/postgres
      - PRINTER_ENDPOINT=http://printer:3000
      - AUTH_SECRET=${AUTH_SECRET}
      # Add other optional env vars as needed (SMTP, S3, OAuth, etc.)
    volumes:
      - reactive_resume_data:/app/data
    networks:
      - reactive_resume_network
    depends_on:
      postgres:
        condition: service_healthy
      printer:
        condition: service_healthy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.reactive-resume.rule=Host(`resume.${DOMAIN}`)"
      - "traefik.http.routers.reactive-resume.entrypoints=websecure"
      - "traefik.http.routers.reactive-resume.tls.certresolver=letsencrypt"
      - "traefik.http.services.reactive-resume.loadbalancer.server.port=3000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  reactive_resume_network:
    driver: bridge

volumes:
  traefik_letsencrypt:
  postgres_data:
  reactive_resume_data:
```

**Environment variables (`.env`):**

```bash .env
DOMAIN="example.com"
ACME_EMAIL="admin@example.com"
POSTGRES_PASSWORD="your-secure-postgres-password"
AUTH_SECRET="your-auth-secret-from-openssl-rand-hex-32"
# Optional: Traefik dashboard auth (generate with: htpasswd -nb admin password)
TRAEFIK_DASHBOARD_AUTH="admin:$$apr1$$..."
```

---

## Docker with nginx

This example uses [nginx](https://nginx.org/) as a reverse proxy with SSL certificates (you'll need to provide your own certificates or use certbot separately).

```yaml compose-nginx.yml lines expandable
services:
  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certs:/etc/nginx/certs:ro
    networks:
      - reactive_resume_network

  postgres:
    image: postgres:latest
    restart: unless-stopped
    environment:
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql
    networks:
      - reactive_resume_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  printer:
    image: ghcr.io/browserless/chromium:latest
    restart: unless-stopped
    environment:
      - QUEUED=10
      - HEALTH=true
      - CONCURRENT=5
      # Optional: Set a token for authentication
      # - TOKEN=your-secret-token
    networks:
      - reactive_resume_network

  reactive_resume:
    image: amruthpillai/reactive-resume:latest
    restart: unless-stopped
    environment:
      - APP_URL=https://resume.${DOMAIN}
      - PRINTER_APP_URL=http://reactive_resume:3000
      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/postgres
      - PRINTER_ENDPOINT=http://printer:3000
      - AUTH_SECRET=${AUTH_SECRET}
      # Add other optional env vars as needed (SMTP, S3, OAuth, etc.)
    volumes:
      - reactive_resume_data:/app/data
    networks:
      - reactive_resume_network
    depends_on:
      postgres:
        condition: service_healthy
      printer:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  reactive_resume_network:
    driver: bridge

volumes:
  postgres_data:
  reactive_resume_data:
```

**nginx configuration (`nginx.conf`):**

```nginx nginx.conf lines expandable
events {
    worker_connections 1024;
}

http {
    upstream reactive_resume {
        server reactive_resume:3000;
    }

    # Redirect HTTP to HTTPS
    server {
        listen 80;
        server_name _;
        return 301 https://$host$request_uri;
    }

    # HTTPS server
    server {
        listen 443 ssl http2;
        server_name resume.example.com;

        ssl_certificate /etc/nginx/certs/fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/privkey.pem;

        # SSL configuration
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;

        # Proxy settings
        location / {
            proxy_pass http://reactive_resume;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;

            # Timeouts for long-running requests (PDF generation)
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # Increase max body size for resume uploads
        client_max_body_size 10M;
    }
}
```

<Tip>
  For automatic SSL certificates with nginx, consider using [certbot](https://certbot.eff.org/) with the `--nginx` plugin, or a companion container like [nginx-proxy-acme](https://github.com/nginx-proxy/acme-companion).
</Tip>

---

## Docker Swarm

This example demonstrates a production-grade Docker Swarm deployment with multiple replicas, health checks, rolling updates, and Traefik integration. It includes SeaweedFS for S3-compatible storage and a PostgreSQL database with custom configuration.

<Tip>
  Docker Swarm is great for multi-node deployments where you need high availability and easy scaling. The app service is configured with 2 replicas and rolling update strategy.
</Tip>

```yaml compose-swarm.yml lines expandable
services:
  postgres:
    image: postgres:latest
    networks:
      - reactive_resume_network
    volumes:
      - reactive_resume_postgres_data:/var/lib/postgresql
    environment:
      - POSTGRES_DB=$POSTGRES_DB
      - POSTGRES_USER=$POSTGRES_USER
      - POSTGRES_PASSWORD=$POSTGRES_PASSWORD
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $POSTGRES_USER -d $POSTGRES_DB"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    deploy:
      mode: replicated
      replicas: 1

  printer:
    image: ghcr.io/browserless/chromium:latest
    networks:
      - reactive_resume_network
    environment:
      - QUEUED=10
      - HEALTH=true
      - CONCURRENT=5
      # Optional: Set a token for authentication
      # - TOKEN=your-secret-token
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/pressure?token=your-secret-token"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    deploy:
      mode: replicated
      replicas: 1

  seaweedfs:
    image: chrislusf/seaweedfs:latest
    command: server -s3 -filer -dir=/data -ip=0.0.0.0
    networks:
      - reactive_resume_network
    volumes:
      - reactive_resume_seaweedfs_data:/data
    environment:
      - AWS_ACCESS_KEY_ID=$S3_ACCESS_KEY_ID
      - AWS_SECRET_ACCESS_KEY=$S3_SECRET_ACCESS_KEY
    healthcheck:
      test: ["CMD", "wget", "-q", "-O", "/dev/null", "http://localhost:8888"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    deploy:
      mode: replicated
      replicas: 1

  seaweedfs_create_bucket:
    image: quay.io/minio/mc:latest
    entrypoint: >
      /bin/sh -c "
        until mc alias set seaweedfs http://seaweedfs:8333 $S3_ACCESS_KEY_ID $S3_SECRET_ACCESS_KEY; do
          echo 'Waiting for SeaweedFS...';
          sleep 2;
        done;
        mc mb seaweedfs/$S3_BUCKET --ignore-existing;
      "
    networks:
      - reactive_resume_network
    deploy:
      mode: replicated
      replicas: 1

  reactive_resume:
    image: ghcr.io/amruthpillai/reactive-resume:latest
    networks:
      - traefik_network
      - reactive_resume_network
    volumes:
      - reactive_resume_data:/app/data
    environment:
      - APP_URL=$APP_URL
      # If using browserless with token auth, include the token in the URL:
      # PRINTER_ENDPOINT=ws://printer:3000?token=your-secret-token
      - PRINTER_ENDPOINT=$PRINTER_ENDPOINT
      - DATABASE_URL=$DATABASE_URL
      - AUTH_SECRET=$AUTH_SECRET
      - GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID
      - GOOGLE_CLIENT_SECRET=$GOOGLE_CLIENT_SECRET
      - GITHUB_CLIENT_ID=$GITHUB_CLIENT_ID
      - GITHUB_CLIENT_SECRET=$GITHUB_CLIENT_SECRET
      - SMTP_HOST=$SMTP_HOST
      - SMTP_PORT=$SMTP_PORT
      - SMTP_USER=$SMTP_USER
      - SMTP_PASS=$SMTP_PASS
      - SMTP_FROM=$SMTP_FROM
      - SMTP_SECURE=$SMTP_SECURE
      - S3_ACCESS_KEY_ID=$S3_ACCESS_KEY_ID
      - S3_SECRET_ACCESS_KEY=$S3_SECRET_ACCESS_KEY
      - S3_REGION=$S3_REGION
      - S3_ENDPOINT=$S3_ENDPOINT
      - S3_BUCKET=$S3_BUCKET
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    deploy:
      mode: replicated
      replicas: 1
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.app.rule=Host(`rxresu.me`)"
        - "traefik.http.routers.app.entrypoints=websecure"
        - "traefik.http.routers.app.tls=true"
        - "traefik.http.services.app.loadbalancer.server.port=3000"

configs:
  reactive_resume_postgres_config:
    name: reactive_resume_postgres_config
    external: true

networks:
  traefik_network:
    external: true
  reactive_resume_network:
    name: reactive_resume_network
    driver: overlay
    attachable: true

volumes:
  reactive_resume_postgres_data:
    name: reactive_resume_postgres_data
  reactive_resume_seaweedfs_data:
    name: reactive_resume_seaweedfs_data
  reactive_resume_data:
    name: reactive_resume_data
```

**Deploy the stack:**

```bash
docker stack deploy -c compose-swarm.yml reactive_resume
```

**Useful commands:**

```bash
# Check service status
docker stack services reactive_resume

# View logs for the app
docker service logs -f reactive_resume_app

# Scale the app
docker service scale reactive_resume_app=3

# Remove the stack
docker stack rm reactive_resume
```

<Note>
  This example assumes you have an external Traefik network already set up. Adjust the `traefik_network` reference and labels based on your Traefik configuration.
</Note>

---

## Contributing Your Setup

Have a different deployment setup that works well? Consider contributing it here. Some examples include:

- Kubernetes / Helm charts
- Cloudflare Tunnel
- Caddy reverse proxy
- Docker with Portainer
- Podman configurations
- Cloud-specific deployments (AWS ECS, Google Cloud Run, Azure Container Apps)

To contribute, [open a pull request](https://github.com/amruthpillai/reactive-resume) with your example added to this page. Include:

1. A brief description of when/why someone would use this setup
2. The complete Docker Compose (or equivalent) configuration
3. Any additional configuration files (nginx.conf, etc.)
4. Required environment variables

## Links discovered
- [Self-Hosting with Docker](https://github.com/AmruthPillai/Reactive-Resume/blob/main/self-hosting/docker.md)
- [open a pull request](https://github.com/amruthpillai/reactive-resume)
- [Traefik](https://traefik.io/)
- [nginx](https://nginx.org/)
- [certbot](https://certbot.eff.org/)
- [nginx-proxy-acme](https://github.com/nginx-proxy/acme-companion)

--- docs/changelog/index.mdx ---
---
title: "Changelog"
description: "List of all notable changes and updates to Reactive Resume"
rss: true
---

<Update label="v5.0.9" description="9th February 2026">
  - Add Computer Modern web fonts to the font selector, allowing the user to choose from a variety of "Computer Modern" (LaTeX) fonts.
    - This lets you create a resume that looks just like a LaTeX document, with the same fonts and styles.
  - Update dependencies to the latest versions.
</Update>

<Update label="v5.0.8" description="9th February 2026">
  - Remove Passkey support from the authentication system, as it was causing issues with the authentication provider.
  - Update dependencies to the latest versions.
</Update>

<Update label="v5.0.7" description="9th February 2026">
  - Introduce a new **MCP (Model Context Protocol) server** that lets you manage and edit resumes from any MCP-compatible AI tool — Claude Desktop, Cursor, Codex, and more. Supports listing, reading, creating, deleting, locking/unlocking, and patching resumes via natural language. [(guide)](/guides/using-the-mcp-server)
  - Add an **AI Chat** panel to the resume builder, allowing you to modify your resume through conversational AI directly within the editor. The chat uses tool-calling to apply JSON Patch operations to your resume in real-time, with visual feedback for each change.
  - Add a system prompt and `patch_resume` tool for the AI chat, enabling structured, minimal-diff resume edits following RFC 6902 JSON Patch operations.
  - Chat history is now persisted per resume in localStorage, so conversations are preserved across sessions.
  - Fix rendering issues in the Lapras and Onyx resume templates.
  - Improvements to the Combobox and ScrollArea UI components.
  - Fix an issue with skills item rendering in the shared resume components.
  - Update authentication configuration and auth route handling.
  - Update the JSON Schema to reflect the latest resume data model.
  - Update dependencies to the latest versions.
</Update>

<Update label="v5.0.6" description="8th February 2026">
  - Implement Atomic Resume Patching API for fine-grained resume updates, allowing partial, atomic updates to resumes via a new PATCH endpoint. [#2692](https://github.com/amruthpillai/reactive-resume/pull/2692)
  - The API endpoint `PUT /resume/{id}` now returns the updated resume object instead of void. Also, resume routing/services now use explicit DTOs for input and output schemas. [#2688](https://github.com/amruthpillai/reactive-resume/pull/2688)
  - Add error logging for API server errors (server-side only) to improve debugging and reliability.
  - Refactor and clean up imports/exports for clarity and maintainability.
  - Added `.devcontainer` configuration for improved contributor development environment.
  - Update dependencies to the latest versions.
  - Add build status badge and documentation link to README.
  - Sync latest translations from Crowdin (notably: French, other languages).
  - Other minor fixes and improvements.
</Update>


<Update label="v5.0.5" description="31st January 2026">
  - Implement Cover Letter functionality in the resume builder, allowing the user to create cover letters as custom sections. [(link)](/guides/adding-a-cover-letter)
  - Implement full-screen mode for the rich text editor in the resume builder, allowing the user to write in a more focused environment.
  - Implement a new custom section type: `summary`, which allows the user to add another "summary" like section to the resume.
  - Implement a `useFormBlocker` hook to prevent the user from closing a dialog while the form has unsaved changes.
  - Fix an issue where keywords spacing was not consistent in the interests section. [#2631](https://github.com/amruthpillai/reactive-resume/pull/2631)
  - Fix an issue where the AI connection test was not working correctly, also return appropriate error messages for AI provider issues.
</Update>

<Update label="v5.0.4" description="28th January 2026">
  - Bring back Undo/Redo functionality in the resume builder for improved editing experience.
  - Arrange the sidebar builder dynamically based on the section type in each template. [#2564](https://github.com/amruthpillai/reactive-resume/pull/2603)
  - Remove extra spacing when proficiency is empty. [#2607](https://github.com/amruthpillai/reactive-resume/pull/2626)
  - Fix rendering in Pikachu template: conditionally render header and page picture using `isFirstPage`, and respect the `fullWidth` property for page layout.
  - Fixes to templates to improve layout and rendering consistency.
  - Fix GitHub OAuth login for users migrated from previous versions.
  - Improve communication with the printer service and reduce resource usage for better PDF generation reliability.
  - Update and sync translations from Crowdin (Afrikaans, Persian, Portuguese/Brazilian, and other languages).
  - Update translation sources and configuration.
  - Fix "empty" Git merge remnants in codebase.
  - Update package dependencies and fix self-hosting guide links in README.
  - Remove dead code, update screenshots, and add PWA (Progressive Web App) support.
  - Update links to PDF example files in documentation.
  - Other bug fixes and minor improvements (#2542, #2573, #2598).
</Update>

<Update label="v5.0.3" description="25th January 2026">
  - Implement the ability to print Free-Form PDFs which do not have a fixed page height, allowing the user to fit the content on a page as they see fit. [(link)](/guides/selecting-page-format)
  - Allow the user to override the default endpoint for all AI providers, not just Ollama. Also display the default endpoint for each provider in the AI settings page.
  - Updated the chip input component, to allow the user to add, edit, remove or reorder keywords for skills and other sections.
  - Improved RTL support across the app, thanks to @obreo for the contribution. [(link)](https://github.com/amruthpillai/reactive-resume/pull/2583)
  - Updates to the translation configuration to remove line numbers from the translation files, as this was causing unnecessary diffs.
  - Updated the video on the homepage to be lighter and faster to load, while still maintaining the same quality.
  - Increased the screenshot TTL for resumes, to avoid regenerating screenshots unnecessarily unless the resume has been updated recently (in the last hour).
  - Update dependencies and translations to the latest versions.
</Update>

<Update label="v5.0.2" description="24th January 2026">
  - Added an agent skill `skills/resume-builder` for agentic AI assistants to build resumes for Reactive Resume through conversational AI.
  - Added a new guide on how to fit content on a page, to avoid issues when exporting to PDF. [(link)](/guides/fitting-content-on-a-page)
  - Display an alert when the content is too tall for a page, to help the user fit the content on a page.
  - Fix an issue with the Ditgar template, where the page was not respecting the `fullWidth` setting.
  - Updated the JSON Schema to conform to a proper format.
  - Updated the Discord Server invite link to a new one.
  - Updated dependencies to the latest versions.
</Update>

<Update label="v5.0.1" description="23th January 2026">
  - Updated translations from Crowdin.
  - Added a Community Spotlight section to the documentation.
  - Remove `-r require-metadata` from the Dockerfile as it was not needed.
  - Fixed inconsistencies in the docker compose examples in the documentation.
  - Fixed an issue with usernames not allowing hyphens in them.
  - Fixed issues with the printer service, when using the `getResumeScreenshot` or `printResumeAsPDF` endpoints.
</Update>

<Update label="v5.0.0" description="22th January 2026">
  This has been a major overhaul from the previous version of Reactive Resume. The app has been completely redesigned and rebuilt from scratch, to be more intuitive and user-friendly.

  **Here are some of the key changes from the previous version:**
  - 2 new templates: _Ditgar_ and _Lapras_
  - Authentication via Passkeys
  - New user interface and refreshed design
  - API Access and Reference Documentation
  - AI Integration with OpenAI, Google, Anthropic, and Ollama
  - A better font selector, with real-time preview of the font
  - More comprehensive documentation, with guides for specific features
  - An improved templates gallery, with clear overview of each template
  - Ability to import resumes from PDF or DOCX (requires AI Integration)
  - Reliable server infrastructure, with improved performance and scalability
  - Ability to move items between sections and pages, for better organization
  - A more powerful CSS Editor, with better autocomplete and syntax highlighting
  - Extended Custom Sections to include a type, for better customization and organization
  - Ability to choose the kind of icons to display for level indicators (stars, circles, custom icons, etc.)
  - Ability to resize how wide/narrow the sidebar should be on the resume, or convert a page to be full width

  There's still a lot more that I'm forgetting, but I'm sure you'll find out soon enough as you explore the new version. I hope you enjoy building your resume now, better than ever. If you have any feedback, please feel free to [contact me](https://amruthpillai.com/#contact) or [open an issue](https://github.com/amruthpillai/reactive-resume/issues) on GitHub.
</Update>

## Links discovered
- [(guide)](https://github.com/AmruthPillai/Reactive-Resume/blob/main/guides/using-the-mcp-server.md)
- [#2692](https://github.com/amruthpillai/reactive-resume/pull/2692)
- [#2688](https://github.com/amruthpillai/reactive-resume/pull/2688)
- [(link)](https://github.com/AmruthPillai/Reactive-Resume/blob/main/guides/adding-a-cover-letter.md)
- [#2631](https://github.com/amruthpillai/reactive-resume/pull/2631)
- [#2564](https://github.com/amruthpillai/reactive-resume/pull/2603)
- [#2607](https://github.com/amruthpillai/reactive-resume/pull/2626)
- [(link)](https://github.com/AmruthPillai/Reactive-Resume/blob/main/guides/selecting-page-format.md)
- [(link)](https://github.com/amruthpillai/reactive-resume/pull/2583)
- [(link)](https://github.com/AmruthPillai/Reactive-Resume/blob/main/guides/fitting-content-on-a-page.md)
- [contact me](https://amruthpillai.com/#contact)
- [open an issue](https://github.com/amruthpillai/reactive-resume/issues)

--- docs/guides/accessing-the-previous-version.mdx ---
---
title: "Accessing the Previous Version"
description: "Learn how to access the previous version (v4) of Reactive Resume if you need to retrieve old resumes or prefer the classic experience."
---

## The previous version is still available

If you've been using Reactive Resume for a while, you may have resumes saved in the previous version of the application. The good news is that **version 4 (v4) is still fully accessible** and will remain online for the foreseeable future.

<Info>
  The previous version of Reactive Resume is available at [https://v4.rxresu.me](https://v4.rxresu.me).
</Info>

## Why keep the old version running?

There are several reasons why v4 remains available:

- **Access to existing resumes**: Users who created resumes in v4 can still access, edit, and export them
- **Familiarity**: Some users may prefer the interface they're already comfortable with
- **Transition time**: Moving to a new version takes time, and there's no rush

## How long will v4 be available?

The previous version will continue to run for as long as possible—until the maintainer runs out of breath or funds to keep the server active. There are no immediate plans to shut it down.

<Warning>
  While v4 will remain accessible for the foreseeable future, I recommend gradually transitioning to the latest version to benefit from new features, improvements, and ongoing support.
</Warning>

## Accessing your v4 resumes

<Steps>
  <Step title="Visit the v4 application">
    Go to [https://v4.rxresu.me](https://v4.rxresu.me) in your browser.
  </Step>

  <Step title="Log in with your existing credentials">
    Use the same account credentials you used when you originally created your resumes in v4.

    <Tip>
      If you used social login (Google, GitHub, etc.) in v4, use the same method to sign in.
    </Tip>
  </Step>

  <Step title="Access your resumes">
    Once logged in, you'll find all your previously created resumes in your dashboard, exactly as you left them.
  </Step>
</Steps>

## Migrating to the new version

If you'd like to move your resumes to the latest version of Reactive Resume, you can export them from v4 and import them into the new version:

1. In v4, open the resume you want to migrate
2. Export it as a JSON file
3. In the new version at [https://rxresu.me](https://rxresu.me), create a new account or log in
4. Use the import feature to upload your JSON file (select the "Reactive Resume v4 (JSON)" option)

<Info>
  Your existing resumes should already be available in the new version. If you don't see them, you can manually import them using the steps above.
</Info>

## Questions or issues?

If you encounter any problems accessing v4 or have questions about migrating your resumes, feel free to open an issue on [GitHub](https://github.com/amruthpillai/reactive-resume/issues).


## Links discovered
- [https://v4.rxresu.me](https://v4.rxresu.me)
- [https://rxresu.me](https://rxresu.me)
- [GitHub](https://github.com/amruthpillai/reactive-resume/issues)

--- docs/guides/adding-a-cover-letter.mdx ---
---
title: "Adding a cover letter"
description: "Learn how to create a cover letter as a custom section in Reactive Resume, format it professionally, and place it on a separate page."
---

A cover letter is a personalized document that accompanies your resume when applying for a job. It introduces you to the employer, highlights your relevant qualifications, and explains why you're a good fit for the position. Reactive Resume lets you create cover letters as custom sections, giving you full control over formatting and placement.

## Why include a cover letter?

- **Stand out**: A well-written cover letter demonstrates genuine interest in the position
- **Personalize your application**: Tailor your message to each employer and role
- **Explain gaps or transitions**: Address career changes or gaps in your resume
- **Show communication skills**: Demonstrate your ability to write clearly and professionally

## Creating a cover letter section

<Steps>
  <Step title="Open the resume builder">
    Navigate to your resume and open it in the builder.
  </Step>

  <Step title="Scroll to Custom Sections">
    In the left sidebar, scroll down to find the **Custom Sections** area at the bottom.
  </Step>

  <Step title="Add a new custom section">
    Click <Badge>Add a new custom section</Badge> to open the section creation dialog.
  </Step>

  <Step title="Select 'Cover Letter' as the type">
    In the dialog:
    - Enter a **Title** for your section (e.g., "Cover Letter" or "Cover Letter - [Company Name]")
    - Select **Cover Letter** from the **Type** dropdown
    - Click **Create** to add the section
  </Step>

  <Step title="Add a cover letter item">
    In your new cover letter section, click <Badge>Add a new item</Badge> to create your cover letter.
  </Step>
</Steps>

## Formatting your cover letter

A cover letter has two main fields:

### Recipient field

The **Recipient** field is where you enter the recipient's information. This typically includes:
- Date (optional)
- Hiring manager's name
- Their job title
- Company name
- Company address

<Tip>
  Use line breaks to format the address block. For example:

  ```
  January 31, 2026

  Jane Smith
  Senior Hiring Manager
  Acme Corporation
  123 Main Street, Suite 400
  New York, NY 10001
  ```
</Tip>

### Content field

The **Content** field is where you write the body of your cover letter. Include:
- **Salutation**: "Dear Ms. Smith," or "Dear Hiring Team,"
- **Opening paragraph**: State the position you're applying for and how you learned about it
- **Body paragraphs**: Highlight relevant experience, skills, and achievements
- **Closing paragraph**: Express enthusiasm and include a call to action
- **Sign-off**: "Sincerely," followed by your name

<Info>
  The recipient and content are both rendered directly on your resume without a section header, giving your cover letter a clean, professional appearance.
</Info>

## Using fullscreen mode for writing

For a distraction-free writing experience, use the fullscreen mode in the rich text editor:

<Steps>
  <Step title="Open the cover letter item">
    Click on your cover letter item in the sidebar to open the edit dialog.
  </Step>

  <Step title="Expand the editor">
    In either the Recipient or Content field, click the **expand icon** (arrows pointing outward) in the bottom-right corner of the editor.
  </Step>

  <Step title="Write in fullscreen">
    The editor will expand to nearly fill your screen, giving you a focused writing environment with all formatting tools available.
  </Step>

  <Step title="Exit fullscreen">
    Click the **collapse icon** or press **Escape** to return to the normal view.
  </Step>
</Steps>

## Formatting options

The rich text editor supports various formatting options for your cover letter:

- **Text styling**: Bold, italic, underline, strikethrough, highlight
- **Headings**: H1 through H6 (though typically not needed in a cover letter)
- **Alignment**: Left, center, right, or justified text
- **Lists**: Bullet points and numbered lists
- **Links**: Add hyperlinks to your portfolio or LinkedIn

## Moving your cover letter to a separate page

Cover letters are typically on their own page, separate from the resume content. To achieve this:

<Steps>
  <Step title="Create a second page">
    In the right sidebar, go to the **Layout** section and add a new page to your resume.
  </Step>

  <Step title="Move the cover letter section">
    Use the **Move to** feature to relocate your cover letter section to the second page.

    <Tip>
      See [Moving items between sections](/guides/moving-items-between-sections) for detailed instructions on how to move sections between pages.
    </Tip>
  </Step>

  <Step title="Verify the layout">
    Check the preview to ensure your cover letter appears on its own page with proper formatting.
  </Step>
</Steps>

<Warning>
  When exporting as PDF, pages are rendered in order. If you want the cover letter first, place it on page 1 and move your resume content to subsequent pages.
</Warning>

## Tips for effective cover letters

<Tip>
  **Keep it concise**: Aim for 250-400 words. Recruiters spend about one minute reading cover letters.
</Tip>

<Tip>
  **Tailor each letter**: Customize your cover letter for each application. Reference specific job requirements and company values.
</Tip>

<Tip>
  **Use the same styling**: Your cover letter will inherit the fonts and colors from your resume template, ensuring a cohesive look.
</Tip>

<Tip>
  **Proofread carefully**: Spelling and grammar errors can disqualify your application. Review your letter before exporting.
</Tip>

## Managing multiple cover letters

Since cover letters are custom sections, you can:

- Create multiple cover letter sections for different job applications
- Name each section descriptively (e.g., "Cover Letter - Google", "Cover Letter - Meta")
- Show or hide sections as needed when exporting
- Duplicate sections to use as templates for new applications


## Links discovered
- [Moving items between sections](https://github.com/AmruthPillai/Reactive-Resume/blob/main/guides/moving-items-between-sections.md)

--- docs/contributing/architecture.mdx ---
---
title: "Project Architecture"
description: "Understand the architecture and codebase structure of Reactive Resume"
---

This guide provides a comprehensive overview of Reactive Resume's architecture and codebase structure, helping you understand how different parts of the application work together.

---

## Tech Stack Overview

Reactive Resume is built with a modern, type-safe stack:

<CardGroup cols={2}>
  <Card title="Frontend" icon="browser">
    - **React 19** with TanStack Start
    - **TypeScript** for type safety
    - **Tailwind CSS** for styling
    - **Radix UI** for accessible components
  </Card>
  <Card title="Backend" icon="server">
    - **ORPC** for type-safe RPC
    - **Drizzle ORM** with PostgreSQL
    - **Better Auth** for authentication
    - **Sharp** for image processing
  </Card>
</CardGroup>

---

## Application Architecture

```mermaid
flowchart TD
  %% Client Side
  subgraph Client ["Client"]
    Router["TanStack Router"]
    Query["TanStack Query"]
    ORPCClient["oRPC Client"]
  end

  %% Server Side
  subgraph Server ["Server"]
    ORPCRouter["oRPC Router"]
    Auth["Better Auth"]
    Services["Services Layer"]
    Drizzle["Drizzle ORM"]
  end

  Database["PostgreSQL"]
  Storage["File System OR S3-Compatible Storage"]
  Printer["Printer (Browserless/Chromium)"]

  Router --> ORPCClient
  Query --> ORPCClient
  ORPCClient -- calls --> ORPCRouter
  ORPCRouter --> Services
  Auth --> Services
  Services --> Drizzle
  Drizzle --> Database
  Services --> Storage
  Services --> Printer
```

**Diagram:** This flow shows data and control flow between the main architectural layers of Reactive Resume.

---

## Directory Structure

### Root Level

| Directory | Purpose |
|-----------|---------|
| `src/` | Main application source code |
| `public/` | Static assets served directly |
| `locales/` | Translation files (.po format) |
| `migrations/` | Database migration files |
| `docs/` | Mintlify documentation |
| `data/` | Local data storage (fonts, uploads) |
| `scripts/` | Utility scripts |

### Source Code (`src/`)

<AccordionGroup>
  <Accordion title="components/" icon="cube">
    Reusable React components organized by category:
    
    - **`ui/`** — Base UI components (Button, Card, Dialog, etc.)
    - **`resume/`** — Resume-specific components (sections, templates)
    - **`input/`** — Form input components (ColorPicker, RichInput)
    - **`layout/`** — Layout components (Sidebar, LoadingScreen)
    - **`animation/`** — Animation components (Spotlight, TextMask)
    - **`theme/`** — Theme management components
    - **`typography/`** — Font management components
  </Accordion>
  
  <Accordion title="routes/" icon="route">
    File-based routing using TanStack Router:
    
    - **`__root.tsx`** — Root layout with providers
    - **`_home/`** — Public home page routes
    - **`auth/`** — Authentication routes (login, register, etc.)
    - **`dashboard/`** — User dashboard routes
    - **`builder/`** — Resume builder routes (the main editor)
    - **`printer/`** — PDF printing route
    - **`api/`** — API routes
  </Accordion>
  
  <Accordion title="integrations/" icon="plug">
    Third-party service integrations:
    
    - **`auth/`** — Better Auth client configuration
    - **`drizzle/`** — Database schema and utilities
    - **`orpc/`** — API router, client, and services
    - **`ai/`** — AI service integrations
    - **`import/`** — Resume import utilities
  </Accordion>
  
  <Accordion title="dialogs/" icon="window-maximize">
    Modal dialog components:
    
    - **`auth/`** — Authentication dialogs
    - **`resume/`** — Resume management dialogs
    - **`api-key/`** — API key management dialogs
    - **`manager.tsx`** — Dialog manager component
    - **`store.ts`** — Dialog state management (Zustand)
  </Accordion>
  
  <Accordion title="schema/" icon="file-code">
    Zod schemas for validation:
    
    - **`resume/`** — Resume data schemas
    - **`icons.ts`** — Icon definitions
    - **`templates.ts`** — Template definitions
  </Accordion>
  
  <Accordion title="hooks/" icon="hook">
    Custom React hooks:
    
    - `use-confirm.tsx` — Confirmation dialog hook
    - `use-prompt.tsx` — Prompt dialog hook
    - `use-mobile.tsx` — Mobile detection hook
    - `use-safe-context.tsx` — Safe context consumption
  </Accordion>
  
  <Accordion title="utils/" icon="wrench">
    Utility functions:
    
    - `env.ts` — Environment variable validation
    - `locale.ts` — Locale utilities
    - `theme.ts` — Theme utilities
    - `string.ts` — String manipulation
    - `file.ts` — File handling utilities
  </Accordion>
</AccordionGroup>

---

## Key Concepts

### File-Based Routing

Routes are automatically generated from the file structure in `src/routes/`. TanStack Router conventions:

| Pattern | Description | Example |
|---------|-------------|---------|
| `index.tsx` | Index route | `/dashboard` |
| `$param.tsx` | Dynamic parameter | `/builder/$resumeId` |
| `_layout/` | Layout group (prefix) | `_home/` |
| `__root.tsx` | Root layout | Wraps all routes |

<Warning>
  Never edit `src/routeTree.gen.ts` manually — it's auto-generated when you run the dev server.
</Warning>

### API Layer (ORPC)

ORPC provides end-to-end type safety for API calls:

```
src/integrations/orpc/
├── client.ts         # Client-side ORPC setup
├── router/           # API route definitions
│   ├── auth.ts      # Authentication endpoints
│   ├── resume.ts    # Resume CRUD operations
│   └── storage.ts   # File storage operations
├── services/         # Business logic layer
└── helpers/          # Utility functions
```

**Using the API client:**

```tsx
import { useQuery } from "@tanstack/react-query";
import { orpc } from "@/integrations/orpc/client";

// Type-safe API calls with TanStack Query
const { data } = useQuery(orpc.resume.findMany.queryOptions());
```

### State Management

Reactive Resume uses a hybrid approach:

| Type | Tool | Use Case |
|------|------|----------|
| Server State | TanStack Query | API data, caching, sync |
| Client State | Zustand | UI state, dialogs, preferences |
| Form State | React Hook Form | Form inputs and validation |

### Database Schema

The database schema is defined using Drizzle ORM in `src/integrations/drizzle/schema.ts`:

```tsx
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";

export const resume = pgTable("resume", {
  id: uuid("id").primaryKey().defaultRandom(),
  title: text("title").notNull(),
  slug: text("slug").notNull(),
  // ... more fields
});
```

---

## Common Development Patterns

### Adding a New Component

1. Create the component in the appropriate `src/components/` subdirectory
2. Export it from the directory's index file (if applicable)
3. Use TypeScript props interfaces for type safety
4. Follow existing patterns for consistency

```tsx
// src/components/ui/my-component.tsx
import { cn } from "@/utils/style";

interface MyComponentProps {
  title: string;
  className?: string;
}

export const MyComponent = ({ title, className }: MyComponentProps) => {
  return <div className={cn("p-4", className)}>{title}</div>;
};
```

### Adding a New Route

1. Create a new file in `src/routes/` following TanStack Router conventions
2. The route tree auto-generates when you save
3. Use `createFileRoute` for type-safe routes

```tsx
// src/routes/my-page.tsx
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/my-page")({
  component: MyPage,
});

function MyPage() {
  return <div>My Page Content</div>;
}
```

### Adding an API Endpoint

1. Add the route handler in `src/integrations/orpc/router/`
2. Create service functions in `src/integrations/orpc/services/` if needed
3. The endpoint is automatically typed on the client

```tsx
// In router file
import { z } from "zod";
import { publicProcedure, router } from "../server";

export const myRouter = router({
  hello: publicProcedure
    .input(z.object({ name: z.string() }))
    .handler(async ({ input }) => {
      return { message: `Hello, ${input.name}!` };
    }),
});
```

### Adding Translations

1. Wrap text with `t` macro or `<Trans>` component
2. Run `pnpm run lingui:extract` to update locale files
3. Edit the `.po` files in `locales/` to add translations

```tsx
import { t } from "@lingui/core/macro";
import { Trans } from "@lingui/react/macro";

// In component
const title = t`Welcome`;
<Trans>Click here to continue</Trans>
```

---

## Configuration Files

| File | Purpose |
|------|---------|
| `vite.config.ts` | Vite bundler configuration |
| `tsconfig.json` | TypeScript configuration |
| `biome.json` | Linter and formatter settings |
| `drizzle.config.ts` | Drizzle ORM configuration |
| `lingui.config.ts` | Lingui i18n configuration |
| `components.json` | shadcn/ui component configuration |

---

## Contributing Guidelines

<Steps>
  <Step title="Fork & Clone">
    Fork the repository on GitHub and clone your fork locally.
  </Step>
  
  <Step title="Create a Branch">
    Create a feature branch from `main`:
    ```bash
    git checkout -b feature/my-feature
    ```
  </Step>
  
  <Step title="Make Changes">
    Implement your changes following the patterns described above.
  </Step>
  
  <Step title="Test Locally">
    Ensure the app works correctly with your changes:
    ```bash
    pnpm run dev
    pnpm run lint
    pnpm run typecheck
    ```
  </Step>
  
  <Step title="Commit & Push">
    Write clear commit messages and push to your fork.
  </Step>
  
  <Step title="Open a Pull Request">
    Open a PR against the main repository with a clear description of your changes.
  </Step>
</Steps>

<Note>
  Make sure to read any `CONTRIBUTING.md` file in the repository for additional guidelines.
</Note>

---

## Need Help?

<CardGroup cols={2}>
  <Card
    title="GitHub Discussions"
    icon="comments"
    href="https://github.com/amruthpillai/reactive-resume/discussions"
  >
    Ask questions and discuss ideas with the community.
  </Card>
  <Card
    title="GitHub Issues"
    icon="bug"
    href="https://github.com/amruthpillai/reactive-resume/issues"
  >
    Report bugs or request features.
  </Card>
</CardGroup>


--- docs/guides/checking-service-status.mdx ---
---
title: "Checking Service Status"
description: "Learn how to check the status of Reactive Resume's servers and what to do if the service is experiencing issues"
---

## Status Page

You can monitor the health and availability of Reactive Resume's servers at any time by visiting our status page:

<Card title="Status Page" icon="signal" href="https://status.rxresu.me">
  View real-time server metrics including uptime, CPU usage, memory usage, and more.
</Card>

The status page provides information such as:

- **Uptime**: How long the servers have been running without interruption
- **CPU Usage**: Current processor utilization
- **Memory Usage**: RAM consumption across services
- **Response Times**: How quickly the servers are responding to requests

---

## What to Do If Servers Are Down

If you notice the servers are experiencing high load or downtime, here are some recommendations:

<Steps>
  <Step title="Check the status page">
    Visit [status.rxresu.me](https://status.rxresu.me) to confirm if there's an ongoing issue. The page will show you the current state of all services.
  </Step>

  <Step title="Wait and try again later">
    If the servers are under heavy load, the best course of action is to wait a bit and try again later. Peak usage times can cause temporary slowdowns.

    <Info>
      Reactive Resume is a **free, open-source service** used by thousands of people worldwide. During peak times, the servers may experience higher than usual load.
    </Info>
  </Step>

  <Step title="Check for announcements">
    For major outages or planned maintenance, announcements may be posted on our [GitHub repository](https://github.com/amruthpillai/reactive-resume).
  </Step>
</Steps>

---

## A Note on Server Capacity

<Warning>
  Reactive Resume is a **free service** that runs on limited server resources. As an open-source project maintained by a single developer, it's not feasible to invest in powerful dedicated servers without community support.
</Warning>

The reality is:

- **High demand**: Thousands of users rely on this service daily
- **Limited resources**: As a free service, server capacity is constrained
- **No corporate backing**: This isn't a venture-funded startup with unlimited cloud budgets

If you find Reactive Resume valuable and want to help keep the servers running smoothly (and maybe even help scale them up), please consider supporting the project.

---

## Support the Project

Your donations directly help cover server costs, improve infrastructure, and keep Reactive Resume free for everyone.

<Card title="Donate on Open Collective" icon="heart" href="https://opencollective.com/reactive-resume">
  Support Reactive Resume's development and server costs through Open Collective. Every contribution helps keep the service running.
</Card>

<CardGroup cols={2}>
  <Card title="One-time Donation" icon="gift">
    Make a single contribution of any amount to help with immediate server costs.
  </Card>
  <Card title="Recurring Support" icon="repeat">
    Become a backer with a monthly contribution to provide sustainable support.
  </Card>
</CardGroup>

---

## Self-Hosting as an Alternative

If you need guaranteed uptime or want to avoid shared server limitations, you can always self-host Reactive Resume on your own infrastructure.

<Card title="Self-Hosting Guide" icon="server" href="/self-hosting/docker">
  Learn how to deploy Reactive Resume on your own servers using Docker.
</Card>

Self-hosting gives you:

- **Full control** over your data and infrastructure
- **Guaranteed availability** based on your own server capacity
- **No shared resources** with other users


## Links discovered
- [status.rxresu.me](https://status.rxresu.me)
- [GitHub repository](https://github.com/amruthpillai/reactive-resume)

--- docs/guides/choosing-a-template.mdx ---
---
title: "Choosing a template"
description: "Learn how to choose the perfect template for your resume and explore all available template designs in Reactive Resume."
---

Reactive Resume offers a variety of unique templates, each with its own design aesthetic. This guide will help you understand the differences between templates and how to change your resume's template at any time.

## How to change your template

Changing your resume template is simple and can be done at any time without losing any of your content.

<Steps>
  <Step title="Open your resume in the builder">
    Navigate to your Dashboard and click on the resume you want to edit.

    <Frame caption="Screenshot of your resumes dashboard showing all your resume">
      <img src="/images/guides/choosing-a-template/screenshot-1.webp" alt="Screenshot of your resumes dashboard showing all your resume" />
    </Frame>
  </Step>

  <Step title="Open the right sidebar">
    In the resume builder, look for the right sidebar. This is where you'll find all the design and layout options.
  </Step>

  <Step title="Navigate to the Template section">
    In the right sidebar, find and click on the **Template** section to expand it.

    <Frame caption="Screenshot of the template section in the right sidebar">
      <img src="/images/guides/choosing-a-template/screenshot-2.webp" alt="Screenshot of the template section in the right sidebar" />
    </Frame>
  </Step>

  <Step title="Select your new template">
    Browse through the available templates and click on the one you want to use. Your resume will instantly update to reflect the new design.

    <Frame caption="Screenshot of selecting a new template from the gallery">
      <img src="/images/guides/choosing-a-template/screenshot-3.webp" alt="Screenshot of selecting a new template from the gallery" />
    </Frame>
  </Step>

  <Step title="Review and adjust">
    After changing the template, review your resume in the live preview. You may want to adjust spacing, colors, or layout to optimize for the new design.

    <Frame caption="Screenshot of the resume with a new template applied">
      <img src="/images/guides/choosing-a-template/screenshot-4.webp" alt="Screenshot of the resume with a new template applied" />
    </Frame>

    <Tip>
      Different templates may display your content differently. Some templates work better with shorter content, while others are designed to handle more detailed information.
    </Tip>
  </Step>
</Steps>

## Tips for choosing the right template

<AccordionGroup>
  <Accordion title="Consider your industry" icon="briefcase">
    Different industries have different expectations:
    - **Creative fields** (design, marketing, arts): Templates with more visual flair like Gengar or Pikachu
    - **Corporate/Traditional** (finance, law, consulting): Clean, minimal templates like Onyx or Ditto
    - **Tech/Startups**: Modern, balanced templates like Chikorita or Leafish
  </Accordion>

  <Accordion title="Think about content length" icon="ruler">
    If you have a lot of experience to showcase, choose a template with efficient space usage. For shorter resumes, templates with more white space can make your content feel more substantial.
  </Accordion>

  <Accordion title="Match your personal brand" icon="palette">
    Your resume is part of your personal brand. Choose a template that reflects your personality while remaining professional and appropriate for your target roles.
  </Accordion>

  <Accordion title="Test with real content" icon="file-lines">
    Don't choose a template based on how it looks empty. Fill in your actual content and see how it flows across pages. What looks great with sample data might not work as well with your specific information.
  </Accordion>
</AccordionGroup>

---

## Available templates

Reactive Resume includes a variety of professionally designed templates. Each template can be further customized with your choice of colors, fonts, and layout options.

<Info>
  All templates support the same features and sections. The difference is purely in how they present your information visually.
</Info>

<div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
  <Frame caption="Azurill">
    <img src="/images/templates/azurill.webp" alt="Azurill template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Bronzor">
    <img src="/images/templates/bronzor.webp" alt="Bronzor template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Chikorita">
    <img src="/images/templates/chikorita.webp" alt="Chikorita template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Ditto">
    <img src="/images/templates/ditto.webp" alt="Ditto template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Ditgar">
    <img src="/images/templates/ditgar.webp" alt="Ditgar template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Gengar">
    <img src="/images/templates/gengar.webp" alt="Gengar template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Glalie">
    <img src="/images/templates/glalie.webp" alt="Glalie template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Kakuna">
    <img src="/images/templates/kakuna.webp" alt="Kakuna template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Lapras">
    <img src="/images/templates/lapras.webp" alt="Lapras template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Leafish">
    <img src="/images/templates/leafish.webp" alt="Leafish template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Onyx">
    <img src="/images/templates/onyx.webp" alt="Onyx template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Pikachu">
    <img src="/images/templates/pikachu.webp" alt="Pikachu template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>

  <Frame caption="Rhyhorn">
    <img src="/images/templates/rhyhorn.webp" alt="Rhyhorn template preview" style={{ aspectRatio: "210/297" }} />
  </Frame>
</div>

---

## Customizing your template

After selecting a template, you can customize it further:

| Setting | Description |
|---------|-------------|
| **Colors** | Change the primary color scheme to match your personal brand |
| **Typography** | Choose from various Google Fonts for headings and body text |
| **Layout** | Adjust sidebar width, section order, and page margins |
| **Spacing** | Fine-tune gaps between sections and elements |

<Tip>
  For more advanced customization options, check out [Using Custom CSS](/guides/using-custom-css).
</Tip>


## Links discovered
- [Using Custom CSS](https://github.com/AmruthPillai/Reactive-Resume/blob/main/guides/using-custom-css.md)

--- docs/guides/creating-an-account.mdx ---
---
title: "Creating an account"
description: "Learn how to create an account on Reactive Resume and get started on building your resume"
---

<Steps>
  <Step title="Visit the homepage">
    Head over to [https://rxresu.me](https://rxresu.me) and click on the <Badge>Get Started</Badge> button.
  </Step>
  
  <Step title="Navigate to the sign up page">
    You should see a link that says <Badge>Don't have an account? Create one now →</Badge>. Click on that link to go to the sign up page and you should see a form.
  </Step>
  
  <Step title="Fill in your details">
    Complete the sign up form with the following information:
    
    - **Name**: Your full name
    - **Email Address**: A valid email address you have access to.
    - **Username**: Choose a unique username (this will be used in your public resume URLs)
    - **Password**: Create a strong password

    <Warning>
      Make sure to choose a username you're happy with, as it will be part of your public resume URL (e.g., `rxresu.me/your-username/resume-slug`).
    </Warning>
  </Step>
  
  <Step title="Sign up and log in">
    After filling in all the required fields, click the **Sign Up** button. You will be immediately logged in and can start using Reactive Resume right away.
    
    <Tip>
      No email verification is required to get started. However, it is highly recommended to verify your email address for account security.
    </Tip>
  </Step>
  
  <Step title="Verify your email (recommended)">
    While email verification is optional, it is strongly recommended to verify your email address. This helps in:
    
    - **Securing your account**: Ensures you have access to the email address associated with your account
    - **Password recovery**: Allows you to reset your password, in case you forget it
    
    <Info>
      You can verify your email at any time from your account settings. Look for the verification prompt in your dashboard or navigate to **Settings → Profile**.
    </Info>
  </Step>
  
  <Step title="Access your dashboard">
    Click on **Continue** and you should be taken to your Dashboard, where you can:
    
    - Create your first resume
    - Import an existing resume
    - Manage your account settings
  </Step>
</Steps>

---

## Account Security Tips

<CardGroup cols={2}>
  <Card title="Use a strong password" icon="lock">
    Create a password that's at least 8 characters long and includes a mix of letters, numbers, and special characters.
  </Card>
  <Card title="Setup 2FA/Passkeys" icon="key">
    Setup two-factor authentication or passkeys on your account to add an extra layer of security.
  </Card>
</CardGroup>

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="Username Already Taken">
    If you see an error that your username is already taken, try a different variation. Usernames must be unique across all users.
  </Accordion>
  
  <Accordion title="Email Already Registered">
    If your email is already registered, you can use the **Forgot Password** link on the login page to reset your password and regain access to your account.
  </Accordion>
  
  <Accordion title="Didn't Receive Verification Email">
    Check your spam folder first. If you still don't see it, you can request a new verification email from your account settings.
  </Accordion>
</AccordionGroup>


## Links discovered
- [https://rxresu.me](https://rxresu.me)

--- src/routes/api/auth.$.ts ---
import { createFileRoute } from "@tanstack/react-router";
import { auth } from "@/integrations/auth/config";

async function handler({ request }: { request: Request }) {
	if (request.method === "GET" && request.url.endsWith("/spec.json")) {
		const spec = await auth.api.generateOpenAPISchema();

		return Response.json(spec);
	}

	return auth.handler(request);
}

export const Route = createFileRoute("/api/auth/$")({
	server: {
		handlers: {
			GET: handler,
			POST: handler,
		},
	},
});


--- src/routes/api/health.ts ---
import { createFileRoute } from "@tanstack/react-router";
import { sql } from "drizzle-orm";
import { db } from "@/integrations/drizzle/client";
import { printerService } from "@/integrations/orpc/services/printer";
import { getStorageService } from "@/integrations/orpc/services/storage";

function isUnhealthy(check: unknown): boolean {
	return (
		!!check &&
		typeof check === "object" &&
		"status" in check &&
		typeof check.status === "string" &&
		check.status === "unhealthy"
	);
}

async function handler() {
	const checks = {
		version: process.env.npm_package_version,
		status: "healthy",
		timestamp: new Date().toISOString(),
		uptime: `${process.uptime().toFixed(2)}s`,
		database: await checkDatabase(),
		printer: await checkPrinter(),
		storage: await checkStorage(),
	};

	if (checks.status === "unhealthy" || Object.values(checks).some(isUnhealthy)) {
		checks.status = "unhealthy";
	}

	const headers = new Headers();
	const body = JSON.stringify(checks);
	headers.set("Content-Type", "application/json; charset=UTF-8");
	headers.set("Content-Length", Buffer.byteLength(body, "utf-8").toString());

	return new Response(body, {
		headers,
		status: checks.status === "unhealthy" ? 500 : 200,
	});
}

async function checkDatabase() {
	try {
		await db.execute(sql`SELECT 1`);
		return { status: "healthy" };
	} catch (error) {
		return {
			status: "unhealthy",
			error: error instanceof Error ? error.message : "Unknown error",
		};
	}
}

async function checkPrinter() {
	try {
		const result = await printerService.healthcheck();

		return { status: "healthy", ...result };
	} catch (error) {
		return {
			status: "unhealthy",
			error: error instanceof Error ? error.message : "Unknown error",
		};
	}
}

async function checkStorage() {
	try {
		const storageService = getStorageService();
		return await storageService.healthcheck();
	} catch (error) {
		return {
			status: "unhealthy",
			error: error instanceof Error ? error.message : "Unknown error",
		};
	}
}

export const Route = createFileRoute("/api/health")({
	server: {
		handlers: {
			GET: handler,
		},
	},
});


--- src/routes/api/openapi.$.ts ---
import { SmartCoercionPlugin } from "@orpc/json-schema";
import { OpenAPIGenerator } from "@orpc/openapi";
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { onError } from "@orpc/server";
import { BatchHandlerPlugin, RequestHeadersPlugin, StrictGetMethodPlugin } from "@orpc/server/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { createFileRoute } from "@tanstack/react-router";
import router from "@/integrations/orpc/router";
import { resumeDataSchema } from "@/schema/resume/data";
import { env } from "@/utils/env";
import { getLocale } from "@/utils/locale";

const openAPIHandler = new OpenAPIHandler(router, {
	plugins: [
		new BatchHandlerPlugin(),
		new RequestHeadersPlugin(),
		new StrictGetMethodPlugin(),
		new SmartCoercionPlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(`ERROR [OpenAPI]: ${error}`);
		}),
	],
});

const openAPIGenerator = new OpenAPIGenerator({
	schemaConverters: [new ZodToJsonSchemaConverter()],
});

async function handler({ request }: { request: Request }) {
	const locale = await getLocale();

	if (request.method === "GET" && request.url.endsWith("/spec.json")) {
		const spec = await openAPIGenerator.generate(router, {
			info: {
				title: "Reactive Resume",
				version: __APP_VERSION__,
				description: "Reactive Resume API",
				license: { name: "MIT", url: "https://github.com/amruthpillai/reactive-resume/blob/main/LICENSE" },
				contact: { name: "Amruth Pillai", email: "hello@amruthpillai.com", url: "https://amruthpillai.com" },
			},
			servers: [{ url: `${env.APP_URL}/api/openapi` }],
			externalDocs: { url: "https://docs.rxresu.me", description: "Reactive Resume Documentation" },
			commonSchemas: {
				ResumeData: { schema: resumeDataSchema },
			},
			components: {
				securitySchemes: {
					apiKey: {
						type: "apiKey",
						name: "x-api-key",
						in: "header",
						description: "The API key to authenticate requests.",
					},
				},
			},
			security: [{ apiKey: [] }],
			filter: ({ contract }) => !contract["~orpc"].route.tags?.includes("Internal"),
		});

		return Response.json(spec);
	}

	const { response } = await openAPIHandler.handle(request, {
		prefix: "/api/openapi",
		context: { locale, reqHeaders: request.headers },
	});

	if (!response) {
		return new Response("NOT_FOUND", { status: 404 });
	}

	return response;
}

export const Route = createFileRoute("/api/openapi/$")({
	server: {
		handlers: {
			ANY: handler,
		},
	},
});


--- src/routes/api/rpc.$.ts ---
import { onError } from "@orpc/server";
import { RPCHandler } from "@orpc/server/fetch";
import { BatchHandlerPlugin, RequestHeadersPlugin, StrictGetMethodPlugin } from "@orpc/server/plugins";
import { createFileRoute } from "@tanstack/react-router";
import router from "@/integrations/orpc/router";
import { getLocale } from "@/utils/locale";

const rpcHandler = new RPCHandler(router, {
	plugins: [new BatchHandlerPlugin(), new RequestHeadersPlugin(), new StrictGetMethodPlugin()],
	interceptors: [
		onError((error) => {
			console.error(`ERROR [oRPC]: ${error}`);
		}),
	],
});

async function handler({ request }: { request: Request }) {
	const { response } = await rpcHandler.handle(request, {
		prefix: "/api/rpc",
		context: { locale: await getLocale() },
	});

	if (!response) return new Response("NOT_FOUND", { status: 404 });

	return response;
}

export const Route = createFileRoute("/api/rpc/$")({
	server: {
		handlers: {
			ANY: handler,
		},
	},
});


--- skills/resume-builder/references/schema.md ---
# Reactive Resume Schema Reference

The complete JSON Schema is available at: https://rxresu.me/schema.json

This reference provides key structural information for generating valid resume data.

## Top-Level Structure

```json
{
  "picture": { ... },
  "basics": { ... },
  "summary": { ... },
  "sections": { ... },
  "customSections": [ ... ],
  "metadata": { ... }
}
```

## Picture Configuration

```json
{
  "hidden": false,
  "url": "https://example.com/photo.jpg",
  "size": 80,
  "rotation": 0,
  "aspectRatio": 1,
  "borderRadius": 0,
  "borderColor": "rgba(0, 0, 0, 0.5)",
  "borderWidth": 0,
  "shadowColor": "rgba(0, 0, 0, 0.5)",
  "shadowWidth": 0
}
```

## Basics

```json
{
  "name": "John Doe",
  "headline": "Senior Software Engineer",
  "email": "john@example.com",
  "phone": "+1 (555) 123-4567",
  "location": "San Francisco, CA",
  "website": { "url": "https://johndoe.com", "label": "Portfolio" },
  "customFields": []
}
```

## Summary

```json
{
  "title": "Summary",
  "columns": 1,
  "hidden": false,
  "content": "<p>HTML-formatted summary content here.</p>"
}
```

## Sections

All sections share a common structure:

```json
{
  "title": "Section Title",
  "columns": 1,
  "hidden": false,
  "items": [ ... ]
}
```

### Experience Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "company": "Acme Corp",
  "position": "Software Engineer",
  "location": "San Francisco, CA",
  "period": "Jan 2020 - Present",
  "website": { "url": "https://acme.com", "label": "" },
  "description": "<ul><li>Built scalable microservices</li><li>Led team of 5 engineers</li></ul>"
}
```

### Education Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "school": "Stanford University",
  "degree": "Bachelor of Science",
  "area": "Computer Science",
  "grade": "3.8 GPA",
  "location": "Stanford, CA",
  "period": "2012 - 2016",
  "website": { "url": "", "label": "" },
  "description": ""
}
```

### Skills Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "icon": "",
  "name": "JavaScript",
  "proficiency": "Expert",
  "level": 5,
  "keywords": ["React", "Node.js", "TypeScript"]
}
```

Level: 0-5 (0 hides the visual indicator)

### Project Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "name": "Open Source Project",
  "period": "2023 - Present",
  "website": { "url": "https://github.com/user/project", "label": "GitHub" },
  "description": "<p>Description of the project and your contributions.</p>"
}
```

### Language Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "language": "English",
  "fluency": "Native",
  "level": 5
}
```

Fluency examples: Native, Fluent, Conversational, Basic, or CEFR levels (A1-C2)

### Certification Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "title": "AWS Solutions Architect",
  "issuer": "Amazon Web Services",
  "date": "March 2023",
  "website": { "url": "https://aws.amazon.com/certification/", "label": "Verify" },
  "description": ""
}
```

### Award Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "title": "Employee of the Year",
  "awarder": "Acme Corp",
  "date": "2022",
  "website": { "url": "", "label": "" },
  "description": ""
}
```

### Publication Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "title": "Research Paper Title",
  "publisher": "IEEE",
  "date": "2021",
  "website": { "url": "https://doi.org/...", "label": "DOI" },
  "description": ""
}
```

### Volunteer Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "organization": "Local Food Bank",
  "location": "San Francisco, CA",
  "period": "2020 - Present",
  "website": { "url": "", "label": "" },
  "description": "<p>Volunteer activities and impact.</p>"
}
```

### Interest Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "icon": "",
  "name": "Photography",
  "keywords": ["Landscape", "Portrait", "Street"]
}
```

### Reference Items

```json
{
  "id": "uuid-here",
  "hidden": false,
  "name": "Jane Smith",
  "position": "Engineering Manager at Acme Corp",
  "website": { "url": "https://linkedin.com/in/janesmith", "label": "LinkedIn" },
  "phone": "+1 (555) 987-6543",
  "description": "<p>Optional testimonial or quote.</p>"
}
```

### Profile Items (Social Links)

```json
{
  "id": "uuid-here",
  "hidden": false,
  "icon": "linkedin-logo",
  "network": "LinkedIn",
  "username": "johndoe",
  "website": { "url": "https://linkedin.com/in/johndoe", "label": "" }
}
```

Icons use @phosphor-icons/web names. Common icons: `linkedin-logo`, `github-logo`, `twitter-logo`, `globe`

## Metadata

### Template Options

Available templates: `azurill`, `bronzor`, `chikorita`, `ditto`, `ditgar`, `gengar`, `glalie`, `kakuna`, `lapras`, `leafish`, `onyx`, `pikachu`, `rhyhorn`

### Layout Configuration

```json
{
  "sidebarWidth": 35,
  "pages": [
    {
      "fullWidth": false,
      "main": ["profiles", "summary", "experience", "education", "projects"],
      "sidebar": ["skills", "languages", "certifications", "interests"]
    }
  ]
}
```

Section IDs for layout: `profiles`, `experience`, `education`, `projects`, `skills`, `languages`, `interests`, `awards`, `certifications`, `publications`, `volunteer`, `references`, `summary`

### Page Settings

```json
{
  "gapX": 4,
  "gapY": 6,
  "marginX": 14,
  "marginY": 12,
  "format": "a4",
  "locale": "en-US",
  "hideIcons": false
}
```

Format options: `a4`, `letter`

### Design Settings

```json
{
  "colors": {
    "primary": "rgba(220, 38, 38, 1)",
    "text": "rgba(0, 0, 0, 1)",
    "background": "rgba(255, 255, 255, 1)"
  },
  "level": {
    "icon": "star",
    "type": "circle"
  }
}
```

Level types: `hidden`, `circle`, `square`, `rectangle`, `rectangle-full`, `progress-bar`, `icon`

### Typography

```json
{
  "body": {
    "fontFamily": "IBM Plex Serif",
    "fontWeights": ["400", "500"],
    "fontSize": 10,
    "lineHeight": 1.5
  },
  "heading": {
    "fontFamily": "IBM Plex Serif",
    "fontWeights": ["600"],
    "fontSize": 14,
    "lineHeight": 1.5
  }
}
```

Font family must be available on Google Fonts. Font weights: 100-900.

### CSS Customization

```json
{
  "enabled": false,
  "value": ""
}
```

## Custom Sections

Custom sections extend the base section structure with additional fields:

```json
{
  "id": "uuid-here",
  "title": "Custom Section Title",
  "columns": 1,
  "hidden": false,
  "type": "experience",
  "items": [ ... ]
}
```

The `type` field determines the item schema. Valid types: `profiles`, `experience`, `education`, `projects`, `skills`, `languages`, `interests`, `awards`, `certifications`, `publications`, `volunteer`, `references`

## UUID Generation

All `id` fields require valid UUIDs version 7. If available, use 'v7()' from the 'uuid' package to generate a valid UUID. Otherwise, fallback to generating a valid UUID v4 using crypto.randomUUID() from 'node' or the equivalent.

## HTML Content

Fields marked as "HTML-formatted string" accept basic HTML:
- `<p>` for paragraphs
- `<ul><li>` for bullet lists
- `<ol><li>` for numbered lists
- `<strong>` for bold
- `<em>` for italic
- `<a href="...">` for links

Keep formatting minimal for best rendering across templates.


--- CLAUDE.md ---
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Reactive Resume is a free, open-source resume builder built with TanStack Start (React 19 + Vite 8), using ORPC for type-safe RPC APIs, Drizzle ORM with PostgreSQL, Nitro as the server runtime, and Better Auth for authentication. It is a PWA with 47 supported locales and 13 resume templates.

## Development Commands

```bash
# Start development server (runs on port 3000)
pnpm dev

# Build for production
pnpm build

# Start production server
pnpm start

# Linting and formatting (uses Biome)
pnpm lint

# Type checking (uses tsgo)
pnpm typecheck

# Database operations
pnpm db:generate    # Generate migration files
pnpm db:migrate     # Run migrations
pnpm db:push        # Push schema changes directly
pnpm db:studio      # Open Drizzle Studio

# Extract i18n strings for translation
pnpm lingui:extract

# Find unused exports / dead code
dotenvx run -- pnpm knip
```

**There is no test framework configured.** No unit, integration, or E2E tests exist in the codebase.

## Local Development Setup

1. Copy `.env.example` to `.env` and configure environment variables
2. Start required services: `docker compose -f compose.dev.yml up -d`
   - PostgreSQL (port 5432)
   - Browserless/Chromium for PDF generation (port 4000)
   - SeaweedFS for S3-compatible storage (port 8333)
   - Mailpit for email testing (ports 1025, 8025)
   - Adminer for DB management (port 8080)
3. Run `pnpm dev`

Database migrations run automatically on server startup via the Nitro plugin at `plugins/1.migrate.ts`.

## Architecture

### Directory Structure

- `src/routes/` - TanStack Router file-based routing
- `src/integrations/` - External service integrations (auth, database, ORPC, AI, email, import)
- `src/integrations/orpc/router/` - oRPC server routers (procedure definitions)
- `src/integrations/orpc/services/` - oRPC server services (business logic)
- `src/integrations/orpc/dto/` - Data transfer objects
- `src/integrations/orpc/context.ts` - Auth and request context setup
- `src/components/` - React components organized by feature
- `src/components/ui/` - Shadcn UI components (Radix + Phosphor icons)
- `src/schema/` - Zod schemas for validation
- `src/hooks/` - Custom React hooks
- `plugins/` - Nitro server plugins (auto-migration on startup)
- `migrations/` - Drizzle database migrations
- `locales/` - i18n translation files (managed by Lingui)
- `docs/` - Documentation (Mintlify)

### Key Integrations (`src/integrations/`)

- **auth/** - Better Auth configuration (session-based + API key via `x-api-key` header)
- **drizzle/** - Database schema and client (PostgreSQL)
- **orpc/** - Type-safe RPC router with procedures for ai, auth, flags, printer, resume, statistics, storage
- **query/** - TanStack Query client configuration
- **ai/** - AI provider integrations (OpenAI, Anthropic, Google Gemini, Ollama)
- **email/** - Nodemailer integration (falls back to console logging if SMTP is not configured)
- **import/** - Resume file parsing/import

### ORPC Procedure Types

Three procedure types exist in `src/integrations/orpc/context.ts`:
- `publicProcedure` - No authentication required
- `protectedProcedure` - Requires authenticated user (session or API key)
- `serverOnlyProcedure` - Server-side calls only

Procedures follow this pattern:
```ts
const handler = protectedProcedure
  .route({ method: "GET", path: "/resumes/{id}", tags: ["Resumes"], ... })
  .input(schema)
  .output(schema)
  .handler(async ({ context, input }) => { ... })
```

### Resume Data Model

The resume schema is defined in `src/schema/resume/data.ts`. Key concepts:
- **ResumeData** - Complete resume data including basics, sections, customSections, metadata
- **Sections** - Built-in sections (profiles, experience, education, skills, etc.)
- **CustomSections** - User-created sections that follow one of the built-in section types
- **Metadata** - Template, layout, typography, design settings, custom CSS

### Resume Templates

13 templates in `src/components/resume/templates/` (Pokemon-themed names):
azurill, bronzor, chikorita, ditgar, ditto, gengar, glalie, kakuna, lapras, leafish, onyx, pikachu, rhyhorn

Shared rendering components live in `src/components/resume/shared/`.

### Database Schema

Defined in `src/integrations/drizzle/schema.ts`:
- `user`, `session`, `account`, `verification`, `twoFactor`, `passkey`, `apikey` - Better Auth tables
- `resume` - Stores Resume Data as JSONB (defined in `src/schema/resume/data.ts`)
- `resumeStatistics` - Views/Download tracking

### Routing

Uses TanStack Router with file-based routing. Key routes:
- `/_home/` - Public landing pages
- `/auth/` - Authentication flows
- `/dashboard/` - User dashboard and resume management
- `/builder/$resumeId/` - Resume editor
- `/printer/$resumeId/` - PDF rendering endpoint
- `/api/` - Public API endpoints
- `/mcp/` - MCP server endpoint for LLM integration

Routes use `createFileRoute()` with `beforeLoad()` for auth guards and `loader()` for server-side data fetching.

### MCP Server

An MCP (Model Context Protocol) server is available at `/mcp/` for LLM-based resume interaction. It requires an `x-api-key` header for authentication. Configuration is in `src/routes/mcp/` with helper modules for resources, prompts, and tools.

### State Management

- **Zustand** - Client-side state (resume editor state in `src/components/resume/store/`)
- **Zundo** - Undo/redo history for resume edits (built on Zustand)
- **TanStack Query** - Server state and caching (configured via ORPC integration)

### Global Providers

Defined in `src/routes/__root.tsx`:
- I18nProvider (Lingui), ThemeProvider, MotionConfig, IconContext (Phosphor Icons)
- ConfirmDialogProvider, PromptDialogProvider, DialogManager, CommandPalette, Toaster

## Code Style

- Uses **Biome** for linting and formatting (`biome.json`)
- Tab indentation, double quotes, 120 character line width
- Imports are auto-organized; unused imports are errors
- a11y rules are disabled
- Path alias: `@/` maps to `src/`
- Tailwind CSS v4 with sorted class names (enforced by Biome's `useSortedClasses`)
- Uses `cn()` utility (from `@/utils/style`) for conditional class names
- Uses `cva()` for component variants
- Shadcn UI components in `src/components/ui/` (Radix UI + Phosphor icons, zinc base color)
- i18n strings use Lingui macros: `<Trans>`, `t`, `msg`
- TypeScript strict mode enabled; `noUnusedLocals` and `noUnusedParameters` enforced

## Environment Variables

Key variables (see `.env.example` for full list):
- `APP_URL` - Application URL
- `DATABASE_URL` - PostgreSQL connection string
- `AUTH_SECRET` - Secret for authentication
- `PRINTER_ENDPOINT` - WebSocket endpoint for PDF printer service
- `PRINTER_APP_URL` - Internal URL for printer to reach the app (important for Docker)
- `S3_*` - S3-compatible storage configuration (falls back to local `/data` filesystem)
- `SMTP_*` - Email configuration (falls back to console logging)
- `GOOGLE_CLIENT_ID/SECRET` - Google OAuth (optional)
- `GITHUB_CLIENT_ID/SECRET` - GitHub OAuth (optional)
- `OAUTH_*` - Custom OAuth provider (optional)
- `FLAG_DEBUG_PRINTER` - Debug PDF printing endpoint
- `FLAG_DISABLE_SIGNUPS` - Block new account registration
- `FLAG_DISABLE_EMAIL_AUTH` - Disable email/password login
- `FLAG_DISABLE_IMAGE_PROCESSING` - Disable image processing

## Build & Deployment

- **Build output**: `.output/` directory (Nitro server bundle)
- **Production start**: `node .output/server/index.mjs`
- **Docker**: Multi-stage Dockerfile with Node 24-slim base
- **Health check**: `GET /api/health`
- **PWA**: Configured via vite-plugin-pwa with auto-update, standalone display, dark theme


--- README.md ---
<div align="center">
  <a href="https://rxresu.me">
    <img src="public/opengraph/banner.jpg" alt="Reactive Resume" />
  </a>

  <h1>Reactive Resume</h1>

  <p>Reactive Resume is a free and open-source resume builder that simplifies the process of creating, updating, and sharing your resume.</p>

  <p>
    <a href="https://rxresu.me"><strong>Get Started</strong></a>
    ·
    <a href="https://docs.rxresu.me"><strong>Learn More</strong></a>
  </p>

  <p>
    <img src="https://img.shields.io/github/package-json/v/amruthpillai/reactive-resume?style=flat-square" alt="Reactive Resume version">
    <img src="https://img.shields.io/github/stars/amruthpillai/Reactive-Resume?style=flat-square" alt="GitHub Stars">
    <img src="https://img.shields.io/github/license/amruthpillai/Reactive-Resume?style=flat-square" alt="License" />
    <img src="https://img.shields.io/docker/pulls/amruthpillai/reactive-resume?style=flat-square" alt="Docker Pulls" />
    <a href="https://discord.gg/aSyA5ZSxpb"><img src="https://img.shields.io/discord/1173518977851473940?style=flat-square&label=discord" alt="Discord" /></a>
    <a href="https://crowdin.com/project/reactive-resume"><img src="https://badges.crowdin.net/reactive-resume/localized.svg?style=flat-square" alt="Crowdin" /></a>
    <a href="https://github.com/sponsors/AmruthPillai"><img src="https://img.shields.io/github/sponsors/AmruthPillai?style=flat-square&label=sponsors" alt="Sponsors" /></a>
    <a href="https://opencollective.com/reactive-resume"><img src="https://img.shields.io/opencollective/backers/reactive-resume?style=flat-square&label=donations" alt="Donations" /></a>
  </p>
</div>

---

Reactive Resume makes building resumes straightforward. Pick a template, fill in your details, and export to PDF—no account required for basic use. For those who want more control, the entire application can be self-hosted on your own infrastructure.

Built with privacy as a core principle, Reactive Resume gives you complete ownership of your data. The codebase is fully open-source under the MIT license, with no tracking, no ads, and no hidden costs.

## Features

**Resume Building**

- Real-time preview as you type
- Multiple export formats (PDF, JSON)
- Drag-and-drop section ordering
- Custom sections for any content type
- Rich text editor with formatting support

**Templates**

- Professionally designed templates
- A4 and Letter size support
- Customizable colors, fonts, and spacing
- Custom CSS for advanced styling

**Privacy & Control**

- Self-host on your own infrastructure
- No tracking or analytics by default
- Full data export at any time
- Delete your data permanently with one click

**Extras**

- AI integration (OpenAI, Google Gemini, Anthropic Claude)
- Multi-language support
- Share resumes via unique links
- Import from JSON Resume format
- Dark mode support
- Passkey and two-factor authentication

## Templates

<table>
  <tr>
    <td align="center">
      <img src="public/templates/jpg/azurill.jpg" alt="Azurill" width="150" />
      <br /><sub><b>Azurill</b></sub>
    </td>
    <td align="center">
      <img src="public/templates/jpg/bronzor.jpg" alt="Bronzor" width="150" />
      <br /><sub><b>Bronzor</b></sub>
    </td>
    <td align="center">
      <img src="public/templates/jpg/chikorita.jpg" alt="Chikorita" width="150" />
      <br /><sub><b>Chikorita</b></sub>
    </td>
    <td align="center">
      <img src="public/templates/jpg/ditto.jpg" alt="Ditto" width="150" />
      <br /><sub><b>Ditto</b></sub>
    </td>
  </tr>
  <tr>
    <td align="center">
      <img src="public/templates/jpg/gengar.jpg" alt="Gengar" width="150" />
      <br /><sub><b>Gengar</b></sub>
    </td>
    <td align="center">
      <img src="public/templates/jpg/glalie.jpg" alt="Glalie" width="150" />
      <br /><sub><b>Glalie</b></sub>
    </td>
    <td align="center">
      <img src="public/templates/jpg/kakuna.jpg" alt="Kakuna" width="150" />
      <br /><sub><b>Kakuna</b></sub>
    </td>
    <td align="center">
      <img src="public/templates/jpg/lapras.jpg" alt="Lapras" width="150" />
      <br /><sub><b>Lapras</b></sub>
    </td>
  </tr>
  <tr>
    <td align="center">
      <img src="public/templates/jpg/leafish.jpg" alt="Leafish" width="150" />
      <br /><sub><b>Leafish</b></sub>
    </td>
    <td align="center">
      <img src="public/templates/jpg/onyx.jpg" alt="Onyx" width="150" />
      <br /><sub><b>Onyx</b></sub>
    </td>
    <td align="center">
      <img src="public/templates/jpg/pikachu.jpg" alt="Pikachu" width="150" />
      <br /><sub><b>Pikachu</b></sub>
    </td>
    <td align="center">
      <img src="public/templates/jpg/rhyhorn.jpg" alt="Rhyhorn" width="150" />
      <br /><sub><b>Rhyhorn</b></sub>
    </td>
  </tr>
  <tr>
    <td align="center">
      <img src="public/templates/jpg/ditgar.jpg" alt="Ditgar" width="150" />
      <br /><sub><b>Ditgar</b></sub>
    </td>
  </tr>
</table>

## Quick Start

The quickest way to run Reactive Resume locally:

```bash
# Clone the repository
git clone https://github.com/amruthpillai/reactive-resume.git
cd reactive-resume

# Start all services
docker compose up -d

# Access the app
open http://localhost:3000
```

[![Build with Ona](https://ona.com/build-with-ona.svg)](https://app.ona.com/#https://github.com/amruthpillai/reactive-resume)

For detailed setup instructions, environment configuration, and self-hosting guides, see the [documentation](https://docs.rxresu.me).

## Tech Stack

| Category         | Technology                           |
| ---------------- | ------------------------------------ |
| Framework        | TanStack Start (React 19, Vite)      |
| Runtime          | Node.js                              |
| Language         | TypeScript                           |
| Database         | PostgreSQL with Drizzle ORM          |
| API              | ORPC (Type-safe RPC)                 |
| Auth             | Better Auth                          |
| Styling          | Tailwind CSS                         |
| UI Components    | Radix UI                             |
| State Management | Zustand + TanStack Query             |

## Documentation

Comprehensive guides are available at [docs.rxresu.me](https://docs.rxresu.me):

| Guide                                                                       | Description                       |
| --------------------------------------------------------------------------- | --------------------------------- |
| [Getting Started](https://docs.rxresu.me/getting-started)                   | First-time setup and basic usage  |
| [Self-Hosting](https://docs.rxresu.me/self-hosting/docker)                  | Deploy on your own server         |
| [Development Setup](https://docs.rxresu.me/contributing/development)        | Local development environment     |
| [Project Architecture](https://docs.rxresu.me/contributing/architecture)    | Codebase structure and patterns   |
| [Exporting Your Resume](https://docs.rxresu.me/guides/exporting-your-resume)| PDF and JSON export options       |

## Self-Hosting

Reactive Resume can be self-hosted using Docker. The stack includes:

- **PostgreSQL** — Database for storing user data and resumes
- **Printer** — Headless Chromium service for PDF and screenshot generation
- **SeaweedFS** (optional) — S3-compatible storage for file uploads

Pull the latest image from Docker Hub or GitHub Container Registry:

```bash
# Docker Hub
docker pull amruthpillai/reactive-resume:latest

# GitHub Container Registry
docker pull ghcr.io/amruthpillai/reactive-resume:latest
```

See the [self-hosting guide](https://docs.rxresu.me/self-hosting/docker) for complete instructions.

## Support

Reactive Resume is and always will be free and open-source. If it has helped you land a job or saved you time, please consider supporting continued development:

<p>
  <a href="https://github.com/sponsors/AmruthPillai">
    <img src="https://img.shields.io/badge/GitHub%20Sponsors-Support-ea4aaa?style=flat-square&logo=github-sponsors" alt="GitHub Sponsors" />
  </a>
  <a href="https://opencollective.com/reactive-resume">
    <img src="https://img.shields.io/badge/Open%20Collective-Contribute-7FADF2?style=flat-square&logo=open-collective" alt="Open Collective" />
  </a>
</p>

Other ways to support:

- Star this repository
- Report bugs and suggest features
- Improve documentation
- Help with translations

## Star History

<a href="https://www.star-history.com/#amruthpillai/reactive-resume&type=date&legend=top-left">
 <picture>
   <source media="(prefers-color-scheme: dark)" srcset="https://api.star-history.com/svg?repos=amruthpillai/reactive-resume&type=date&theme=dark&legend=top-left" />
   <source media="(prefers-color-scheme: light)" srcset="https://api.star-history.com/svg?repos=amruthpillai/reactive-resume&type=date&legend=top-left" />
   <img alt="Star History Chart" src="https://api.star-history.com/svg?repos=amruthpillai/reactive-resume&type=date&legend=top-left" />
 </picture>
</a>

## Contributing

Contributions make open-source thrive. Whether fixing a typo or adding a feature, all contributions are welcome.

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

See the [development setup guide](https://docs.rxresu.me/contributing/development) for detailed instructions on how to set up the project locally.

## License

[MIT](./LICENSE) — do whatever you want with it.


## Links discovered
- [![Build with Ona](https://ona.com/build-with-ona.svg)
- [documentation](https://docs.rxresu.me)
- [docs.rxresu.me](https://docs.rxresu.me)
- [Getting Started](https://docs.rxresu.me/getting-started)
- [Self-Hosting](https://docs.rxresu.me/self-hosting/docker)
- [Development Setup](https://docs.rxresu.me/contributing/development)
- [Project Architecture](https://docs.rxresu.me/contributing/architecture)
- [Exporting Your Resume](https://docs.rxresu.me/guides/exporting-your-resume)
- [self-hosting guide](https://docs.rxresu.me/self-hosting/docker)
- [development setup guide](https://docs.rxresu.me/contributing/development)
- [MIT](https://github.com/AmruthPillai/Reactive-Resume/blob/main/LICENSE.md)
- [<img src="public/opengraph/banner.jpg" alt="Reactive Resume" />](https://rxresu.me)
- [<strong>Get Started</strong>](https://rxresu.me)
- [<strong>Learn More</strong>](https://docs.rxresu.me)
- [<img src="https://img.shields.io/discord/1173518977851473940?style=flat-square&label=discord" alt="Discord" />](https://discord.gg/aSyA5ZSxpb)
- [<img src="https://badges.crowdin.net/reactive-resume/localized.svg?style=flat-square" alt="Crowdin" />](https://crowdin.com/project/reactive-resume)
- [<img src="https://img.shields.io/github/sponsors/AmruthPillai?style=flat-square&label=sponsors" alt="Sponsors" />](https://github.com/sponsors/AmruthPillai)
- [<img src="https://img.shields.io/opencollective/backers/reactive-resume?style=flat-square&label=donations" alt="Donations" />](https://opencollective.com/reactive-resume)
- [<img src="https://img.shields.io/badge/GitHub%20Sponsors-Support-ea4aaa?style=flat-square&logo=github-sponsors" alt="GitHub Sponsors" />](https://github.com/sponsors/AmruthPillai)
- [<img src="https://img.shields.io/badge/Open%20Collective-Contribute-7FADF2?style=flat-square&logo=open-collective" alt="Open Collective" />](https://opencollective.com/reactive-resume)

--- drizzle.config.ts ---
import { defineConfig } from "drizzle-kit";
import invariant from "tiny-invariant";

invariant(process.env.DATABASE_URL, "DATABASE_URL is not set");

export default defineConfig({
	out: "./migrations",
	dialect: "postgresql",
	schema: "./src/integrations/drizzle/schema.ts",
	dbCredentials: {
		url: process.env.DATABASE_URL,
	},
});


--- lingui.config.ts ---
import { defineConfig } from "@lingui/cli";

export default defineConfig({
	sourceLocale: "en-US",
	pseudoLocale: "zu-ZA",
	locales: [
		"af-ZA",
		"am-ET",
		"ar-SA",
		"az-AZ",
		"bg-BG",
		"bn-BD",
		"ca-ES",
		"cs-CZ",
		"da-DK",
		"de-DE",
		"el-GR",
		"en-US",
		"es-ES",
		"fa-IR",
		"fi-FI",
		"fr-FR",
		"he-IL",
		"hi-IN",
		"hu-HU",
		"id-ID",
		"it-IT",
		"ja-JP",
		"km-KH",
		"kn-IN",
		"ko-KR",
		"lt-LT",
		"lv-LV",
		"ml-IN",
		"mr-IN",
		"ms-MY",
		"ne-NP",
		"nl-NL",
		"no-NO",
		"or-IN",
		"pl-PL",
		"pt-BR",
		"pt-PT",
		"ro-RO",
		"ru-RU",
		"sk-SK",
		"sq-AL",
		"sr-SP",
		"sv-SE",
		"ta-IN",
		"te-IN",
		"th-TH",
		"tr-TR",
		"uk-UA",
		"uz-UZ",
		"vi-VN",
		"zh-CN",
		"zh-TW",
		"zu-ZA",
	],
	fallbackLocales: {
		"zu-ZA": "en-US",
		default: "en-US",
	},
	formatOptions: {
		lineNumbers: false,
	},
	catalogs: [
		{
			path: "<rootDir>/locales/{locale}",
			include: ["src"],
		},
	],
});


--- plugins/1.migrate.ts ---
import { drizzle } from "drizzle-orm/node-postgres";
import { migrate } from "drizzle-orm/node-postgres/migrator";
import { definePlugin } from "nitro";
import { Pool } from "pg";

async function migrateDatabase() {
	console.log("⌛ Running database migrations...");

	const connectionString = process.env.DATABASE_URL;

	if (!connectionString) {
		throw new Error("DATABASE_URL is not set");
	}

	const pool = new Pool({ connectionString });
	const db = drizzle({ client: pool });

	try {
		await migrate(db, { migrationsFolder: "./migrations" });
		console.log("✅ Database migrations completed");
	} catch (error) {
		console.error("🚨 Database migrations failed:", error);
	} finally {
		await pool.end();
	}
}

export default definePlugin(async () => {
	await migrateDatabase();
});


--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Allow: /

Sitemap: https://rxresu.me/sitemap.xml

--- skills/resume-builder/SKILL.md ---
---
name: resume-builder
description: Generate professional resumes that conform to the Reactive Resume schema. Use when the user wants to create, build, or generate a resume through conversational AI, or asks about resume structure, sections, or content. This skill guides the agent to ask clarifying questions, avoid hallucination, and produce valid JSON output for https://rxresu.me.
---

# Resume Builder for Reactive Resume

Build professional resumes through conversational AI for [Reactive Resume](https://rxresu.me), a free and open-source resume builder.

## Core Principles

1. **Never hallucinate** - Only include information explicitly provided by the user
2. **Ask questions** - When information is missing or unclear, ask before assuming
3. **Be concise** - Use clear, direct language; avoid filler words
4. **Validate output** - Ensure all generated JSON conforms to the schema

## Workflow

### Step 1: Gather Basic Information

Ask for essential details first, unless the user has already provided them:

- Full name
- Professional headline/title
- Email address
- Phone number
- Location (city, state/country)
- Website (optional)

### Step 2: Collect Section Content

For each section the user wants to include, gather specific details. Never invent dates, company names, or achievements.

**Experience**: company, position, location, period (e.g., "Jan 2020 - Present"), description of responsibilities/achievements

**Education**: school, degree, area of study, grade (optional), location, period

**Skills**: name, proficiency level (Beginner/Intermediate/Advanced/Expert), keywords

**Projects**: name, period, website (optional), description

**Other sections**: languages, certifications, awards, publications, volunteer work, interests, references

### Step 3: Configure Layout and Design

Ask about preferences:

- Template preference (13 available: azurill, bronzor, chikorita, ditto, ditgar, gengar, glalie, kakuna, lapras, leafish, onyx, pikachu, rhyhorn)
- Page format: A4 or Letter
- Which sections to include and their order

### Step 4: Generate Valid JSON

Output must conform to the Reactive Resume schema. See [references/schema.md](references/schema.md) for the complete schema structure.

Key requirements:
- All item `id` fields must be valid UUIDs
- Description fields accept HTML-formatted strings
- Website fields require both `url` and `label` properties
- Colors use `rgba(r, g, b, a)` format
- Fonts must be available on Google Fonts

## Resume Writing Tips

Share these tips when helping users craft their resume content:

### Content Guidelines

- **Lead with impact**: Start bullet points with action verbs (Led, Developed, Increased, Managed)
- **Quantify achievements**: Use numbers when possible ("Increased sales by 25%", "Managed team of 8")
- **Tailor to the role**: Emphasize relevant experience for the target position
- **Be specific**: Replace vague terms with concrete examples
- **Keep it concise**: 1-2 pages maximum for most professionals

### Section Order Recommendations

For most professionals:
1. Summary (if experienced)
2. Experience
3. Education
4. Skills
5. Projects (if relevant)
6. Certifications/Awards

For students/recent graduates:
1. Education
2. Projects
3. Skills
4. Experience (if any)
5. Activities/Volunteer

### Common Mistakes to Avoid

- Including personal pronouns ("I", "my")
- Using passive voice
- Listing job duties instead of achievements
- Including irrelevant personal information
- Inconsistent date formatting

## Output Format

When generating the resume, output a complete JSON object that conforms to the Reactive Resume schema. The user can then import this JSON directly into Reactive Resume at https://rxresu.me.

Example minimal structure:

```json
{
  "picture": { "hidden": true, "url": "", "size": 80, "rotation": 0, "aspectRatio": 1, "borderRadius": 0, "borderColor": "rgba(0, 0, 0, 0.5)", "borderWidth": 0, "shadowColor": "rgba(0, 0, 0, 0.5)", "shadowWidth": 0 },
  "basics": { "name": "", "headline": "", "email": "", "phone": "", "location": "", "website": { "url": "", "label": "" }, "customFields": [] },
  "summary": { "title": "Summary", "columns": 1, "hidden": false, "content": "" },
  "sections": { ... },
  "customSections": [],
  "metadata": { "template": "onyx", "layout": { ... }, ... }
}
```

For the complete schema, see [references/schema.md](references/schema.md).

## Asking Good Questions

When information is missing, ask specific questions:

- "What was your job title at [Company]?"
- "What dates did you work there? (e.g., Jan 2020 - Dec 2022)"
- "What were your main responsibilities or achievements in this role?"
- "Do you have a specific target role or industry in mind?"

Avoid compound questions. Ask one thing at a time for clarity.


## Links discovered
- [Reactive Resume](https://rxresu.me)
- [references/schema.md](https://github.com/AmruthPillai/Reactive-Resume/blob/main/skills/resume-builder/references/schema.md)

--- vite.config.ts ---
import { lingui } from "@lingui/vite-plugin";
import tailwindcss from "@tailwindcss/vite";
import { tanstackStart } from "@tanstack/react-start/plugin/vite";
import viteReact from "@vitejs/plugin-react";
import { nitro } from "nitro/vite";
import { defineConfig } from "vite";
import { VitePWA } from "vite-plugin-pwa";

const config = defineConfig({
	define: {
		__APP_VERSION__: JSON.stringify(process.env.npm_package_version),
	},

	resolve: {
		tsconfigPaths: true,
	},

	build: {
		sourcemap: true,
		chunkSizeWarningLimit: 10 * 1024, // 10mb
	},

	server: {
		host: true,
		port: 3000,
		strictPort: true,
		allowedHosts: true,
		hmr: {
			host: "localhost",
			port: 3000,
		},
	},

	plugins: [
		lingui(),
		tailwindcss(),
		nitro({ plugins: ["plugins/1.migrate.ts"] }),
		tanstackStart({ router: { semicolons: true, quoteStyle: "double" } }),
		viteReact({ babel: { plugins: ["@lingui/babel-plugin-lingui-macro"] } }),
		VitePWA({
			outDir: "public",
			useCredentials: true,
			injectRegister: false,
			includeAssets: ["**/*"],
			registerType: "autoUpdate",
			workbox: {
				skipWaiting: true,
				clientsClaim: true,
				globPatterns: ["**/*"],
				maximumFileSizeToCacheInBytes: 10 * 1024 * 1024, // 10mb
				navigateFallback: null, // Disable navigation fallback for SSR
			},
			manifest: {
				name: "Reactive Resume",
				short_name: "Reactive Resume",
				description: "A free and open-source resume builder.",
				id: "/?source=pwa",
				start_url: "/?source=pwa",
				display: "standalone",
				orientation: "portrait",
				theme_color: "#09090B",
				background_color: "#09090B",
				icons: [
					{
						src: "favicon.ico",
						sizes: "128x128",
						type: "image/x-icon",
					},
					{
						src: "pwa-64x64.png",
						sizes: "64x64",
						type: "image/png",
					},
					{
						src: "pwa-192x192.png",
						sizes: "192x192",
						type: "image/png",
					},
					{
						src: "pwa-512x512.png",
						sizes: "512x512",
						type: "image/png",
						purpose: "any",
					},
					{
						src: "maskable-icon-512x512.png",
						sizes: "512x512",
						type: "image/png",
						purpose: "maskable",
					},
				],
				screenshots: [
					{
						src: "screenshots/web/1-landing-page.webp",
						sizes: "1920x1080 any",
						type: "image/webp",
						form_factor: "wide",
						label: "Landing Page",
					},
					{
						src: "screenshots/web/2-resume-dashboard.webp",
						sizes: "1920x1080 any",
						type: "image/webp",
						form_factor: "wide",
						label: "Resume Dashboard",
					},
					{
						src: "screenshots/web/3-builder-screen.webp",
						sizes: "1920x1080 any",
						type: "image/webp",
						form_factor: "wide",
						label: "Builder Screen",
					},
					{
						src: "screenshots/web/4-template-gallery.webp",
						sizes: "1920x1080 any",
						type: "image/webp",
						form_factor: "wide",
						label: "Template Gallery",
					},
					{
						src: "screenshots/mobile/1-landing-page.webp",
						sizes: "1284x2778 any",
						type: "image/webp",
						form_factor: "narrow",
						label: "Landing Page",
					},
					{
						src: "screenshots/mobile/2-resume-dashboard.webp",
						sizes: "1284x2778 any",
						type: "image/webp",
						form_factor: "narrow",
						label: "Resume Dashboard",
					},
					{
						src: "screenshots/mobile/3-builder-screen.webp",
						sizes: "1284x2778 any",
						type: "image/webp",
						form_factor: "narrow",
						label: "Builder Screen",
					},
					{
						src: "screenshots/mobile/4-template-gallery.webp",
						sizes: "1284x2778 any",
						type: "image/webp",
						form_factor: "narrow",
						label: "Template Gallery",
					},
				],
				categories: [
					"ai",
					"builder",
					"business",
					"career",
					"cv",
					"editor",
					"free",
					"generator",
					"job-search",
					"multilingual",
					"open-source",
					"privacy",
					"productivity",
					"resume",
					"self-hosted",
					"templates",
					"utilities",
					"writing",
				],
			},
		}),
	],
});

export default config;


--- scripts/fonts/generate.ts ---
/**
 * This script generates a JSON file containing the fonts served by Google Fonts,
 * and also injects the Computer Modern font families as served by https://github.com/bitmaks/cm-web-fonts
 * to ensure they appear in the application's typography options.
 *
 * See:
 * - Google Fonts API: https://developers.google.com/fonts/docs/developer_api
 * - Computer Modern Web Fonts: https://github.com/bitmaks/cm-web-fonts
 */

import { mkdir, readFile, writeFile } from "node:fs/promises";
import type { APIResponse, Variant, WebFont, Weight } from "./types";

const args = process.argv.slice(2);
const argForce = args.includes("--force");
const argCompress = args.includes("--compress");
const argLimit = args.includes("--limit") ? parseInt(args[args.indexOf("--limit") + 1], 10) : 500;

const skippedFamilies = ["Material Icons", "Material Symbols", "Noto Color Emoji"];

const FONTS_DIR = "./scripts/fonts";
const RESPONSE_FILE = `${FONTS_DIR}/response.json`;
const WEBFONTLIST_FILE = `${FONTS_DIR}/webfontlist.json`;

/** Returns JSON from Google Fonts API or (unless --force) from local cache if it exists */
async function getGoogleFontsJSON() {
	let contents: string | null = null;

	try {
		contents = await readFile(RESPONSE_FILE, "utf-8");
	} catch {
		// If the file doesn't exist or there's an error reading, just continue.
	}

	if (!argForce && contents) return JSON.parse(contents) as APIResponse;

	const apiKey = process.env.GOOGLE_CLOUD_API_KEY;
	if (!apiKey) throw new Error("GOOGLE_CLOUD_API_KEY is not set");

	const url = `https://www.googleapis.com/webfonts/v1/webfonts?key=${apiKey}&sort=popularity`;
	const response = await fetch(url);
	const data = (await response.json()) as APIResponse;

	const jsonString = argCompress ? JSON.stringify(data) : JSON.stringify(data, null, 2);
	await mkdir(FONTS_DIR, { recursive: true });
	await writeFile(RESPONSE_FILE, jsonString, "utf-8");

	return data;
}

/** Map Google Fonts API variant strings to simple weights */
function variantToWeight(variant: Variant): Weight | null {
	if (["100", "200", "300", "500", "600", "700", "800", "900"].includes(variant)) return variant as Weight;
	if (variant === "regular") return "400";
	return null;
}

/**
 * Helper: Get additional Computer Modern webfonts (manually curated from https://github.com/bitmaks/cm-web-fonts)
 * These do NOT come from Google Fonts but should appear in webfontlist.json output.
 * Files are delivered via jsDelivr CDN.
 */
function getComputerModernWebFonts(): WebFont[] {
	const CDN = "https://cdn.jsdelivr.net/gh/bitmaks/cm-web-fonts@latest/font";

	return [
		{
			type: "web",
			category: "display",
			family: "Computer Modern Bright",
			weights: ["400", "700"],
			preview: `${CDN}/Bright/cmunbmr.woff`,
			files: {
				"400": `${CDN}/Bright/cmunbmr.woff`,
				"400italic": `${CDN}/Bright/cmunbmo.woff`,
				"700": `${CDN}/Bright/cmunbbx.woff`,
				"700italic": `${CDN}/Bright/cmunbxo.woff`,
			},
		},
		{
			type: "web",
			category: "serif",
			family: "Computer Modern Concrete",
			weights: ["400", "700"],
			preview: `${CDN}/Concrete/cmunorm.woff`,
			files: {
				"400": `${CDN}/Concrete/cmunorm.woff`,
				"400italic": `${CDN}/Concrete/cmunobi.woff`,
				"700": `${CDN}/Concrete/cmunobx.woff`,
				"700italic": `${CDN}/Concrete/cmunoti.woff`,
			},
		},
		{
			type: "web",
			category: "sans-serif",
			family: "Computer Modern Sans",
			weights: ["400", "700"],
			preview: `${CDN}/Sans/cmunss.woff`,
			files: {
				"400": `${CDN}/Sans/cmunss.woff`,
				"400italic": `${CDN}/Sans/cmunsl.woff`,
				"700": `${CDN}/Sans/cmunsx.woff`,
				"700italic": `${CDN}/Sans/cmunsi.woff`,
			},
		},
		{
			type: "web",
			category: "serif",
			family: "Computer Modern Serif",
			weights: ["400", "700"],
			preview: `${CDN}/Serif/cmunrm.woff`,
			files: {
				"400": `${CDN}/Serif/cmunrm.woff`,
				"400italic": `${CDN}/Serif/cmunti.woff`,
				"700": `${CDN}/Serif/cmunbx.woff`,
				"700italic": `${CDN}/Serif/cmunbi.woff`,
			},
		},
		{
			type: "web",
			category: "monospace",
			family: "Computer Modern Typewriter",
			weights: ["400", "700"],
			preview: `${CDN}/Typewriter/cmuntt.woff`,
			files: {
				"400": `${CDN}/Typewriter/cmuntt.woff`,
				"400italic": `${CDN}/Typewriter/cmunit.woff`,
				"700": `${CDN}/Typewriter/cmuntx.woff`,
				"700italic": `${CDN}/Typewriter/cmuntb.woff`,
			},
		},
	];
}

export async function generateFonts() {
	const response = await getGoogleFontsJSON();
	console.log(`Found ${response.items.length} fonts in total (Google Fonts).`);

	const filteredItems = response.items.filter(
		(item) => !skippedFamilies.some((family) => item.family.includes(family)),
	);

	const googleFontResults: WebFont[] = filteredItems.slice(0, argLimit).map((item) => {
		// 1. weights: Only non-italic, convert "regular" to "400"
		const weights: Weight[] = item.variants.map((v) => variantToWeight(v)).filter((w): w is Weight => !!w);

		// 2. files: all files, but change "regular"->"400", "italic"->"400italic"
		const files: Record<string, string> = {};

		for (const [variant, url] of Object.entries(item.files)) {
			let key = variant;
			if (variant === "regular") key = "400";
			else if (variant === "italic") key = "400italic";
			files[key] = url;
		}

		return {
			type: "web",
			category: item.category,
			family: item.family,
			weights,
			preview: item.menu,
			files,
		} satisfies WebFont;
	});

	// Manually append Computer Modern web fonts
	const computerModernFonts = getComputerModernWebFonts();
	const allWebFonts: WebFont[] = [...computerModernFonts, ...googleFontResults];

	console.log(
		`Added ${computerModernFonts.length} Computer Modern Web Fonts. Total output: ${allWebFonts.length} web fonts.`,
	);

	const jsonString = argCompress ? JSON.stringify(allWebFonts) : JSON.stringify(allWebFonts, null, 2);
	await mkdir(FONTS_DIR, { recursive: true });
	await writeFile(WEBFONTLIST_FILE, jsonString, "utf-8");

	console.log(`Generated ${allWebFonts.length} fonts in the list (including Computer Modern web fonts).`);
}

if (import.meta.main) {
	await generateFonts();
}


--- scripts/database/migrate.ts ---
import { drizzle } from "drizzle-orm/node-postgres";
import { migrate } from "drizzle-orm/node-postgres/migrator";
import { Pool } from "pg";
import { env } from "@/utils/env";

export async function migrateDatabase() {
	console.log("⌛ Running database migrations...");

	const pool = new Pool({ connectionString: env.DATABASE_URL });
	const db = drizzle({ client: pool });

	try {
		await migrate(db, { migrationsFolder: "./migrations" });
		console.log("✅ Database migrations completed");
	} catch (error) {
		console.error("🚨 Database migrations failed:", error);
	} finally {
		await pool.end();
	}
}

if (import.meta.main) {
	await migrateDatabase();
}


--- scripts/database/reset.ts ---
import { sql } from "drizzle-orm";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import { env } from "@/utils/env";

export async function resetDatabase() {
	console.log("⌛ Resetting database...");

	const pool = new Pool({ connectionString: env.DATABASE_URL });
	const db = drizzle({ client: pool });

	try {
		await db.transaction(async (tx) => {
			await tx.execute(sql`DROP SCHEMA drizzle CASCADE`);
			await tx.execute(sql`CREATE SCHEMA drizzle`);
			await tx.execute(sql`GRANT ALL ON SCHEMA drizzle TO postgres`);

			await tx.execute(sql`DROP SCHEMA public CASCADE`);
			await tx.execute(sql`CREATE SCHEMA public`);
			await tx.execute(sql`GRANT ALL ON SCHEMA public TO postgres`);
		});

		console.log("✅ Database reset completed");
	} catch (error) {
		console.error("🚨 Database reset failed:", error);
	} finally {
		await pool.end();
	}
}

if (import.meta.main) {
	await resetDatabase();
}


--- scripts/migration/resume.ts ---
import fs from "node:fs/promises";
import { and, inArray, sql } from "drizzle-orm";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool, type QueryResult } from "pg";
import { schema } from "@/integrations/drizzle";
import { ReactiveResumeV4JSONImporter } from "@/integrations/import/reactive-resume-v4-json";
import { defaultResumeData } from "@/schema/resume/data";
import { generateId } from "@/utils/string";

// Types for the production database
type Visibility = "public" | "private";

interface ProductionResume {
	id: string;
	title: string;
	slug: string;
	data: unknown; // JSON data
	visibility: Visibility;
	locked: boolean;
	userId: string;
	createdAt: Date;
	updatedAt: Date;
}

interface ProductionStatistics {
	id: string;
	views: number;
	downloads: number;
	resumeId: string;
	createdAt: Date;
	updatedAt: Date;
}

const productionUrl = process.env.PRODUCTION_DATABASE_URL;
const localUrl = process.env.DATABASE_URL;

if (!productionUrl) throw new Error("PRODUCTION_DATABASE_URL is not set");
if (!localUrl) throw new Error("DATABASE_URL is not set");

const productionPool = new Pool({ connectionString: productionUrl });
const localPool = new Pool({ connectionString: localUrl });

const productionDb = drizzle({ client: productionPool });
const localDb = drizzle({ client: localPool, schema });

// == Persistent mapping file paths ==
const USER_ID_MAP_FILE = "./scripts/migration/user-id-map.json";
const RESUME_ID_MAP_FILE = "./scripts/migration/resume-id-map.json";

// == Progress checkpoint file path ==
const PROGRESS_FILE = "./scripts/migration/resume-progress.json";

// You may tune this for your use case
// Reduced from 10000 to avoid PostgreSQL message format errors
const BATCH_SIZE = 10_000;

// Chunk size for actual inserts - smaller to avoid PostgreSQL message size limits
// Especially important for resumes as they contain large JSONB data
const INSERT_CHUNK_SIZE = 1000;

// == Progress checkpoint interface ==
// Uses cursor-based pagination with (createdAt, id) composite key for efficiency
interface MigrationProgress {
	// Cursor for pagination - last seen createdAt timestamp
	lastSeenCreatedAt: string | null;
	// Cursor for pagination - last seen id (for tiebreaker when timestamps are equal)
	lastSeenId: string | null;
	resumesCreated: number;
	statisticsCreated: number;
	skipped: number;
	totalResumesProcessed: number;
	errors: number;
	lastUpdated: string;
}

// Flag to track if shutdown was requested
let shutdownRequested = false;

async function loadProgress(): Promise<MigrationProgress | null> {
	try {
		const text = await fs.readFile(PROGRESS_FILE, { encoding: "utf-8" });
		const progress = JSON.parse(text) as MigrationProgress;
		console.log(`📂 Found existing progress file. Last updated: ${progress.lastUpdated}`);
		console.log(`   Resuming from cursor (createdAt: ${progress.lastSeenCreatedAt}, id: ${progress.lastSeenId})...`);
		return progress;
	} catch (e) {
		console.warn("⚠️  Failed to load progress file, starting from beginning.", e);
	}
	return null;
}

async function saveProgress(progress: MigrationProgress): Promise<void> {
	try {
		progress.lastUpdated = new Date().toISOString();
		await fs.writeFile(PROGRESS_FILE, JSON.stringify(progress, null, 2), { encoding: "utf-8" });
		console.log(`💾 Progress saved at cursor (createdAt: ${progress.lastSeenCreatedAt}, id: ${progress.lastSeenId})`);
	} catch (e) {
		console.error("🚨 Failed to save progress:", e);
	}
}

async function clearProgress(): Promise<void> {
	try {
		await fs.unlink(PROGRESS_FILE);
		console.log("🗑️  Progress file cleared.");
	} catch {
		// Ignore errors when clearing
	}
}

async function loadUserIdMapFromFile(): Promise<Map<string, string>> {
	try {
		const text = await fs.readFile(USER_ID_MAP_FILE, { encoding: "utf-8" });
		const obj = JSON.parse(text);
		return new Map(Object.entries(obj));
	} catch (e) {
		console.warn("⚠️  Failed to load userIdMap from disk, continuing with empty map.", e);
	}
	return new Map<string, string>();
}

async function loadResumeIdMapFromFile(): Promise<Map<string, string>> {
	try {
		const text = await fs.readFile(RESUME_ID_MAP_FILE, { encoding: "utf-8" });
		const obj = JSON.parse(text);
		return new Map(Object.entries(obj));
	} catch (e) {
		console.warn("⚠️  Failed to load resumeIdMap from disk, continuing with empty map.", e);
	}
	return new Map<string, string>();
}

async function saveResumeIdMapToFile(resumeIdMap: Map<string, string>) {
	const obj: Record<string, string> = Object.fromEntries(resumeIdMap.entries());
	await fs.writeFile(RESUME_ID_MAP_FILE, JSON.stringify(obj, null, "\t"), { encoding: "utf-8" });
}

export async function migrateResumes() {
	const migrationStart = performance.now();
	console.log("⌛ Starting resume migration...");

	let hasMore = true;

	// Cursor-based pagination state
	let lastSeenCreatedAt: string | null = null;
	let lastSeenId: string | null = null;

	// Load persistent ID maps from file
	const userIdMap = await loadUserIdMapFromFile();
	const resumeIdMap = await loadResumeIdMapFromFile();

	// Track migration stats
	let resumesCreated = 0;
	let statisticsCreated = 0;
	let skipped = 0;
	let totalResumesProcessed = 0;
	let errors = 0;

	// Load saved progress if exists
	const savedProgress = await loadProgress();
	if (savedProgress) {
		lastSeenCreatedAt = savedProgress.lastSeenCreatedAt;
		lastSeenId = savedProgress.lastSeenId;
		resumesCreated = savedProgress.resumesCreated;
		statisticsCreated = savedProgress.statisticsCreated;
		skipped = savedProgress.skipped;
		totalResumesProcessed = savedProgress.totalResumesProcessed;
		errors = savedProgress.errors;
	}

	// Helper to get current progress object
	const getCurrentProgress = (): MigrationProgress => ({
		lastSeenCreatedAt,
		lastSeenId,
		resumesCreated,
		statisticsCreated,
		skipped,
		totalResumesProcessed,
		errors,
		lastUpdated: new Date().toISOString(),
	});

	// Setup graceful shutdown handler
	const handleShutdown = async () => {
		if (shutdownRequested) return;
		shutdownRequested = true;
		console.log("\n⚠️  Shutdown requested. Saving progress...");
		await saveProgress(getCurrentProgress());
		await saveResumeIdMapToFile(resumeIdMap);
		console.log("👋 Exiting. Run the script again to resume from where you left off.");
		process.exit(0);
	};

	process.on("SIGINT", handleShutdown);
	process.on("SIGTERM", handleShutdown);

	// Initialize the importer
	const importer = new ReactiveResumeV4JSONImporter();

	while (hasMore) {
		// Check if shutdown was requested
		if (shutdownRequested) break;

		console.log(
			`📥 Fetching resumes batch from production database (cursor: createdAt=${lastSeenCreatedAt}, id=${lastSeenId})...`,
		);

		// Use cursor-based pagination for better performance
		// Tuple comparison syntax allows Postgres to use composite index efficiently
		let resumes: ProductionResume[];

		if (lastSeenCreatedAt && lastSeenId) {
			const result = (await productionDb.execute(sql`
				SELECT id, title, slug, data, visibility, locked, "userId", "createdAt", "updatedAt"
				FROM "Resume"
				WHERE ("createdAt", id) < (${lastSeenCreatedAt}::timestamp, ${lastSeenId})
				ORDER BY "createdAt" DESC, id DESC
				LIMIT ${BATCH_SIZE}
			`)) as unknown as QueryResult<ProductionResume>;
			resumes = result.rows;
		} else {
			const result = (await productionDb.execute(sql`
				SELECT id, title, slug, data, visibility, locked, "userId", "createdAt", "updatedAt"
				FROM "Resume"
				ORDER BY "createdAt" DESC, id DESC
				LIMIT ${BATCH_SIZE}
			`)) as unknown as QueryResult<ProductionResume>;
			resumes = result.rows;
		}

		console.log(`📋 Found ${resumes.length} resumes in this batch.`);

		if (resumes.length === 0) {
			hasMore = false;
			break;
		}

		// Fetch statistics only for these resumes in this batch
		const resumeIds = resumes.map((r) => r.id);

		// Drizzle does not interpolate arrays, so we join and use a custom SQL string
		// Escape single quotes in IDs (though UUIDs shouldn't contain them, this is safer)
		const resumeIdsForSql = resumeIds.map((id) => `'${id.replace(/'/g, "''")}'`).join(", ");

		const { rows: statistics } = (await productionDb.execute(sql`
			SELECT id, views, downloads, "resumeId", "createdAt", "updatedAt"
			FROM "Statistics"
			WHERE "resumeId" IN (${sql.raw(resumeIdsForSql)})
		`)) as unknown as QueryResult<ProductionStatistics>;

		// Create a map of resumeId -> statistics for quick lookup
		const statisticsMap = new Map<string, ProductionStatistics>();
		for (const stat of statistics) {
			statisticsMap.set(stat.resumeId, stat);
		}

		// Filter out resumes where userId is not in userIdMap
		const resumesToProcess = resumes
			.map((resume) => {
				const newUserId = userIdMap.get(resume.userId);
				if (!newUserId) {
					skipped++;
					return null;
				}
				return { resume, newUserId };
			})
			.filter((item): item is NonNullable<typeof item> => item !== null);

		if (resumesToProcess.length === 0) {
			console.log(`⏭️  All resumes in this batch have userIds not found in userIdMap.`);
			// Update cursor to the last resume in this batch
			const lastResume = resumes[resumes.length - 1];
			if (lastResume) {
				lastSeenCreatedAt =
					lastResume.createdAt instanceof Date ? lastResume.createdAt.toISOString() : String(lastResume.createdAt);
				lastSeenId = lastResume.id;
			}
			totalResumesProcessed += resumes.length;
			await saveProgress(getCurrentProgress());
			continue;
		}

		// Get unique userIds and bulk check if they exist in local database
		const uniqueUserIds = [...new Set(resumesToProcess.map((r) => r.newUserId))];
		const existingUsers = await localDb.select().from(schema.user).where(inArray(schema.user.id, uniqueUserIds));

		const existingUserIds = new Set(existingUsers.map((u) => u.id));

		// Filter out resumes where user doesn't exist
		const resumesWithValidUsers = resumesToProcess.filter(({ newUserId }) => {
			if (!existingUserIds.has(newUserId)) {
				skipped++;
				return false;
			}
			return true;
		});

		if (resumesWithValidUsers.length === 0) {
			console.log(`⏭️  All resumes in this batch have userIds not found in local database.`);
			// Update cursor to the last resume in this batch
			const lastResume = resumes[resumes.length - 1];
			if (lastResume) {
				lastSeenCreatedAt =
					lastResume.createdAt instanceof Date ? lastResume.createdAt.toISOString() : String(lastResume.createdAt);
				lastSeenId = lastResume.id;
			}
			totalResumesProcessed += resumes.length;
			await saveProgress(getCurrentProgress());
			continue;
		}

		// Bulk check for existing resumes (by slug + userId)
		// We need to check each unique combination
		const slugUserIdPairs = resumesWithValidUsers.map(({ resume, newUserId }) => ({
			slug: resume.slug,
			userId: newUserId,
		}));

		// Get all unique slugs and userIds
		const uniqueSlugs = [...new Set(slugUserIdPairs.map((p) => p.slug))];
		const userIdsForSlugCheck = [...new Set(slugUserIdPairs.map((p) => p.userId))];

		// Fetch all existing resumes that match any of our slugs and userIds
		const existingResumes = await localDb
			.select()
			.from(schema.resume)
			.where(and(inArray(schema.resume.slug, uniqueSlugs), inArray(schema.resume.userId, userIdsForSlugCheck)));

		// Create a set of existing slug+userId combinations
		const existingResumeKeys = new Set(existingResumes.map((r) => `${r.slug}:${r.userId}`));

		// Filter out resumes that already exist
		const resumesToInsert = resumesWithValidUsers.filter(({ resume, newUserId }) => {
			const key = `${resume.slug}:${newUserId}`;
			if (existingResumeKeys.has(key)) {
				skipped++;
				return false;
			}
			return true;
		});

		if (resumesToInsert.length === 0) {
			console.log(`⏭️  All resumes in this batch already exist in target DB.`);
			// Update cursor to the last resume in this batch
			const lastResume = resumes[resumes.length - 1];
			if (lastResume) {
				lastSeenCreatedAt =
					lastResume.createdAt instanceof Date ? lastResume.createdAt.toISOString() : String(lastResume.createdAt);
				lastSeenId = lastResume.id;
			}
			totalResumesProcessed += resumes.length;
			await saveProgress(getCurrentProgress());
			continue;
		}

		console.log(`📝 Preparing to bulk insert ${resumesToInsert.length} resumes...`);

		// Prepare bulk insert data
		const batchStart = performance.now();
		try {
			const resumesToInsertData = resumesToInsert.map(({ resume, newUserId }) => {
				// Transform the data using the V4 importer
				let transformedData = defaultResumeData;
				try {
					const dataJson = typeof resume.data === "string" ? resume.data : JSON.stringify(resume.data);
					transformedData = importer.parse(dataJson);
				} catch (error) {
					console.error(`⚠️  Failed to parse resume data for resume ${resume.id}, using default data:`, error);
					// Use default data if parsing fails
					transformedData = defaultResumeData;
				}

				// Map visibility to isPublic (visibility === "public" -> isPublic = true)
				const isPublic = resume.visibility === "public";

				const newResumeId = generateId();

				// Track the ID mapping for future reference
				resumeIdMap.set(resume.id, newResumeId);

				return {
					resumeData: {
						id: newResumeId,
						name: resume.title,
						slug: resume.slug,
						tags: [], // Default empty array
						isPublic: isPublic,
						isLocked: resume.locked,
						password: null, // No password in old schema
						data: transformedData,
						userId: newUserId,
						createdAt: resume.createdAt,
						updatedAt: resume.updatedAt,
					},
					originalResumeId: resume.id,
					newResumeId: newResumeId,
				};
			});

			// Bulk insert resumes (chunked to avoid PostgreSQL message size limits)
			// Resumes contain large JSONB data, so we use smaller chunks
			const resumeDataList = resumesToInsertData.map(({ resumeData }) => resumeData);
			for (let i = 0; i < resumeDataList.length; i += INSERT_CHUNK_SIZE) {
				const chunk = resumeDataList.slice(i, i + INSERT_CHUNK_SIZE);
				await localDb.insert(schema.resume).values(chunk);
			}
			resumesCreated += resumesToInsertData.length;

			// Prepare statistics for bulk insert
			const statisticsToInsert = resumesToInsertData
				.map(({ originalResumeId, newResumeId }) => {
					const resumeStatistics = statisticsMap.get(originalResumeId);
					if (!resumeStatistics) return null;

					return {
						id: generateId(),
						views: resumeStatistics.views,
						downloads: resumeStatistics.downloads,
						lastViewedAt: null, // Not available in old schema
						lastDownloadedAt: null, // Not available in old schema
						resumeId: newResumeId,
						createdAt: resumeStatistics.createdAt,
						updatedAt: resumeStatistics.updatedAt,
					};
				})
				.filter((stat): stat is NonNullable<typeof stat> => stat !== null);

			// Bulk insert statistics (chunked)
			if (statisticsToInsert.length > 0) {
				for (let i = 0; i < statisticsToInsert.length; i += INSERT_CHUNK_SIZE) {
					const chunk = statisticsToInsert.slice(i, i + INSERT_CHUNK_SIZE);
					await localDb.insert(schema.resumeStatistics).values(chunk);
				}
				statisticsCreated += statisticsToInsert.length;
			}

			const batchEnd = performance.now();
			const batchTimeMs = batchEnd - batchStart;
			console.log(
				`✅ Bulk inserted ${resumesToInsertData.length} resumes in ${batchTimeMs.toFixed(1)} ms (avg ${(batchTimeMs / resumesToInsertData.length).toFixed(1)} ms/resume)`,
			);

			// Save resume ID map after each successful batch
			await saveResumeIdMapToFile(resumeIdMap);
		} catch (error) {
			console.error(`🚨 Failed to bulk insert resumes batch:`, error);
			errors++;
			// Continue with next batch even if this one fails
		}

		// Update cursor to the last resume in this batch
		const lastResume = resumes[resumes.length - 1];
		if (lastResume) {
			lastSeenCreatedAt =
				lastResume.createdAt instanceof Date ? lastResume.createdAt.toISOString() : String(lastResume.createdAt);
			lastSeenId = lastResume.id;
		}

		totalResumesProcessed += resumes.length;
		console.log(`📦 Processed ${totalResumesProcessed} resumes so far...\n`);

		// Save progress after each batch
		await saveProgress(getCurrentProgress());
	}

	// Remove signal handlers
	process.off("SIGINT", handleShutdown);
	process.off("SIGTERM", handleShutdown);

	const migrationEnd = performance.now();
	const migrationDurationMs = migrationEnd - migrationStart;

	console.log("\n📊 Migration Summary:");
	console.log(`   Resumes created: ${resumesCreated}`);
	console.log(`   Statistics created: ${statisticsCreated}`);
	console.log(`   Skipped (userId not found or already exist): ${skipped}`);
	console.log(`   Errors: ${errors}`);
	console.log(
		`⏱️  Total migration time: ${migrationDurationMs.toFixed(1)} ms (${(migrationDurationMs / 1000).toFixed(2)} seconds)`,
	);

	// Final save of the mapping (ensures up-to-date state)
	await saveResumeIdMapToFile(resumeIdMap);

	// Clear progress file on successful completion (only if not interrupted)
	if (!shutdownRequested) {
		await clearProgress();
		console.log("✅ Resume migration complete!");
	} else {
		console.log("⏸️  Migration paused. Run again to resume.");
	}
}

if (import.meta.main) {
	// Reset shutdown flag for fresh run
	shutdownRequested = false;

	try {
		await migrateResumes();
	} finally {
		await productionPool.end();
		await localPool.end();
	}
}


--- scripts/migration/test-database.ts ---
import { sql } from "drizzle-orm";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

const productionUrl = process.env.PRODUCTION_DATABASE_URL;
if (!productionUrl) throw new Error("PRODUCTION_DATABASE_URL is not set");
const productionPool = new Pool({ connectionString: productionUrl });
const productionDb = drizzle({ client: productionPool });

const localUrl = process.env.DATABASE_URL;
if (!localUrl) throw new Error("DATABASE_URL is not set");
const localPool = new Pool({ connectionString: localUrl });
const localDb = drizzle({ client: localPool });

try {
	const productionResult = await productionDb.execute(sql`SELECT 1 as connected`);
	console.log("✅ Production database connection successful", JSON.stringify(productionResult));

	const localResult = await localDb.execute(sql`SELECT 1 as connected`);
	console.log("✅ Local database connection successful", JSON.stringify(localResult));
} catch (error) {
	console.error("🚨 Database connection failed:", error);
	process.exit(1);
} finally {
	await productionPool.end();
	await localPool.end();
	process.exit(0);
}


--- scripts/fonts/types.ts ---
type Category = "display" | "handwriting" | "monospace" | "serif" | "sans-serif";

export type Variant =
	| "100"
	| "100italic"
	| "200"
	| "200italic"
	| "300"
	| "300italic"
	| "regular"
	| "italic"
	| "500"
	| "500italic"
	| "600"
	| "600italic"
	| "700"
	| "700italic"
	| "800"
	| "800italic"
	| "900"
	| "900italic";

type Item = {
	kind: "webfonts#webfont";
	menu: string;
	family: string;
	version: string;
	category: Category;
	lastModified: string;
	subsets: string[];
	variants: Variant[];
	colorCapabilities?: string[];
	files: Partial<Record<Variant, string>>;
};

export type APIResponse = {
	kind: "webfonts#webfontList";
	items: Item[];
};

export type Weight = "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900";
type FileWeight = Weight | `${Weight}italic`;

export type WebFont = {
	type: "web";
	category: Category;
	family: string;
	weights: Weight[];
	preview: string;
	files: Partial<Record<FileWeight, string>>;
};


--- scripts/migration/user.ts ---
import fs from "node:fs/promises";
import { inArray, or, sql } from "drizzle-orm";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool, type QueryResult } from "pg";
import { schema } from "@/integrations/drizzle";
import { generateId, toUsername } from "@/utils/string";

type Provider = "credential" | "google" | "github" | "custom";

// Types for the production database
type ProductionProvider = "email" | "github" | "google" | "openid";

interface ProductionUser {
	id: string;
	name: string;
	picture: string | null;
	username: string;
	email: string;
	locale: string;
	emailVerified: boolean;
	createdAt: Date;
	updatedAt: Date;
	provider: ProductionProvider;
}

interface ProductionSecrets {
	id: string;
	password: string | null;
	lastSignedIn: Date;
	userId: string;
}

// Map old provider to new providerId
function mapProviderId(provider: ProductionProvider): Provider {
	switch (provider) {
		case "email":
			return "credential";
		case "google":
			return "google";
		case "github":
			return "github";
		default:
			return "custom";
	}
}

const productionUrl = process.env.PRODUCTION_DATABASE_URL;
const localUrl = process.env.DATABASE_URL;

if (!productionUrl) throw new Error("PRODUCTION_DATABASE_URL is not set");
if (!localUrl) throw new Error("DATABASE_URL is not set");

const productionPool = new Pool({ connectionString: productionUrl });
const localPool = new Pool({ connectionString: localUrl });

const productionDb = drizzle({ client: productionPool });
const localDb = drizzle({ client: localPool, schema });

// == Persistent mapping file path ==
const USER_ID_MAP_FILE = "./scripts/migration/user-id-map.json";

// == Progress checkpoint file path ==
const PROGRESS_FILE = "./scripts/migration/user-progress.json";

// You may tune this for your use case
const BATCH_SIZE = 10_000;

// Chunk size for actual inserts - smaller to avoid PostgreSQL message size limits
const INSERT_CHUNK_SIZE = 1000;

// == Progress checkpoint interface ==
// Uses cursor-based pagination with (createdAt, id) composite key for efficiency
interface MigrationProgress {
	// Cursor for pagination - last seen createdAt timestamp
	lastSeenCreatedAt: string | null;
	// Cursor for pagination - last seen id (for tiebreaker when timestamps are equal)
	lastSeenId: string | null;
	usersCreated: number;
	accountsCreated: number;
	skipped: number;
	totalUsersProcessed: number;
	lastUpdated: string;
}

// Flag to track if shutdown was requested
let shutdownRequested = false;

async function loadProgress(): Promise<MigrationProgress | null> {
	try {
		const text = await fs.readFile(PROGRESS_FILE, { encoding: "utf-8" });
		const progress = JSON.parse(text) as MigrationProgress;
		console.log(`📂 Found existing progress file. Last updated: ${progress.lastUpdated}`);
		console.log(`   Resuming from cursor (createdAt: ${progress.lastSeenCreatedAt}, id: ${progress.lastSeenId})...`);
		return progress;
	} catch (e) {
		console.warn("⚠️  Failed to load progress file, starting from beginning.", e);
	}
	return null;
}

async function saveProgress(progress: MigrationProgress): Promise<void> {
	try {
		progress.lastUpdated = new Date().toISOString();
		await fs.writeFile(PROGRESS_FILE, JSON.stringify(progress, null, 2), { encoding: "utf-8" });
		console.log(`💾 Progress saved at cursor (createdAt: ${progress.lastSeenCreatedAt}, id: ${progress.lastSeenId})`);
	} catch (e) {
		console.error("🚨 Failed to save progress:", e);
	}
}

async function clearProgress(): Promise<void> {
	try {
		await fs.unlink(PROGRESS_FILE);
		console.log("🗑️  Progress file cleared.");
	} catch {
		// Ignore errors when clearing
	}
}

async function loadUserIdMapFromFile(): Promise<Map<string, string>> {
	try {
		const text = await fs.readFile(USER_ID_MAP_FILE, { encoding: "utf-8" });
		const obj = JSON.parse(text);
		return new Map(Object.entries(obj));
	} catch (e) {
		console.warn("⚠️  Failed to load userIdMap from disk, continuing with empty map.", e);
	}
	return new Map<string, string>();
}

async function saveUserIdMapToFile(userIdMap: Map<string, string>) {
	const obj: Record<string, string> = Object.fromEntries(userIdMap.entries());
	await fs.writeFile(USER_ID_MAP_FILE, JSON.stringify(obj, null, "\t"), { encoding: "utf-8" });
}

export async function migrateUsers() {
	const migrationStart = performance.now();
	console.log("⌛ Starting user migration...");

	let hasMore = true;

	// Cursor-based pagination state
	let lastSeenCreatedAt: string | null = null;
	let lastSeenId: string | null = null;

	// Load persistent userIdMap from file
	const userIdMap = await loadUserIdMapFromFile();

	// Track migration stats
	let usersCreated = 0;
	let accountsCreated = 0;
	let skipped = 0;
	let totalUsersProcessed = 0;

	// Load saved progress if exists
	const savedProgress = await loadProgress();
	if (savedProgress) {
		lastSeenCreatedAt = savedProgress.lastSeenCreatedAt;
		lastSeenId = savedProgress.lastSeenId;
		usersCreated = savedProgress.usersCreated;
		accountsCreated = savedProgress.accountsCreated;
		skipped = savedProgress.skipped;
		totalUsersProcessed = savedProgress.totalUsersProcessed;
	}

	// Helper to get current progress object
	const getCurrentProgress = (): MigrationProgress => ({
		lastSeenCreatedAt,
		lastSeenId,
		usersCreated,
		accountsCreated,
		skipped,
		totalUsersProcessed,
		lastUpdated: new Date().toISOString(),
	});

	// Setup graceful shutdown handler
	const handleShutdown = async () => {
		if (shutdownRequested) return;
		shutdownRequested = true;
		console.log("\n⚠️  Shutdown requested. Saving progress...");
		await saveProgress(getCurrentProgress());
		await saveUserIdMapToFile(userIdMap);
		console.log("👋 Exiting. Run the script again to resume from where you left off.");
		process.exit(0);
	};

	process.on("SIGINT", handleShutdown);
	process.on("SIGTERM", handleShutdown);

	while (hasMore) {
		// Check if shutdown was requested
		if (shutdownRequested) break;

		console.log(
			`📥 Fetching users batch from production database (cursor: createdAt=${lastSeenCreatedAt}, id=${lastSeenId})...`,
		);

		let users: ProductionUser[];

		if (lastSeenCreatedAt && lastSeenId) {
			const result = (await productionDb.execute(sql`
				SELECT id, name, picture, username, email, locale, "emailVerified", "createdAt", "updatedAt", provider
				FROM "User"
				WHERE ("createdAt", id) < (${lastSeenCreatedAt}::timestamp, ${lastSeenId})
				ORDER BY "createdAt" DESC, id DESC
				LIMIT ${BATCH_SIZE}
			`)) as unknown as QueryResult<ProductionUser>;
			users = result.rows;
		} else {
			const result = (await productionDb.execute(sql`
				SELECT id, name, picture, username, email, locale, "emailVerified", "createdAt", "updatedAt", provider
				FROM "User"
				ORDER BY "createdAt" DESC, id DESC
				LIMIT ${BATCH_SIZE}
			`)) as unknown as QueryResult<ProductionUser>;
			users = result.rows;
		}

		console.log(`📋 Found ${users.length} users in this batch.`);

		if (users.length === 0) {
			hasMore = false;
			break;
		}

		// Fetch secrets only for these users in this batch
		const userIds = users.map((u) => u.id);

		// Drizzle does not interpolate arrays, so we join and use a custom SQL string
		// Escape single quotes in IDs (though UUIDs shouldn't contain them, this is safer)
		const userIdsForSql = userIds.map((id) => `'${id.replace(/'/g, "''")}'`).join(", ");

		const { rows: secrets } = (await productionDb.execute(sql`
			SELECT id, password, "lastSignedIn", "userId"
			FROM "Secrets"
			WHERE "userId" IN (${sql.raw(userIdsForSql)})
		`)) as unknown as QueryResult<ProductionSecrets>;

		// Create a map of userId -> secrets for quick lookup
		const secretsMap = new Map<string, ProductionSecrets>();
		for (const secret of secrets) {
			secretsMap.set(secret.userId, secret);
		}

		// Filter out users already in userIdMap (previously migrated)
		const usersToProcess = users.filter((user) => {
			if (userIdMap.has(user.id)) {
				skipped++;
				return false;
			}
			return true;
		});

		if (usersToProcess.length === 0) {
			console.log(`⏭️  All users in this batch were already migrated.`);
			// Update cursor to the last user in this batch
			const lastUser = users[users.length - 1];
			if (lastUser) {
				lastSeenCreatedAt =
					lastUser.createdAt instanceof Date ? lastUser.createdAt.toISOString() : String(lastUser.createdAt);
				lastSeenId = lastUser.id;
			}
			totalUsersProcessed += users.length;
			await saveProgress(getCurrentProgress());
			continue;
		}

		// Prepare usernames for all users
		const userData = usersToProcess.map((user) => ({
			user,
			username: toUsername(user.username),
			displayUsername: user.username,
		}));

		// Bulk check for existing users (by email or username)
		const emails = userData.map((u) => u.user.email);
		const usernames = userData.map((u) => u.username);
		const displayUsernames = userData.map((u) => u.displayUsername);

		const existingUsers = await localDb
			.select()
			.from(schema.user)
			.where(
				or(
					inArray(schema.user.email, emails),
					inArray(schema.user.username, usernames),
					inArray(schema.user.displayUsername, displayUsernames),
				),
			);

		const existingEmails = new Set(existingUsers.map((u) => u.email));
		const existingUsernames = new Set(existingUsers.map((u) => u.username));
		const existingDisplayUsernames = new Set(existingUsers.map((u) => u.displayUsername));

		// Filter out users that already exist
		const usersToInsert = userData.filter(({ user, username, displayUsername }) => {
			if (
				existingEmails.has(user.email) ||
				existingUsernames.has(username) ||
				existingDisplayUsernames.has(displayUsername)
			) {
				skipped++;
				return false;
			}
			return true;
		});

		if (usersToInsert.length === 0) {
			console.log(`⏭️  All users in this batch already exist in target DB.`);
			// Update cursor to the last user in this batch
			const lastUser = users[users.length - 1];
			if (lastUser) {
				lastSeenCreatedAt =
					lastUser.createdAt instanceof Date ? lastUser.createdAt.toISOString() : String(lastUser.createdAt);
				lastSeenId = lastUser.id;
			}
			totalUsersProcessed += users.length;
			await saveUserIdMapToFile(userIdMap);
			await saveProgress(getCurrentProgress());
			continue;
		}

		console.log(`📝 Preparing to bulk insert ${usersToInsert.length} users...`);

		// Prepare bulk insert data
		const usersToInsertData = usersToInsert.map(({ user, username, displayUsername }) => {
			const newUserId = generateId();
			userIdMap.set(user.id, newUserId);
			return {
				userData: {
					id: newUserId,
					name: user.name,
					email: user.email,
					image: user.picture,
					username: username,
					displayUsername: displayUsername,
					emailVerified: user.emailVerified,
					twoFactorEnabled: false, // All users start with 2FA disabled in the new system
					createdAt: user.createdAt,
					updatedAt: user.updatedAt,
				},
				originalUser: user,
				newUserId: newUserId,
			};
		});

		// Bulk insert users (chunked to avoid PostgreSQL message size limits)
		const batchStart = performance.now();
		try {
			const userDataList = usersToInsertData.map(({ userData }) => userData);
			for (let i = 0; i < userDataList.length; i += INSERT_CHUNK_SIZE) {
				const chunk = userDataList.slice(i, i + INSERT_CHUNK_SIZE);
				await localDb.insert(schema.user).values(chunk);
			}
			usersCreated += usersToInsertData.length;

			// Prepare accounts for bulk insert
			const accountsToInsert = usersToInsertData.map(({ originalUser, newUserId, userData }) => {
				const userSecrets = secretsMap.get(originalUser.id);
				const providerId = mapProviderId(originalUser.provider);
				const accountId = providerId === "credential" ? newUserId : originalUser.id;

				return {
					id: generateId(),
					userId: newUserId,
					accountId: accountId,
					providerId: providerId,
					password: userSecrets?.password ?? null,
					createdAt: userData.createdAt,
					updatedAt: userData.updatedAt,
				};
			});

			// Bulk insert accounts (chunked)
			for (let i = 0; i < accountsToInsert.length; i += INSERT_CHUNK_SIZE) {
				const chunk = accountsToInsert.slice(i, i + INSERT_CHUNK_SIZE);
				await localDb.insert(schema.account).values(chunk);
			}
			accountsCreated += accountsToInsert.length;

			const batchEnd = performance.now();
			const batchTimeMs = batchEnd - batchStart;
			console.log(
				`✅ Bulk inserted ${usersToInsertData.length} users in ${batchTimeMs.toFixed(1)} ms (avg ${(batchTimeMs / usersToInsertData.length).toFixed(1)} ms/user)`,
			);

			// Save progress after each batch
			await saveUserIdMapToFile(userIdMap);
		} catch (error) {
			console.error(`🚨 Failed to bulk insert users batch:`, error);
			// Continue with next batch even if this one fails
		}

		// Update cursor to the last user in this batch
		const lastUser = users[users.length - 1];
		if (lastUser) {
			lastSeenCreatedAt =
				lastUser.createdAt instanceof Date ? lastUser.createdAt.toISOString() : String(lastUser.createdAt);
			lastSeenId = lastUser.id;
		}

		totalUsersProcessed += users.length;
		console.log(`📦 Processed ${totalUsersProcessed} users so far...\n`);

		// Save progress after updating cursor
		await saveProgress(getCurrentProgress());
	}

	// Remove signal handlers
	process.off("SIGINT", handleShutdown);
	process.off("SIGTERM", handleShutdown);

	const migrationEnd = performance.now();
	const migrationDurationMs = migrationEnd - migrationStart;

	console.log("\n📊 Migration Summary:");
	console.log(`   Users created: ${usersCreated}`);
	console.log(`   Accounts created: ${accountsCreated}`);
	console.log(`   Skipped (already exist): ${skipped}`);
	console.log(
		`⏱️  Total migration time: ${migrationDurationMs.toFixed(1)} ms (${(migrationDurationMs / 1000).toFixed(2)} seconds)`,
	);

	// Final save of the mapping (ensures up-to-date state)
	await saveUserIdMapToFile(userIdMap);

	// Clear progress file on successful completion (only if not interrupted)
	if (!shutdownRequested) {
		await clearProgress();
		console.log("✅ User migration complete!");
	} else {
		console.log("⏸️  Migration paused. Run again to resume.");
	}

	// Return the ID mapping for use in other migrations (e.g., resumes)
	return userIdMap;
}

if (import.meta.main) {
	// Reset shutdown flag for fresh run
	shutdownRequested = false;

	try {
		await migrateUsers();
	} finally {
		await productionPool.end();
		await localPool.end();
	}
}


--- src/routeTree.gen.ts ---
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Route as rootRouteImport } from "./routes/__root";
import { Route as SchemaDotjsonRouteImport } from "./routes/schema[.]json";
import { Route as DashboardRouteRouteImport } from "./routes/dashboard/route";
import { Route as AuthRouteRouteImport } from "./routes/auth/route";
import { Route as HomeRouteRouteImport } from "./routes/_home/route";
import { Route as McpIndexRouteImport } from "./routes/mcp/index";
import { Route as DashboardIndexRouteImport } from "./routes/dashboard/index";
import { Route as AuthIndexRouteImport } from "./routes/auth/index";
import { Route as HomeIndexRouteImport } from "./routes/_home/index";
import { Route as PrinterResumeIdRouteImport } from "./routes/printer/$resumeId";
import { Route as AuthVerify2faBackupRouteImport } from "./routes/auth/verify-2fa-backup";
import { Route as AuthVerify2faRouteImport } from "./routes/auth/verify-2fa";
import { Route as AuthResumePasswordRouteImport } from "./routes/auth/resume-password";
import { Route as AuthResetPasswordRouteImport } from "./routes/auth/reset-password";
import { Route as AuthRegisterRouteImport } from "./routes/auth/register";
import { Route as AuthLoginRouteImport } from "./routes/auth/login";
import { Route as AuthForgotPasswordRouteImport } from "./routes/auth/forgot-password";
import { Route as ApiHealthRouteImport } from "./routes/api/health";
import { Route as UsernameSlugRouteImport } from "./routes/$username/$slug";
import { Route as BuilderResumeIdRouteRouteImport } from "./routes/builder/$resumeId/route";
import { Route as DashboardResumesIndexRouteImport } from "./routes/dashboard/resumes/index";
import { Route as BuilderResumeIdIndexRouteImport } from "./routes/builder/$resumeId/index";
import { Route as UploadsUserIdSplatRouteImport } from "./routes/uploads/$userId.$";
import { Route as DashboardSettingsProfileRouteImport } from "./routes/dashboard/settings/profile";
import { Route as DashboardSettingsPreferencesRouteImport } from "./routes/dashboard/settings/preferences";
import { Route as DashboardSettingsDangerZoneRouteImport } from "./routes/dashboard/settings/danger-zone";
import { Route as DashboardSettingsApiKeysRouteImport } from "./routes/dashboard/settings/api-keys";
import { Route as DashboardSettingsAiRouteImport } from "./routes/dashboard/settings/ai";
import { Route as ApiRpcSplatRouteImport } from "./routes/api/rpc.$";
import { Route as ApiOpenapiSplatRouteImport } from "./routes/api/openapi.$";
import { Route as ApiAuthSplatRouteImport } from "./routes/api/auth.$";
import { Route as DashboardSettingsAuthenticationIndexRouteImport } from "./routes/dashboard/settings/authentication/index";

const SchemaDotjsonRoute = SchemaDotjsonRouteImport.update({
  id: "/schema.json",
  path: "/schema.json",
  getParentRoute: () => rootRouteImport,
} as any);
const DashboardRouteRoute = DashboardRouteRouteImport.update({
  id: "/dashboard",
  path: "/dashboard",
  getParentRoute: () => rootRouteImport,
} as any);
const AuthRouteRoute = AuthRouteRouteImport.update({
  id: "/auth",
  path: "/auth",
  getParentRoute: () => rootRouteImport,
} as any);
const HomeRouteRoute = HomeRouteRouteImport.update({
  id: "/_home",
  getParentRoute: () => rootRouteImport,
} as any);
const McpIndexRoute = McpIndexRouteImport.update({
  id: "/mcp/",
  path: "/mcp/",
  getParentRoute: () => rootRouteImport,
} as any);
const DashboardIndexRoute = DashboardIndexRouteImport.update({
  id: "/",
  path: "/",
  getParentRoute: () => DashboardRouteRoute,
} as any);
const AuthIndexRoute = AuthIndexRouteImport.update({
  id: "/",
  path: "/",
  getParentRoute: () => AuthRouteRoute,
} as any);
const HomeIndexRoute = HomeIndexRouteImport.update({
  id: "/",
  path: "/",
  getParentRoute: () => HomeRouteRoute,
} as any);
const PrinterResumeIdRoute = PrinterResumeIdRouteImport.update({
  id: "/printer/$resumeId",
  path: "/printer/$resumeId",
  getParentRoute: () => rootRouteImport,
} as any);
const AuthVerify2faBackupRoute = AuthVerify2faBackupRouteImport.update({
  id: "/verify-2fa-backup",
  path: "/verify-2fa-backup",
  getParentRoute: () => AuthRouteRoute,
} as any);
const AuthVerify2faRoute = AuthVerify2faRouteImport.update({
  id: "/verify-2fa",
  path: "/verify-2fa",
  getParentRoute: () => AuthRouteRoute,
} as any);
const AuthResumePasswordRoute = AuthResumePasswordRouteImport.update({
  id: "/resume-password",
  path: "/resume-password",
  getParentRoute: () => AuthRouteRoute,
} as any);
const AuthResetPasswordRoute = AuthResetPasswordRouteImport.update({
  id: "/reset-password",
  path: "/reset-password",
  getParentRoute: () => AuthRouteRoute,
} as any);
const AuthRegisterRoute = AuthRegisterRouteImport.update({
  id: "/register",
  path: "/register",
  getParentRoute: () => AuthRouteRoute,
} as any);
const AuthLoginRoute = AuthLoginRouteImport.update({
  id: "/login",
  path: "/login",
  getParentRoute: () => AuthRouteRoute,
} as any);
const AuthForgotPasswordRoute = AuthForgotPasswordRouteImport.update({
  id: "/forgot-password",
  path: "/forgot-password",
  getParentRoute: () => AuthRouteRoute,
} as any);
const ApiHealthRoute = ApiHealthRouteImport.update({
  id: "/api/health",
  path: "/api/health",
  getParentRoute: () => rootRouteImport,
} as any);
const UsernameSlugRoute = UsernameSlugRouteImport.update({
  id: "/$username/$slug",
  path: "/$username/$slug",
  getParentRoute: () => rootRouteImport,
} as any);
const BuilderResumeIdRouteRoute = BuilderResumeIdRouteRouteImport.update({
  id: "/builder/$resumeId",
  path: "/builder/$resumeId",
  getParentRoute: () => rootRouteImport,
} as any);
const DashboardResumesIndexRoute = DashboardResumesIndexRouteImport.update({
  id: "/resumes/",
  path: "/resumes/",
  getParentRoute: () => DashboardRouteRoute,
} as any);
const BuilderResumeIdIndexRoute = BuilderResumeIdIndexRouteImport.update({
  id: "/",
  path: "/",
  getParentRoute: () => BuilderResumeIdRouteRoute,
} as any);
const UploadsUserIdSplatRoute = UploadsUserIdSplatRouteImport.update({
  id: "/uploads/$userId/$",
  path: "/uploads/$userId/$",
  getParentRoute: () => rootRouteImport,
} as any);
const DashboardSettingsProfileRoute =
  DashboardSettingsProfileRouteImport.update({
    id: "/settings/profile",
    path: "/settings/profile",
    getParentRoute: () => DashboardRouteRoute,
  } as any);
const DashboardSettingsPreferencesRoute =
  DashboardSettingsPreferencesRouteImport.update({
    id: "/settings/preferences",
    path: "/settings/preferences",
    getParentRoute: () => DashboardRouteRoute,
  } as any);
const DashboardSettingsDangerZoneRoute =
  DashboardSettingsDangerZoneRouteImport.update({
    id: "/settings/danger-zone",
    path: "/settings/danger-zone",
    getParentRoute: () => DashboardRouteRoute,
  } as any);
const DashboardSettingsApiKeysRoute =
  DashboardSettingsApiKeysRouteImport.update({
    id: "/settings/api-keys",
    path: "/settings/api-keys",
    getParentRoute: () => DashboardRouteRoute,
  } as any);
const DashboardSettingsAiRoute = DashboardSettingsAiRouteImport.update({
  id: "/settings/ai",
  path: "/settings/ai",
  getParentRoute: () => DashboardRouteRoute,
} as any);
const ApiRpcSplatRoute = ApiRpcSplatRouteImport.update({
  id: "/api/rpc/$",
  path: "/api/rpc/$",
  getParentRoute: () => rootRouteImport,
} as any);
const ApiOpenapiSplatRoute = ApiOpenapiSplatRouteImport.update({
  id: "/api/openapi/$",
  path: "/api/openapi/$",
  getParentRoute: () => rootRouteImport,
} as any);
const ApiAuthSplatRoute = ApiAuthSplatRouteImport.update({
  id: "/api/auth/$",
  path: "/api/auth/$",
  getParentRoute: () => rootRouteImport,
} as any);
const DashboardSettingsAuthenticationIndexRoute =
  DashboardSettingsAuthenticationIndexRouteImport.update({
    id: "/settings/authentication/",
    path: "/settings/authentication/",
    getParentRoute: () => DashboardRouteRoute,
  } as any);

export interface FileRoutesByFullPath {
  "/": typeof HomeIndexRoute;
  "/auth": typeof AuthRouteRouteWithChildren;
  "/dashboard": typeof DashboardRouteRouteWithChildren;
  "/schema.json": typeof SchemaDotjsonRoute;
  "/builder/$resumeId": typeof BuilderResumeIdRouteRouteWithChildren;
  "/$username/$slug": typeof UsernameSlugRoute;
  "/api/health": typeof ApiHealthRoute;
  "/auth/forgot-password": typeof AuthForgotPasswordRoute;
  "/auth/login": typeof AuthLoginRoute;
  "/auth/register": typeof AuthRegisterRoute;
  "/auth/reset-password": typeof AuthResetPasswordRoute;
  "/auth/resume-password": typeof AuthResumePasswordRoute;
  "/auth/verify-2fa": typeof AuthVerify2faRoute;
  "/auth/verify-2fa-backup": typeof AuthVerify2faBackupRoute;
  "/printer/$resumeId": typeof PrinterResumeIdRoute;
  "/auth/": typeof AuthIndexRoute;
  "/dashboard/": typeof DashboardIndexRoute;
  "/mcp/": typeof McpIndexRoute;
  "/api/auth/$": typeof ApiAuthSplatRoute;
  "/api/openapi/$": typeof ApiOpenapiSplatRoute;
  "/api/rpc/$": typeof ApiRpcSplatRoute;
  "/dashboard/settings/ai": typeof DashboardSettingsAiRoute;
  "/dashboard/settings/api-keys": typeof DashboardSettingsApiKeysRoute;
  "/dashboard/settings/danger-zone": typeof DashboardSettingsDangerZoneRoute;
  "/dashboard/settings/preferences": typeof DashboardSettingsPreferencesRoute;
  "/dashboard/settings/profile": typeof DashboardSettingsProfileRoute;
  "/uploads/$userId/$": typeof UploadsUserIdSplatRoute;
  "/builder/$resumeId/": typeof BuilderResumeIdIndexRoute;
  "/dashboard/resumes/": typeof DashboardResumesIndexRoute;
  "/dashboard/settings/authentication/": typeof DashboardSettingsAuthenticationIndexRoute;
}
export interface FileRoutesByTo {
  "/schema.json": typeof SchemaDotjsonRoute;
  "/$username/$slug": typeof UsernameSlugRoute;
  "/api/health": typeof ApiHealthRoute;
  "/auth/forgot-password": typeof AuthForgotPasswordRoute;
  "/auth/login": typeof AuthLoginRoute;
  "/auth/register": typeof AuthRegisterRoute;
  "/auth/reset-password": typeof AuthResetPasswordRoute;
  "/auth/resume-password": typeof AuthResumePasswordRoute;
  "/auth/verify-2fa": typeof AuthVerify2faRoute;
  "/auth/verify-2fa-backup": typeof AuthVerify2faBackupRoute;
  "/printer/$resumeId": typeof PrinterResumeIdRoute;
  "/": typeof HomeIndexRoute;
  "/auth": typeof AuthIndexRoute;
  "/dashboard": typeof DashboardIndexRoute;
  "/mcp": typeof McpIndexRoute;
  "/api/auth/$": typeof ApiAuthSplatRoute;
  "/api/openapi/$": typeof ApiOpenapiSplatRoute;
  "/api/rpc/$": typeof ApiRpcSplatRoute;
  "/dashboard/settings/ai": typeof DashboardSettingsAiRoute;
  "/dashboard/settings/api-keys": typeof DashboardSettingsApiKeysRoute;
  "/dashboard/settings/danger-zone": typeof DashboardSettingsDangerZoneRoute;
  "/dashboard/settings/preferences": typeof DashboardSettingsPreferencesRoute;
  "/dashboard/settings/profile": typeof DashboardSettingsProfileRoute;
  "/uploads/$userId/$": typeof UploadsUserIdSplatRoute;
  "/builder/$resumeId": typeof BuilderResumeIdIndexRoute;
  "/dashboard/resumes": typeof DashboardResumesIndexRoute;
  "/dashboard/settings/authentication": typeof DashboardSettingsAuthenticationIndexRoute;
}
export interface FileRoutesById {
  __root__: typeof rootRouteImport;
  "/_home": typeof HomeRouteRouteWithChildren;
  "/auth": typeof AuthRouteRouteWithChildren;
  "/dashboard": typeof DashboardRouteRouteWithChildren;
  "/schema.json": typeof SchemaDotjsonRoute;
  "/builder/$resumeId": typeof BuilderResumeIdRouteRouteWithChildren;
  "/$username/$slug": typeof UsernameSlugRoute;
  "/api/health": typeof ApiHealthRoute;
  "/auth/forgot-password": typeof AuthForgotPasswordRoute;
  "/auth/login": typeof AuthLoginRoute;
  "/auth/register": typeof AuthRegisterRoute;
  "/auth/reset-password": typeof AuthResetPasswordRoute;
  "/auth/resume-password": typeof AuthResumePasswordRoute;
  "/auth/verify-2fa": typeof AuthVerify2faRoute;
  "/auth/verify-2fa-backup": typeof AuthVerify2faBackupRoute;
  "/printer/$resumeId": typeof PrinterResumeIdRoute;
  "/_home/": typeof HomeIndexRoute;
  "/auth/": typeof AuthIndexRoute;
  "/dashboard/": typeof DashboardIndexRoute;
  "/mcp/": typeof McpIndexRoute;
  "/api/auth/$": typeof ApiAuthSplatRoute;
  "/api/openapi/$": typeof ApiOpenapiSplatRoute;
  "/api/rpc/$": typeof ApiRpcSplatRoute;
  "/dashboard/settings/ai": typeof DashboardSettingsAiRoute;
  "/dashboard/settings/api-keys": typeof DashboardSettingsApiKeysRoute;
  "/dashboard/settings/danger-zone": typeof DashboardSettingsDangerZoneRoute;
  "/dashboard/settings/preferences": typeof DashboardSettingsPreferencesRoute;
  "/dashboard/settings/profile": typeof DashboardSettingsProfileRoute;
  "/uploads/$userId/$": typeof UploadsUserIdSplatRoute;
  "/builder/$resumeId/": typeof BuilderResumeIdIndexRoute;
  "/dashboard/resumes/": typeof DashboardResumesIndexRoute;
  "/dashboard/settings/authentication/": typeof DashboardSettingsAuthenticationIndexRoute;
}
export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath;
  fullPaths:
    | "/"
    | "/auth"
    | "/dashboard"
    | "/schema.json"
    | "/builder/$resumeId"
    | "/$username/$slug"
    | "/api/health"
    | "/auth/forgot-password"
    | "/auth/login"
    | "/auth/register"
    | "/auth/reset-password"
    | "/auth/resume-password"
    | "/auth/verify-2fa"
    | "/auth/verify-2fa-backup"
    | "/printer/$resumeId"
    | "/auth/"
    | "/dashboard/"
    | "/mcp/"
    | "/api/auth/$"
    | "/api/openapi/$"
    | "/api/rpc/$"
    | "/dashboard/settings/ai"
    | "/dashboard/settings/api-keys"
    | "/dashboard/settings/danger-zone"
    | "/dashboard/settings/preferences"
    | "/dashboard/settings/profile"
    | "/uploads/$userId/$"
    | "/builder/$resumeId/"
    | "/dashboard/resumes/"
    | "/dashboard/settings/authentication/";
  fileRoutesByTo: FileRoutesByTo;
  to:
    | "/schema.json"
    | "/$username/$slug"
    | "/api/health"
    | "/auth/forgot-password"
    | "/auth/login"
    | "/auth/register"
    | "/auth/reset-password"
    | "/auth/resume-password"
    | "/auth/verify-2fa"
    | "/auth/verify-2fa-backup"
    | "/printer/$resumeId"
    | "/"
    | "/auth"
    | "/dashboard"
    | "/mcp"
    | "/api/auth/$"
    | "/api/openapi/$"
    | "/api/rpc/$"
    | "/dashboard/settings/ai"
    | "/dashboard/settings/api-keys"
    | "/dashboard/settings/danger-zone"
    | "/dashboard/settings/preferences"
    | "/dashboard/settings/profile"
    | "/uploads/$userId/$"
    | "/builder/$resumeId"
    | "/dashboard/resumes"
    | "/dashboard/settings/authentication";
  id:
    | "__root__"
    | "/_home"
    | "/auth"
    | "/dashboard"
    | "/schema.json"
    | "/builder/$resumeId"
    | "/$username/$slug"
    | "/api/health"
    | "/auth/forgot-password"
    | "/auth/login"
    | "/auth/register"
    | "/auth/reset-password"
    | "/auth/resume-password"
    | "/auth/verify-2fa"
    | "/auth/verify-2fa-backup"
    | "/printer/$resumeId"
    | "/_home/"
    | "/auth/"
    | "/dashboard/"
    | "/mcp/"
    | "/api/auth/$"
    | "/api/openapi/$"
    | "/api/rpc/$"
    | "/dashboard/settings/ai"
    | "/dashboard/settings/api-keys"
    | "/dashboard/settings/danger-zone"
    | "/dashboard/settings/preferences"
    | "/dashboard/settings/profile"
    | "/uploads/$userId/$"
    | "/builder/$resumeId/"
    | "/dashboard/resumes/"
    | "/dashboard/settings/authentication/";
  fileRoutesById: FileRoutesById;
}
export interface RootRouteChildren {
  HomeRouteRoute: typeof HomeRouteRouteWithChildren;
  AuthRouteRoute: typeof AuthRouteRouteWithChildren;
  DashboardRouteRoute: typeof DashboardRouteRouteWithChildren;
  SchemaDotjsonRoute: typeof SchemaDotjsonRoute;
  BuilderResumeIdRouteRoute: typeof BuilderResumeIdRouteRouteWithChildren;
  UsernameSlugRoute: typeof UsernameSlugRoute;
  ApiHealthRoute: typeof ApiHealthRoute;
  PrinterResumeIdRoute: typeof PrinterResumeIdRoute;
  McpIndexRoute: typeof McpIndexRoute;
  ApiAuthSplatRoute: typeof ApiAuthSplatRoute;
  ApiOpenapiSplatRoute: typeof ApiOpenapiSplatRoute;
  ApiRpcSplatRoute: typeof ApiRpcSplatRoute;
  UploadsUserIdSplatRoute: typeof UploadsUserIdSplatRoute;
}

declare module "@tanstack/react-router" {
  interface FileRoutesByPath {
    "/schema.json": {
      id: "/schema.json";
      path: "/schema.json";
      fullPath: "/schema.json";
      preLoaderRoute: typeof SchemaDotjsonRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/dashboard": {
      id: "/dashboard";
      path: "/dashboard";
      fullPath: "/dashboard";
      preLoaderRoute: typeof DashboardRouteRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/auth": {
      id: "/auth";
      path: "/auth";
      fullPath: "/auth";
      preLoaderRoute: typeof AuthRouteRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/_home": {
      id: "/_home";
      path: "";
      fullPath: "/";
      preLoaderRoute: typeof HomeRouteRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/mcp/": {
      id: "/mcp/";
      path: "/mcp";
      fullPath: "/mcp/";
      preLoaderRoute: typeof McpIndexRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/dashboard/": {
      id: "/dashboard/";
      path: "/";
      fullPath: "/dashboard/";
      preLoaderRoute: typeof DashboardIndexRouteImport;
      parentRoute: typeof DashboardRouteRoute;
    };
    "/auth/": {
      id: "/auth/";
      path: "/";
      fullPath: "/auth/";
      preLoaderRoute: typeof AuthIndexRouteImport;
      parentRoute: typeof AuthRouteRoute;
    };
    "/_home/": {
      id: "/_home/";
      path: "/";
      fullPath: "/";
      preLoaderRoute: typeof HomeIndexRouteImport;
      parentRoute: typeof HomeRouteRoute;
    };
    "/printer/$resumeId": {
      id: "/printer/$resumeId";
      path: "/printer/$resumeId";
      fullPath: "/printer/$resumeId";
      preLoaderRoute: typeof PrinterResumeIdRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/auth/verify-2fa-backup": {
      id: "/auth/verify-2fa-backup";
      path: "/verify-2fa-backup";
      fullPath: "/auth/verify-2fa-backup";
      preLoaderRoute: typeof AuthVerify2faBackupRouteImport;
      parentRoute: typeof AuthRouteRoute;
    };
    "/auth/verify-2fa": {
      id: "/auth/verify-2fa";
      path: "/verify-2fa";
      fullPath: "/auth/verify-2fa";
      preLoaderRoute: typeof AuthVerify2faRouteImport;
      parentRoute: typeof AuthRouteRoute;
    };
    "/auth/resume-password": {
      id: "/auth/resume-password";
      path: "/resume-password";
      fullPath: "/auth/resume-password";
      preLoaderRoute: typeof AuthResumePasswordRouteImport;
      parentRoute: typeof AuthRouteRoute;
    };
    "/auth/reset-password": {
      id: "/auth/reset-password";
      path: "/reset-password";
      fullPath: "/auth/reset-password";
      preLoaderRoute: typeof AuthResetPasswordRouteImport;
      parentRoute: typeof AuthRouteRoute;
    };
    "/auth/register": {
      id: "/auth/register";
      path: "/register";
      fullPath: "/auth/register";
      preLoaderRoute: typeof AuthRegisterRouteImport;
      parentRoute: typeof AuthRouteRoute;
    };
    "/auth/login": {
      id: "/auth/login";
      path: "/login";
      fullPath: "/auth/login";
      preLoaderRoute: typeof AuthLoginRouteImport;
      parentRoute: typeof AuthRouteRoute;
    };
    "/auth/forgot-password": {
      id: "/auth/forgot-password";
      path: "/forgot-password";
      fullPath: "/auth/forgot-password";
      preLoaderRoute: typeof AuthForgotPasswordRouteImport;
      parentRoute: typeof AuthRouteRoute;
    };
    "/api/health": {
      id: "/api/health";
      path: "/api/health";
      fullPath: "/api/health";
      preLoaderRoute: typeof ApiHealthRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/$username/$slug": {
      id: "/$username/$slug";
      path: "/$username/$slug";
      fullPath: "/$username/$slug";
      preLoaderRoute: typeof UsernameSlugRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/builder/$resumeId": {
      id: "/builder/$resumeId";
      path: "/builder/$resumeId";
      fullPath: "/builder/$resumeId";
      preLoaderRoute: typeof BuilderResumeIdRouteRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/dashboard/resumes/": {
      id: "/dashboard/resumes/";
      path: "/resumes";
      fullPath: "/dashboard/resumes/";
      preLoaderRoute: typeof DashboardResumesIndexRouteImport;
      parentRoute: typeof DashboardRouteRoute;
    };
    "/builder/$resumeId/": {
      id: "/builder/$resumeId/";
      path: "/";
      fullPath: "/builder/$resumeId/";
      preLoaderRoute: typeof BuilderResumeIdIndexRouteImport;
      parentRoute: typeof BuilderResumeIdRouteRoute;
    };
    "/uploads/$userId/$": {
      id: "/uploads/$userId/$";
      path: "/uploads/$userId/$";
      fullPath: "/uploads/$userId/$";
      preLoaderRoute: typeof UploadsUserIdSplatRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/dashboard/settings/profile": {
      id: "/dashboard/settings/profile";
      path: "/settings/profile";
      fullPath: "/dashboard/settings/profile";
      preLoaderRoute: typeof DashboardSettingsProfileRouteImport;
      parentRoute: typeof DashboardRouteRoute;
    };
    "/dashboard/settings/preferences": {
      id: "/dashboard/settings/preferences";
      path: "/settings/preferences";
      fullPath: "/dashboard/settings/preferences";
      preLoaderRoute: typeof DashboardSettingsPreferencesRouteImport;
      parentRoute: typeof DashboardRouteRoute;
    };
    "/dashboard/settings/danger-zone": {
      id: "/dashboard/settings/danger-zone";
      path: "/settings/danger-zone";
      fullPath: "/dashboard/settings/danger-zone";
      preLoaderRoute: typeof DashboardSettingsDangerZoneRouteImport;
      parentRoute: typeof DashboardRouteRoute;
    };
    "/dashboard/settings/api-keys": {
      id: "/dashboard/settings/api-keys";
      path: "/settings/api-keys";
      fullPath: "/dashboard/settings/api-keys";
      preLoaderRoute: typeof DashboardSettingsApiKeysRouteImport;
      parentRoute: typeof DashboardRouteRoute;
    };
    "/dashboard/settings/ai": {
      id: "/dashboard/settings/ai";
      path: "/settings/ai";
      fullPath: "/dashboard/settings/ai";
      preLoaderRoute: typeof DashboardSettingsAiRouteImport;
      parentRoute: typeof DashboardRouteRoute;
    };
    "/api/rpc/$": {
      id: "/api/rpc/$";
      path: "/api/rpc/$";
      fullPath: "/api/rpc/$";
      preLoaderRoute: typeof ApiRpcSplatRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/api/openapi/$": {
      id: "/api/openapi/$";
      path: "/api/openapi/$";
      fullPath: "/api/openapi/$";
      preLoaderRoute: typeof ApiOpenapiSplatRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/api/auth/$": {
      id: "/api/auth/$";
      path: "/api/auth/$";
      fullPath: "/api/auth/$";
      preLoaderRoute: typeof ApiAuthSplatRouteImport;
      parentRoute: typeof rootRouteImport;
    };
    "/dashboard/settings/authentication/": {
      id: "/dashboard/settings/authentication/";
      path: "/settings/authentication";
      fullPath: "/dashboard/settings/authentication/";
      preLoaderRoute: typeof DashboardSettingsAuthenticationIndexRouteImport;
      parentRoute: typeof DashboardRouteRoute;
    };
  }
}

interface HomeRouteRouteChildren {
  HomeIndexRoute: typeof HomeIndexRoute;
}

const HomeRouteRouteChildren: HomeRouteRouteChildren = {
  HomeIndexRoute: HomeIndexRoute,
};

const HomeRouteRouteWithChildren = HomeRouteRoute._addFileChildren(
  HomeRouteRouteChildren,
);

interface AuthRouteRouteChildren {
  AuthForgotPasswordRoute: typeof AuthForgotPasswordRoute;
  AuthLoginRoute: typeof AuthLoginRoute;
  AuthRegisterRoute: typeof AuthRegisterRoute;
  AuthResetPasswordRoute: typeof AuthResetPasswordRoute;
  AuthResumePasswordRoute: typeof AuthResumePasswordRoute;
  AuthVerify2faRoute: typeof AuthVerify2faRoute;
  AuthVerify2faBackupRoute: typeof AuthVerify2faBackupRoute;
  AuthIndexRoute: typeof AuthIndexRoute;
}

const AuthRouteRouteChildren: AuthRouteRouteChildren = {
  AuthForgotPasswordRoute: AuthForgotPasswordRoute,
  AuthLoginRoute: AuthLoginRoute,
  AuthRegisterRoute: AuthRegisterRoute,
  AuthResetPasswordRoute: AuthResetPasswordRoute,
  AuthResumePasswordRoute: AuthResumePasswordRoute,
  AuthVerify2faRoute: AuthVerify2faRoute,
  AuthVerify2faBackupRoute: AuthVerify2faBackupRoute,
  AuthIndexRoute: AuthIndexRoute,
};

const AuthRouteRouteWithChildren = AuthRouteRoute._addFileChildren(
  AuthRouteRouteChildren,
);

interface DashboardRouteRouteChildren {
  DashboardIndexRoute: typeof DashboardIndexRoute;
  DashboardSettingsAiRoute: typeof DashboardSettingsAiRoute;
  DashboardSettingsApiKeysRoute: typeof DashboardSettingsApiKeysRoute;
  DashboardSettingsDangerZoneRoute: typeof DashboardSettingsDangerZoneRoute;
  DashboardSettingsPreferencesRoute: typeof DashboardSettingsPreferencesRoute;
  DashboardSettingsProfileRoute: typeof DashboardSettingsProfileRoute;
  DashboardResumesIndexRoute: typeof DashboardResumesIndexRoute;
  DashboardSettingsAuthenticationIndexRoute: typeof DashboardSettingsAuthenticationIndexRoute;
}

const DashboardRouteRouteChildren: DashboardRouteRouteChildren = {
  DashboardIndexRoute: DashboardIndexRoute,
  DashboardSettingsAiRoute: DashboardSettingsAiRoute,
  DashboardSettingsApiKeysRoute: DashboardSettingsApiKeysRoute,
  DashboardSettingsDangerZoneRoute: DashboardSettingsDangerZoneRoute,
  DashboardSettingsPreferencesRoute: DashboardSettingsPreferencesRoute,
  DashboardSettingsProfileRoute: DashboardSettingsProfileRoute,
  DashboardResumesIndexRoute: DashboardResumesIndexRoute,
  DashboardSettingsAuthenticationIndexRoute:
    DashboardSettingsAuthenticationIndexRoute,
};

const DashboardRouteRouteWithChildren = DashboardRouteRoute._addFileChildren(
  DashboardRouteRouteChildren,
);

interface BuilderResumeIdRouteRouteChildren {
  BuilderResumeIdIndexRoute: typeof BuilderResumeIdIndexRoute;
}

const BuilderResumeIdRouteRouteChildren: BuilderResumeIdRouteRouteChildren = {
  BuilderResumeIdIndexRoute: BuilderResumeIdIndexRoute,
};

const BuilderResumeIdRouteRouteWithChildren =
  BuilderResumeIdRouteRoute._addFileChildren(BuilderResumeIdRouteRouteChildren);

const rootRouteChildren: RootRouteChildren = {
  HomeRouteRoute: HomeRouteRouteWithChildren,
  AuthRouteRoute: AuthRouteRouteWithChildren,
  DashboardRouteRoute: DashboardRouteRouteWithChildren,
  SchemaDotjsonRoute: SchemaDotjsonRoute,
  BuilderResumeIdRouteRoute: BuilderResumeIdRouteRouteWithChildren,
  UsernameSlugRoute: UsernameSlugRoute,
  ApiHealthRoute: ApiHealthRoute,
  PrinterResumeIdRoute: PrinterResumeIdRoute,
  McpIndexRoute: McpIndexRoute,
  ApiAuthSplatRoute: ApiAuthSplatRoute,
  ApiOpenapiSplatRoute: ApiOpenapiSplatRoute,
  ApiRpcSplatRoute: ApiRpcSplatRoute,
  UploadsUserIdSplatRoute: UploadsUserIdSplatRoute,
};
export const routeTree = rootRouteImport
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>();

import type { getRouter } from "./router.tsx";
import type { createStart } from "@tanstack/react-start";
declare module "@tanstack/react-start" {
  interface Register {
    ssr: true;
    router: Awaited<ReturnType<typeof getRouter>>;
  }
}


--- src/vite-env.d.ts ---
/// <reference types="vite-plugin-pwa/client" />

declare const __APP_VERSION__: string;

declare module "*.css";
declare module "@fontsource/*" {}
declare module "@fontsource-variable/*" {}

declare namespace NodeJS {
	interface ProcessEnv {
		// Basics
		PORT: string;
		APP_URL: string;
		PRINTER_APP_URL?: string;

		// Authentication
		AUTH_SECRET: string;

		// Printer
		PRINTER_ENDPOINT?: string;

		// Database
		DATABASE_URL: string;

		// Social Auth (Google)
		GOOGLE_CLIENT_ID?: string;
		GOOGLE_CLIENT_SECRET?: string;

		// Social Auth (GitHub)
		GITHUB_CLIENT_ID?: string;
		GITHUB_CLIENT_SECRET?: string;

		// Storage (Optional)
		S3_ACCESS_KEY_ID?: string;
		S3_SECRET_ACCESS_KEY?: string;
		S3_REGION?: string;
		S3_ENDPOINT?: string;
		S3_BUCKET?: string;
		S3_FORCE_PATH_STYLE?: string | boolean;

		// Custom OAuth Provider
		OAUTH_PROVIDER_NAME?: string;
		OAUTH_CLIENT_ID?: string;
		OAUTH_CLIENT_SECRET?: string;
		OAUTH_DISCOVERY_URL?: string;
		OAUTH_AUTHORIZATION_URL?: string;
		OAUTH_TOKEN_URL?: string;
		OAUTH_USER_INFO_URL?: string;
		OAUTH_SCOPES?: string;

		// Feature Flags
		FLAG_DEBUG_PRINTER: string | boolean;
		FLAG_DISABLE_SIGNUPS: string | boolean;
		FLAG_DISABLE_EMAIL_AUTH: string | boolean;
		FLAG_DISABLE_IMAGE_PROCESSING: string | boolean;
	}
}


--- src/utils/color.ts ---
export interface ColorValue {
	r: number;
	g: number;
	b: number;
	a: number;
}

export interface HSVColorValue {
	h: number;
	s: number;
	v: number;
	a: number;
}

export function rgbToHsv(color: ColorValue): HSVColorValue {
	const r = color.r / 255;
	const g = color.g / 255;
	const b = color.b / 255;

	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const diff = max - min;

	let h = 0;
	if (diff !== 0) {
		switch (max) {
			case r:
				h = ((g - b) / diff) % 6;
				break;
			case g:
				h = (b - r) / diff + 2;
				break;
			case b:
				h = (r - g) / diff + 4;
				break;
		}
	}
	h = Math.round(h * 60);
	if (h < 0) h += 360;

	const s = max === 0 ? 0 : diff / max;
	const v = max;

	return {
		h,
		s: Math.round(s * 100),
		v: Math.round(v * 100),
		a: color.a,
	};
}

export function hsvToRgb(hsv: HSVColorValue): ColorValue {
	const h = hsv.h / 360;
	const s = hsv.s / 100;
	const v = hsv.v / 100;

	const i = Math.floor(h * 6);
	const f = h * 6 - i;
	const p = v * (1 - s);
	const q = v * (1 - f * s);
	const t = v * (1 - (1 - f) * s);

	let r: number;
	let g: number;
	let b: number;

	switch (i % 6) {
		case 0: {
			r = v;
			g = t;
			b = p;
			break;
		}
		case 1: {
			r = q;
			g = v;
			b = p;
			break;
		}
		case 2: {
			r = p;
			g = v;
			b = t;
			break;
		}
		case 3: {
			r = p;
			g = q;
			b = v;
			break;
		}
		case 4: {
			r = t;
			g = p;
			b = v;
			break;
		}
		case 5: {
			r = v;
			g = p;
			b = q;
			break;
		}
		default: {
			r = 0;
			g = 0;
			b = 0;
		}
	}

	return {
		r: Math.round(r * 255),
		g: Math.round(g * 255),
		b: Math.round(b * 255),
		a: hsv.a,
	};
}

export function parseRgbString(value: string): ColorValue | null {
	const trimmed = value.trim();

	// Parse rgb/rgba colors
	const rgbMatch = trimmed.match(/^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+))?\s*\)$/);
	if (rgbMatch) {
		return {
			r: Number.parseInt(rgbMatch[1] ?? "0", 10),
			g: Number.parseInt(rgbMatch[2] ?? "0", 10),
			b: Number.parseInt(rgbMatch[3] ?? "0", 10),
			a: rgbMatch[4] ? Number.parseFloat(rgbMatch[4]) : 1,
		};
	}

	// Parse hex colors (convert to RGB)
	if (trimmed.startsWith("#")) {
		const hexMatch = trimmed.match(/^#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/i);
		if (hexMatch) {
			return {
				r: Number.parseInt(hexMatch[1] ?? "0", 16),
				g: Number.parseInt(hexMatch[2] ?? "0", 16),
				b: Number.parseInt(hexMatch[3] ?? "0", 16),
				a: 1,
			};
		}
		// Support 3-digit hex
		const hexMatch3 = trimmed.match(/^#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/i);
		if (hexMatch3) {
			return {
				r: Number.parseInt((hexMatch3[1] ?? "0") + (hexMatch3[1] ?? "0"), 16),
				g: Number.parseInt((hexMatch3[2] ?? "0") + (hexMatch3[2] ?? "0"), 16),
				b: Number.parseInt((hexMatch3[3] ?? "0") + (hexMatch3[3] ?? "0"), 16),
				a: 1,
			};
		}
	}

	return null;
}

export function rgbToString(color: ColorValue): string {
	return color.a < 1
		? `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`
		: `rgb(${color.r}, ${color.g}, ${color.b})`;
}

export function hexToRgb(hex: string, alpha = 1): ColorValue {
	const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result
		? {
				r: Number.parseInt(result[1] ?? "0", 16),
				g: Number.parseInt(result[2] ?? "0", 16),
				b: Number.parseInt(result[3] ?? "0", 16),
				a: alpha,
			}
		: { r: 0, g: 0, b: 0, a: alpha };
}


--- src/utils/compose-refs.ts ---
import { useCallback } from "react";

type PossibleRef<T> = React.Ref<T> | undefined;

/**
 * Set a given ref to a given value
 * This utility takes care of different types of refs: callback refs and RefObject(s)
 */
function setRef<T>(ref: PossibleRef<T>, value: T) {
	if (typeof ref === "function") {
		return ref(value);
	}

	if (ref !== null && ref !== undefined) {
		ref.current = value;
	}
}

/**
 * A utility to compose multiple refs together
 * Accepts callback refs and RefObject(s)
 */
function composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {
	return (node) => {
		let hasCleanup = false;

		const cleanups = refs.map((ref) => {
			const cleanup = setRef(ref, node);
			if (!hasCleanup && typeof cleanup === "function") {
				hasCleanup = true;
			}
			return cleanup;
		});

		// React <19 will log an error to the console if a callback ref returns a
		// value. We don't use ref cleanups internally so this will only happen if a
		// user's ref callback returns a value, which we only expect if they are
		// using the cleanup functionality added in React 19.
		if (hasCleanup) {
			return () => {
				for (let i = 0; i < cleanups.length; i++) {
					const cleanup = cleanups[i];

					if (typeof cleanup === "function") {
						cleanup();
					} else {
						setRef(refs[i], null);
					}
				}
			};
		}
	};
}

/**
 * A custom hook that composes multiple refs
 * Accepts callback refs and RefObject(s)
 */
function useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {
	return useCallback(composeRefs(...refs), refs);
}

export { useComposedRefs };


--- src/utils/env.ts ---
import { createEnv } from "@t3-oss/env-core";
import { z } from "zod";

export const env = createEnv({
	clientPrefix: "VITE_",
	runtimeEnv: process.env,
	emptyStringAsUndefined: true,

	client: {},

	server: {
		// Server
		TZ: z.string().default("Etc/UTC"),
		APP_URL: z.url({ protocol: /https?/ }),
		PRINTER_APP_URL: z.url({ protocol: /https?/ }).optional(),

		// Printer
		PRINTER_ENDPOINT: z.url({ protocol: /^(wss?|https?)$/ }),

		// Database
		DATABASE_URL: z.url({ protocol: /postgres(ql)?/ }),

		// Authentication
		AUTH_SECRET: z.string().min(1),

		// Social Auth (Google)
		GOOGLE_CLIENT_ID: z.string().min(1).optional(),
		GOOGLE_CLIENT_SECRET: z.string().min(1).optional(),

		// Social Auth (GitHub)
		GITHUB_CLIENT_ID: z.string().min(1).optional(),
		GITHUB_CLIENT_SECRET: z.string().min(1).optional(),

		// Custom OAuth Provider
		OAUTH_PROVIDER_NAME: z.string().min(1).optional(),
		OAUTH_CLIENT_ID: z.string().min(1).optional(),
		OAUTH_CLIENT_SECRET: z.string().min(1).optional(),
		OAUTH_DISCOVERY_URL: z.url({ protocol: /https?/ }).optional(),
		OAUTH_AUTHORIZATION_URL: z.url({ protocol: /https?/ }).optional(),
		OAUTH_TOKEN_URL: z.url({ protocol: /https?/ }).optional(),
		OAUTH_USER_INFO_URL: z.url({ protocol: /https?/ }).optional(),
		OAUTH_SCOPES: z
			.string()
			.min(1)
			.transform((value) => value.split(" "))
			.default(["openid", "profile", "email"]),

		// Email (SMTP)
		SMTP_HOST: z.string().min(1).optional(),
		SMTP_PORT: z.coerce.number().int().min(1).max(65535).default(587),
		SMTP_USER: z.string().min(1).optional(),
		SMTP_PASS: z.string().min(1).optional(),
		SMTP_FROM: z.string().min(1).optional(),
		SMTP_SECURE: z.stringbool().default(false),

		// Storage (Optional)
		S3_ACCESS_KEY_ID: z.string().min(1).optional(),
		S3_SECRET_ACCESS_KEY: z.string().min(1).optional(),
		S3_REGION: z.string().default("us-east-1"),
		S3_ENDPOINT: z.url({ protocol: /https?/ }).optional(),
		S3_BUCKET: z.string().min(1).optional(),
		// Set to "true" for path-style URLs (endpoint/bucket), common with MinIO, SeaweedFS, etc.
		// Set to "false" for virtual-hosted-style URLs (bucket.endpoint), common with AWS S3, Cloudflare R2, etc.
		S3_FORCE_PATH_STYLE: z.stringbool().default(false),

		// Feature Flags
		FLAG_DEBUG_PRINTER: z.stringbool().default(false),
		FLAG_DISABLE_SIGNUPS: z.stringbool().default(false),
		FLAG_DISABLE_EMAIL_AUTH: z.stringbool().default(false),
		FLAG_DISABLE_IMAGE_PROCESSING: z.stringbool().default(false),
	},
});


--- src/utils/file.ts ---
import { slugify } from "./string";

function getReadableTimestamp(now: Date) {
	const y = now.getFullYear();
	const m = String(now.getMonth() + 1).padStart(2, "0");
	const d = String(now.getDate()).padStart(2, "0");
	const h = String(now.getHours()).padStart(2, "0");
	const min = String(now.getMinutes()).padStart(2, "0");

	return `${y}${m}${d}_${h}${min}`;
}

export function generateFilename(prefix: string, extension?: string) {
	const now = new Date();
	const name = slugify(prefix);
	const timestamp = getReadableTimestamp(now);

	return `${name}_${timestamp}${extension ? `.${extension}` : ""}`;
}

export function downloadWithAnchor(blob: Blob, filename: string) {
	const a = document.createElement("a");
	const url = URL.createObjectURL(blob);

	a.href = url;
	a.rel = "noopener";
	a.download = filename;

	document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);

	setTimeout(() => URL.revokeObjectURL(url), 500);
}

export async function downloadFromUrl(url: string, filename: string) {
	const response = await fetch(url);
	const blob = await response.blob();

	downloadWithAnchor(blob, filename);
}


--- src/schema/icons.ts ---
export const icons = [
	"",
	"acorn",
	"address-book",
	"address-book-tabs",
	"air-traffic-control",
	"airplane",
	"airplane-in-flight",
	"airplane-landing",
	"airplane-takeoff",
	"airplane-taxiing",
	"airplane-tilt",
	"airplay",
	"alarm",
	"alien",
	"align-bottom",
	"align-bottom-simple",
	"align-center-horizontal",
	"align-center-horizontal-simple",
	"align-center-vertical",
	"align-center-vertical-simple",
	"align-left",
	"align-left-simple",
	"align-right",
	"align-right-simple",
	"align-top",
	"align-top-simple",
	"amazon-logo",
	"ambulance",
	"anchor",
	"anchor-simple",
	"android-logo",
	"angle",
	"angular-logo",
	"aperture",
	"app-store-logo",
	"app-window",
	"apple-logo",
	"apple-podcasts-logo",
	"approximate-equals",
	"archive",
	"armchair",
	"arrow-arc-left",
	"arrow-arc-right",
	"arrow-bend-double-up-left",
	"arrow-bend-double-up-right",
	"arrow-bend-down-left",
	"arrow-bend-down-right",
	"arrow-bend-left-down",
	"arrow-bend-left-up",
	"arrow-bend-right-down",
	"arrow-bend-right-up",
	"arrow-bend-up-left",
	"arrow-bend-up-right",
	"arrow-circle-down",
	"arrow-circle-down-left",
	"arrow-circle-down-right",
	"arrow-circle-left",
	"arrow-circle-right",
	"arrow-circle-up",
	"arrow-circle-up-left",
	"arrow-circle-up-right",
	"arrow-clockwise",
	"arrow-counter-clockwise",
	"arrow-down",
	"arrow-down-left",
	"arrow-down-right",
	"arrow-elbow-down-left",
	"arrow-elbow-down-right",
	"arrow-elbow-left",
	"arrow-elbow-left-down",
	"arrow-elbow-left-up",
	"arrow-elbow-right",
	"arrow-elbow-right-down",
	"arrow-elbow-right-up",
	"arrow-elbow-up-left",
	"arrow-elbow-up-right",
	"arrow-fat-down",
	"arrow-fat-left",
	"arrow-fat-line-down",
	"arrow-fat-line-left",
	"arrow-fat-line-right",
	"arrow-fat-line-up",
	"arrow-fat-lines-down",
	"arrow-fat-lines-left",
	"arrow-fat-lines-right",
	"arrow-fat-lines-up",
	"arrow-fat-right",
	"arrow-fat-up",
	"arrow-left",
	"arrow-line-down",
	"arrow-line-down-left",
	"arrow-line-down-right",
	"arrow-line-left",
	"arrow-line-right",
	"arrow-line-up",
	"arrow-line-up-left",
	"arrow-line-up-right",
	"arrow-right",
	"arrow-square-down",
	"arrow-square-down-left",
	"arrow-square-down-right",
	"arrow-square-in",
	"arrow-square-left",
	"arrow-square-out",
	"arrow-square-right",
	"arrow-square-up",
	"arrow-square-up-left",
	"arrow-square-up-right",
	"arrow-u-down-left",
	"arrow-u-down-right",
	"arrow-u-left-down",
	"arrow-u-left-up",
	"arrow-u-right-down",
	"arrow-u-right-up",
	"arrow-u-up-left",
	"arrow-u-up-right",
	"arrow-up",
	"arrow-up-left",
	"arrow-up-right",
	"arrows-clockwise",
	"arrows-counter-clockwise",
	"arrows-down-up",
	"arrows-horizontal",
	"arrows-in",
	"arrows-in-cardinal",
	"arrows-in-line-horizontal",
	"arrows-in-line-vertical",
	"arrows-in-simple",
	"arrows-left-right",
	"arrows-merge",
	"arrows-out",
	"arrows-out-cardinal",
	"arrows-out-line-horizontal",
	"arrows-out-line-vertical",
	"arrows-out-simple",
	"arrows-split",
	"arrows-vertical",
	"article",
	"article-medium",
	"article-ny-times",
	"asclepius",
	"caduceus",
	"asterisk",
	"asterisk-simple",
	"at",
	"atom",
	"avocado",
	"axe",
	"baby",
	"baby-carriage",
	"backpack",
	"backspace",
	"bag",
	"bag-simple",
	"balloon",
	"bandaids",
	"bank",
	"barbell",
	"barcode",
	"barn",
	"barricade",
	"baseball",
	"baseball-cap",
	"baseball-helmet",
	"basket",
	"basketball",
	"bathtub",
	"battery-charging",
	"battery-charging-vertical",
	"battery-empty",
	"battery-full",
	"battery-high",
	"battery-low",
	"battery-medium",
	"battery-plus",
	"battery-plus-vertical",
	"battery-vertical-empty",
	"battery-vertical-full",
	"battery-vertical-high",
	"battery-vertical-low",
	"battery-vertical-medium",
	"battery-warning",
	"battery-warning-vertical",
	"beach-ball",
	"beanie",
	"bed",
	"beer-bottle",
	"beer-stein",
	"behance-logo",
	"bell",
	"bell-ringing",
	"bell-simple",
	"bell-simple-ringing",
	"bell-simple-slash",
	"bell-simple-z",
	"bell-slash",
	"bell-z",
	"belt",
	"bezier-curve",
	"bicycle",
	"binary",
	"binoculars",
	"biohazard",
	"bird",
	"blueprint",
	"bluetooth",
	"bluetooth-connected",
	"bluetooth-slash",
	"bluetooth-x",
	"boat",
	"bomb",
	"bone",
	"book",
	"book-bookmark",
	"book-open",
	"book-open-text",
	"book-open-user",
	"bookmark",
	"bookmark-simple",
	"bookmarks",
	"bookmarks-simple",
	"books",
	"boot",
	"boules",
	"bounding-box",
	"bowl-food",
	"bowl-steam",
	"bowling-ball",
	"box-arrow-down",
	"archive-box",
	"box-arrow-up",
	"boxing-glove",
	"brackets-angle",
	"brackets-curly",
	"brackets-round",
	"brackets-square",
	"brain",
	"brandy",
	"bread",
	"bridge",
	"briefcase",
	"briefcase-metal",
	"broadcast",
	"broom",
	"browser",
	"browsers",
	"bug",
	"bug-beetle",
	"bug-droid",
	"building",
	"building-apartment",
	"building-office",
	"buildings",
	"bulldozer",
	"bus",
	"butterfly",
	"cable-car",
	"cactus",
	"cake",
	"calculator",
	"calendar",
	"calendar-blank",
	"calendar-check",
	"calendar-dot",
	"calendar-dots",
	"calendar-heart",
	"calendar-minus",
	"calendar-plus",
	"calendar-slash",
	"calendar-star",
	"calendar-x",
	"call-bell",
	"camera",
	"camera-plus",
	"camera-rotate",
	"camera-slash",
	"campfire",
	"car",
	"car-battery",
	"car-profile",
	"car-simple",
	"cardholder",
	"cards",
	"cards-three",
	"caret-circle-double-down",
	"caret-circle-double-left",
	"caret-circle-double-right",
	"caret-circle-double-up",
	"caret-circle-down",
	"caret-circle-left",
	"caret-circle-right",
	"caret-circle-up",
	"caret-circle-up-down",
	"caret-double-down",
	"caret-double-left",
	"caret-double-right",
	"caret-double-up",
	"caret-down",
	"caret-left",
	"caret-line-down",
	"caret-line-left",
	"caret-line-right",
	"caret-line-up",
	"caret-right",
	"caret-up",
	"caret-up-down",
	"carrot",
	"cash-register",
	"cassette-tape",
	"castle-turret",
	"cat",
	"cell-signal-full",
	"cell-signal-high",
	"cell-signal-low",
	"cell-signal-medium",
	"cell-signal-none",
	"cell-signal-slash",
	"cell-signal-x",
	"cell-tower",
	"certificate",
	"chair",
	"chalkboard",
	"chalkboard-simple",
	"chalkboard-teacher",
	"champagne",
	"charging-station",
	"chart-bar",
	"chart-bar-horizontal",
	"chart-donut",
	"chart-line",
	"chart-line-down",
	"chart-line-up",
	"chart-pie",
	"chart-pie-slice",
	"chart-polar",
	"chart-scatter",
	"chat",
	"chat-centered",
	"chat-centered-dots",
	"chat-centered-slash",
	"chat-centered-text",
	"chat-circle",
	"chat-circle-dots",
	"chat-circle-slash",
	"chat-circle-text",
	"chat-dots",
	"chat-slash",
	"chat-teardrop",
	"chat-teardrop-dots",
	"chat-teardrop-slash",
	"chat-teardrop-text",
	"chat-text",
	"chats",
	"chats-circle",
	"chats-teardrop",
	"check",
	"check-circle",
	"check-fat",
	"check-square",
	"check-square-offset",
	"checkerboard",
	"checks",
	"cheers",
	"cheese",
	"chef-hat",
	"cherries",
	"church",
	"cigarette",
	"cigarette-slash",
	"circle",
	"circle-dashed",
	"circle-half",
	"circle-half-tilt",
	"circle-notch",
	"circles-four",
	"circles-three",
	"circles-three-plus",
	"circuitry",
	"city",
	"clipboard",
	"clipboard-text",
	"clock",
	"clock-afternoon",
	"clock-clockwise",
	"clock-countdown",
	"clock-counter-clockwise",
	"clock-user",
	"closed-captioning",
	"cloud",
	"cloud-arrow-down",
	"cloud-arrow-up",
	"cloud-check",
	"cloud-fog",
	"cloud-lightning",
	"cloud-moon",
	"cloud-rain",
	"cloud-slash",
	"cloud-snow",
	"cloud-sun",
	"cloud-warning",
	"cloud-x",
	"clover",
	"club",
	"coat-hanger",
	"coda-logo",
	"code",
	"code-block",
	"code-simple",
	"codepen-logo",
	"codesandbox-logo",
	"coffee",
	"coffee-bean",
	"coin",
	"coin-vertical",
	"coins",
	"columns",
	"columns-plus-left",
	"columns-plus-right",
	"command",
	"compass",
	"compass-rose",
	"compass-tool",
	"computer-tower",
	"confetti",
	"contactless-payment",
	"control",
	"cookie",
	"cooking-pot",
	"copy",
	"copy-simple",
	"copyleft",
	"copyright",
	"corners-in",
	"corners-out",
	"couch",
	"court-basketball",
	"cow",
	"cowboy-hat",
	"cpu",
	"crane",
	"crane-tower",
	"credit-card",
	"cricket",
	"crop",
	"cross",
	"crosshair",
	"crosshair-simple",
	"crown",
	"crown-cross",
	"crown-simple",
	"cube",
	"cube-focus",
	"cube-transparent",
	"currency-btc",
	"currency-circle-dollar",
	"currency-cny",
	"currency-dollar",
	"currency-dollar-simple",
	"currency-eth",
	"currency-eur",
	"currency-gbp",
	"currency-inr",
	"currency-jpy",
	"currency-krw",
	"currency-kzt",
	"currency-ngn",
	"currency-rub",
	"cursor",
	"cursor-click",
	"cursor-text",
	"cylinder",
	"database",
	"desk",
	"desktop",
	"desktop-tower",
	"detective",
	"dev-to-logo",
	"device-mobile",
	"device-mobile-camera",
	"device-mobile-slash",
	"device-mobile-speaker",
	"device-rotate",
	"device-tablet",
	"device-tablet-camera",
	"device-tablet-speaker",
	"devices",
	"diamond",
	"diamonds-four",
	"dice-five",
	"dice-four",
	"dice-one",
	"dice-six",
	"dice-three",
	"dice-two",
	"disc",
	"disco-ball",
	"discord-logo",
	"divide",
	"dna",
	"dog",
	"door",
	"door-open",
	"dot",
	"dot-outline",
	"dots-nine",
	"dots-six",
	"dots-six-vertical",
	"dots-three",
	"dots-three-circle",
	"dots-three-circle-vertical",
	"dots-three-outline",
	"dots-three-outline-vertical",
	"dots-three-vertical",
	"download",
	"download-simple",
	"dress",
	"dresser",
	"dribbble-logo",
	"drone",
	"drop",
	"drop-half",
	"drop-half-bottom",
	"drop-simple",
	"drop-slash",
	"dropbox-logo",
	"ear",
	"ear-slash",
	"egg",
	"egg-crack",
	"eject",
	"eject-simple",
	"elevator",
	"empty",
	"engine",
	"envelope",
	"envelope-open",
	"envelope-simple",
	"envelope-simple-open",
	"equalizer",
	"equals",
	"eraser",
	"escalator-down",
	"escalator-up",
	"exam",
	"exclamation-mark",
	"exclude",
	"exclude-square",
	"export",
	"eye",
	"eye-closed",
	"eye-slash",
	"eyedropper",
	"eyedropper-sample",
	"eyeglasses",
	"eyes",
	"face-mask",
	"facebook-logo",
	"factory",
	"faders",
	"faders-horizontal",
	"fallout-shelter",
	"fan",
	"farm",
	"fast-forward",
	"fast-forward-circle",
	"feather",
	"fediverse-logo",
	"figma-logo",
	"file",
	"file-archive",
	"file-arrow-down",
	"file-arrow-up",
	"file-audio",
	"file-c",
	"file-c-sharp",
	"file-cloud",
	"file-code",
	"file-cpp",
	"file-css",
	"file-csv",
	"file-dashed",
	"file-dotted",
	"file-doc",
	"file-html",
	"file-image",
	"file-ini",
	"file-jpg",
	"file-js",
	"file-jsx",
	"file-lock",
	"file-magnifying-glass",
	"file-search",
	"file-md",
	"file-minus",
	"file-pdf",
	"file-plus",
	"file-png",
	"file-ppt",
	"file-py",
	"file-rs",
	"file-sql",
	"file-svg",
	"file-text",
	"file-ts",
	"file-tsx",
	"file-txt",
	"file-video",
	"file-vue",
	"file-x",
	"file-xls",
	"file-zip",
	"files",
	"film-reel",
	"film-script",
	"film-slate",
	"film-strip",
	"fingerprint",
	"fingerprint-simple",
	"finn-the-human",
	"fire",
	"fire-extinguisher",
	"fire-simple",
	"fire-truck",
	"first-aid",
	"first-aid-kit",
	"fish",
	"fish-simple",
	"flag",
	"flag-banner",
	"flag-banner-fold",
	"flag-checkered",
	"flag-pennant",
	"flame",
	"flashlight",
	"flask",
	"flip-horizontal",
	"flip-vertical",
	"floppy-disk",
	"floppy-disk-back",
	"flow-arrow",
	"flower",
	"flower-lotus",
	"flower-tulip",
	"flying-saucer",
	"folder",
	"folder-notch",
	"folder-dashed",
	"folder-dotted",
	"folder-lock",
	"folder-minus",
	"folder-notch-minus",
	"folder-open",
	"folder-notch-open",
	"folder-plus",
	"folder-notch-plus",
	"folder-simple",
	"folder-simple-dashed",
	"folder-simple-dotted",
	"folder-simple-lock",
	"folder-simple-minus",
	"folder-simple-plus",
	"folder-simple-star",
	"folder-simple-user",
	"folder-star",
	"folder-user",
	"folders",
	"football",
	"football-helmet",
	"footprints",
	"fork-knife",
	"four-k",
	"frame-corners",
	"framer-logo",
	"function",
	"funnel",
	"funnel-simple",
	"funnel-simple-x",
	"funnel-x",
	"game-controller",
	"garage",
	"gas-can",
	"gas-pump",
	"gauge",
	"gavel",
	"gear",
	"gear-fine",
	"gear-six",
	"gender-female",
	"gender-intersex",
	"gender-male",
	"gender-neuter",
	"gender-nonbinary",
	"gender-transgender",
	"ghost",
	"gif",
	"gift",
	"git-branch",
	"git-commit",
	"git-diff",
	"git-fork",
	"git-merge",
	"git-pull-request",
	"github-logo",
	"gitlab-logo",
	"gitlab-logo-simple",
	"globe",
	"globe-hemisphere-east",
	"globe-hemisphere-west",
	"globe-simple",
	"globe-simple-x",
	"globe-stand",
	"globe-x",
	"goggles",
	"golf",
	"goodreads-logo",
	"google-cardboard-logo",
	"google-chrome-logo",
	"google-drive-logo",
	"google-logo",
	"google-photos-logo",
	"google-play-logo",
	"google-podcasts-logo",
	"gps",
	"gps-fix",
	"gps-slash",
	"gradient",
	"graduation-cap",
	"grains",
	"grains-slash",
	"graph",
	"graphics-card",
	"greater-than",
	"greater-than-or-equal",
	"grid-four",
	"grid-nine",
	"guitar",
	"hair-dryer",
	"hamburger",
	"hammer",
	"hand",
	"hand-arrow-down",
	"hand-arrow-up",
	"hand-coins",
	"hand-deposit",
	"hand-eye",
	"hand-fist",
	"hand-grabbing",
	"hand-heart",
	"hand-palm",
	"hand-peace",
	"hand-pointing",
	"hand-soap",
	"hand-swipe-left",
	"hand-swipe-right",
	"hand-tap",
	"hand-waving",
	"hand-withdraw",
	"handbag",
	"handbag-simple",
	"hands-clapping",
	"hands-praying",
	"handshake",
	"hard-drive",
	"hard-drives",
	"hard-hat",
	"hash",
	"hash-straight",
	"head-circuit",
	"headlights",
	"headphones",
	"headset",
	"heart",
	"heart-break",
	"heart-half",
	"heart-straight",
	"heart-straight-break",
	"heartbeat",
	"hexagon",
	"high-definition",
	"high-heel",
	"highlighter",
	"highlighter-circle",
	"hockey",
	"hoodie",
	"horse",
	"hospital",
	"hourglass",
	"hourglass-high",
	"hourglass-low",
	"hourglass-medium",
	"hourglass-simple",
	"hourglass-simple-high",
	"hourglass-simple-low",
	"hourglass-simple-medium",
	"house",
	"house-line",
	"house-simple",
	"hurricane",
	"ice-cream",
	"identification-badge",
	"identification-card",
	"image",
	"image-broken",
	"image-square",
	"images",
	"images-square",
	"infinity",
	"lemniscate",
	"info",
	"instagram-logo",
	"intersect",
	"intersect-square",
	"intersect-three",
	"intersection",
	"invoice",
	"island",
	"jar",
	"jar-label",
	"jeep",
	"joystick",
	"kanban",
	"key",
	"key-return",
	"keyboard",
	"keyhole",
	"knife",
	"ladder",
	"ladder-simple",
	"lamp",
	"lamp-pendant",
	"laptop",
	"lasso",
	"lastfm-logo",
	"layout",
	"leaf",
	"lectern",
	"lego",
	"lego-smiley",
	"less-than",
	"less-than-or-equal",
	"letter-circle-h",
	"letter-circle-p",
	"letter-circle-v",
	"lifebuoy",
	"lightbulb",
	"lightbulb-filament",
	"lighthouse",
	"lightning",
	"lightning-a",
	"lightning-slash",
	"line-segment",
	"line-segments",
	"line-vertical",
	"link",
	"link-break",
	"link-simple",
	"link-simple-break",
	"link-simple-horizontal",
	"link-simple-horizontal-break",
	"linkedin-logo",
	"linktree-logo",
	"linux-logo",
	"list",
	"list-bullets",
	"list-checks",
	"list-dashes",
	"list-heart",
	"list-magnifying-glass",
	"list-numbers",
	"list-plus",
	"list-star",
	"lock",
	"lock-key",
	"lock-key-open",
	"lock-laminated",
	"lock-laminated-open",
	"lock-open",
	"lock-simple",
	"lock-simple-open",
	"lockers",
	"log",
	"magic-wand",
	"magnet",
	"magnet-straight",
	"magnifying-glass",
	"magnifying-glass-minus",
	"magnifying-glass-plus",
	"mailbox",
	"map-pin",
	"map-pin-area",
	"map-pin-line",
	"map-pin-plus",
	"map-pin-simple",
	"map-pin-simple-area",
	"map-pin-simple-line",
	"map-trifold",
	"markdown-logo",
	"marker-circle",
	"martini",
	"mask-happy",
	"mask-sad",
	"mastodon-logo",
	"math-operations",
	"matrix-logo",
	"medal",
	"medal-military",
	"medium-logo",
	"megaphone",
	"megaphone-simple",
	"member-of",
	"memory",
	"messenger-logo",
	"meta-logo",
	"meteor",
	"metronome",
	"microphone",
	"microphone-slash",
	"microphone-stage",
	"microscope",
	"microsoft-excel-logo",
	"microsoft-outlook-logo",
	"microsoft-powerpoint-logo",
	"microsoft-teams-logo",
	"microsoft-word-logo",
	"minus",
	"minus-circle",
	"minus-square",
	"money",
	"money-wavy",
	"monitor",
	"monitor-arrow-up",
	"monitor-play",
	"moon",
	"moon-stars",
	"moped",
	"moped-front",
	"mosque",
	"motorcycle",
	"mountains",
	"mouse",
	"mouse-left-click",
	"mouse-middle-click",
	"mouse-right-click",
	"mouse-scroll",
	"mouse-simple",
	"music-note",
	"music-note-simple",
	"music-notes",
	"music-notes-minus",
	"music-notes-plus",
	"music-notes-simple",
	"navigation-arrow",
	"needle",
	"network",
	"network-slash",
	"network-x",
	"newspaper",
	"newspaper-clipping",
	"not-equals",
	"not-member-of",
	"not-subset-of",
	"not-superset-of",
	"notches",
	"note",
	"note-blank",
	"note-pencil",
	"notebook",
	"notepad",
	"notification",
	"notion-logo",
	"nuclear-plant",
	"number-circle-eight",
	"number-circle-five",
	"number-circle-four",
	"number-circle-nine",
	"number-circle-one",
	"number-circle-seven",
	"number-circle-six",
	"number-circle-three",
	"number-circle-two",
	"number-circle-zero",
	"number-eight",
	"number-five",
	"number-four",
	"number-nine",
	"number-one",
	"number-seven",
	"number-six",
	"number-square-eight",
	"number-square-five",
	"number-square-four",
	"number-square-nine",
	"number-square-one",
	"number-square-seven",
	"number-square-six",
	"number-square-three",
	"number-square-two",
	"number-square-zero",
	"number-three",
	"number-two",
	"number-zero",
	"numpad",
	"nut",
	"ny-times-logo",
	"octagon",
	"office-chair",
	"onigiri",
	"open-ai-logo",
	"option",
	"orange",
	"orange-slice",
	"oven",
	"package",
	"paint-brush",
	"paint-brush-broad",
	"paint-brush-household",
	"paint-bucket",
	"paint-roller",
	"palette",
	"panorama",
	"pants",
	"paper-plane",
	"paper-plane-right",
	"paper-plane-tilt",
	"paperclip",
	"paperclip-horizontal",
	"parachute",
	"paragraph",
	"parallelogram",
	"park",
	"password",
	"path",
	"patreon-logo",
	"pause",
	"pause-circle",
	"paw-print",
	"paypal-logo",
	"peace",
	"pen",
	"pen-nib",
	"pen-nib-straight",
	"pencil",
	"pencil-circle",
	"pencil-line",
	"pencil-ruler",
	"pencil-simple",
	"pencil-simple-line",
	"pencil-simple-slash",
	"pencil-slash",
	"pentagon",
	"pentagram",
	"pepper",
	"percent",
	"person",
	"person-arms-spread",
	"person-simple",
	"person-simple-bike",
	"person-simple-circle",
	"person-simple-hike",
	"person-simple-run",
	"person-simple-ski",
	"person-simple-snowboard",
	"person-simple-swim",
	"person-simple-tai-chi",
	"person-simple-throw",
	"person-simple-walk",
	"perspective",
	"phone",
	"phone-call",
	"phone-disconnect",
	"phone-incoming",
	"phone-list",
	"phone-outgoing",
	"phone-pause",
	"phone-plus",
	"phone-slash",
	"phone-transfer",
	"phone-x",
	"phosphor-logo",
	"pi",
	"piano-keys",
	"picnic-table",
	"picture-in-picture",
	"piggy-bank",
	"pill",
	"ping-pong",
	"pint-glass",
	"pinterest-logo",
	"pinwheel",
	"pipe",
	"pipe-wrench",
	"pix-logo",
	"pizza",
	"placeholder",
	"planet",
	"plant",
	"play",
	"play-circle",
	"play-pause",
	"playlist",
	"plug",
	"plug-charging",
	"plugs",
	"plugs-connected",
	"plus",
	"plus-circle",
	"plus-minus",
	"plus-square",
	"poker-chip",
	"police-car",
	"polygon",
	"popcorn",
	"popsicle",
	"potted-plant",
	"power",
	"prescription",
	"presentation",
	"presentation-chart",
	"printer",
	"prohibit",
	"prohibit-inset",
	"projector-screen",
	"projector-screen-chart",
	"pulse",
	"activity",
	"push-pin",
	"push-pin-simple",
	"push-pin-simple-slash",
	"push-pin-slash",
	"puzzle-piece",
	"qr-code",
	"question",
	"question-mark",
	"queue",
	"quotes",
	"rabbit",
	"racquet",
	"radical",
	"radio",
	"radio-button",
	"radioactive",
	"rainbow",
	"rainbow-cloud",
	"ranking",
	"read-cv-logo",
	"receipt",
	"receipt-x",
	"record",
	"rectangle",
	"rectangle-dashed",
	"recycle",
	"reddit-logo",
	"repeat",
	"repeat-once",
	"replit-logo",
	"resize",
	"rewind",
	"rewind-circle",
	"road-horizon",
	"robot",
	"rocket",
	"rocket-launch",
	"rows",
	"rows-plus-bottom",
	"rows-plus-top",
	"rss",
	"rss-simple",
	"rug",
	"ruler",
	"sailboat",
	"scales",
	"scan",
	"scan-smiley",
	"scissors",
	"scooter",
	"screencast",
	"screwdriver",
	"scribble",
	"scribble-loop",
	"scroll",
	"seal",
	"circle-wavy",
	"seal-check",
	"circle-wavy-check",
	"seal-percent",
	"seal-question",
	"circle-wavy-question",
	"seal-warning",
	"circle-wavy-warning",
	"seat",
	"seatbelt",
	"security-camera",
	"selection",
	"selection-all",
	"selection-background",
	"selection-foreground",
	"selection-inverse",
	"selection-plus",
	"selection-slash",
	"shapes",
	"share",
	"share-fat",
	"share-network",
	"shield",
	"shield-check",
	"shield-checkered",
	"shield-chevron",
	"shield-plus",
	"shield-slash",
	"shield-star",
	"shield-warning",
	"shipping-container",
	"shirt-folded",
	"shooting-star",
	"shopping-bag",
	"shopping-bag-open",
	"shopping-cart",
	"shopping-cart-simple",
	"shovel",
	"shower",
	"shrimp",
	"shuffle",
	"shuffle-angular",
	"shuffle-simple",
	"sidebar",
	"sidebar-simple",
	"sigma",
	"sign-in",
	"sign-out",
	"signature",
	"signpost",
	"sim-card",
	"siren",
	"sketch-logo",
	"skip-back",
	"skip-back-circle",
	"skip-forward",
	"skip-forward-circle",
	"skull",
	"skype-logo",
	"slack-logo",
	"sliders",
	"sliders-horizontal",
	"slideshow",
	"smiley",
	"smiley-angry",
	"smiley-blank",
	"smiley-meh",
	"smiley-melting",
	"smiley-nervous",
	"smiley-sad",
	"smiley-sticker",
	"smiley-wink",
	"smiley-x-eyes",
	"snapchat-logo",
	"sneaker",
	"sneaker-move",
	"snowflake",
	"soccer-ball",
	"sock",
	"solar-panel",
	"solar-roof",
	"sort-ascending",
	"sort-descending",
	"soundcloud-logo",
	"spade",
	"sparkle",
	"speaker-hifi",
	"speaker-high",
	"speaker-low",
	"speaker-none",
	"speaker-simple-high",
	"speaker-simple-low",
	"speaker-simple-none",
	"speaker-simple-slash",
	"speaker-simple-x",
	"speaker-slash",
	"speaker-x",
	"speedometer",
	"sphere",
	"spinner",
	"spinner-ball",
	"spinner-gap",
	"spiral",
	"split-horizontal",
	"split-vertical",
	"spotify-logo",
	"spray-bottle",
	"square",
	"square-half",
	"square-half-bottom",
	"square-logo",
	"square-split-horizontal",
	"square-split-vertical",
	"squares-four",
	"stack",
	"stack-minus",
	"stack-overflow-logo",
	"stack-plus",
	"stack-simple",
	"stairs",
	"stamp",
	"standard-definition",
	"star",
	"star-and-crescent",
	"star-four",
	"star-half",
	"star-of-david",
	"steam-logo",
	"steering-wheel",
	"steps",
	"stethoscope",
	"sticker",
	"stool",
	"stop",
	"stop-circle",
	"storefront",
	"strategy",
	"stripe-logo",
	"student",
	"subset-of",
	"subset-proper-of",
	"subtitles",
	"subtitles-slash",
	"subtract",
	"subtract-square",
	"subway",
	"suitcase",
	"suitcase-rolling",
	"suitcase-simple",
	"sun",
	"sun-dim",
	"sun-horizon",
	"sunglasses",
	"superset-of",
	"superset-proper-of",
	"swap",
	"swatches",
	"swimming-pool",
	"sword",
	"synagogue",
	"syringe",
	"t-shirt",
	"table",
	"tabs",
	"tag",
	"tag-chevron",
	"tag-simple",
	"target",
	"taxi",
	"tea-bag",
	"telegram-logo",
	"television",
	"television-simple",
	"tennis-ball",
	"tent",
	"terminal",
	"terminal-window",
	"test-tube",
	"text-a-underline",
	"text-aa",
	"text-align-center",
	"text-align-justify",
	"text-align-left",
	"text-align-right",
	"text-b",
	"text-bolder",
	"text-columns",
	"text-h",
	"text-h-five",
	"text-h-four",
	"text-h-one",
	"text-h-six",
	"text-h-three",
	"text-h-two",
	"text-indent",
	"text-italic",
	"text-outdent",
	"text-strikethrough",
	"text-subscript",
	"text-superscript",
	"text-t",
	"text-t-slash",
	"text-underline",
	"textbox",
	"thermometer",
	"thermometer-cold",
	"thermometer-hot",
	"thermometer-simple",
	"threads-logo",
	"three-d",
	"thumbs-down",
	"thumbs-up",
	"ticket",
	"tidal-logo",
	"tiktok-logo",
	"tilde",
	"timer",
	"tip-jar",
	"tipi",
	"tire",
	"toggle-left",
	"toggle-right",
	"toilet",
	"toilet-paper",
	"toolbox",
	"tooth",
	"tornado",
	"tote",
	"tote-simple",
	"towel",
	"tractor",
	"trademark",
	"trademark-registered",
	"traffic-cone",
	"traffic-sign",
	"traffic-signal",
	"train",
	"train-regional",
	"train-simple",
	"tram",
	"translate",
	"trash",
	"trash-simple",
	"tray",
	"tray-arrow-down",
	"archive-tray",
	"tray-arrow-up",
	"treasure-chest",
	"tree",
	"tree-evergreen",
	"tree-palm",
	"tree-structure",
	"tree-view",
	"trend-down",
	"trend-up",
	"triangle",
	"triangle-dashed",
	"trolley",
	"trolley-suitcase",
	"trophy",
	"truck",
	"truck-trailer",
	"tumblr-logo",
	"twitch-logo",
	"twitter-logo",
	"umbrella",
	"umbrella-simple",
	"union",
	"unite",
	"unite-square",
	"upload",
	"upload-simple",
	"usb",
	"user",
	"user-check",
	"user-circle",
	"user-circle-check",
	"user-circle-dashed",
	"user-circle-gear",
	"user-circle-minus",
	"user-circle-plus",
	"user-focus",
	"user-gear",
	"user-list",
	"user-minus",
	"user-plus",
	"user-rectangle",
	"user-sound",
	"user-square",
	"user-switch",
	"users",
	"users-four",
	"users-three",
	"van",
	"vault",
	"vector-three",
	"vector-two",
	"vibrate",
	"video",
	"video-camera",
	"video-camera-slash",
	"video-conference",
	"vignette",
	"vinyl-record",
	"virtual-reality",
	"virus",
	"visor",
	"voicemail",
	"volleyball",
	"wall",
	"wallet",
	"warehouse",
	"warning",
	"warning-circle",
	"warning-diamond",
	"warning-octagon",
	"washing-machine",
	"watch",
	"wave-sawtooth",
	"wave-sine",
	"wave-square",
	"wave-triangle",
	"waveform",
	"waveform-slash",
	"waves",
	"webcam",
	"webcam-slash",
	"webhooks-logo",
	"wechat-logo",
	"whatsapp-logo",
	"wheelchair",
	"wheelchair-motion",
	"wifi-high",
	"wifi-low",
	"wifi-medium",
	"wifi-none",
	"wifi-slash",
	"wifi-x",
	"wind",
	"windmill",
	"windows-logo",
	"wine",
	"wrench",
	"x",
	"x-circle",
	"x-logo",
	"x-square",
	"yarn",
	"yin-yang",
	"youtube-logo",
] as const;

export type IconName = (typeof icons)[number];


--- src/utils/locale.ts ---
import { i18n, type MessageDescriptor, type Messages } from "@lingui/core";
import { msg } from "@lingui/core/macro";
import { createIsomorphicFn, createServerFn } from "@tanstack/react-start";
import { getCookie, setCookie } from "@tanstack/react-start/server";
import Cookies from "js-cookie";
import z from "zod";

const localeSchema = z.union([
	z.literal("af-ZA"),
	z.literal("am-ET"),
	z.literal("ar-SA"),
	z.literal("az-AZ"),
	z.literal("bg-BG"),
	z.literal("bn-BD"),
	z.literal("ca-ES"),
	z.literal("cs-CZ"),
	z.literal("da-DK"),
	z.literal("de-DE"),
	z.literal("el-GR"),
	z.literal("en-US"),
	z.literal("es-ES"),
	z.literal("fa-IR"),
	z.literal("fi-FI"),
	z.literal("fr-FR"),
	z.literal("he-IL"),
	z.literal("hi-IN"),
	z.literal("hu-HU"),
	z.literal("id-ID"),
	z.literal("it-IT"),
	z.literal("ja-JP"),
	z.literal("km-KH"),
	z.literal("kn-IN"),
	z.literal("ko-KR"),
	z.literal("lt-LT"),
	z.literal("lv-LV"),
	z.literal("ml-IN"),
	z.literal("mr-IN"),
	z.literal("ms-MY"),
	z.literal("ne-NP"),
	z.literal("nl-NL"),
	z.literal("no-NO"),
	z.literal("or-IN"),
	z.literal("pl-PL"),
	z.literal("pt-BR"),
	z.literal("pt-PT"),
	z.literal("ro-RO"),
	z.literal("ru-RU"),
	z.literal("sk-SK"),
	z.literal("sq-AL"),
	z.literal("sr-SP"),
	z.literal("sv-SE"),
	z.literal("ta-IN"),
	z.literal("te-IN"),
	z.literal("th-TH"),
	z.literal("tr-TR"),
	z.literal("uk-UA"),
	z.literal("uz-UZ"),
	z.literal("vi-VN"),
	z.literal("zh-CN"),
	z.literal("zh-TW"),
	z.literal("zu-ZA"),
]);

export type Locale = z.infer<typeof localeSchema>;

const storageKey = "locale";
const defaultLocale: Locale = "en-US";

export const localeMap = {
	"af-ZA": msg`Afrikaans`,
	"am-ET": msg`Amharic`,
	"ar-SA": msg`Arabic`,
	"az-AZ": msg`Azerbaijani`,
	"bg-BG": msg`Bulgarian`,
	"bn-BD": msg`Bengali`,
	"ca-ES": msg`Catalan`,
	"cs-CZ": msg`Czech`,
	"da-DK": msg`Danish`,
	"de-DE": msg`German`,
	"el-GR": msg`Greek`,
	"en-US": msg`English`,
	"es-ES": msg`Spanish`,
	"fa-IR": msg`Persian`,
	"fi-FI": msg`Finnish`,
	"fr-FR": msg`French`,
	"he-IL": msg`Hebrew`,
	"hi-IN": msg`Hindi`,
	"hu-HU": msg`Hungarian`,
	"id-ID": msg`Indonesian`,
	"it-IT": msg`Italian`,
	"ja-JP": msg`Japanese`,
	"km-KH": msg`Khmer`,
	"kn-IN": msg`Kannada`,
	"ko-KR": msg`Korean`,
	"lt-LT": msg`Lithuanian`,
	"lv-LV": msg`Latvian`,
	"ml-IN": msg`Malayalam`,
	"mr-IN": msg`Marathi`,
	"ms-MY": msg`Malay`,
	"ne-NP": msg`Nepali`,
	"nl-NL": msg`Dutch`,
	"no-NO": msg`Norwegian`,
	"or-IN": msg`Odia`,
	"pl-PL": msg`Polish`,
	"pt-BR": msg`Portuguese (Brazil)`,
	"pt-PT": msg`Portuguese (Portugal)`,
	"ro-RO": msg`Romanian`,
	"ru-RU": msg`Russian`,
	"sk-SK": msg`Slovak`,
	"sq-AL": msg`Albanian`,
	"sr-SP": msg`Serbian`,
	"sv-SE": msg`Swedish`,
	"ta-IN": msg`Tamil`,
	"te-IN": msg`Telugu`,
	"th-TH": msg`Thai`,
	"tr-TR": msg`Turkish`,
	"uk-UA": msg`Ukrainian`,
	"uz-UZ": msg`Uzbek`,
	"vi-VN": msg`Vietnamese`,
	"zh-CN": msg`Chinese (Simplified)`,
	"zh-TW": msg`Chinese (Traditional)`,
	"zu-ZA": msg`Zulu`,
} satisfies Record<Locale, MessageDescriptor>;

export function isLocale(locale: string): locale is Locale {
	return localeSchema.safeParse(locale).success;
}

const RTL_LANGUAGES = new Set([
	"ar", // Arabic
	"ckb", // Kurdish (Sorani)
	"dv", // Dhivehi
	"fa", // Persian
	"he", // Hebrew
	"ps", // Pashto
	"sd", // Sindhi
	"ug", // Uyghur
	"ur", // Urdu
	"yi", // Yiddish
]);

export function isRTL(locale: string): boolean {
	const language = locale.split("-")[0].toLowerCase();
	return RTL_LANGUAGES.has(language);
}

export const getLocale = createIsomorphicFn()
	.client(() => {
		const locale = Cookies.get(storageKey);
		if (!locale || !isLocale(locale)) return defaultLocale;
		return locale;
	})
	.server(async () => {
		const cookieLocale = getCookie(storageKey);
		if (!cookieLocale || !isLocale(cookieLocale)) return defaultLocale;
		return cookieLocale;
	});

export const setLocaleServerFn = createServerFn({ method: "POST" })
	.inputValidator(localeSchema)
	.handler(async ({ data }) => {
		setCookie(storageKey, data);
	});

export const loadLocale = async (locale: string) => {
	if (!isLocale(locale)) locale = defaultLocale;
	const { messages } = await (import(`../../locales/${locale}.po`) as Promise<{ messages: Messages }>);
	i18n.loadAndActivate({ locale, messages });
};


--- src/schema/page.ts ---
export const pageDimensionsAsPixels = {
	a4: {
		width: 794,
		height: 1123,
	},
	letter: {
		width: 816,
		height: 1056,
	},
	"free-form": {
		width: 794,
		height: 1123, // used as minimum height
	},
} as const;

export const pageDimensionsAsMillimeters = {
	a4: {
		width: "210mm",
		height: "297mm",
	},
	letter: {
		width: "216mm",
		height: "279mm",
	},
	"free-form": {
		width: "210mm",
		height: "297mm", // used as minimum height
	},
} as const;


--- src/utils/password.ts ---
import { compare, hash } from "bcrypt";

const SALT_ROUNDS = 10;

export const hashPassword = (password: string): Promise<string> => hash(password, SALT_ROUNDS);

export const verifyPassword = (password: string, passwordHash: string): Promise<boolean> =>
	compare(password, passwordHash);

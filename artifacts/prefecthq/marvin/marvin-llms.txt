<!-- llmstxt:source=dspy -->
# Marvin: Structured Agentic AI Framework

## Project Purpose
Marvin aims to empower developers to build structured, agentic AI applications by simplifying the orchestration of LLM tasks, agent coordination, and data transformation. It enables users to define workflows using tasks with clear objectives, assign specialized agents to execute them, and compose these into threads for multi-step reasoning. The framework supports type-safe outputs, tool integration, observability, and seamless compatibility with major LLM providers — all while maintaining developer-friendly syntax and extensibility.

## Key Concepts
- Task-Centric Architecture
- Agents
- Threads
- Structured Output Utilities (cast, extract, classify, generate)
- Type-Safe Results
- Multi-Agent Orchestration
- Memory Providers (Chroma, Lance, Postgres, Qdrant)
- Pydantic AI Integration
- Observability and Logging
- Tool-Enabled Tasks

## Architecture Overview
Marvin is structured around a modular, composable architecture centered on three core abstractions: **Tasks**, **Agents**, and **Threads**. Tasks represent atomic objectives with defined instructions and result types, while Agents are specialized LLM configurations that execute tasks using configurable models, tools, and instructions. Threads manage context and history across interconnected tasks, enabling complex workflows to be composed and executed in sequence or parallel. The framework integrates with Pydantic AI for LLM interactions and supports multiple memory providers for persistent state. Its architecture is built for extensibility — with clear separation between core logic (src/marvin/), utilities (utilities/), database layer (database.py), and agent/task implementations (agents/, tasks/). Documentation and examples are deeply integrated into the codebase, emphasizing developer onboarding and practical use.

## Important Directories
- `src/marvin/` — Core Marvin logic, agents, tasks, and thread orchestration.
- `docs/` — Project documentation and API references.
- `examples/` — Real-world usage examples (e.g., Slackbot, database workflows).
- `tests/` — Unit and integration tests with async support.
- `migrations/` — Schema migrations for memory providers.
- `.github/workflows/` — CI/CD pipelines for building and deploying.
- `examples/slackbot/` — Example agent-based bot application.
- `alembic.ini` — Database migration configuration.
- `pyproject.toml` — Project metadata, dependencies, and build configuration.

## Entry Points
```python
marvin = marvin.cli.main:app
```

## Development Info
The project uses modern Python tooling with `hatch` as the build system, managing dependencies via `pyproject.toml`. It includes:

- Development dependencies in `[dependency-groups]` (e.g., pytest, ruff, pre-commit).
- Optional dependencies for features: `audio`, `slackbot`, `mcp`, `prefect`.
- CLI entry point defined via `scripts.marvin = "marvin.cli.main:app"`.
- Testing infrastructure with `pytest`, async support, and environment variables for testing.
- Linting with `ruff` configured per-file ignores.
- CI/CD workflows for building images and deploying to Cloud Run (internal/community).
- Pre-commit hooks via `.pre-commit-config.yaml`.
- Workspace configuration for `uv.lock` and external dependencies like `fastmcp` from GitHub.
- Environment variables set for testing and development, including model, memory provider, and logging levels.

## Usage Examples
```python
from marvin import Marvin

# Initialize Marvin with LLM provider (e.g., OpenAI)
marvin = Marvin(llm="openai")

# Define a task with structured output expectations
task = marvin.task(
    name="fetch_user_data",
    description="Retrieve user data from a database",
    output_schema=UserProfile,
    tools=["database_query"]
)

# Assign an agent to execute the task
agent = marvin.agent(
    name="db_agent",
    tools=["database_query"],
    memory_provider="chroma"
)

# Run the task with the assigned agent
result = agent.execute(task)

# Extract structured output
user_data = result.cast(UserProfile)
print(user_data.name)  # e.g., "Alice Smith"

# Chain multiple tasks into a thread for multi-step reasoning
thread = marvin.thread([
    task1,
    task2,
    task3
])

# Observe execution logs and metrics
thread.observe()  # Logs and observability features enabled
```

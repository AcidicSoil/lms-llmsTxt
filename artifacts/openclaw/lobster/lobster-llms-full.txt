# llms-full (private-aware)
> Built from GitHub files and website pages. Large files may be truncated.

--- src/sdk/index.ts ---
/**
 * Lobster SDK - Workflow runtime for AI agents
 *
 * @example
 * import { Lobster, approve, exec } from 'lobster-sdk';
 *
 * const workflow = new Lobster()
 *   .pipe(exec('gh pr view 123 --repo owner/repo --json title,url'))
 *   .pipe(items => items.filter(e => e.unread))
 *   .pipe(approve({ prompt: 'Process these emails?' }))
 *   .pipe(async function* (items) {
 *     for (const item of items) {
 *       yield { ...item, processed: true };
 *     }
 *   });
 *
 * const result = await workflow.run();
 */

export { Lobster } from './Lobster.js';
export { approve } from './primitives/approve.js';
export { exec } from './primitives/exec.js';
export { stateGet, stateSet, state } from './primitives/state.js';
export { diffLast } from './primitives/diff.js';
export { runPipeline } from './runtime.js';


--- src/sdk/Lobster.ts ---
import { runPipelineInternal } from './runtime.js';
import { encodeToken, decodeToken } from './token.js';

/**
 * @typedef {Object} LobsterResult
 * @property {boolean} ok - Whether the workflow completed successfully
 * @property {'ok' | 'needs_approval' | 'cancelled' | 'error'} status - Workflow status
 * @property {any[]} output - Output items from the workflow
 * @property {Object|null} requiresApproval - Approval request if halted
 * @property {string} [requiresApproval.prompt] - Approval prompt
 * @property {any[]} [requiresApproval.items] - Items pending approval
 * @property {string} [requiresApproval.resumeToken] - Token to resume workflow
 * @property {Object} [error] - Error details if failed
 */

/**
 * @typedef {Object} LobsterOptions
 * @property {Object} [env] - Environment variables
 * @property {string} [stateDir] - State directory override
 */

/**
 * Lobster - Fluent workflow builder for AI agents
 *
 * @example
 * const workflow = new Lobster()
 *   .pipe(exec('gh pr view 123 --repo owner/repo --json title,url'))
 *   .pipe(approve({ prompt: 'Continue?' }))
 *   .run();
 */
export class Lobster {
  /** @type {Array<Function|Object>} */
  #stages = [];

  /** @type {any} */
  #options: any = {} as any;

  /** @type {Object|null} */
  #meta = null;

  /**
   * Create a new Lobster workflow builder
   * @param {LobsterOptions} [options]
   */
  constructor(options: any = {}) { 
    this.#options = {
      env: options.env ?? process.env,
      stateDir: options.stateDir,
    };
  }

  /**
   * Add a stage to the pipeline
   *
   * Stages can be:
   * - A function: (items: any[]) => any[] | AsyncIterable
   * - An async generator function: async function* (input) { ... }
   * - A stage object with { run: Function }
   * - A primitive from lobster-sdk (approve, exec, etc.)
   *
   * @param {Function|Object} stage - Stage to add
   * @returns {Lobster} - Returns this for chaining
   *
   * @example
   * new Lobster()
   *   .pipe(exec('gh pr view 123 --repo owner/repo --json title,url'))
   *   .pipe(items => items)
   *   .pipe(approve({ prompt: 'Proceed?' }))
   */
  pipe(stage) {
    if (typeof stage !== 'function' && typeof stage?.run !== 'function') {
      throw new Error('Stage must be a function or have a run() method');
    }
    this.#stages.push(stage);
    return this;
  }

  /**
   * Set metadata for this workflow (for recipe discovery)
   * @param {Object} meta
   * @param {string} meta.name - Workflow name
   * @param {string} meta.description - Description
   * @param {string[]} [meta.requires] - Required CLI tools
   * @param {Object} [meta.args] - Argument schema
   * @returns {Lobster}
   */
  meta(meta) {
    this.#meta = meta;
    return this;
  }

  /**
   * Get workflow metadata
   * @returns {Object|null}
   */
  getMeta() {
    return this.#meta;
  }

  /**
   * Execute the workflow
   * @param {any[]} [initialInput] - Optional initial input items
   * @returns {Promise<LobsterResult>}
   */
  async run(initialInput = []) {
    const ctx = {
      env: this.#options.env,
      stateDir: this.#options.stateDir,
      mode: 'sdk',
    };

    try {
      const result = await runPipelineInternal({
        stages: this.#stages,
        ctx,
        input: initialInput,
      });

      // Check for approval halt
      if (result.halted && result.items.length === 1 && result.items[0]?.type === 'approval_request') {
        const approval = result.items[0];
        const resumeToken = encodeToken({
          protocolVersion: 1,
          v: 1,
          stageIndex: result.haltedAt?.index ?? -1,
          resumeAtIndex: (result.haltedAt?.index ?? -1) + 1,
          items: approval.items,
          prompt: approval.prompt,
          // Note: We can't serialize the stages themselves, so resume requires
          // the caller to maintain the workflow reference
        });

        return {
          ok: true,
          status: 'needs_approval',
          output: [],
          requiresApproval: {
            prompt: approval.prompt,
            items: approval.items,
            resumeToken,
          },
        };
      }

      return {
        ok: true,
        status: 'ok',
        output: result.items,
        requiresApproval: null,
      };
    } catch (err) {
      return {
        ok: false,
        status: 'error',
        output: [],
        requiresApproval: null,
        error: {
          type: 'runtime_error',
          message: err?.message ?? String(err),
        },
      };
    }
  }

  /**
   * Resume a halted workflow after approval
   * @param {string} token - Resume token from previous run
   * @param {Object} options
   * @param {boolean} options.approved - Whether the approval was granted
   * @returns {Promise<LobsterResult>}
   */
  async resume(token, { approved }) {
    if (!approved) {
      return {
        ok: true,
        status: 'cancelled',
        output: [],
        requiresApproval: null,
      };
    }

    const payload = decodeToken(token);
    const resumeIndex = payload.resumeAtIndex ?? 0;
    const resumeItems = payload.items ?? [];

    // Get remaining stages
    const remainingStages = this.#stages.slice(resumeIndex);

    const ctx = {
      env: this.#options.env,
      stateDir: this.#options.stateDir,
      mode: 'sdk',
    };

    try {
      const result = await runPipelineInternal({
        stages: remainingStages,
        ctx,
        input: resumeItems,
      });

      // Check for another approval halt
      if (result.halted && result.items.length === 1 && result.items[0]?.type === 'approval_request') {
        const approval = result.items[0];
        const resumeToken = encodeToken({
          protocolVersion: 1,
          v: 1,
          stageIndex: resumeIndex + (result.haltedAt?.index ?? 0),
          resumeAtIndex: resumeIndex + (result.haltedAt?.index ?? 0) + 1,
          items: approval.items,
          prompt: approval.prompt,
        });

        return {
          ok: true,
          status: 'needs_approval',
          output: [],
          requiresApproval: {
            prompt: approval.prompt,
            items: approval.items,
            resumeToken,
          },
        };
      }

      return {
        ok: true,
        status: 'ok',
        output: result.items,
        requiresApproval: null,
      };
    } catch (err) {
      return {
        ok: false,
        status: 'error',
        output: [],
        requiresApproval: null,
        error: {
          type: 'runtime_error',
          message: err?.message ?? String(err),
        },
      };
    }
  }

  /**
   * Clone this workflow (for creating variants)
   * @returns {Lobster}
   */
  clone() {
    const cloned = new Lobster(this.#options);
    cloned.#stages = [...this.#stages];
    cloned.#meta = this.#meta ? { ...this.#meta } : null;
    return cloned;
  }
}


--- src/sdk/runtime.ts ---
/**
 * SDK Runtime - Executes Lobster pipelines
 *
 * This is adapted from the CLI runtime but designed for SDK use.
 */

/**
 * @typedef {Object} StageResult
 * @property {AsyncIterable|any[]} [output] - Output items
 * @property {boolean} [halt] - Whether to halt the pipeline
 * @property {boolean} [rendered] - Whether output was rendered
 */

/**
 * @typedef {Object} PipelineResult
 * @property {any[]} items - Collected output items
 * @property {boolean} halted - Whether pipeline halted
 * @property {Object|null} haltedAt - Stage where halt occurred
 */

/**
 * Convert various inputs to an async iterable
 * @param {any} input
 * @returns {AsyncIterable}
 */
async function* toAsyncIterable(input) {
  if (input === null || input === undefined) {
    return;
  }

  if (Array.isArray(input)) {
    for (const item of input) {
      yield item;
    }
    return;
  }

  if (typeof input[Symbol.asyncIterator] === 'function') {
    yield* input;
    return;
  }

  if (typeof input[Symbol.iterator] === 'function') {
    for (const item of input) {
      yield item;
    }
    return;
  }

  // Single item
  yield input;
}

/**
 * Collect async iterable to array
 * @param {AsyncIterable} iterable
 * @returns {Promise<any[]>}
 */
async function collectItems(iterable) {
  const items = [];
  for await (const item of iterable) {
    items.push(item);
  }
  return items;
}

/**
 * Run a pipeline of stages
 *
 * @param {Object} options
 * @param {Array<Function|Object>} options.stages - Pipeline stages
 * @param {Object} options.ctx - Execution context
 * @param {any[]} [options.input] - Initial input items
 * @returns {Promise<PipelineResult>}
 */
export async function runPipelineInternal({ stages, ctx, input = [] }) {
  let stream = toAsyncIterable(input);
  let halted = false;
  let haltedAt = null;

  for (let idx = 0; idx < stages.length; idx++) {
    const stage = stages[idx];

    let result;

    if (typeof stage === 'function') {
      // Check if it's a generator function
      const isGenerator = stage.constructor?.name === 'AsyncGeneratorFunction' ||
                          stage.constructor?.name === 'GeneratorFunction';

      if (isGenerator) {
        // Generator function - pass the stream directly
        result = { output: stage(stream, ctx) };
      } else {
        // Regular function - collect items first, then call
        const items = await collectItems(stream);
        const output = await stage(items, ctx);
        result = { output: toAsyncIterable(output) };
      }
    } else if (typeof stage?.run === 'function') {
      // Stage object with run method (primitives)
      result = await stage.run({ input: stream, ctx });
    } else {
      throw new Error(`Invalid stage at index ${idx}: must be a function or have run() method`);
    }

    // Handle halt
    if (result?.halt) {
      halted = true;
      haltedAt = { index: idx, stage };
      stream = result.output ?? toAsyncIterable([]);
      break;
    }

    stream = result?.output ?? toAsyncIterable([]);
  }

  // Collect final output
  const items = await collectItems(stream);

  return { items, halted, haltedAt };
}

/**
 * Re-export for compatibility with CLI runtime
 */
export async function runPipeline({ pipeline, registry, stdin, stdout, stderr, env, mode = 'human', input }) {
  // This wraps the CLI-style pipeline execution
  // Convert pipeline stages to functions using registry

  const stages = pipeline.map((stage) => {
    const command = registry.get(stage.name);
    if (!command) {
      throw new Error(`Unknown command: ${stage.name}`);
    }

    return {
      run: async ({ input, ctx }) => {
        return command.run({ input, args: stage.args, ctx });
      },
    };
  });

  const ctx = {
    stdin,
    stdout,
    stderr,
    env,
    mode,
  };

  return runPipelineInternal({
    stages,
    ctx,
    input: input ? await collectItems(input) : [],
  });
}


--- src/sdk/token.ts ---
/**
 * Token encoding/decoding for SDK resume functionality
 *
 * Re-exports from the main token module for consistency
 */

import { encodeToken as mainEncode, decodeToken as mainDecode } from '../token.js';

export const encodeToken = mainEncode;
export const decodeToken = mainDecode;


--- src/sdk/primitives/approve.ts ---
/**
 * Approve primitive - Creates a hard halt point requiring human approval
 *
 * @example
 * import { Lobster, approve } from 'lobster-sdk';
 *
 * new Lobster()
 *   .pipe(fetchEmails())
 *   .pipe(approve({ prompt: 'Send these replies?' }))
 *   .pipe(sendReplies())
 */

/**
 * Create an approval stage
 *
 * @param {Object} [options]
 * @param {string} [options.prompt='Approve?'] - Prompt to show user
 * @param {boolean} [options.preview=true] - Include items in approval request
 * @returns {Object} Stage object with run method
 */
export function approve(options: any = {}) {
  const prompt = options.prompt ?? 'Approve?';
  const preview = options.preview !== false;

  return {
    type: 'approve',
    prompt,

    async run({ input, ctx: _ctx }) {
      // Collect all items
      const items = [];
      for await (const item of input) {
        items.push(item);
      }

      // In SDK mode, always emit approval request and halt
      return {
        halt: true,
        output: (async function* () {
          yield {
            type: 'approval_request',
            prompt,
            items: preview ? items : [],
            itemCount: items.length,
          };
        })(),
      };
    },
  };
}


--- src/sdk/primitives/diff.ts ---
/**
 * Diff primitive - Compare current value against last stored value
 *
 * @example
 * import { Lobster, diffLast } from 'lobster-sdk';
 *
 * new Lobster()
 *   .pipe(fetchPRStatus())
 *   .pipe(diffLast('pr-123'))
 *   .pipe(result => {
 *     if (result.changed) {
 *       console.log('PR changed!', result.changes);
 *     }
 *   });
 */

import { promises as fsp } from 'node:fs';
import os from 'node:os';
import path from 'node:path';

/**
 * Get the state directory
 * @param {Object} ctx
 * @returns {string}
 */
function getStateDir(ctx) {
  return (
    ctx?.stateDir ||
    (ctx?.env?.LOBSTER_STATE_DIR && String(ctx.env.LOBSTER_STATE_DIR).trim()) ||
    path.join(os.homedir(), '.lobster', 'state')
  );
}

/**
 * Convert a key to a safe file path
 * @param {string} stateDir
 * @param {string} key
 * @returns {string}
 */
function keyToPath(stateDir, key) {
  const safe = String(key)
    .toLowerCase()
    .replace(/[^a-z0-9._-]+/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_+|_+$/g, '');
  if (!safe) throw new Error('state key is empty/invalid');
  return path.join(stateDir, `${safe}.json`);
}

/**
 * Stable JSON stringify for comparison
 * @param {any} value
 * @returns {string}
 */
function stableStringify(value) {
  return JSON.stringify(value, (_k, v) => {
    if (v && typeof v === 'object' && !Array.isArray(v)) {
      return Object.fromEntries(Object.keys(v).sort().map((k) => [k, v[k]]));
    }
    return v;
  });
}

/**
 * Create a diff.last stage
 *
 * Compares the input against the last stored value for the given key,
 * stores the new value, and outputs a diff result.
 *
 * @param {string} key - State key to compare against
 * @param {Object} [options]
 * @param {boolean} [options.changesOnly=false] - If true, suppress output when unchanged
 * @returns {Object} Stage object with run method
 */
export function diffLast(key, options: any = {}) {
  if (!key) throw new Error('diffLast requires a key');

  const changesOnly = options.changesOnly === true;

  return {
    type: 'diff.last',
    key,

    async run({ input, ctx }) {
      // Collect all input items
      const items = [];
      for await (const item of input) {
        items.push(item);
      }

      const value = items.length === 1 ? items[0] : items;

      const stateDir = getStateDir(ctx);
      const filePath = keyToPath(stateDir, key);

      // Read previous value
      let before = null;
      try {
        const text = await fsp.readFile(filePath, 'utf8');
        before = JSON.parse(text);
      } catch (err) {
        if (err?.code !== 'ENOENT') {
          throw err;
        }
      }

      // Compare
      const changed = stableStringify(before) !== stableStringify(value);

      // Store new value
      await fsp.mkdir(stateDir, { recursive: true });
      await fsp.writeFile(filePath, JSON.stringify(value, null, 2) + '\n', 'utf8');

      // Build result
      const result = {
        kind: 'diff.last',
        key,
        changed,
        before,
        after: value,
      };

      // If changesOnly and no change, output suppressed marker
      if (changesOnly && !changed) {
        return {
          output: (async function* () {
            yield { kind: 'diff.last', key, changed: false, suppressed: true };
          })(),
        };
      }

      return {
        output: (async function* () {
          yield result;
        })(),
      };
    },
  };
}

/**
 * Diff and store directly (not as a pipeline stage)
 * @param {string} key
 * @param {any} value
 * @param {Object} [ctx]
 * @returns {Promise<{before: any, after: any, changed: boolean}>}
 */
export async function diffAndStoreValue(key, value, ctx = {}) {
  const stateDir = getStateDir(ctx);
  const filePath = keyToPath(stateDir, key);

  // Read previous value
  let before = null;
  try {
    const text = await fsp.readFile(filePath, 'utf8');
    before = JSON.parse(text);
  } catch (err) {
    if (err?.code !== 'ENOENT') {
      throw err;
    }
  }

  // Compare
  const changed = stableStringify(before) !== stableStringify(value);

  // Store new value
  await fsp.mkdir(stateDir, { recursive: true });
  await fsp.writeFile(filePath, JSON.stringify(value, null, 2) + '\n', 'utf8');

  return { before, after: value, changed };
}


--- src/sdk/primitives/exec.ts ---
/**
 * Exec primitive - Execute shell commands and return JSON output
 *
 * @example
 * import { Lobster, exec } from 'lobster-sdk';
 *
 * new Lobster()
 *   .pipe(exec('gh pr view 123 --repo owner/repo --json title,url'))
 *   .pipe(items => items.filter(e => e.unread))
 */

import { spawn } from 'node:child_process';

/**
 * Run a process and capture output
 * @param {string} command
 * @param {string[]} argv
 * @param {Object} options
 * @returns {Promise<{stdout: string, stderr: string}>}
 */
function runProcess(command, argv, { env, cwd }) {
  return new Promise<any>((resolve, reject) => {
    const child = spawn(command, argv, {
      env,
      cwd,
      stdio: ['ignore', 'pipe', 'pipe'],
      shell: false,
    });

    let stdout = '';
    let stderr = '';

    child.stdout.setEncoding('utf8');
    child.stderr.setEncoding('utf8');

    child.stdout.on('data', (d) => { stdout += d; });
    child.stderr.on('data', (d) => { stderr += d; });

    child.on('error', (err) => {
      reject(new Error(`Failed to execute ${command}: ${err.message}`));
    });

    child.on('close', (code) => {
      if (code === 0) {
        resolve({ stdout, stderr });
      } else {
        reject(new Error(`${command} exited with code ${code}: ${stderr.trim() || stdout.trim()}`));
      }
    });
  });
}

/**
 * Parse a shell command string into command and arguments
 * Simple parsing - for complex cases, use options.shell
 * @param {string} cmdString
 * @returns {{command: string, args: string[]}}
 */
function parseCommand(cmdString) {
  const tokens = [];
  let current = '';
  let quote = null;

  for (let i = 0; i < cmdString.length; i++) {
    const ch = cmdString[i];

    if (quote) {
      if (ch === '\\' && cmdString[i + 1]) {
        current += cmdString[i + 1];
        i++;
        continue;
      }
      if (ch === quote) {
        quote = null;
        continue;
      }
      current += ch;
      continue;
    }

    if (ch === '"' || ch === "'") {
      quote = ch;
      continue;
    }

    if (ch === ' ' || ch === '\t') {
      if (current.length > 0) {
        tokens.push(current);
        current = '';
      }
      continue;
    }

    current += ch;
  }

  if (current.length > 0) {
    tokens.push(current);
  }

  const [command, ...args] = tokens;
  return { command, args };
}

/**
 * Create an exec stage
 *
 * @param {string} cmdString - Command to execute
 * @param {Object} [options]
 * @param {boolean} [options.json=true] - Parse output as JSON
 * @param {boolean} [options.shell=false] - Use shell execution
 * @param {string} [options.cwd] - Working directory
 * @returns {Object} Stage object with run method
 */
export function exec(cmdString, options: any = {}) {
  const parseJson = options.json !== false;
  const useShell = options.shell === true;
  const cwd = options.cwd ?? process.cwd();

  return {
    type: 'exec',
    command: cmdString,

    async run({ input, ctx }) {
      // Drain input (exec doesn't use input stream)
      for await (const _item of input) {
        // no-op
      }

      const env = ctx.env ?? process.env;

      let stdout;

      if (useShell) {
        // Shell execution
        const result = await runProcess('/bin/sh', ['-c', cmdString], { env, cwd });
        stdout = result.stdout;
      } else {
        // Direct execution
        const { command, args } = parseCommand(cmdString);
        const result = await runProcess(command, args, { env, cwd });
        stdout = result.stdout;
      }

      // Parse output
      let output;
      if (parseJson) {
        try {
          output = JSON.parse(stdout.trim() || '[]');
        } catch {
          throw new Error(`exec output is not valid JSON: ${stdout.slice(0, 100)}`);
        }
      } else {
        output = stdout;
      }

      // Normalize to array
      const items = Array.isArray(output) ? output : [output];

      return {
        output: (async function* () {
          for (const item of items) {
            yield item;
          }
        })(),
      };
    },
  };
}

/**
 * Create an exec stage that runs in shell mode
 * Convenience wrapper for exec(cmd, { shell: true })
 *
 * @param {string} cmdString
 * @param {Object} [options]
 * @returns {Object}
 */
export function shell(cmdString, options = {}) {
  return exec(cmdString, { ...options, shell: true });
}


--- src/sdk/primitives/state.ts ---
/**
 * State primitives - Persistent state management
 *
 * @example
 * import { Lobster, stateGet, stateSet } from 'lobster-sdk';
 *
 * // Read state
 * new Lobster()
 *   .pipe(stateGet('my-key'))
 *   .pipe(value => console.log(value));
 *
 * // Write state
 * new Lobster()
 *   .pipe(() => ({ count: 42 }))
 *   .pipe(stateSet('my-key'));
 */

import { promises as fsp } from 'node:fs';
import os from 'node:os';
import path from 'node:path';

/**
 * Get the state directory
 * @param {Object} ctx
 * @returns {string}
 */
function getStateDir(ctx) {
  return (
    ctx?.stateDir ||
    (ctx?.env?.LOBSTER_STATE_DIR && String(ctx.env.LOBSTER_STATE_DIR).trim()) ||
    path.join(os.homedir(), '.lobster', 'state')
  );
}

/**
 * Convert a key to a safe file path
 * @param {string} stateDir
 * @param {string} key
 * @returns {string}
 */
function keyToPath(stateDir, key) {
  const safe = String(key)
    .toLowerCase()
    .replace(/[^a-z0-9._-]+/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_+|_+$/g, '');
  if (!safe) throw new Error('state key is empty/invalid');
  return path.join(stateDir, `${safe}.json`);
}

/**
 * Create a state.get stage
 *
 * @param {string} key - State key to read
 * @returns {Object} Stage object with run method
 */
export function stateGet(key) {
  if (!key) throw new Error('stateGet requires a key');

  return {
    type: 'state.get',
    key,

    async run({ input, ctx }) {
      // Drain input
      for await (const _item of input) {
        // no-op
      }

      const stateDir = getStateDir(ctx);
      const filePath = keyToPath(stateDir, key);

      let value = null;
      try {
        const text = await fsp.readFile(filePath, 'utf8');
        value = JSON.parse(text);
      } catch (err) {
        if (err?.code !== 'ENOENT') {
          throw err;
        }
        // File doesn't exist, return null
      }

      return {
        output: (async function* () {
          yield value;
        })(),
      };
    },
  };
}

/**
 * Create a state.set stage
 *
 * @param {string} key - State key to write
 * @returns {Object} Stage object with run method
 */
export function stateSet(key) {
  if (!key) throw new Error('stateSet requires a key');

  return {
    type: 'state.set',
    key,

    async run({ input, ctx }) {
      // Collect all input items
      const items = [];
      for await (const item of input) {
        items.push(item);
      }

      const value = items.length === 1 ? items[0] : items;

      const stateDir = getStateDir(ctx);
      const filePath = keyToPath(stateDir, key);

      await fsp.mkdir(stateDir, { recursive: true });
      await fsp.writeFile(filePath, JSON.stringify(value, null, 2) + '\n', 'utf8');

      // Pass through the value
      return {
        output: (async function* () {
          yield value;
        })(),
      };
    },
  };
}

/**
 * State namespace - provides get/set methods
 *
 * @example
 * import { state } from 'lobster-sdk';
 *
 * new Lobster()
 *   .pipe(state.get('my-key'))
 *   .pipe(state.set('my-key'));
 */
export const state = {
  get: stateGet,
  set: stateSet,
};

/**
 * Read state directly (not as a pipeline stage)
 * @param {string} key
 * @param {Object} [ctx]
 * @returns {Promise<any>}
 */
export async function readState(key, ctx = {}) {
  const stateDir = getStateDir(ctx);
  const filePath = keyToPath(stateDir, key);

  try {
    const text = await fsp.readFile(filePath, 'utf8');
    return JSON.parse(text);
  } catch (err) {
    if (err?.code === 'ENOENT') return null;
    throw err;
  }
}

/**
 * Write state directly (not as a pipeline stage)
 * @param {string} key
 * @param {any} value
 * @param {Object} [ctx]
 * @returns {Promise<void>}
 */
export async function writeState(key, value, ctx = {}) {
  const stateDir = getStateDir(ctx);
  const filePath = keyToPath(stateDir, key);

  await fsp.mkdir(stateDir, { recursive: true });
  await fsp.writeFile(filePath, JSON.stringify(value, null, 2) + '\n', 'utf8');
}


--- CHANGELOG.md ---
# Changelog

All notable changes to Lobster will be documented in this file.

## Unreleased

- Add workflow file runner for `.lobster`/YAML/JSON workflows with args, env, conditions, and approval gates.
- Add compact workflow resume tokens backed by Lobster state storage.
- Add `exec --stdin raw|json|jsonl` to pipe workflow output into subprocess stdin.
- Add `approve --preview-from-stdin --limit N` for approval previews without extra glue.
- Add `clawd.invoke --each` to map pipeline input items into tool calls.
- Extend CLI to run workflow files with `lobster run <file>` or `--file` + `--args-json`.

## 2026.1.21-1

- Published release (pre-changelog).

## 2026.1.21

- Initial published release (pre-changelog).


--- README.md ---
# Lobster

A Moltbot-native workflow shell: typed (JSON-first) pipelines, jobs, and approval gates.


## Example of lobster at work
Moltbot or any other AI agent can use `lobster` as a workflow engine and not construct a query every time - thus saving tokens, providing room for determinism, and resumability.

### Watching a PR that hasn't had changes
```
node bin/lobster.js "workflows.run --name github.pr.monitor --args-json '{\"repo\":\"moltbot/moltbot\",\"pr\":1152}'"
[
  {
    "kind": "github.pr.monitor",
    "repo": "moltbot/moltbot",
    "prNumber": 1152,
    "key": "github.pr:moltbot/moltbot#1152",
    "changed": false,
    "summary": {
      "changedFields": [],
      "changes": {}
    },
    "prSnapshot": {
      "author": {
        "id": "MDQ6VXNlcjE0MzY4NTM=",
        "is_bot": false,
        "login": "vignesh07",
        "name": "Vignesh"
      },
      "baseRefName": "main",
      "headRefName": "feat/lobster-plugin",
      "isDraft": false,
      "mergeable": "MERGEABLE",
      "number": 1152,
      "reviewDecision": "",
      "state": "OPEN",
      "title": "feat: Add optional lobster plugin tool (typed workflows, approvals/resume)",
      "updatedAt": "2026-01-18T20:16:56Z",
      "url": "https://github.com/moltbot/moltbot/pull/1152"
    }
  }
]
```
### And a PR that has a state change (in this case an approved PR)

```
 node bin/lobster.js "workflows.run --name github.pr.monitor --args-json '{\"repo\":\"moltbot/moltbot\",\"pr\":1200}'"
[
  {
    "kind": "github.pr.monitor",
    "repo": "moltbot/moltbot",
    "prNumber": 1200,
    "key": "github.pr:moltbot/moltbot#1200",
    "changed": true,
    "summary": {
      "changedFields": [
        "number",
        "title",
        "url",
        "state",
        "isDraft",
        "mergeable",
        "reviewDecision",
        "updatedAt",
        "baseRefName",
        "headRefName"
      ],
      "changes": {
        "number": {
          "from": null,
          "to": 1200
        },
        "title": {
          "from": null,
          "to": "feat(tui): add syntax highlighting for code blocks"
        },
        "url": {
          "from": null,
          "to": "https://github.com/moltbot/moltbot/pull/1200"
        },
        "state": {
          "from": null,
          "to": "MERGED"
        },
        "isDraft": {
          "from": null,
          "to": false
        },
        "mergeable": {
          "from": null,
          "to": "UNKNOWN"
        },
        "reviewDecision": {
          "from": null,
          "to": ""
        },
        "updatedAt": {
          "from": null,
          "to": "2026-01-19T05:06:09Z"
        },
        "baseRefName": {
          "from": null,
          "to": "main"
        },
        "headRefName": {
          "from": null,
          "to": "feat/tui-syntax-highlighting"
        }
      }
    },
    "prSnapshot": {
      "author": {
        "id": "MDQ6VXNlcjE0MzY4NTM=",
        "is_bot": false,
        "login": "vignesh07",
        "name": "Vignesh"
      },
      "baseRefName": "main",
      "headRefName": "feat/tui-syntax-highlighting",
      "isDraft": false,
      "mergeable": "UNKNOWN",
      "number": 1200,
      "reviewDecision": "",
      "state": "MERGED",
      "title": "feat(tui): add syntax highlighting for code blocks",
      "updatedAt": "2026-01-19T05:06:09Z",
      "url": "https://github.com/moltbot/moltbot/pull/1200"
    }
  }
]
```

## Goals


- Typed pipelines (objects/arrays), not text pipes.
- Local-first execution.
- No new auth surface: Lobster must not own OAuth/tokens.
- Composable macros that Moltbot can invoke in one step to save tokens.

## Quick start

From this folder:

- `pnpm install`
- `pnpm test`
- `pnpm lint`
- `node ./bin/lobster.js --help`
- `node ./bin/lobster.js doctor`
- `node ./bin/lobster.js "exec --json --shell 'echo [1,2,3]' | where '0>=0' | json"`

### Notes

- `pnpm test` runs `tsc` and then executes tests against `dist/`.
- `bin/lobster.js` prefers the compiled entrypoint in `dist/` when present.
## Commands

- `exec`: run OS commands
- `exec --stdin raw|json|jsonl`: feed pipeline input into subprocess stdin
- `where`, `pick`, `head`: data shaping
- `json`, `table`: renderers
- `approve`: approval gate (TTY prompt or `--emit` for Moltbot integration)

## Next steps

- Moltbot integration: ship as an optional Moltbot plugin tool.

## Workflow files

Lobster can run YAML/JSON workflow files with `steps`, `env`, `condition`, and approval gates.

```
lobster run path/to/workflow.lobster
lobster run --file path/to/workflow.lobster --args-json '{"tag":"family"}'
```

Example file:

```yaml
name: inbox-triage
steps:
  - id: collect
    command: inbox list --json
  - id: categorize
    command: inbox categorize --json
    stdin: $collect.stdout
  - id: approve
    command: inbox apply --approve
    stdin: $categorize.stdout
    approval: required
  - id: execute
    command: inbox apply --execute
    stdin: $categorize.stdout
    condition: $approve.approved
```


--- VISION.md ---
# Lobster: Vision & Value Proposition

## One-liner

**Lobster is safe automation for Clawdbot — workflows that ask before acting.**

---

## What is Lobster?

Lobster is a workflow runtime for Clawdbot. It lets you define multi-step automations that:

- Run deterministically (no LLM re-planning each step)
- Halt at checkpoints and ask for approval before side effects
- Resume exactly where they left off
- Remember what they've already processed

Think of it as **IFTTT/Zapier for Clawdbot, but with human checkpoints**.

---

## The Problem Lobster Solves

### Today's workflow in Clawdbot

```
User: "Check my email, draft replies to anything urgent, and send them"

What happens:
1. LLM plans: "I should search emails first"
2. Tool call: gmail.search
3. LLM interprets results, plans next step
4. Tool call: gmail.get (for each email)
5. LLM drafts replies
6. LLM decides to send
7. Tool call: gmail.send
... repeat for each email
```

**Problems:**
- Many tool calls = many tokens = expensive
- LLM decides when to send = risky (what if it misunderstands?)
- No memory = tomorrow it re-triages the same emails
- Not repeatable = you can't save this as an automation

### With Lobster

```
Clawdbot calls: lobster.run("email.triage")

What happens:
1. Lobster fetches emails (deterministic)
2. Lobster classifies them (rule-based)
3. Lobster drafts replies (optional LLM step)
4. Lobster HALTS: "Send 3 drafts? [approve/reject]"
5. User approves
6. Lobster sends

Tomorrow: Lobster remembers cursor, only processes new emails
```

**One call. Deterministic. Safe. Stateful.**

---

## Why Lobster Makes Clawdbot Better

| Without Lobster | With Lobster |
|-----------------|--------------|
| LLM orchestrates every step | Deterministic pipeline, LLM only for judgment |
| 10+ tool calls per workflow | 1 call to Lobster |
| "Don't send until I confirm" (hope it listens) | `approve` halts execution until explicit resume |
| Forgets what it did yesterday | Stateful — tracks cursors/checkpoints |
| Hard to share automations | Workflows are code — shareable, versionable |

### Token savings (real)
A 10-step workflow today might cost 10 tool calls × LLM planning overhead.
With Lobster: 1 tool call + compact structured output.

### Safety (the killer feature)
The `approve` primitive isn't a prompt hint — it's a **hard stop**. The workflow literally cannot continue until you resume it. No "oops, it sent 50 emails."

### Memory (underrated)
Workflows can persist state: "last processed email ID", "last PR SHA seen", etc. Tomorrow's run picks up where yesterday left off.

---

## How Lobster Fits with Clawdbot

```
┌─────────────────────────────────────────────────┐
│                   User                          │
│         "triage my email daily"                 │
└─────────────────────┬───────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────┐
│                 Clawdbot                        │
│   - Understands intent                          │
│   - Chooses appropriate tool/workflow           │
│   - Presents results and approval prompts       │
└─────────────────────┬───────────────────────────┘
                      │ lobster.run("email.triage")
                      ▼
┌─────────────────────────────────────────────────┐
│                  Lobster                        │
│   - Executes deterministic pipeline             │
│   - Calls Clawdbot tools (gmail, trello, etc)   │
│   - Halts at approval checkpoints               │
│   - Returns structured result + resume token    │
└─────────────────────────────────────────────────┘
```

**Key insight:** Lobster doesn't replace Clawdbot. It's the execution layer that makes Clawdbot's automations safe and efficient.

- **Clawdbot** = the brain (understands what you want)
- **Lobster** = the hands (executes workflows safely)
- **Tools/Skills** = the capabilities (gmail, trello, github, etc.)

---

## Who Should Use Lobster?

### Average Clawdbot users (invisible benefit)
They don't need to know Lobster exists. They just notice:
- "Set up daily email triage" works better
- Automations ask before sending/posting
- Things don't get re-processed every day

### Power users / tinkerers
They can:
- Customize workflows ("I want triage to also create Trello cards")
- Write new workflows for their specific needs
- Share workflows with the community

### The Clawdbot ecosystem
- Workflow recipes become a new category of shareable assets
- Skills stay simple (just expose APIs)
- Lobster handles the orchestration layer

---

## Analogies That Work

| If you know... | Lobster is like... |
|----------------|-------------------|
| IFTTT/Zapier | Multi-step version with approval checkpoints |
| GitHub Actions | But for personal automation, not CI/CD |
| AWS Step Functions | But local-first and human-in-the-loop |
| Unix pipes | But for JSON objects, not text bytes |
| Temporal | But 80/20 version for personal workflows |

**Best analogy for most people:**
> "Lobster is Zapier for Clawdbot, except it asks you before doing anything irreversible."

---

## Why Not Build This Into Clawdbot Core?

It could be. But the plugin architecture is intentional:

1. **Core stays small** — Clawdbot is already complex
2. **Faster iteration** — Lobster can evolve without core releases
3. **Opt-in** — Not everyone needs workflow automation
4. **Community** — Easier to contribute workflows than core changes
5. **Ecosystem proof** — If plugins work for Lobster, they work for other capabilities

Pete (Clawdbot creator) explicitly built the plugin boundary to enable this pattern. Lobster is the first proof that it works.

---

## Example Workflows

### Email triage (flagship)
```
gog.gmail.search --query "newer_than:1d" 
  | email.normalize 
  | email.classify 
  | where bucket==needs_reply 
  | draft.reply 
  | approve --prompt "Send N replies?" 
  | gog.gmail.send
```

### PR monitor
```
github.pr.get --repo org/repo --pr 123
  | diff.last
  | where changed==true
  | notify --channel telegram --message "PR updated: {summary}"
```

### Daily planning
```
calendar.today
  | join tasks.today
  | prioritize
  | format.plan
  | approve --prompt "Post to #daily?"
  | message.send --channel slack --to "#daily"
```

### Inbox → Trello
```
email.triage
  | where bucket==needs_action
  | to.trelloCard
  | approve --prompt "Create N cards?"
  | trello.card.create --list "Inbox"
```

---

## The USP (Unique Selling Proposition)

**"Automations that ask before acting."**

Other automation tools either:
- Run blindly (IFTTT, Zapier) — scary for important actions
- Require complex configuration for approvals
- Don't integrate with your AI assistant

Lobster is:
- Native to Clawdbot (uses the same tools you already have)
- Safe by default (approvals are a language primitive)
- Invisible when you want (Clawdbot uses it automatically)
- Customizable when you need (write your own workflows)

---

## What Lobster Is NOT

- **Not a terminal replacement** — You don't switch your shell to Lobster
- **Not a general programming language** — It's for workflows, not apps
- **Not trying to replace Clawdbot** — It makes Clawdbot better
- **Not managing your secrets** — Clawdbot handles auth, Lobster orchestrates

---

## Summary

| Question | Answer |
|----------|--------|
| What is it? | Workflow runtime for Clawdbot |
| One-liner? | Safe automation — workflows that ask before acting |
| Why use it? | Cheaper, safer, stateful automations |
| Who uses it? | Everyone (invisibly) or power users (directly) |
| Why not in core? | Plugin architecture — core stays small, capabilities are extensions |
| Best analogy? | Zapier for Clawdbot, but with approval checkpoints |


--- bin/lobster.js ---
#!/usr/bin/env node

import { existsSync } from "node:fs";
import { fileURLToPath } from "node:url";
import { dirname, join } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

async function load() {
  const distEntry = join(__dirname, "../dist/src/cli.js");
  if (existsSync(distEntry)) {
    return import(distEntry);
  }
  return import(join(__dirname, "../src/cli.js"));
}

const mod = await load();
if (typeof mod.runCli !== "function") {
  throw new Error("lobster CLI entrypoint missing runCli()");
}

await mod.runCli(process.argv.slice(2));


--- src/cli.ts ---
import { parsePipeline } from './parser.js';
import { createDefaultRegistry } from './commands/registry.js';
import { runPipeline } from './runtime.js';
import { encodeToken } from './token.js';
import { decodeResumeToken, parseResumeArgs } from './resume.js';
import { runWorkflowFile } from './workflows/file.js';

export async function runCli(argv) {
  const registry = createDefaultRegistry();

  if (argv.length === 0 || argv.includes('-h') || argv.includes('--help')) {
    process.stdout.write(helpText());
    return;
  }

  if (argv[0] === 'help') {
    const topic = argv[1];
    if (!topic) {
      process.stdout.write(helpText());
      return;
    }
    const cmd = registry.get(topic);
    if (!cmd) {
      process.stderr.write(`Unknown command: ${topic}\n`);
      process.exitCode = 2;
      return;
    }
    process.stdout.write(cmd.help());
    return;
  }

  if (argv[0] === 'version' || argv[0] === '--version' || argv[0] === '-v') {
    process.stdout.write(`${await readVersion()}\n`);
    return;
  }

  if (argv[0] === 'doctor') {
    await handleDoctor({ argv: argv.slice(1), registry });
    return;
  }

  if (argv[0] === 'run') {
    await handleRun({ argv: argv.slice(1), registry });
    return;
  }

  if (argv[0] === 'resume') {
    await handleResume({ argv: argv.slice(1), registry });
    return;
  }

  // Default: treat argv as a pipeline string.
  await handleRun({ argv, registry });
}

async function handleRun({ argv, registry }) {
  const { mode, rest, filePath, argsJson } = parseRunArgs(argv);
  const normalizedMode = normalizeMode(mode);

  const workflowFile = filePath
    ? await resolveWorkflowFile(filePath)
    : await detectWorkflowFile(rest);
  if (workflowFile) {
    let parsedArgs = {};
    if (argsJson) {
      try {
        parsedArgs = JSON.parse(argsJson);
      } catch {
        if (mode === 'tool') {
          writeToolEnvelope({ ok: false, error: { type: 'parse_error', message: 'run --args-json must be valid JSON' } });
          process.exitCode = 2;
          return;
        }
        process.stderr.write('run --args-json must be valid JSON\n');
        process.exitCode = 2;
        return;
      }
    }

    try {
      const output = await runWorkflowFile({
        filePath: workflowFile,
        args: parsedArgs,
        ctx: {
          stdin: process.stdin,
          stdout: process.stdout,
          stderr: process.stderr,
          env: process.env,
          mode: normalizedMode,
        },
      });

      if (normalizedMode === 'tool') {
        if (output.status === 'needs_approval') {
          writeToolEnvelope({
            ok: true,
            status: 'needs_approval',
            output: [],
            requiresApproval: output.requiresApproval ?? null,
          });
          return;
        }

        writeToolEnvelope({
          ok: true,
          status: 'ok',
          output: output.output,
          requiresApproval: null,
        });
        return;
      }

      if (output.status === 'ok' && output.output.length) {
        process.stdout.write(JSON.stringify(output.output, null, 2));
        process.stdout.write('\n');
      }
      return;
    } catch (err) {
      if (normalizedMode === 'tool') {
        writeToolEnvelope({ ok: false, error: { type: 'runtime_error', message: err?.message ?? String(err) } });
        process.exitCode = 1;
        return;
      }
      process.stderr.write(`Error: ${err?.message ?? String(err)}\n`);
      process.exitCode = 1;
      return;
    }
  }

  const pipelineString = rest.join(' ');

  let pipeline;
  try {
    pipeline = parsePipeline(pipelineString);
  } catch (err) {
    if (mode === 'tool') {
      writeToolEnvelope({ ok: false, error: { type: 'parse_error', message: err?.message ?? String(err) } });
      process.exitCode = 2;
      return;
    }
    process.stderr.write(`Parse error: ${err?.message ?? String(err)}\n`);
    process.exitCode = 2;
    return;
  }

  try {
    const output = await runPipeline({
      pipeline,
      registry,
      input: [],
      stdin: process.stdin,
      stdout: process.stdout,
      stderr: process.stderr,
      env: process.env,
      mode: normalizedMode,
    });

    if (normalizedMode === 'tool') {
      const approval = output.halted && output.items.length === 1 && output.items[0]?.type === 'approval_request'
        ? output.items[0]
        : null;

      if (approval) {
        const resumeToken = encodeToken({
          protocolVersion: 1,
          v: 1,
          pipeline,
          resumeAtIndex: (output.haltedAt?.index ?? -1) + 1,
          items: approval.items,
          prompt: approval.prompt,
        });

        writeToolEnvelope({
          ok: true,
          status: 'needs_approval',
          output: [],
          requiresApproval: {
            ...approval,
            resumeToken,
          },
        });
        return;
      }

      writeToolEnvelope({
        ok: true,
        status: 'ok',
        output: output.items,
        requiresApproval: null,
      });
      return;
    }

    // Human mode: if the last command didn't render, print JSON.
    if (!output.rendered) {
      process.stdout.write(JSON.stringify(output.items, null, 2));
      process.stdout.write('\n');
    }
  } catch (err) {
    if (normalizedMode === 'tool') {
      writeToolEnvelope({ ok: false, error: { type: 'runtime_error', message: err?.message ?? String(err) } });
      process.exitCode = 1;
      return;
    }
    process.stderr.write(`Error: ${err?.message ?? String(err)}\n`);
    process.exitCode = 1;
  }
}

function parseRunArgs(argv) {
  const rest = [];
  let mode = 'human';
  let filePath = null;
  let argsJson = null;

  for (let i = 0; i < argv.length; i++) {
    const tok = argv[i];

    if (tok === '--mode') {
      const value = argv[i + 1];
      if (value) {
        mode = value;
        i++;
      }
      continue;
    }

    if (tok.startsWith('--mode=')) {
      mode = tok.slice('--mode='.length) || 'human';
      continue;
    }

    if (tok === '--file') {
      const value = argv[i + 1];
      if (value) {
        filePath = value;
        i++;
      }
      continue;
    }

    if (tok.startsWith('--file=')) {
      filePath = tok.slice('--file='.length);
      continue;
    }

    if (tok === '--args-json') {
      const value = argv[i + 1];
      if (value) {
        argsJson = value;
        i++;
      }
      continue;
    }

    if (tok.startsWith('--args-json=')) {
      argsJson = tok.slice('--args-json='.length);
      continue;
    }

    rest.push(tok);
  }

  return { mode, rest, filePath, argsJson };
}

function normalizeMode(mode) {
  return mode === 'tool' ? 'tool' : 'human';
}

async function detectWorkflowFile(rest) {
  if (rest.length !== 1) return null;
  const candidate = rest[0];
  if (!candidate || candidate.includes('|')) return null;
  try {
    return await resolveWorkflowFile(candidate);
  } catch {
    return null;
  }
}

async function resolveWorkflowFile(candidate) {
  const { promises: fsp } = await import('node:fs');
  const { resolve, extname, isAbsolute } = await import('node:path');
  const resolved = isAbsolute(candidate) ? candidate : resolve(process.cwd(), candidate);
  const stat = await fsp.stat(resolved);
  if (!stat.isFile()) throw new Error('Workflow path is not a file');

  const ext = extname(resolved).toLowerCase();
  if (!['.lobster', '.yaml', '.yml', '.json'].includes(ext)) {
    throw new Error('Workflow file must end in .lobster, .yaml, .yml, or .json');
  }

  return resolved;
}

async function handleResume({ argv, registry }) {
  const mode = 'tool';
  const { token, approved } = parseResumeArgs(argv);
  const payload = decodeResumeToken(token);

  if (!approved) {
    writeToolEnvelope({ ok: true, status: 'cancelled', output: [], requiresApproval: null });
    return;
  }

  if (payload.kind === 'workflow-file') {
    try {
      const output = await runWorkflowFile({
        filePath: payload.filePath,
        ctx: {
          stdin: process.stdin,
          stdout: process.stdout,
          stderr: process.stderr,
          env: process.env,
          mode: 'tool',
        },
        resume: payload,
        approved: true,
      });

      if (output.status === 'needs_approval') {
        writeToolEnvelope({
          ok: true,
          status: 'needs_approval',
          output: [],
          requiresApproval: output.requiresApproval ?? null,
        });
        return;
      }

      writeToolEnvelope({ ok: true, status: 'ok', output: output.output, requiresApproval: null });
      return;
    } catch (err) {
      writeToolEnvelope({ ok: false, error: { type: 'runtime_error', message: err?.message ?? String(err) } });
      process.exitCode = 1;
      return;
    }
  }

  const remaining = payload.pipeline.slice(payload.resumeAtIndex);
  const input = (async function* () {
    for (const item of payload.items) yield item;
  })();

  try {
    const output = await runPipeline({
      pipeline: remaining,
      registry,
      stdin: process.stdin,
      stdout: process.stdout,
      stderr: process.stderr,
      env: process.env,
      mode,
      input,
    });

    const approval = output.halted && output.items.length === 1 && output.items[0]?.type === 'approval_request'
      ? output.items[0]
      : null;

    if (approval) {
      const resumeToken = encodeToken({
        protocolVersion: 1,
        v: 1,
        pipeline: remaining,
        resumeAtIndex: (output.haltedAt?.index ?? -1) + 1,
        items: approval.items,
        prompt: approval.prompt,
      });

      writeToolEnvelope({
        ok: true,
        status: 'needs_approval',
        output: [],
        requiresApproval: { ...approval, resumeToken },
      });
      return;
    }

    writeToolEnvelope({ ok: true, status: 'ok', output: output.items, requiresApproval: null });
  } catch (err) {
    writeToolEnvelope({ ok: false, error: { type: 'runtime_error', message: err?.message ?? String(err) } });
    process.exitCode = 1;
  }
}

async function readVersion() {
  const { readFile } = await import('node:fs/promises');
  const { fileURLToPath } = await import('node:url');
  const { dirname, join } = await import('node:path');

  const here = dirname(fileURLToPath(import.meta.url));
  const pkgPath = join(here, '..', '..', 'package.json');
  const pkg = JSON.parse(await readFile(pkgPath, 'utf8'));
  return pkg.version ?? '0.0.0';
}

async function handleDoctor({ argv, registry }) {
  const mode = 'tool';
  const pipeline = "exec --json --shell 'echo [1]'";
  const output: any = await (async () => {
    try {
      const parsed = parsePipeline(pipeline);
      return await runPipeline({
        pipeline: parsed,
        registry,
        input: [],
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr,
        env: process.env,
        mode,
      });
    } catch (err: any) {
      return { error: err };
    }
  })();

  if (output?.error) {
    writeToolEnvelope({
      ok: false,
      error: { type: 'doctor_error', message: output.error?.message ?? String(output.error) },
    });
    process.exitCode = 1;
    return;
  }

  writeToolEnvelope({
    ok: true,
    status: 'ok',
    output: [{
      toolMode: true,
      protocolVersion: 1,
      version: await readVersion(),
      notes: argv.length ? argv : undefined,
    }],
    requiresApproval: null,
  });
}

function writeToolEnvelope(payload) {
  const envelope = {
    protocolVersion: 1,
    ...payload,
  };
  process.stdout.write(JSON.stringify(envelope, null, 2));
  process.stdout.write('\n');
}

function helpText() {
  return `lobster — Clawdbot-native typed shell\n\n` +
    `Usage:\n` +
    `  lobster '<pipeline>'\n` +
    `  lobster run --mode tool '<pipeline>'\n` +
    `  lobster run path/to/workflow.lobster\n` +
    `  lobster run --file path/to/workflow.lobster --args-json '{...}'\n` +
    `  lobster resume --token <token> --approve yes|no\n` +
    `  lobster doctor\n` +
    `  lobster version\n` +
    `  lobster help <command>\n\n` +
    `Modes:\n` +
    `  - human (default): renderers can write to stdout\n` +
    `  - tool: prints a single JSON envelope for easy integration\n\n` +
    `Examples:\n` +
    `  lobster 'exec --json "echo [1,2,3]" | json'\n` +
    `  lobster run --mode tool 'exec --json "echo [1]" | approve --prompt "ok?"'\n\n` +
    `Commands:\n` +
    `  exec, head, json, pick, table, where, approve, clawd.invoke, state.get, state.set, diff.last, commands.list, workflows.list, workflows.run\n`;
}


--- src/parser.ts ---
function isWhitespace(ch) {
  return ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r';
}

function splitPipes(input) {
  const parts = [];
  let current = '';
  let quote = null;

  for (let i = 0; i < input.length; i++) {
    const ch = input[i];

    if (quote) {
      if (ch === '\\') {
        const next = input[i + 1];
        if (next) {
          current += ch + next;
          i++;
          continue;
        }
      }
      current += ch;
      if (ch === quote) {
        quote = null;
      }
      continue;
    }

    if (ch === '"' || ch === "'") {
      quote = ch;
      current += ch;
      continue;
    }

    if (ch === '|') {
      parts.push(current.trim());
      current = '';
      continue;
    }

    current += ch;
  }

  if (quote) throw new Error('Unclosed quote');
  if (current.trim().length > 0) parts.push(current.trim());
  return parts;
}

function tokenizeCommand(input) {
  const tokens = [];
  let current = '';
  let quote = null;

  const push = () => {
    if (current.length > 0) tokens.push(current);
    current = '';
  };

  for (let i = 0; i < input.length; i++) {
    const ch = input[i];

    if (quote) {
      if (ch === '\\') {
        const next = input[i + 1];
        if (next) {
          current += next;
          i++;
          continue;
        }
      }
      if (ch === quote) {
        quote = null;
        continue;
      }
      current += ch;
      continue;
    }

    if (ch === '"' || ch === "'") {
      quote = ch;
      continue;
    }

    if (isWhitespace(ch)) {
      push();
      continue;
    }

    current += ch;
  }

  if (quote) throw new Error('Unclosed quote');
  push();
  return tokens;
}

function parseArgs(tokens) {
  const args = { _: [] };

  for (let i = 0; i < tokens.length; i++) {
    const tok = tokens[i];

    if (tok.startsWith('--')) {
      const eq = tok.indexOf('=');
      if (eq !== -1) {
        const key = tok.slice(2, eq);
        const value = tok.slice(eq + 1);
        args[key] = value;
        continue;
      }

      const key = tok.slice(2);
      const next = tokens[i + 1];
      if (!next || next.startsWith('--')) {
        args[key] = true;
        continue;
      }
      args[key] = next;
      i++;
      continue;
    }

    args._.push(tok);
  }

  return args;
}

export function parsePipeline(input) {
  const stages = splitPipes(input);
  if (stages.length === 0) throw new Error('Empty pipeline');

  return stages.map((stage) => {
    const tokens = tokenizeCommand(stage);
    if (tokens.length === 0) throw new Error('Empty command stage');
    const name = tokens[0];
    const args = parseArgs(tokens.slice(1));
    return { name, args, raw: stage };
  });
}


--- src/resume.ts ---
import { decodeToken } from './token.js';
import { decodeWorkflowResumePayload } from './workflows/file.js';

export function parseResumeArgs(argv) {
  const args = { decision: null, token: null };

  for (let i = 0; i < argv.length; i++) {
    const tok = argv[i];
    if (tok === '--token') {
      args.token = argv[i + 1];
      i++;
      continue;
    }
    if (tok.startsWith('--token=')) {
      args.token = tok.slice('--token='.length);
      continue;
    }
    if (tok === '--approve' || tok === '--decision') {
      args.decision = argv[i + 1];
      i++;
      continue;
    }
    if (tok.startsWith('--approve=')) {
      args.decision = tok.slice('--approve='.length);
      continue;
    }
    if (tok.startsWith('--decision=')) {
      args.decision = tok.slice('--decision='.length);
      continue;
    }
  }

  if (!args.token) throw new Error('resume requires --token');
  if (!args.decision) throw new Error('resume requires --approve yes|no');

  const decision = String(args.decision).toLowerCase();
  if (!['yes', 'y', 'no', 'n'].includes(decision)) throw new Error('resume --approve must be yes or no');

  return { token: String(args.token), approved: decision === 'yes' || decision === 'y' };
}

export function decodeResumeToken(token) {
  const payload = decodeToken(token);
  if (!payload || typeof payload !== 'object') throw new Error('Invalid token');
  if (payload.protocolVersion !== 1) throw new Error('Unsupported protocol version');
  if (payload.v !== 1) throw new Error('Unsupported token version');
  const workflowPayload = decodeWorkflowResumePayload(payload);
  if (workflowPayload) return workflowPayload;

  if (!Array.isArray(payload.pipeline)) throw new Error('Invalid token');
  if (typeof payload.resumeAtIndex !== 'number') throw new Error('Invalid token');
  if (!Array.isArray(payload.items)) throw new Error('Invalid token');

  return payload;
}


--- src/runtime.ts ---
import { createJsonRenderer } from './renderers/json.js';

export async function runPipeline({ pipeline, registry, stdin, stdout, stderr, env, mode = 'human', input }) {
  let stream = input ?? emptyStream();
  let rendered = false;
  let halted = false;
  let haltedAt = null;

  const ctx = {
    stdin,
    stdout,
    stderr,
    env,
    registry,
    mode,
    render: createJsonRenderer(stdout),
  };

  for (let idx = 0; idx < pipeline.length; idx++) {
    const stage = pipeline[idx];
    const command = registry.get(stage.name);
    if (!command) {
      throw new Error(`Unknown command: ${stage.name}`);
    }

    const result = await command.run({ input: stream, args: stage.args, ctx });

    if (result?.rendered) {
      rendered = true;
    }

    if (result?.halt) {
      halted = true;
      haltedAt = { index: idx, stage };
      stream = result.output ?? emptyStream();
      break;
    }

    stream = result?.output ?? emptyStream();
  }

  const items = [];
  for await (const item of stream) items.push(item);

  return { items, rendered, halted, haltedAt };
}

async function* emptyStream() {}


--- src/token.ts ---
import { Buffer } from 'node:buffer';

export function encodeToken(obj) {
  const json = JSON.stringify(obj);
  return Buffer.from(json, 'utf8').toString('base64url');
}

export function decodeToken(token) {
  try {
    const json = Buffer.from(String(token), 'base64url').toString('utf8');
    return JSON.parse(json);
  } catch (_err) {
    throw new Error('Invalid token');
  }
}


--- src/commands/commands_list.ts ---
import type { CommandMeta, LobsterCommand } from './types.js';

function parseDescriptionFromHelp(helpText: string): string {
  const firstLine = helpText.split('\n').find((l) => l.trim().length > 0) ?? '';
  // Expected pattern: "name — description" but fall back to the line as-is.
  return firstLine.includes('—') ? firstLine.split('—').slice(1).join('—').trim() : firstLine.trim();
}

export const commandsListCommand: LobsterCommand = {
  name: 'commands.list',
  help() {
    return (
      `commands.list — list available Lobster pipeline commands\n\n` +
      `Usage:\n` +
      `  commands.list\n\n` +
      `Notes:\n` +
      `  - Intended for agents (e.g. Clawdbot) to discover available pipeline stages dynamically.\n` +
      `  - Output includes name/description plus optional metadata (argsSchema/examples/sideEffects) when provided by commands.\n`
    );
  },
  meta: {
    description: 'List available Lobster pipeline commands',
    argsSchema: { type: 'object', properties: {}, required: [] },
    sideEffects: [],
  } satisfies CommandMeta,
  async run({ input, ctx }) {
    // Drain input
    for await (const _ of input) {
      // no-op
    }

    const names = ctx.registry.list();
    const output = names.map((name) => {
      const cmd = ctx.registry.get(name) as LobsterCommand | undefined;
      const help = typeof cmd?.help === 'function' ? String(cmd.help()) : '';
      const description = cmd?.meta?.description ?? parseDescriptionFromHelp(help);

      return {
        name,
        description,
        argsSchema: cmd?.meta?.argsSchema ?? null,
        examples: cmd?.meta?.examples ?? null,
        sideEffects: cmd?.meta?.sideEffects ?? null,
      };
    });

    return {
      output: (async function* () {
        for (const item of output) yield item;
      })(),
    };
  },
};


--- src/workflows/file.ts ---
import { promises as fsp } from 'node:fs';
import path from 'node:path';
import { parse as parseYaml } from 'yaml';

import { randomUUID } from 'node:crypto';

import { encodeToken } from '../token.js';
import { readStateJson, writeStateJson } from '../state/store.js';

export type WorkflowFile = {
  name?: string;
  description?: string;
  args?: Record<string, { default?: unknown; description?: string }>;
  env?: Record<string, string>;
  cwd?: string;
  steps: WorkflowStep[];
};

export type WorkflowStep = {
  id: string;
  command: string;
  env?: Record<string, string>;
  cwd?: string;
  stdin?: unknown;
  approval?: boolean | 'required';
  condition?: unknown;
  when?: unknown;
};

export type WorkflowStepResult = {
  id: string;
  stdout?: string;
  json?: unknown;
  approved?: boolean;
  skipped?: boolean;
};

export type WorkflowRunResult = {
  status: 'ok' | 'needs_approval' | 'cancelled';
  output: unknown[];
  requiresApproval?: {
    type: 'approval_request';
    prompt: string;
    items: unknown[];
    preview?: string;
    resumeToken?: string;
  };
};

type RunContext = {
  stdin: NodeJS.ReadableStream;
  stdout: NodeJS.WritableStream;
  stderr: NodeJS.WritableStream;
  env: Record<string, string | undefined>;
  mode: 'human' | 'tool' | 'sdk';
};

export type WorkflowResumePayload = {
  protocolVersion: 1;
  v: 1;
  kind: 'workflow-file';
  stateKey?: string;
  filePath?: string;
  resumeAtIndex?: number;
  steps?: Record<string, WorkflowStepResult>;
  args?: Record<string, unknown>;
  approvalStepId?: string;
};

type WorkflowResumeState = {
  filePath: string;
  resumeAtIndex: number;
  steps: Record<string, WorkflowStepResult>;
  args: Record<string, unknown>;
  approvalStepId?: string;
  createdAt: string;
};

export async function loadWorkflowFile(filePath: string): Promise<WorkflowFile> {
  const text = await fsp.readFile(filePath, 'utf8');
  const ext = path.extname(filePath).toLowerCase();
  const parsed = ext === '.json' ? JSON.parse(text) : parseYaml(text);

  if (!parsed || typeof parsed !== 'object') {
    throw new Error('Workflow file must be a JSON/YAML object');
  }

  const steps = (parsed as WorkflowFile).steps;
  if (!Array.isArray(steps) || steps.length === 0) {
    throw new Error('Workflow file requires a non-empty steps array');
  }

  const seen = new Set<string>();
  for (const step of steps) {
    if (!step || typeof step !== 'object') {
      throw new Error('Workflow step must be an object');
    }
    if (!step.id || typeof step.id !== 'string') {
      throw new Error('Workflow step requires an id');
    }
    if (!step.command || typeof step.command !== 'string') {
      throw new Error(`Workflow step ${step.id} requires a command string`);
    }
    if (seen.has(step.id)) {
      throw new Error(`Duplicate workflow step id: ${step.id}`);
    }
    seen.add(step.id);
  }

  return parsed as WorkflowFile;
}

export function resolveWorkflowArgs(
  argDefs: WorkflowFile['args'],
  provided: Record<string, unknown> | undefined,
) {
  const resolved: Record<string, unknown> = {};
  if (argDefs) {
    for (const [key, def] of Object.entries(argDefs)) {
      if (def && typeof def === 'object' && 'default' in def) {
        resolved[key] = def.default;
      }
    }
  }
  if (provided) {
    for (const [key, value] of Object.entries(provided)) {
      resolved[key] = value;
    }
  }
  return resolved;
}

export async function runWorkflowFile({
  filePath,
  args,
  ctx,
  resume,
  approved,
}: {
  filePath?: string;
  args?: Record<string, unknown>;
  ctx: RunContext;
  resume?: WorkflowResumePayload;
  approved?: boolean;
}): Promise<WorkflowRunResult> {
  const resumeState = resume?.stateKey
    ? await loadWorkflowResumeState(ctx.env, resume.stateKey)
    : resume ?? null;
  const resolvedFilePath = filePath ?? resumeState?.filePath;
  if (!resolvedFilePath) {
    throw new Error('Workflow file path required');
  }
  const workflow = await loadWorkflowFile(resolvedFilePath);
  const resolvedArgs = resolveWorkflowArgs(workflow.args, args ?? resumeState?.args);
  const steps = workflow.steps;
  const results: Record<string, WorkflowStepResult> = resumeState?.steps
    ? cloneResults(resumeState.steps)
    : {};
  const startIndex = resumeState?.resumeAtIndex ?? 0;

  if (resumeState?.approvalStepId && typeof approved === 'boolean') {
    const previous = results[resumeState.approvalStepId] ?? { id: resumeState.approvalStepId };
    previous.approved = approved;
    results[resumeState.approvalStepId] = previous;
  }

  let lastStepId: string | null = null;

  for (let idx = startIndex; idx < steps.length; idx++) {
    const step = steps[idx];

    if (!evaluateCondition(step.when ?? step.condition, results)) {
      results[step.id] = { id: step.id, skipped: true };
      continue;
    }

    const command = resolveTemplate(step.command, resolvedArgs, results);
    const stdinValue = resolveStdin(step.stdin, resolvedArgs, results);
    const env = mergeEnv(ctx.env, workflow.env, step.env, resolvedArgs, results);
    const cwd = resolveCwd(step.cwd ?? workflow.cwd, resolvedArgs);

    const { stdout } = await runShellCommand({ command, stdin: stdinValue, env, cwd });
    const json = parseJson(stdout);

    results[step.id] = { id: step.id, stdout, json };
    lastStepId = step.id;

    if (isApprovalStep(step.approval)) {
      const approval = extractApprovalRequest(step, results[step.id]);

      if (ctx.mode === 'tool' || !isInteractive(ctx.stdin)) {
        const stateKey = await saveWorkflowResumeState(ctx.env, {
          filePath: resolvedFilePath,
          resumeAtIndex: idx + 1,
          steps: results,
          args: resolvedArgs,
          approvalStepId: step.id,
          createdAt: new Date().toISOString(),
        });

        const resumeToken = encodeToken({
          protocolVersion: 1,
          v: 1,
          kind: 'workflow-file',
          stateKey,
        } satisfies WorkflowResumePayload);

        return {
          status: 'needs_approval',
          output: [],
          requiresApproval: {
            ...approval,
            resumeToken,
          },
        };
      }

      ctx.stdout.write(`${approval.prompt} [y/N] `);
      const answer = await readLine(ctx.stdin);
      if (!/^y(es)?$/i.test(String(answer).trim())) {
        throw new Error('Not approved');
      }
      results[step.id].approved = true;
    }
  }

  const output = lastStepId ? toOutputItems(results[lastStepId]) : [];
  return { status: 'ok', output };
}

export function decodeWorkflowResumePayload(payload: unknown): WorkflowResumePayload | null {
  if (!payload || typeof payload !== 'object') return null;
  const data = payload as Partial<WorkflowResumePayload>;
  if (data.kind !== 'workflow-file') return null;
  if (data.protocolVersion !== 1 || data.v !== 1) throw new Error('Unsupported token version');
  if (data.stateKey && typeof data.stateKey === 'string') {
    return data as WorkflowResumePayload;
  }
  if (!data.filePath || typeof data.filePath !== 'string') throw new Error('Invalid workflow token');
  if (typeof data.resumeAtIndex !== 'number') throw new Error('Invalid workflow token');
  if (!data.steps || typeof data.steps !== 'object') throw new Error('Invalid workflow token');
  if (!data.args || typeof data.args !== 'object') throw new Error('Invalid workflow token');
  return data as WorkflowResumePayload;
}

async function saveWorkflowResumeState(env: Record<string, string | undefined>, state: WorkflowResumeState) {
  const stateKey = `workflow_resume_${randomUUID()}`;
  await writeStateJson({ env, key: stateKey, value: state });
  return stateKey;
}

async function loadWorkflowResumeState(env: Record<string, string | undefined>, stateKey: string) {
  const stored = await readStateJson({ env, key: stateKey });
  if (!stored || typeof stored !== 'object') {
    throw new Error('Workflow resume state not found');
  }
  const data = stored as Partial<WorkflowResumeState>;
  if (!data.filePath || typeof data.filePath !== 'string') throw new Error('Invalid workflow resume state');
  if (typeof data.resumeAtIndex !== 'number') throw new Error('Invalid workflow resume state');
  if (!data.steps || typeof data.steps !== 'object') throw new Error('Invalid workflow resume state');
  if (!data.args || typeof data.args !== 'object') throw new Error('Invalid workflow resume state');
  return data as WorkflowResumeState;
}

function mergeEnv(
  base: Record<string, string | undefined>,
  workflowEnv: WorkflowFile['env'],
  stepEnv: WorkflowStep['env'],
  args: Record<string, unknown>,
  results: Record<string, WorkflowStepResult>,
) {
  const env = { ...base } as Record<string, string | undefined>;
  const apply = (source?: Record<string, string>) => {
    if (!source) return;
    for (const [key, value] of Object.entries(source)) {
      if (typeof value === 'string') {
        env[key] = resolveTemplate(value, args, results);
      }
    }
  };
  apply(workflowEnv);
  apply(stepEnv);
  return env;
}

function resolveCwd(cwd: string | undefined, args: Record<string, unknown>) {
  if (!cwd) return undefined;
  return resolveArgsTemplate(cwd, args);
}

function resolveStdin(
  stdin: unknown,
  args: Record<string, unknown>,
  results: Record<string, WorkflowStepResult>,
) {
  if (stdin === null || stdin === undefined) return null;
  if (typeof stdin === 'string') {
    const ref = parseStepRef(stdin.trim());
    if (ref) return getStepRefValue(ref, results, true);
    return resolveTemplate(stdin, args, results);
  }
  return JSON.stringify(stdin);
}

function resolveTemplate(
  input: string,
  args: Record<string, unknown>,
  results: Record<string, WorkflowStepResult>,
) {
  const withArgs = resolveArgsTemplate(input, args);
  return resolveStepRefs(withArgs, results);
}

function resolveArgsTemplate(input: string, args: Record<string, unknown>) {
  return input.replace(/\$\{([A-Za-z0-9_-]+)\}/g, (match, key) => {
    if (key in args) return String(args[key]);
    return match;
  });
}

function resolveStepRefs(input: string, results: Record<string, WorkflowStepResult>) {
  return input.replace(/\$([A-Za-z0-9_-]+)\.(stdout|json|approved)/g, (match, id, field) => {
    const step = results[id];
    if (!step) return match;
    if (field === 'stdout') return step.stdout ?? '';
    if (field === 'json') return step.json !== undefined ? JSON.stringify(step.json) : '';
    if (field === 'approved') return step.approved === true ? 'true' : 'false';
    return match;
  });
}

function parseStepRef(value: string) {
  const match = value.match(/^\$([A-Za-z0-9_-]+)\.(stdout|json)$/);
  if (!match) return null;
  return { id: match[1], field: match[2] as 'stdout' | 'json' };
}

function getStepRefValue(
  ref: { id: string; field: 'stdout' | 'json' },
  results: Record<string, WorkflowStepResult>,
  strict: boolean,
) {
  const step = results[ref.id];
  if (!step) {
    if (strict) throw new Error(`Unknown step reference: ${ref.id}.${ref.field}`);
    return '';
  }
  if (ref.field === 'stdout') return step.stdout ?? '';
  return step.json !== undefined ? JSON.stringify(step.json) : '';
}

function evaluateCondition(
  condition: unknown,
  results: Record<string, WorkflowStepResult>,
) {
  if (condition === undefined || condition === null) return true;
  if (typeof condition === 'boolean') return condition;
  if (typeof condition !== 'string') throw new Error('Unsupported condition type');

  const trimmed = condition.trim();
  if (trimmed === 'true') return true;
  if (trimmed === 'false') return false;

  const match = trimmed.match(/^\$([A-Za-z0-9_-]+)\.(approved|skipped)$/);
  if (!match) throw new Error(`Unsupported condition: ${condition}`);

  const step = results[match[1]];
  if (!step) return false;

  return match[2] === 'approved' ? step.approved === true : step.skipped === true;
}

function isApprovalStep(approval: WorkflowStep['approval']) {
  if (approval === true) return true;
  if (typeof approval === 'string' && approval.toLowerCase() === 'required') return true;
  return false;
}

function extractApprovalRequest(step: WorkflowStep, result: WorkflowStepResult) {
  const fallbackPrompt = `Approve ${step.id}?`;
  const json = result.json;

  if (json && typeof json === 'object' && !Array.isArray(json)) {
    const candidate = json as {
      requiresApproval?: { prompt?: string; items?: unknown[]; preview?: string };
      prompt?: string;
      items?: unknown[];
      preview?: string;
    };
    if (candidate.requiresApproval?.prompt) {
      return {
        type: 'approval_request' as const,
        prompt: candidate.requiresApproval.prompt,
        items: candidate.requiresApproval.items ?? [],
        ...(candidate.requiresApproval.preview ? { preview: candidate.requiresApproval.preview } : null),
      };
    }
    if (candidate.prompt) {
      return {
        type: 'approval_request' as const,
        prompt: candidate.prompt,
        items: candidate.items ?? [],
        ...(candidate.preview ? { preview: candidate.preview } : null),
      };
    }
  }

  return {
    type: 'approval_request' as const,
    prompt: fallbackPrompt,
    items: [],
    ...(result.stdout ? { preview: result.stdout.trim().slice(0, 2000) } : null),
  };
}

function parseJson(stdout: string) {
  const trimmed = stdout.trim();
  if (!trimmed) return undefined;
  try {
    return JSON.parse(trimmed);
  } catch {
    return undefined;
  }
}

function toOutputItems(result: WorkflowStepResult | undefined) {
  if (!result) return [];
  if (result.json !== undefined) {
    return Array.isArray(result.json) ? result.json : [result.json];
  }
  if (result.stdout !== undefined) {
    return result.stdout === '' ? [] : [result.stdout];
  }
  return [];
}

function cloneResults(results: Record<string, WorkflowStepResult>) {
  const out: Record<string, WorkflowStepResult> = {};
  for (const [key, value] of Object.entries(results)) {
    out[key] = { ...value };
  }
  return out;
}

function isInteractive(stdin: NodeJS.ReadableStream) {
  return Boolean((stdin as NodeJS.ReadStream).isTTY);
}

function readLine(stdin: NodeJS.ReadableStream) {
  return new Promise((resolve) => {
    let buf = '';

    const onData = (chunk: Buffer) => {
      buf += chunk.toString('utf8');
      const idx = buf.indexOf('\n');
      if (idx !== -1) {
        stdin.off('data', onData);
        resolve(buf.slice(0, idx));
      }
    };

    stdin.on('data', onData);
  });
}

async function runShellCommand({
  command,
  stdin,
  env,
  cwd,
}: {
  command: string;
  stdin: string | null;
  env: Record<string, string | undefined>;
  cwd?: string;
}) {
  const { spawn } = await import('node:child_process');

  return await new Promise<{ stdout: string; stderr: string }>((resolve, reject) => {
    const child = spawn('/bin/sh', ['-lc', command], {
      env,
      cwd,
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    let stdout = '';
    let stderr = '';

    child.stdout.setEncoding('utf8');
    child.stderr.setEncoding('utf8');

    child.stdout.on('data', (d) => { stdout += d; });
    child.stderr.on('data', (d) => { stderr += d; });

    if (typeof stdin === 'string') {
      child.stdin.setDefaultEncoding('utf8');
      child.stdin.write(stdin);
    }
    child.stdin.end();

    child.on('error', reject);
    child.on('close', (code) => {
      if (code === 0) return resolve({ stdout, stderr });
      reject(new Error(`workflow command failed (${code}): ${stderr.trim() || stdout.trim() || command}`));
    });
  });
}


--- src/workflows/github_pr_monitor.ts ---
import { spawn } from 'node:child_process';

function runProcess(command, argv, { env, cwd }) {
  return new Promise((resolve, reject) => {
    const child = spawn(command, argv, { env, cwd, stdio: ['ignore', 'pipe', 'pipe'] });

    let stdout = '';
    let stderr = '';

    child.stdout.setEncoding('utf8');
    child.stderr.setEncoding('utf8');

    child.stdout.on('data', (d) => { stdout += d; });
    child.stderr.on('data', (d) => { stderr += d; });

    child.on('error', (err: any) => {
      if (err?.code === 'ENOENT') {
        reject(new Error('gh not found on PATH (install GitHub CLI)'));
        return;
      }
      reject(err);
    });

    child.on('close', (code) => {
      if (code === 0) return resolve({ stdout, stderr });
      reject(new Error(`gh failed (${code}): ${stderr.trim() || stdout.trim()}`));
    });
  });
}

import { diffAndStore } from '../state/store.js';

function pickSubset(snapshot) {
  if (!snapshot || typeof snapshot !== 'object') return null;
  return {
    number: snapshot.number,
    title: snapshot.title,
    url: snapshot.url,
    state: snapshot.state,
    isDraft: snapshot.isDraft,
    mergeable: snapshot.mergeable,
    reviewDecision: snapshot.reviewDecision,
    updatedAt: snapshot.updatedAt,
    baseRefName: snapshot.baseRefName,
    headRefName: snapshot.headRefName,
  };
}

export function buildPrChangeSummary(before, after) {
  const a = pickSubset(after);
  const b = pickSubset(before);

  if (!a) return { changedFields: [], changes: {} };
  if (!b) {
    return {
      changedFields: Object.keys(a),
      changes: Object.fromEntries(Object.keys(a).map((k) => [k, { from: null, to: a[k] }])),
    };
  }

  const changes = {};
  for (const key of Object.keys(a)) {
    if (JSON.stringify(a[key]) !== JSON.stringify(b[key])) {
      changes[key] = { from: b[key], to: a[key] };
    }
  }

  return {
    changedFields: Object.keys(changes),
    changes,
  };
}

function formatPrChangeMessage({ repo, pr, changedFields, prInfo }) {
  const fields = changedFields.length ? ` (${changedFields.join(', ')})` : '';
  const title = prInfo?.title ? `: ${prInfo.title}` : '';
  const url = prInfo?.url ? ` ${prInfo.url}` : '';
  return `PR updated: ${repo}#${pr}${title}${fields}.${url}`.replace(/\s+/g, ' ').trim();
}

export async function runGithubPrMonitorWorkflow({ args, ctx }) {
  const repo = args.repo;
  const pr = args.pr;
  if (!repo || !pr) throw new Error('github.pr.monitor requires args.repo and args.pr');

  const key = args.key ?? `github.pr:${repo}#${pr}`;
  const changesOnly = Boolean(args.changesOnly);
  const summaryOnly = Boolean(args.summaryOnly);

  const argv = [
    'pr',
    'view',
    String(pr),
    '--repo',
    String(repo),
    '--json',
    'number,title,url,state,isDraft,mergeable,reviewDecision,author,baseRefName,headRefName,updatedAt',
  ];

  const { stdout } = (await runProcess('gh', argv, { env: ctx.env, cwd: process.cwd() })) as any;

  let current;
  try {
    current = JSON.parse(stdout.trim());
  } catch {
    throw new Error('gh returned non-JSON output');
  }

  const { changed, before } = await diffAndStore({ env: ctx.env, key, value: current });

  if (changesOnly && !changed) {
    return {
      kind: 'github.pr.monitor',
      repo,
      prNumber: Number(pr),
      key,
      changed: false,
      suppressed: true,
    };
  }

  const summary = buildPrChangeSummary(before, current);

  if (summaryOnly) {
    return {
      kind: 'github.pr.monitor',
      repo,
      prNumber: Number(pr),
      key,
      changed,
      summary,
      pr: {
        number: current.number,
        title: current.title,
        url: current.url,
        state: current.state,
        updatedAt: current.updatedAt,
      },
    };
  }

  return {
    kind: 'github.pr.monitor',
    repo,
    prNumber: Number(pr),
    key,
    changed,
    summary,
    prSnapshot: current,
  };
}

export async function runGithubPrMonitorNotifyWorkflow({ args, ctx }) {
  const base = await runGithubPrMonitorWorkflow({
    args: {
      ...args,
      changesOnly: true,
      summaryOnly: true,
    },
    ctx,
  });

  if (base.suppressed) {
    return { kind: 'github.pr.monitor.notify', suppressed: true };
  }

  const changedFields = base.summary?.changedFields ?? [];
  const prInfo = base.pr ?? {};

  return {
    kind: 'github.pr.monitor.notify',
    changed: Boolean(base.changed),
    repo: args.repo,
    prNumber: Number(args.pr),
    message: formatPrChangeMessage({
      repo: args.repo,
      pr: Number(args.pr),
      changedFields,
      prInfo,
    }),
    pr: prInfo,
    summary: base.summary,
  };
}


--- src/recipes/index.ts ---
/**
 * Recipe entrypoints.
 *
 * Core Lobster intentionally keeps only Clawdbot-first recipes here.
 */

export * from "./github/index.js";


--- src/renderers/json.ts ---
export function createJsonRenderer(stdout) {
  return {
    json(items) {
      stdout.write(JSON.stringify(items, null, 2));
      stdout.write('\n');
    },
    lines(lines) {
      for (const line of lines) stdout.write(String(line) + '\n');
    },
  };
}


--- test/approve_preview.test.ts ---
import test from 'node:test';
import assert from 'node:assert/strict';
import { createDefaultRegistry } from '../src/commands/registry.js';

function streamOf(items) {
  return (async function* () {
    for (const item of items) yield item;
  })();
}

test('approve preview includes stdin sample when requested', async () => {
  const registry = createDefaultRegistry();
  const cmd = registry.get('approve');

  const result = await cmd.run({
    input: streamOf([{ a: 1 }, { a: 2 }]),
    args: {
      _: [],
      emit: true,
      prompt: 'ok?',
      'preview-from-stdin': true,
      limit: 1,
    },
    ctx: {
      stdin: process.stdin,
      stdout: process.stdout,
      stderr: process.stderr,
      env: process.env,
      registry,
      mode: 'tool',
      render: { json() {}, lines() {} },
    },
  });

  const items = [];
  for await (const item of result.output) items.push(item);
  assert.equal(items[0].type, 'approval_request');
  assert.ok(String(items[0].preview).includes('"a": 1'));
});


--- test/clawd_invoke_legacy.test.ts ---
import test from 'node:test';
import assert from 'node:assert/strict';
import http from 'node:http';
import { createDefaultRegistry } from '../src/commands/registry.js';

function streamOf(items) {
  return (async function* () {
    for (const item of items) yield item;
  })();
}

test('clawd.invoke accepts legacy raw JSON response', async () => {
  const server = http.createServer((req, res) => {
    if (req.method !== 'POST' || req.url !== '/tools/invoke') {
      res.writeHead(404);
      res.end('not found');
      return;
    }

    let body = '';
    req.setEncoding('utf8');
    req.on('data', (d) => (body += d));
    req.on('end', () => {
      const parsed = JSON.parse(body);
      assert.equal(parsed.tool, 'demo');
      assert.equal(parsed.action, 'ping');
      res.writeHead(200, { 'content-type': 'application/json' });
      res.end(JSON.stringify([{ ok: true, legacy: true, echo: parsed.args }]));
    });
  });

  await new Promise<void>((resolve) => server.listen(0, () => resolve()));
  const addr = server.address();
  const port = typeof addr === "string" || addr == null ? 0 : addr.port;

  try {
    const registry = createDefaultRegistry();
    const cmd = registry.get('clawd.invoke');

    const result = await cmd.run({
      input: streamOf([]),
      args: {
        _: [],
        url: `http://127.0.0.1:${port}`,
        tool: 'demo',
        action: 'ping',
        'args-json': '{"hello":"world"}',
      },
      ctx: {
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr,
        env: process.env,
        registry,
        mode: 'tool',
        render: { json() {}, lines() {} },
      },
    });

    const items = [];
    for await (const it of result.output) items.push(it);
    assert.deepEqual(items, [{ ok: true, legacy: true, echo: { hello: 'world' } }]);
  } finally {
    server.close();
  }
});


--- test/clawd_invoke.test.ts ---
import test from 'node:test';
import assert from 'node:assert/strict';
import http from 'node:http';
import { createDefaultRegistry } from '../src/commands/registry.js';

function streamOf(items) {
  return (async function* () {
    for (const item of items) yield item;
  })();
}

test('clawd.invoke posts to /tools/invoke and returns JSON', async () => {
  const server = http.createServer((req, res) => {
    if (req.method !== 'POST' || req.url !== '/tools/invoke') {
      res.writeHead(404);
      res.end('not found');
      return;
    }

    let body = '';
    req.setEncoding('utf8');
    req.on('data', (d) => (body += d));
    req.on('end', () => {
      const parsed = JSON.parse(body);
      assert.equal(parsed.tool, 'demo');
      assert.equal(parsed.action, 'ping');
      res.writeHead(200, { 'content-type': 'application/json' });
      res.end(JSON.stringify({ ok: true, result: [{ ok: true, echo: parsed.args }] }));
    });
  });

  await new Promise<void>((resolve) => server.listen(0, () => resolve()));
  const addr = server.address();
  const port = typeof addr === "string" || addr == null ? 0 : addr.port;

  try {
    const registry = createDefaultRegistry();
    const cmd = registry.get('clawd.invoke');

    const result = await cmd.run({
      input: streamOf([]),
      args: {
        _: [],
        url: `http://127.0.0.1:${port}`,
        tool: 'demo',
        action: 'ping',
        'args-json': '{"hello":"world"}',
      },
      ctx: {
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr,
        env: process.env,
        registry,
        mode: 'tool',
        render: { json() {}, lines() {} },
      },
    });

    const items = [];
    for await (const it of result.output) items.push(it);
    assert.deepEqual(items, [{ ok: true, echo: { hello: 'world' } }]);
  } finally {
    server.close();
  }
});

test('clawd.invoke --each maps input items into tool args', async () => {
  const seen: Array<{ call: number; args: unknown }> = [];
  const server = http.createServer((req, res) => {
    if (req.method !== 'POST' || req.url !== '/tools/invoke') {
      res.writeHead(404);
      res.end('not found');
      return;
    }

    let body = '';
    req.setEncoding('utf8');
    req.on('data', (d) => (body += d));
    req.on('end', () => {
      const parsed = JSON.parse(body);
      seen.push({ call: seen.length + 1, args: parsed.args });
      res.writeHead(200, { 'content-type': 'application/json' });
      res.end(JSON.stringify({ ok: true, result: [{ ok: true, call: seen.length }] }));
    });
  });

  await new Promise<void>((resolve) => server.listen(0, () => resolve()));
  const addr = server.address();
  const port = typeof addr === "string" || addr == null ? 0 : addr.port;

  try {
    const registry = createDefaultRegistry();
    const cmd = registry.get('clawd.invoke');

    const result = await cmd.run({
      input: streamOf(['a', 'b']),
      args: {
        _: [],
        url: `http://127.0.0.1:${port}`,
        tool: 'demo',
        action: 'ping',
        each: true,
        'item-key': 'message',
        'args-json': '{"channel":"test"}',
      },
      ctx: {
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr,
        env: process.env,
        registry,
        mode: 'tool',
        render: { json() {}, lines() {} },
      },
    });

    const items = [];
    for await (const it of result.output) items.push(it);
    assert.deepEqual(items, [{ ok: true, call: 1 }, { ok: true, call: 2 }]);
    assert.deepEqual(seen, [
      { call: 1, args: { channel: 'test', message: 'a' } },
      { call: 2, args: { channel: 'test', message: 'b' } },
    ]);
  } finally {
    server.close();
  }
});


--- test/commands_list.test.ts ---
import test from 'node:test';
import assert from 'node:assert/strict';
import { createDefaultRegistry } from '../src/commands/registry.js';

function streamOf(items) {
  return (async function* () {
    for (const item of items) yield item;
  })();
}

test('commands.list returns command inventory including stdlib + workflows', async () => {
  const registry = createDefaultRegistry();
  const cmd = registry.get('commands.list');
  assert.ok(cmd, 'commands.list should be registered');

  const res = await cmd.run({
    input: streamOf([]),
    args: { _: [] },
    ctx: {
      stdin: process.stdin,
      stdout: process.stdout,
      stderr: process.stderr,
      env: process.env,
      registry,
      mode: 'tool',
      render: { json() {}, lines() {} },
    },
  });

  const items = [];
  for await (const it of res.output) items.push(it);

  const names = items.map((x) => x.name).sort();

  // A couple representative commands we always expect.
  assert.ok(names.includes('exec'));
  assert.ok(names.includes('json'));
  assert.ok(names.includes('workflows.list'));
  assert.ok(names.includes('commands.list'));

  const self = items.find((x) => x.name === 'commands.list');
  assert.ok(self);
  assert.equal(typeof self.description, 'string');
  assert.ok(self.description.length > 0);
  // Schema should be present for commands that declare it.
  assert.ok(self.argsSchema);
});


--- test/dedupe.test.ts ---
import test from 'node:test';
import assert from 'node:assert/strict';

import { runPipeline } from '../src/runtime.js';
import { createDefaultRegistry } from '../src/commands/registry.js';
import { parsePipeline } from '../src/parser.js';

async function run(pipelineText: string, input: any[]) {
  const pipeline = parsePipeline(pipelineText);
  const registry = createDefaultRegistry();
  const res = await runPipeline({
    pipeline,
    registry,
    stdin: process.stdin,
    stdout: process.stdout,
    stderr: process.stderr,
    env: process.env,
    mode: 'tool',
    input: (async function* () { for (const x of input) yield x; })(),
  });
  return res.items;
}

test('dedupe removes duplicate primitives (stable)', async () => {
  const out = await run('dedupe', [1, 2, 1, 3, 2]);
  assert.deepEqual(out, [1, 2, 3]);
});

test('dedupe supports --key', async () => {
  const input = [
    { id: 'a', v: 1 },
    { id: 'b', v: 2 },
    { id: 'a', v: 3 },
  ];
  const out = await run('dedupe --key id', input);
  assert.deepEqual(out, [input[0], input[1]]);
});

test('dedupe treats undefined keys as a key value', async () => {
  const input = [
    { id: undefined, v: 1 },
    { id: undefined, v: 2 },
    { id: 'x', v: 3 },
  ];
  const out = await run('dedupe --key id', input);
  assert.equal(out.length, 2);
  assert.equal(out[0].v, 1);
  assert.equal(out[1].v, 3);
});


--- test/diff_last.test.ts ---
import test from 'node:test';
import assert from 'node:assert/strict';
import os from 'node:os';
import path from 'node:path';
import { mkdtempSync } from 'node:fs';
import { createDefaultRegistry } from '../src/commands/registry.js';

function streamOf(items) {
  return (async function* () {
    for (const item of items) yield item;
  })();
}

test('diff.last reports changed on first run and not changed on same input', async () => {
  const tmp = mkdtempSync(path.join(os.tmpdir(), 'lobster-diff-'));
  const env = { ...process.env, LOBSTER_STATE_DIR: tmp };
  const registry = createDefaultRegistry();
  const cmd = registry.get('diff.last');

  const first = await cmd.run({
    input: streamOf([{ a: 1 }]),
    args: { _: [], key: 'k' },
    ctx: { stdin: process.stdin, stdout: process.stdout, stderr: process.stderr, env, registry, mode: 'tool', render: { json() {}, lines() {} } },
  });
  const out1 = [];
  for await (const it of first.output) out1.push(it);
  assert.equal(out1[0].changed, true);

  const second = await cmd.run({
    input: streamOf([{ a: 1 }]),
    args: { _: [], key: 'k' },
    ctx: { stdin: process.stdin, stdout: process.stdout, stderr: process.stderr, env, registry, mode: 'tool', render: { json() {}, lines() {} } },
  });
  const out2 = [];
  for await (const it of second.output) out2.push(it);
  assert.equal(out2[0].changed, false);

  const third = await cmd.run({
    input: streamOf([{ a: 2 }]),
    args: { _: [], key: 'k' },
    ctx: { stdin: process.stdin, stdout: process.stdout, stderr: process.stderr, env, registry, mode: 'tool', render: { json() {}, lines() {} } },
  });
  const out3 = [];
  for await (const it of third.output) out3.push(it);
  assert.equal(out3[0].changed, true);
});


--- test/doctor.test.ts ---
import test from 'node:test';
import assert from 'node:assert/strict';
import { spawnSync } from 'node:child_process';
import path from 'node:path';

test('doctor returns tool-mode ok with version', () => {
  const bin = path.join(process.cwd(), 'bin', 'lobster.js');
  const res = spawnSync('node', [bin, 'doctor'], {
    encoding: 'utf8',
    env: { ...process.env, LOBSTER_STATE_DIR: path.join(process.cwd(), '.tmp-test-state') },
  });
  assert.equal(res.status, 0);
  const out = JSON.parse(res.stdout);
  assert.equal(out.ok, true);
  assert.equal(out.protocolVersion, 1);
  assert.equal(out.status, 'ok');
  assert.equal(out.output[0].toolMode, true);
  assert.ok(typeof out.output[0].version === 'string');
});


--- test/email_triage.test.ts ---
import test from "node:test";
import assert from "node:assert/strict";
import http from "node:http";
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { fileURLToPath } from "node:url";
import { dirname, join } from "node:path";

import { createDefaultRegistry } from "../src/commands/registry.js";
import { runPipeline } from "../src/runtime.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

async function closeServer(server: http.Server) {
  await new Promise<void>((resolve) => server.close(() => resolve()));
}

test("gog.gmail.search | email.triage works end-to-end (mock gog)", async () => {
  const registry = createDefaultRegistry();

  // Tests run from dist/, but fixtures live in source tree.
  const repoRoot = join(__dirname, "..", "..");
  const mockGog = join(repoRoot, "test", "fixtures", "mock-gog.mjs");

  const result = await runPipeline({
    pipeline: [
      { name: "gog.gmail.search", args: { query: "newer_than:1d", max: 20 }, raw: "" },
      { name: "email.triage", args: { limit: 20 }, raw: "" },
    ],
    registry,
    input: [],
    stdin: process.stdin,
    stdout: process.stdout,
    stderr: process.stderr,
    env: { ...process.env, GOG_BIN: mockGog },
    mode: "tool",
  } as any);

  assert.equal(result.items.length, 1);
  assert.equal(result.items[0].summary, "1 need replies, 1 need action, 1 FYI");
});

test("email.triage buckets based on subject/from/labels", async () => {
  const registry = createDefaultRegistry();

  const emails = [
    {
      id: "m1",
      threadId: "t1",
      from: "Alice <alice@example.com>",
      subject: "Quick question",
      date: "2026-01-22T07:00:00Z",
      snippet: "Hey, can you take a look?",
      labels: ["INBOX", "UNREAD"],
    },
    {
      id: "m2",
      threadId: "t2",
      from: "no-reply@service.com",
      subject: "Your receipt",
      date: "2026-01-22T06:00:00Z",
      snippet: "Thanks",
      labels: ["INBOX", "UNREAD"],
    },
    {
      id: "m3",
      threadId: "t3",
      from: "Bob <bob@example.com>",
      subject: "Action required: NDA",
      date: "2026-01-21T23:00:00Z",
      snippet: "Please sign",
      labels: ["INBOX"],
    },
  ];

  const input = (async function* () {
    for (const e of emails) yield e;
  })();

  const result = await runPipeline({
    pipeline: [{ name: "email.triage", args: { limit: 20 }, raw: "" }],
    registry,
    input,
    stdin: process.stdin,
    stdout: process.stdout,
    stderr: process.stderr,
    env: process.env,
    mode: "tool",
  } as any);

  assert.equal(result.items.length, 1);
  const out = result.items[0];
  assert.equal(out.summary, "1 need replies, 1 need action, 1 FYI");
  assert.deepEqual(out.buckets.needsReply, ["m1"]);
  assert.deepEqual(out.buckets.needsAction, ["m3"]);
  assert.deepEqual(out.buckets.fyi, ["m2"]);
});

test("email.triage --llm uses llm_task.invoke to draft replies (and can emit drafts)", async () => {
  const registry = createDefaultRegistry();

  const emails = [
    {
      id: "m1",
      threadId: "t1",
      from: "Alice <alice@example.com>",
      subject: "Quick question",
      date: "2026-01-22T07:00:00Z",
      snippet: "Hey, can you take a look?",
      labels: ["INBOX", "UNREAD"],
    },
    {
      id: "m2",
      threadId: "t2",
      from: "Bob <bob@example.com>",
      subject: "Action required: NDA",
      date: "2026-01-21T23:00:00Z",
      snippet: "Please sign",
      labels: ["INBOX"],
    },
  ];

  const cacheDir = await mkdtemp(join(tmpdir(), "lobster-cache-"));

  const bodyLog: any[] = [];
  const server = http.createServer((req, res) => {
    if (req.method !== "POST" || req.url !== "/tools/invoke") {
      res.writeHead(404);
      res.end("not found");
      return;
    }

    let buf = "";
    req.setEncoding("utf8");
    req.on("data", (d) => (buf += d));
    req.on("end", () => {
      const parsed = JSON.parse(buf || "{}");
      bodyLog.push(parsed);

      res.writeHead(200, { "content-type": "application/json" });
      // Clawdbot tool router envelope -> llm-task tool envelope
      res.end(
        JSON.stringify({
          ok: true,
          result: {
            ok: true,
            result: {
              runId: "triage_1",
              output: {
                data: {
                  decisions: [
                    {
                      id: "m1",
                      category: "needs_reply",
                      rationale: "Unclear question",
                      reply: { body: "Sure — what’s the deadline?" },
                    },
                    { id: "m2", category: "needs_action", rationale: "NDA" },
                  ],
                },
              },
            },
          },
        }),
      );
    });
  });

  await new Promise<void>((resolve) => server.listen(0, resolve));
  const addr = server.address();
  const port = typeof addr === "object" && addr ? addr.port : 0;

  try {
    // Report mode
    const input1 = (async function* () {
      for (const e of emails) yield e;
    })();

    const res1 = await runPipeline({
      pipeline: [{ name: "email.triage", args: { llm: true, model: "claude-test", limit: 20 }, raw: "" }],
      registry,
      input: input1,
      stdin: process.stdin,
      stdout: process.stdout,
      stderr: process.stderr,
      env: {
        ...process.env,
        CLAWD_URL: `http://127.0.0.1:${port}`,
        LOBSTER_CACHE_DIR: cacheDir,
        LLM_TASK_FORCE_REFRESH: "1",
      },
      mode: "tool",
    } as any);

    assert.equal(res1.items.length, 1);
    assert.equal(res1.items[0].mode, "llm");
    assert.equal(res1.items[0].buckets.needsReply.length, 1);
    assert.equal(res1.items[0].drafts.length, 1);
    assert.equal(res1.items[0].drafts[0].to, "alice@example.com");

    // Draft emit mode
    const input2 = (async function* () {
      for (const e of emails) yield e;
    })();

    const res2 = await runPipeline({
      pipeline: [
        {
          name: "email.triage",
          args: { llm: true, model: "claude-test", limit: 20, emit: "drafts" },
          raw: "",
        },
      ],
      registry,
      input: input2,
      stdin: process.stdin,
      stdout: process.stdout,
      stderr: process.stderr,
      env: {
        ...process.env,
        CLAWD_URL: `http://127.0.0.1:${port}`,
        LOBSTER_CACHE_DIR: cacheDir,
        LLM_TASK_FORCE_REFRESH: "1",
      },
      mode: "tool",
    } as any);

    assert.equal(res2.items.length, 1);
    assert.equal(res2.items[0].to, "alice@example.com");
    assert.ok(res2.items[0].subject.toLowerCase().startsWith("re:"));
    assert.equal(bodyLog.length >= 1, true);
    assert.equal(bodyLog[0].args?.model ?? bodyLog[0].model, "claude-test");
    assert.ok(bodyLog[0].prompt || bodyLog[0].args?.prompt);
  } finally {
    await rm(cacheDir, { recursive: true, force: true });
    await closeServer(server);
  }
});


--- test/exec_stdin.test.ts ---
import test from 'node:test';
import assert from 'node:assert/strict';
import { createDefaultRegistry } from '../src/commands/registry.js';

function streamOf(items) {
  return (async function* () {
    for (const item of items) yield item;
  })();
}

test('exec --stdin jsonl feeds pipeline input to subprocess', async () => {
  const registry = createDefaultRegistry();
  const cmd = registry.get('exec');

  const nodeScript = [
    "let d='';",
    "process.stdin.on('data',c=>d+=c);",
    "process.stdin.on('end',()=>{",
    "  const lines=d.trim().split('\\n').filter(Boolean);",
    "  console.log(JSON.stringify(lines));",
    "});",
  ].join('');

  const result = await cmd.run({
    input: streamOf([{ a: 1 }, { a: 2 }]),
    args: {
      _: ['node', '-e', nodeScript],
      stdin: 'jsonl',
      json: true,
    },
    ctx: {
      stdin: process.stdin,
      stdout: process.stdout,
      stderr: process.stderr,
      env: process.env,
      registry,
      mode: 'human',
      render: { json() {}, lines() {} },
    },
  });

  const items = [];
  for await (const item of result.output) items.push(item);
  assert.deepEqual(items, ['{"a":1}', '{"a":2}']);
});


--- test/github_pr_notify_format.test.ts ---
import test from 'node:test';
import assert from 'node:assert/strict';
import { buildPrChangeSummary } from '../src/workflows/github_pr_monitor.js';

function formatLikeWorkflow({ repo, pr, after, before }) {
  const summary = buildPrChangeSummary(before, after);
  const fields = summary.changedFields.length ? ` (${summary.changedFields.join(', ')})` : '';
  const title = after?.title ? `: ${after.title}` : '';
  const url = after?.url ? ` ${after.url}` : '';
  return `PR updated: ${repo}#${pr}${title}${fields}.${url}`.replace(/\s+/g, ' ').trim();
}

test('notify message includes repo/pr and changed fields', () => {
  const before = { number: 1, title: 'A', url: 'u', state: 'OPEN', updatedAt: 't1' };
  const after = { ...before, title: 'B', updatedAt: 't2' };

  const msg = formatLikeWorkflow({ repo: 'o/r', pr: 1, before, after });
  assert.ok(msg.includes('o/r#1'));
  assert.ok(msg.includes('title'));
  assert.ok(msg.includes('updatedAt'));
});

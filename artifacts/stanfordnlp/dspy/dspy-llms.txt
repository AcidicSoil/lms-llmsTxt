<!-- llmstxt:source=dspy -->
# DSPy: Declarative Self-Improving Python for Language Models

## Project Purpose
DSPy aims to revolutionize how developers interact with large language models by replacing brittle prompting with declarative, composable Python code. It enables rapid iteration on modular AI systems such as classifiers, RAG pipelines, and agent loops, while offering built-in tools for prompt optimization, weight tuning, and self-refining behavior. The framework supports research in self-improving pipelines, computational constraints, and hybrid models combining retrieval and generation.

## Key Concepts
- **Declarative Self-improving Python (DSPy)**: A paradigm for building AI systems with self-refining capabilities.
- **Adapters**: Interfaces for different input/output types.
- **Modules**: Reusable AI components like ChainOfThought or Refine.
- **Primitives**: Fundamental building blocks like CodeInterpreter or PythonInterpreter.
- **Teleprompters**: Optimization frameworks like GEPA, Bootstrap, and MIPROv2.
- **Signatures**: Define input/output fields for modular composition.
- **Assertions**: Computational constraints to guide self-refining behavior.
- **RAG (Retrieval-Augmented Generation)**: Integrated with DSPyâ€™s retrieval modules.
- **Optimizers**: Algorithms that refine prompts and weights based on performance.

## Architecture Overview
DSPy is structured as a modular, Python-based framework for composing and optimizing language model pipelines. At its core, it provides a set of primitives (e.g., CodeInterpreter, PythonInterpreter) and modules (e.g., ChainOfThought, Refine) that can be chained together using declarative composition. These components interact through well-defined signatures and adapters to handle diverse input types (text, code, images, audio). The framework includes teleprompting systems (like GEPA, Bootstrap) that optimize instruction generation and model weights based on performance metrics, enabling self-improving behavior. The architecture supports integration with LMs via clients (OpenAI, Databricks, etc.) and offers utilities for caching, streaming, logging, and reliability testing. Documentation is organized into comprehensive tutorials, API references, and research papers, emphasizing both practical usage and theoretical foundations.

## Important Directories
- `dspy/`: Core DSPy modules and primitives.
- `docs/`: Comprehensive documentation, tutorials, and API references.
- `tests/`: Unit and integration tests for all components.
- `.github/workflows/`: CI/CD pipelines managed via GitHub Actions.
- `docs/scripts/`: Example scripts and demos.
- `tests/reliability/`: Tests for system reliability and edge cases.
- `dspy/utils/`: Helper utilities (e.g., logging, caching).
- `dspy/predict/`: Prediction and inference components.
- `dspy/evaluate/`: Evaluation metrics and tools.
- `dspy/teleprompt/`: Teleprompting frameworks (GEPA, Bootstrap).
- `dspy/adapters/`: Adapters for handling diverse input/output types.
- `dspy/primitives/`: Fundamental building blocks.

## Entry Points
- `dspy`: Main module entry point.
- `dspy.cli`: Command-line interface for interactive usage.

## Development Info
The project uses `setuptools` for building and packaging, with Python version constraints >=3.10 and <3.15. Key dependencies include OpenAI, Pydantic, Litellm, Optuna, and GEPA (for advanced optimization). It supports optional extras: `anthropic`, `weaviate`, `mcp`, `langchain`, and `dev` for development tools like `pytest`, `ruff`, `pre-commit`. The project enforces code quality with `ruff` (linter and formatter) configured to check for style, complexity, and naming issues. Tests are organized under `tests/`, covering modules, adapters, primitives, teleprompters, and reliability. Coverage is tracked via `coverage.py`, excluding test files and `__init__.py`. CI/CD is managed via GitHub Actions with workflows for tests, docs, precommits, and releases. The project uses `uv.lock` for dependency pinning and includes `.gitignore` and `pre-commit-config.yaml` for development tooling.

## Usage Examples
```python
from dspy import Program, Signature, ChainOfThought

# Define a simple signature
@Signature
def classify_text(text: str) -> str:
    """Classify text as 'positive' or 'negative'."""
    pass

# Use ChainOfThought for reasoning
classifier = ChainOfThought(classify_text)

# Example usage
result = classifier(text="I love this product!")
print(result)  # Output: "positive"

# Integrate RAG with retrieval module
from dspy import RAG

rag_pipeline = RAG(
    retriever="some_retriever",
    generator=classifier
)

query = "What are the benefits of Python?"
output = rag_pipeline(query)
print(output)
```

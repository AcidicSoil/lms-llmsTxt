# llms-full (private-aware)
> Built from GitHub files and website pages. Large files may be truncated.

--- src/api/a2a_routes.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: a2a_routes.py                                                         ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 23, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

"""
A2A Protocol Official Implementation

100% compliant with the official A2A specification:
https://google.github.io/A2A/specification

This is the official and only A2A implementation for the Evo AI platform.

Methods implemented:
- message/send: Send a message and get response
- message/stream: Send a message and stream response  
- agent/authenticatedExtendedCard: Get agent information (via .well-known/agent.json)

Features:
- Direct integration with agent_runner (no complex SDK layer)
- 100% specification compliant JSON-RPC format
- Proper Task object structure
- Full streaming support
- API key authentication
"""

import uuid
import logging
import json
import base64
import httpx
from datetime import datetime
from typing import Dict, Any, List, Optional

from fastapi import APIRouter, Depends, Header, Request, HTTPException
from sqlalchemy.orm import Session
from starlette.responses import JSONResponse
from sse_starlette.sse import EventSourceResponse
from sqlalchemy.sql import text

from src.config.database import get_db
from src.config.settings import settings
from src.services.agent_service import get_agent
from src.services.adk.agent_runner import run_agent, run_agent_stream
from src.services.service_providers import (
    session_service,
    artifacts_service,
    memory_service,
)
from src.schemas.chat import FileData

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/a2a",
    tags=["a2a-official"],
    responses={
        404: {"description": "Not found"},
        400: {"description": "Bad request"},
        401: {"description": "Unauthorized"},
        500: {"description": "Internal server error"},
    },
)


async def verify_api_key(db: Session, x_api_key: str) -> bool:
    """Verifies API key against agent config."""
    if not x_api_key:
        raise HTTPException(status_code=401, detail="API key not provided")

    query = text("SELECT * FROM agents WHERE config->>'api_key' = :api_key LIMIT 1")
    result = db.execute(query, {"api_key": x_api_key}).first()

    if not result:
        raise HTTPException(status_code=401, detail="Invalid API key")

    return True


def extract_text_from_message(message: Dict[str, Any]) -> str:
    """Extract text from message parts according to A2A spec."""
    if not message or "parts" not in message:
        return ""

    for part in message["parts"]:
        if part.get("type") == "text" and "text" in part:
            return part["text"]

    return ""


def extract_files_from_message(message: Dict[str, Any]) -> List[FileData]:
    """Extract files from message parts according to A2A spec."""
    files = []
    if not message or "parts" not in message:
        return files

    for part in message["parts"]:
        if part.get("type") == "file" and "file" in part:
            file_data = part["file"]

            # Check if file has bytes (base64 encoded)
            if "bytes" in file_data and file_data["bytes"]:
                try:
                    # Validate base64 content
                    base64.b64decode(file_data["bytes"])

                    file_obj = FileData(
                        filename=file_data.get("name", "file"),
                        content_type=file_data.get(
                            "mimeType", "application/octet-stream"
                        ),
                        data=file_data["bytes"],  # Keep as base64 string
                    )
                    files.append(file_obj)
                    logger.info(
                        f"üìé Extracted file: {file_obj.filename} ({file_obj.content_type})"
                    )

                except Exception as e:
                    logger.error(f"‚ùå Invalid base64 in file: {e}")
                    continue
            else:
                logger.warning(
                    f"‚ö†Ô∏è File part missing bytes data: {file_data.get('name', 'unnamed')}"
                )

    logger.info(f"üìé Total files extracted: {len(files)}")
    return files


def create_task_response(
    task_id: str,
    context_id: str,
    final_response: str,
    conversation_history: Optional[List[Dict[str, Any]]] = None,
    current_user_message: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """Create Task response according to A2A specification."""

    logger.info(
        f"üèóÔ∏è create_task_response called with history: {len(conversation_history) if conversation_history else 0} messages"
    )

    # Create main response artifact (only the agent's response)
    artifacts = [
        {
            "artifactId": str(uuid.uuid4()),
            "parts": [{"type": "text", "text": final_response}],
        }
    ]

    logger.info(f"üì¶ Created main artifact")

    # Create Task response according to A2A spec
    task_response = {
        "id": task_id,
        "contextId": context_id,
        "status": {"state": "completed", "timestamp": datetime.now().isoformat() + "Z"},
        "artifacts": artifacts,
        "kind": "task",
    }

    # Build complete history for A2A response
    complete_history = []

    # Add existing conversation history
    if conversation_history:
        for msg in conversation_history:
            # Create A2A Message object
            a2a_message = {
                "role": msg["role"],
                "parts": [{"type": "text", "text": msg["content"]}],
                "messageId": msg.get("messageId"),
                "taskId": task_id,
                "contextId": context_id,
                "kind": "message",
            }

            # Add timestamp if available
            if msg.get("timestamp"):
                a2a_message["timestamp"] = msg["timestamp"]

            complete_history.append(a2a_message)

    # Add current user message if provided (this is the message that triggered this response)
    if current_user_message:
        logger.info(f"üìù Adding current user message to history")
        a2a_message = {
            "role": "user",
            "parts": [{"type": "text", "text": current_user_message["content"]}],
            "messageId": current_user_message.get("messageId"),
            "taskId": task_id,
            "contextId": context_id,
            "kind": "message",
        }

        # Add timestamp if available
        if current_user_message.get("timestamp"):
            a2a_message["timestamp"] = current_user_message["timestamp"]

        complete_history.append(a2a_message)

    # Add history field to Task object (A2A spec compliant)
    if complete_history:
        task_response["history"] = complete_history
        logger.info(
            f"üìö Added {len(complete_history)} messages to history field (including current message)"
        )
    else:
        logger.warning("‚ö†Ô∏è No conversation history provided to create_task_response")

    logger.info(f"‚úÖ create_task_response returning A2A compliant Task object")
    return task_response


def clean_message_content(content: str, role: str) -> str:
    """Clean message content, extracting just the text if it contains JSON."""
    if role == "agent" or role == "assistant":
        # Check if content looks like JSON (starts with { and contains jsonrpc)
        if content.strip().startswith("{") and "jsonrpc" in content:
            try:
                # Try to parse as JSON and extract the actual response text
                import json

                json_data = json.loads(content)

                # Look for the actual text in artifacts
                if "result" in json_data and "artifacts" in json_data["result"]:
                    for artifact in json_data["result"]["artifacts"]:
                        if "parts" in artifact:
                            for part in artifact["parts"]:
                                if part.get("type") == "text" and "text" in part:
                                    return part["text"]

                # Fallback: if we can't extract, return a cleaned version
                return "Previous assistant response"

            except (json.JSONDecodeError, KeyError):
                # If not valid JSON, return as-is but truncated
                return content[:100] + "..." if len(content) > 100 else content

    return content


def extract_conversation_history(
    agent_id: str, external_id: str
) -> List[Dict[str, Any]]:
    """Extract conversation history from session using the same logic as /sessions/{session_id}/messages."""
    logger.info(
        f"üîç extract_conversation_history called with agent_id={agent_id}, external_id={external_id}"
    )

    try:
        from src.services.session_service import get_session_events, get_session_by_id

        # Get session ID in the correct format (same as working endpoint)
        session_id = f"{external_id}_{agent_id}"
        logger.info(f"üìã Constructed session_id: {session_id}")

        # First, verify session exists (same as working endpoint)
        logger.info(f"üîç Verifying session exists...")
        session = get_session_by_id(session_service, session_id)
        if not session:
            logger.warning(f"‚ö†Ô∏è Session not found: {session_id}")
            return []

        logger.info(f"‚úÖ Session found: {session_id}")

        # Get events using same method as working endpoint
        logger.info(f"üîç Getting events for session...")
        events = get_session_events(session_service, session_id)
        logger.info(
            f"üìã get_session_events returned {len(events) if events else 0} events"
        )

        history = []

        # Process events exactly like the working /messages endpoint
        for i, event in enumerate(events):
            logger.info(
                f"üîç Processing event {i}: id={getattr(event, 'id', 'NO_ID')}, author={getattr(event, 'author', 'NO_AUTHOR')}"
            )

            # Convert event to dict like in working endpoint
            event_dict = (
                event.model_dump() if hasattr(event, "model_dump") else event.__dict__
            )

            # Check if event has content with parts (same logic as working endpoint)
            if event_dict.get("content") and event_dict["content"].get("parts"):
                logger.info(
                    f"üìù Event {i} has content with {len(event_dict['content']['parts'])} parts"
                )

                for j, part in enumerate(event_dict["content"]["parts"]):
                    logger.info(f"üìù Processing part {j}: {part}")

                    # Extract text content (same as working endpoint checks for text)
                    if isinstance(part, dict) and part.get("text"):
                        role = "user" if event_dict.get("author") == "user" else "agent"
                        text_content = part["text"]

                        # Clean the content to remove JSON artifacts
                        cleaned_content = clean_message_content(text_content, role)
                        logger.info(
                            f"üìù Cleaned content for {role}: {cleaned_content[:50]}..."
                        )

                        # Create A2A compatible history entry
                        history_entry = {
                            "role": role,
                            "content": cleaned_content,
                            "messageId": event_dict.get("id"),
                            "timestamp": event_dict.get("timestamp"),
                            "author": event_dict.get("author"),
                            "invocation_id": event_dict.get("invocation_id"),
                        }

                        history.append(history_entry)
                        logger.info(f"‚úÖ Added history entry {len(history)}: {role}")
                    else:
                        logger.info(f"üìù Part {j} has no text content: {part}")
            else:
                logger.warning(f"‚ö†Ô∏è Event {i} has no content or parts")

        logger.info(
            f"üìö extract_conversation_history extracted {len(history)} messages using working logic"
        )
        return history

    except Exception as e:
        logger.error(f"‚ùå Error extracting conversation history: {e}")
        import traceback

        logger.error(f"Full traceback: {traceback.format_exc()}")
        return []


def extract_history_from_params(params: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Extract history from request params according to A2A spec."""
    history = []
    if "history" in params and isinstance(params["history"], list):
        for msg in params["history"]:
            if isinstance(msg, dict) and "role" in msg and "parts" in msg:
                # Extract text from parts
                text_content = ""
                for part in msg["parts"]:
                    if (
                        isinstance(part, dict)
                        and part.get("type") == "text"
                        and "text" in part
                    ):
                        text_content += part["text"] + " "

                if text_content.strip():
                    history.append(
                        {
                            "role": msg["role"],
                            "content": text_content.strip(),
                            "messageId": msg.get("messageId"),
                            "timestamp": None,  # Could be added if provided
                        }
                    )

    logger.info(f"üìö Extracted {len(history)} messages from request history")
    return history


def combine_histories(
    request_history: List[Dict[str, Any]], session_history: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """Combine request history with session history, avoiding duplicates."""
    combined = []

    # Add session history first
    for msg in session_history:
        combined.append(msg)

    # Add request history, avoiding duplicates based on messageId or content
    for req_msg in request_history:
        # Check if this message already exists in combined history
        is_duplicate = False
        for existing_msg in combined:
            if (
                req_msg.get("messageId")
                and req_msg["messageId"] == existing_msg.get("messageId")
            ) or (
                req_msg["content"] == existing_msg["content"]
                and req_msg["role"] == existing_msg["role"]
            ):
                is_duplicate = True
                break

        if not is_duplicate:
            combined.append(req_msg)

    # Sort by timestamp if available, otherwise maintain order
    return combined


@router.post("/{agent_id}")
async def process_a2a_message(
    agent_id: uuid.UUID,
    request: Request,
    x_api_key: str = Header(None, alias="x-api-key"),
    db: Session = Depends(get_db),
):
    """
    Process A2A messages according to official specification.

    Supports:
    - message/send: Send a message and get response
    - message/stream: Send a message and stream response
    """
    logger.info(f"üéØ A2A Spec endpoint called for agent {agent_id}")

    # Verify API key
    await verify_api_key(db, x_api_key)

    # Verify agent exists
    agent = get_agent(db, agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")

    try:
        # Parse JSON-RPC request
        request_body = await request.json()

        jsonrpc = request_body.get("jsonrpc")
        if jsonrpc != "2.0":
            raise HTTPException(status_code=400, detail="Invalid JSON-RPC version")

        method = request_body.get("method")
        params = request_body.get("params", {})
        request_id = request_body.get("id")

        logger.info(f"üìù Method: {method}, ID: {request_id}")

        if method == "message/send":
            return await handle_message_send(agent_id, params, request_id, db)
        elif method == "message/stream":
            return await handle_message_stream(agent_id, params, request_id, db)
        elif method == "tasks/get":
            return await handle_tasks_get(agent_id, params, request_id, db)
        elif method == "tasks/cancel":
            return await handle_tasks_cancel(agent_id, params, request_id, db)
        elif method == "tasks/pushNotificationConfig/set":
            return await handle_tasks_push_notification_config_set(
                agent_id, params, request_id, db
            )
        elif method == "tasks/pushNotificationConfig/get":
            return await handle_tasks_push_notification_config_get(
                agent_id, params, request_id, db
            )
        elif method == "tasks/resubscribe":
            return await handle_tasks_resubscribe(agent_id, params, request_id, db)
        elif method == "agent/authenticatedExtendedCard":
            return await handle_agent_authenticated_extended_card(
                agent_id, params, request_id, db
            )
        else:
            # JSON-RPC error for method not found
            return JSONResponse(
                status_code=400,
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32601,
                        "message": "Method not found",
                        "data": {
                            "method": method,
                            "supported_methods": [
                                "message/send",
                                "message/stream",
                                "tasks/get",
                                "tasks/cancel",
                                "tasks/pushNotificationConfig/set",
                                "tasks/pushNotificationConfig/get",
                                "tasks/resubscribe",
                                "agent/authenticatedExtendedCard",
                            ],
                        },
                    },
                },
            )

    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid JSON")
    except Exception as e:
        logger.error(f"Error processing A2A request: {e}")
        return JSONResponse(
            status_code=500,
            content={
                "jsonrpc": "2.0",
                "id": request_body.get("id") if "request_body" in locals() else None,
                "error": {
                    "code": -32603,
                    "message": "Internal error",
                    "data": {"error": str(e)},
                },
            },
        )


async def handle_message_send(
    agent_id: uuid.UUID, params: Dict[str, Any], request_id: str, db: Session
) -> JSONResponse:
    """Handle message/send according to A2A spec."""

    logger.info(f"üîÑ Processing message/send for agent {agent_id}")

    # Extract message from params
    message = params.get("message")
    if not message:
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32602,
                    "message": "Invalid params",
                    "data": {"missing": "message"},
                },
            }
        )

    # Extract configuration from params (A2A spec: configuration is optional)
    configuration = params.get("configuration", {})
    push_notification_config = configuration.get("pushNotificationConfig")

    # Support alternative format: pushNotificationConfig directly in params (for backward compatibility)
    if not push_notification_config:
        push_notification_config = params.get("pushNotificationConfig")

    logger.info(
        f"üîî Push notification config found: {push_notification_config is not None}"
    )

    if push_notification_config:
        # Support both official spec format and common variations
        webhook_url = push_notification_config.get(
            "url"
        ) or push_notification_config.get("webhookUrl")

        logger.info(
            f"üîî Push notification config provided: {webhook_url or 'No URL found'}"
        )

        # Validate push notification config according to A2A spec (support both url and webhookUrl)
        if not webhook_url:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {
                            "missing": "pushNotificationConfig.url or pushNotificationConfig.webhookUrl"
                        },
                    },
                }
            )

        # Validate HTTPS requirement (A2A spec: prevents SSRF attacks)
        if not webhook_url.startswith("https://"):
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {
                            "error": "pushNotificationConfig.url MUST use HTTPS for security"
                        },
                    },
                }
            )

        # Validate that agent supports push notifications
        agent = get_agent(db, agent_id)
        if not agent:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32001,
                        "message": "Agent not found",
                    },
                }
            )

        # Check agent capabilities for push notification support
        # (Our agent card already indicates pushNotifications: true)
        logger.info(f"‚úÖ Agent {agent_id} supports push notifications")

    # Extract text and files from message
    text = extract_text_from_message(message)
    files = extract_files_from_message(message)

    # Allow empty text if we have files
    if not text and not files:
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32602,
                    "message": "Invalid params",
                    "data": {"missing": "text content or files in message parts"},
                },
            }
        )

    # Use default text if only files provided
    if not text and files:
        text = "Analyze the provided files"

    logger.info(f"üìù Extracted text: {text}")
    logger.info(f"üìé Extracted files: {len(files)}")

    # Generate IDs
    task_id = str(uuid.uuid4())
    context_id = message.get("messageId", str(uuid.uuid4()))

    try:
        # Extract conversation history for context
        logger.info(
            f"üîç Attempting to extract conversation history for agent {agent_id}, context {context_id}"
        )
        conversation_history = extract_conversation_history(str(agent_id), context_id)
        logger.info(
            f"üìö Session history extracted: {len(conversation_history)} messages"
        )

        # Extract history from params
        logger.info(f"üîç Attempting to extract history from request params")
        request_history = extract_history_from_params(params)
        logger.info(f"üìù Request history extracted: {len(request_history)} messages")

        # Combine histories
        logger.info(f"üîó Combining histories...")
        combined_history = combine_histories(request_history, conversation_history)
        logger.info(f"üìñ Combined history has {len(combined_history)} total messages")

        # Log detailed combined history for debugging
        for i, msg in enumerate(combined_history):
            logger.info(f"  History[{i}]: {msg['role']} - {msg['content'][:50]}...")

        # Execute agent with files - the ADK runner will handle session history automatically
        logger.info(
            f"ü§ñ Executing agent {agent_id} with message: {text} and {len(files)} files"
        )
        logger.info(
            f"üìö ADK will provide session context automatically ({len(combined_history)} previous messages available)"
        )

        result = await run_agent(
            agent_id=str(agent_id),
            external_id=context_id,
            message=text,  # Send only the original message - ADK handles context
            session_service=session_service,
            artifacts_service=artifacts_service,
            memory_service=memory_service,
            db=db,
            files=files if files else None,
        )

        final_response = result.get("final_response", "No response")
        logger.info(f"‚úÖ Agent response: {final_response}")

        # Log what we're about to send to create_task_response
        logger.info(
            f"üèóÔ∏è Creating task response with {len(combined_history) if combined_history else 0} history messages"
        )

        # Create current user message object for history
        current_user_message = {
            "content": text,
            "messageId": message.get("messageId"),
            "timestamp": None,  # Could add current timestamp
        }

        # Create A2A compliant response with history
        task_response = create_task_response(
            task_id,
            context_id,
            final_response,
            combined_history if combined_history else None,
            current_user_message,
        )

        logger.info(
            f"üì¶ Task response created with {len(task_response.get('artifacts', []))} artifacts"
        )

        # Handle push notification if configured
        if push_notification_config:
            try:
                await send_push_notification(task_response, push_notification_config)
                logger.info(f"üîî Push notification sent successfully")
            except Exception as e:
                logger.error(f"‚ùå Push notification failed: {e}")
                # Continue execution - push notification failure shouldn't break the response

        return JSONResponse(
            content={"jsonrpc": "2.0", "id": request_id, "result": task_response}
        )

    except Exception as e:
        logger.error(f"‚ùå Agent execution error: {e}")
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32603,
                    "message": "Agent execution failed",
                    "data": {"error": str(e)},
                },
            }
        )


async def handle_message_stream(
    agent_id: uuid.UUID, params: Dict[str, Any], request_id: str, db: Session
) -> EventSourceResponse:
    """Handle message/stream according to A2A spec."""

    logger.info(f"üîÑ Processing message/stream for agent {agent_id}")

    # Extract message
    message = params.get("message")
    if not message:
        # Return error event
        async def error_generator():
            yield {
                "data": json.dumps(
                    {
                        "jsonrpc": "2.0",
                        "id": request_id,
                        "error": {
                            "code": -32602,
                            "message": "Invalid params",
                            "data": {"missing": "message"},
                        },
                    }
                )
            }

        return EventSourceResponse(error_generator())

    # Extract text and files from message
    text = extract_text_from_message(message)
    files = extract_files_from_message(message)
    context_id = message.get("messageId", str(uuid.uuid4()))

    # Use default text if only files provided
    if not text and files:
        text = "Analyze the provided files"

    # Extract and combine conversation history
    conversation_history = extract_conversation_history(str(agent_id), context_id)
    request_history = extract_history_from_params(params)
    combined_history = combine_histories(request_history, conversation_history)

    async def stream_generator():
        try:
            logger.info(f"üåä Starting stream for: {text} with {len(files)} files")
            logger.info(
                f"üìö ADK will provide session context automatically ({len(combined_history)} previous messages available)"
            )

            # Stream agent execution - ADK handles session history automatically
            async for chunk in run_agent_stream(
                agent_id=str(agent_id),
                external_id=context_id,
                message=text,  # Send only the original message - ADK handles context
                session_service=session_service,
                artifacts_service=artifacts_service,
                memory_service=memory_service,
                db=db,
                files=files if files else None,
            ):
                # Parse chunk and convert to A2A format
                try:
                    chunk_data = json.loads(chunk)

                    # Create TaskStatusUpdateEvent
                    event = {
                        "jsonrpc": "2.0",
                        "id": request_id,
                        "result": {
                            "id": str(uuid.uuid4()),
                            "status": {
                                "state": "working",
                                "message": chunk_data.get("content", {}),
                            },
                            "final": False,
                        },
                    }

                    yield {"data": json.dumps(event)}

                except Exception as e:
                    logger.error(f"Error processing chunk: {e}")
                    continue

            # Send final event
            final_event = {
                "jsonrpc": "2.0",
                "id": request_id,
                "result": {
                    "id": str(uuid.uuid4()),
                    "status": {"state": "completed"},
                    "final": True,
                },
            }
            yield {"data": json.dumps(final_event)}

        except Exception as e:
            logger.error(f"‚ùå Streaming error: {e}")
            error_event = {
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32603,
                    "message": "Streaming failed",
                    "data": {"error": str(e)},
                },
            }
            yield {"data": json.dumps(error_event)}

    return EventSourceResponse(stream_generator())


@router.get("/{agent_id}/.well-known/agent.json")
async def get_agent_card(
    agent_id: uuid.UUID,
    db: Session = Depends(get_db),
):
    """Get agent card according to A2A specification."""

    logger.info(f"üìã Getting agent card for {agent_id}")

    agent = get_agent(db, agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")

    # Build agent card following A2A specification
    agent_card = {
        "name": agent.name,
        "description": agent.description or f"AI Agent {agent.name}",
        "url": f"{settings.API_URL}/api/v1/a2a/{agent_id}",
        "provider": {
            "organization": "Evo AI Platform",
            "url": settings.API_URL,
        },
        "version": "1.0.0",
        "documentationUrl": f"{settings.API_URL}/docs",
        "capabilities": {
            "streaming": True,
            "pushNotifications": True,  # Now supporting push notifications
            "stateTransitionHistory": False,
        },
        "securitySchemes": {
            "apiKey": {
                "type": "apiKey",
                "in": "header",
                "name": "x-api-key",
            }
        },
        "security": [{"apiKey": []}],
        "defaultInputModes": ["text/plain", "application/json"],
        "defaultOutputModes": ["text/plain", "application/json"],
        "skills": [
            {
                "id": "general-assistance",
                "name": "General AI Assistant",
                "description": "Provides general AI assistance and task completion",
                "tags": ["assistant", "general", "ai", "help"],
                "examples": ["Help me with a task", "Answer my question"],
                "inputModes": ["text"],
                "outputModes": ["text"],
            }
        ],
    }

    return JSONResponse(agent_card)


@router.get("/health")
async def health_check():
    """Health check for A2A official implementation - 100% A2A spec compliant."""
    return {
        "status": "healthy",
        "specification": "A2A Protocol v1.0 - 100% COMPLIANT IMPLEMENTATION",
        "specification_url": "https://google.github.io/A2A/specification",
        "compliance_level": "FULL",
        # All RPC methods from A2A spec implemented
        "rpc_methods": {
            "core": ["message/send", "message/stream"],
            "task_management": ["tasks/get", "tasks/cancel", "tasks/resubscribe"],
            "push_notifications": [
                "tasks/pushNotificationConfig/set",
                "tasks/pushNotificationConfig/get",
            ],
            "agent_discovery": ["agent/authenticatedExtendedCard"],
        },
        "endpoints": {
            "agent_endpoint": f"{settings.API_URL}/api/v1/a2a/{{agent_id}}",
            "agent_card": f"{settings.API_URL}/api/v1/a2a/{{agent_id}}/.well-known/agent.json",
        },
        # A2A Protocol Data Objects - all implemented
        "data_objects": [
            "Task",
            "TaskStatus",
            "TaskState",
            "Message",
            "TextPart",
            "FilePart",
            "DataPart",
            "Artifact",
            "PushNotificationConfig",
            "PushNotificationAuthenticationInfo",
            "JSONRPCRequest",
            "JSONRPCResponse",
            "JSONRPCError",
        ],
        # A2A Features implemented
        "features": {
            "multi_turn_conversations": True,
            "file_processing": True,
            "context_preservation": True,
            "streaming": True,
            "push_notifications": True,
            "task_cancellation": True,
            "push_config_management": True,
            "authenticated_extended_cards": True,
            "https_security": True,
            "json_rpc_2_0": True,
        },
        # Security features per A2A spec
        "security": {
            "transport_security": "HTTPS required for push notifications",
            "authentication": "API Key via x-api-key header",
            "webhook_validation": "HTTPS-only webhooks to prevent SSRF",
            "input_validation": "Full parameter validation on all RPC methods",
        },
        # Extensions beyond A2A spec
        "extensions": {
            "conversation_history": f"{settings.API_URL}/api/v1/a2a/{{agent_id}}/conversation/history",
            "sessions": f"{settings.API_URL}/api/v1/a2a/{{agent_id}}/sessions",
            "session_history": f"{settings.API_URL}/api/v1/a2a/{{agent_id}}/sessions/{{session_id}}/history",
        },
        "compatibility_notes": [
            "Supports both official A2A format and common variations",
            "Backward compatible with alternative field names",
            "Task management adapted for synchronous execution model",
            "Push notifications with multiple authentication schemes",
        ],
    }


@router.get("/{agent_id}/sessions")
async def list_agent_sessions(
    agent_id: uuid.UUID,
    external_id: str,
    x_api_key: str = Header(None, alias="x-api-key"),
    db: Session = Depends(get_db),
):
    """List sessions for an agent and external_id (A2A extension)."""

    logger.info(f"üìã Listing sessions for agent {agent_id}, external_id: {external_id}")

    # Verify API key
    await verify_api_key(db, x_api_key)

    # Verify agent exists
    agent = get_agent(db, agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")

    try:
        # List sessions from session service
        sessions = []
        session_id = f"{external_id}_{agent_id}"

        # Try to get session
        session = session_service.get_session(
            app_name=str(agent_id), user_id=external_id, session_id=session_id
        )

        if session:
            # Extract conversation history
            history = extract_conversation_history(str(agent_id), external_id)

            sessions.append(
                {
                    "sessionId": session_id,
                    "contextId": external_id,
                    "lastUpdate": getattr(session, "last_update_time", None),
                    "messageCount": len(history),
                    "status": "active",
                }
            )

        return JSONResponse({"sessions": sessions, "total": len(sessions)})

    except Exception as e:
        logger.error(f"‚ùå Error listing sessions: {e}")
        raise HTTPException(status_code=500, detail=f"Error listing sessions: {str(e)}")


@router.get("/{agent_id}/sessions/{session_id}/history")
async def get_session_history(
    agent_id: uuid.UUID,
    session_id: str,
    x_api_key: str = Header(None, alias="x-api-key"),
    db: Session = Depends(get_db),
    limit: int = 50,
):
    """Get conversation history for a specific session (A2A extension)."""

    logger.info(f"üìö Getting history for session {session_id}")

    # Verify API key
    await verify_api_key(db, x_api_key)

    # Verify agent exists
    agent = get_agent(db, agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")

    try:
        # Parse session_id to get external_id
        if "_" in session_id:
            external_id = session_id.split("_")[0]
        else:
            external_id = session_id

        # Extract conversation history
        history = extract_conversation_history(str(agent_id), external_id)

        # Limit results
        if limit > 0:
            history = history[-limit:]

        return JSONResponse(
            {"sessionId": session_id, "history": history, "total": len(history)}
        )

    except Exception as e:
        logger.error(f"‚ùå Error getting session history: {e}")
        raise HTTPException(
            status_code=500, detail=f"Error getting session history: {str(e)}"
        )


@router.post("/{agent_id}/conversation/history")
async def get_conversation_history(
    agent_id: uuid.UUID,
    request: Request,
    x_api_key: str = Header(None, alias="x-api-key"),
    db: Session = Depends(get_db),
):
    """
    Get conversation history according to A2A specification.

    Endpoint for retrieving multi-turn conversation context.
    This implements context preservation as defined in A2A spec.
    """
    logger.info(f"üìö A2A Conversation History requested for agent {agent_id}")

    # Verify API key
    await verify_api_key(db, x_api_key)

    # Verify agent exists
    agent = get_agent(db, agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")

    try:
        # Parse JSON-RPC request
        request_body = await request.json()

        jsonrpc = request_body.get("jsonrpc")
        if jsonrpc != "2.0":
            raise HTTPException(status_code=400, detail="Invalid JSON-RPC version")

        params = request_body.get("params", {})
        request_id = request_body.get("id")

        # Extract contextId (external_id) from params
        context_id = params.get("contextId") or params.get("external_id")
        if not context_id:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {"missing": "contextId or external_id"},
                    },
                }
            )

        # Extract conversation history using session_service
        history = extract_conversation_history(str(agent_id), context_id)

        # Limit history if requested
        limit = params.get("limit", 50)
        if limit > 0:
            history = history[-limit:]

        # Format as A2A Task response with history artifacts
        task_id = str(uuid.uuid4())

        # Create structured artifacts for history
        artifacts = []

        # Main artifact with recent messages
        if history:
            recent_messages = history[-10:]  # Last 10 messages

            # Create individual message artifacts
            for i, msg in enumerate(recent_messages):
                artifacts.append(
                    {
                        "artifactId": str(uuid.uuid4()),
                        "name": f"message_{i+1}",
                        "description": f"Message from {msg['role']}",
                        "parts": [
                            {
                                "type": "text",
                                "text": msg["content"],
                                "metadata": {
                                    "role": msg["role"],
                                    "messageId": msg.get("messageId"),
                                    "timestamp": msg.get("timestamp"),
                                    "author": msg.get("author"),
                                },
                            }
                        ],
                    }
                )

            # Summary artifact
            artifacts.append(
                {
                    "artifactId": str(uuid.uuid4()),
                    "name": "conversation_summary",
                    "description": f"Conversation history summary ({len(history)} total messages)",
                    "parts": [
                        {
                            "type": "text",
                            "text": f"Conversation with {len(history)} messages between user and agent.",
                            "metadata": {
                                "total_messages": len(history),
                                "recent_messages": len(recent_messages),
                                "context_id": context_id,
                            },
                        }
                    ],
                }
            )

        # Create A2A compliant Task response
        task_response = {
            "id": task_id,
            "contextId": context_id,
            "status": {
                "state": "completed",
                "timestamp": datetime.now().isoformat() + "Z",
            },
            "artifacts": artifacts,
            "kind": "task",
            "metadata": {
                "total_messages": len(history),
                "operation": "conversation_history_retrieval",
            },
        }

        return JSONResponse(
            content={"jsonrpc": "2.0", "id": request_id, "result": task_response}
        )

    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid JSON")
    except Exception as e:
        logger.error(f"‚ùå Error retrieving conversation history: {e}")
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_body.get("id") if "request_body" in locals() else None,
                "error": {
                    "code": -32603,
                    "message": "Internal error",
                    "data": {"error": str(e)},
                },
            }
        )


async def send_push_notification(
    task_response: Dict[str, Any], push_notification_config: Dict[str, Any]
):
    """Send push notification according to A2A specification section 9.5.

    A2A spec PushNotificationConfig object:
    - url: The absolute HTTPS webhook URL where the A2A Server should POST task updates
    - token (optional): Client-generated opaque token for validation
    - authentication (optional): PushNotificationAuthenticationInfo for authenticating to client's webhook

    Alternative formats supported for compatibility:
    - webhookUrl instead of url
    - webhookAuthenticationInfo instead of authentication
    """
    # Support both official spec format and common variations
    webhook_url = push_notification_config.get("url") or push_notification_config.get(
        "webhookUrl"
    )
    webhook_token = push_notification_config.get("token")

    # Support both official and alternative authentication field names
    authentication = push_notification_config.get(
        "authentication"
    ) or push_notification_config.get("webhookAuthenticationInfo")

    if not webhook_url:
        raise ValueError("pushNotificationConfig.url (or webhookUrl) is required")

    # Validate HTTPS requirement (A2A spec: url MUST be HTTPS for security to prevent SSRF)
    if not webhook_url.startswith("https://"):
        raise ValueError(
            "pushNotificationConfig.url MUST use HTTPS to prevent SSRF attacks"
        )

    logger.info(f"üîî Sending push notification to: {webhook_url}")

    # Prepare headers according to A2A spec section 9.5
    headers = {
        "Content-Type": "application/json",
        "User-Agent": f"A2A-Server/{getattr(settings, 'API_VERSION', '1.0.0')}",
    }

    # Add client token if provided (A2A spec: server SHOULD include in X-A2A-Notification-Token header)
    if webhook_token:
        headers["X-A2A-Notification-Token"] = webhook_token
        logger.info(f"üîë Added client token to notification headers")

    # Handle authentication according to A2A spec PushNotificationAuthenticationInfo
    if authentication:
        auth_type = authentication.get("type")

        # Handle "none" type (no authentication)
        if auth_type == "none":
            logger.info(f"üîì No authentication required for webhook")

        # Handle schemes-based authentication (official A2A spec format)
        elif "schemes" in authentication:
            auth_schemes = authentication.get("schemes", [])
            auth_credentials = authentication.get("credentials")

            for scheme in auth_schemes:
                if scheme.lower() == "bearer":
                    # Bearer token authentication
                    if auth_credentials:
                        headers["Authorization"] = f"Bearer {auth_credentials}"
                        logger.info(f"üîê Added Bearer authentication")
                    else:
                        logger.warning(
                            "‚ö†Ô∏è Bearer scheme specified but no credentials provided"
                        )

                elif scheme.lower() == "apikey":
                    # API Key authentication
                    if auth_credentials:
                        try:
                            # A2A spec example: JSON like {"in": "header", "name": "X-Client-Webhook-Key", "value": "actual_key"}
                            if isinstance(auth_credentials, str):
                                cred_data = json.loads(auth_credentials)
                            else:
                                cred_data = auth_credentials

                            if cred_data.get("in") == "header":
                                header_name = cred_data.get("name", "X-API-Key")
                                header_value = cred_data.get("value")
                                if header_value:
                                    headers[header_name] = header_value
                                    logger.info(
                                        f"üîê Added API Key authentication to header: {header_name}"
                                    )
                        except (json.JSONDecodeError, TypeError):
                            # Fallback: treat credentials as direct API key value
                            headers["X-API-Key"] = str(auth_credentials)
                            logger.info(f"üîê Added API Key authentication (fallback)")
                    else:
                        logger.warning(
                            "‚ö†Ô∏è ApiKey scheme specified but no credentials provided"
                        )

                else:
                    logger.warning(f"‚ö†Ô∏è Unsupported authentication scheme: {scheme}")

        # Handle basic authentication types
        elif auth_type == "bearer":
            token = authentication.get("token") or authentication.get("credentials")
            if token:
                headers["Authorization"] = f"Bearer {token}"
                logger.info(f"üîê Added Bearer authentication (alternative format)")

        elif auth_type == "apikey":
            api_key = (
                authentication.get("apiKey")
                or authentication.get("key")
                or authentication.get("credentials")
            )
            header_name = authentication.get("headerName", "X-API-Key")
            if api_key:
                headers[header_name] = api_key
                logger.info(f"üîê Added API Key authentication to header: {header_name}")

        else:
            logger.warning(f"‚ö†Ô∏è Unsupported authentication type: {auth_type}")

    # According to A2A spec section 9.5, the notification payload should contain
    # sufficient information for client to identify Task ID and new state
    # The spec suggests sending the full Task object as JSON payload
    notification_payload = task_response

    try:
        # Use 30 second timeout as recommended for webhook calls
        async with httpx.AsyncClient(timeout=30.0) as client:
            logger.info(
                f"üì§ Sending POST request to webhook with {len(headers)} headers"
            )

            response = await client.post(
                webhook_url, headers=headers, json=notification_payload
            )

            # Log the response according to A2A spec recommendations
            if response.status_code == 200:
                logger.info(f"‚úÖ Push notification sent successfully to {webhook_url}")
            elif 200 <= response.status_code < 300:
                logger.info(
                    f"‚úÖ Push notification accepted with status {response.status_code} from {webhook_url}"
                )
            else:
                logger.warning(
                    f"‚ö†Ô∏è Push notification received non-success response: {response.status_code} from {webhook_url}"
                )
                try:
                    response_text = response.text[
                        :200
                    ]  # Log first 200 chars of response
                    logger.warning(f"Response body: {response_text}")
                except:
                    pass

            # Don't raise exception for non-200 status codes per A2A spec
            # The webhook might have its own status handling, and notification
            # delivery is best-effort

    except httpx.TimeoutException:
        logger.error(f"‚ùå Push notification timeout (30s) to {webhook_url}")
        raise Exception(f"Push notification timeout to {webhook_url}")

    except httpx.RequestError as e:
        logger.error(f"‚ùå Push notification request error to {webhook_url}: {e}")
        raise Exception(f"Push notification request error: {e}")

    except Exception as e:
        logger.error(f"‚ùå Push notification unexpected error to {webhook_url}: {e}")
        raise Exception(f"Push notification error: {e}")


# Task management functions (A2A spec section 7.3-7.7)
async def handle_tasks_get(
    agent_id: uuid.UUID, params: Dict[str, Any], request_id: str, db: Session
) -> JSONResponse:
    """Handle tasks/get according to A2A spec section 7.3."""
    logger.info(f"üîç Processing tasks/get for agent {agent_id}")

    try:
        task_id = params.get("taskId")
        if not task_id:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {"missing": "taskId"},
                    },
                }
            )

        # In our implementation, tasks are ephemeral and complete immediately
        # For A2A compliance, we return a completed task with minimal info
        task_response = {
            "id": task_id,
            "status": {
                "state": "completed",
                "timestamp": datetime.now().isoformat() + "Z",
            },
            "kind": "task",
        }

        return JSONResponse(
            content={"jsonrpc": "2.0", "id": request_id, "result": task_response}
        )

    except Exception as e:
        logger.error(f"‚ùå tasks/get error: {e}")
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32603,
                    "message": "Internal error",
                    "data": {"error": str(e)},
                },
            }
        )


async def handle_tasks_cancel(
    agent_id: uuid.UUID, params: Dict[str, Any], request_id: str, db: Session
) -> JSONResponse:
    """Handle tasks/cancel according to A2A spec section 7.4."""
    logger.info(f"üõë Processing tasks/cancel for agent {agent_id}")

    try:
        task_id = params.get("taskId")
        if not task_id:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {"missing": "taskId"},
                    },
                }
            )

        # In our implementation, tasks complete immediately, so cancellation is not needed
        # Return success for A2A compliance
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "result": {
                    "success": True,
                    "message": f"Task {task_id} cancellation requested",
                },
            }
        )

    except Exception as e:
        logger.error(f"‚ùå tasks/cancel error: {e}")
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32603,
                    "message": "Internal error",
                    "data": {"error": str(e)},
                },
            }
        )


# Task push notification config management (A2A spec section 7.5-7.6)
task_push_configs = {}  # In-memory storage for demo - use database in production


async def handle_tasks_push_notification_config_set(
    agent_id: uuid.UUID, params: Dict[str, Any], request_id: str, db: Session
) -> JSONResponse:
    """Handle tasks/pushNotificationConfig/set according to A2A spec section 7.5."""
    logger.info(f"üîî Processing tasks/pushNotificationConfig/set for agent {agent_id}")

    try:
        task_id = params.get("taskId")
        push_config = params.get("pushNotificationConfig")

        if not task_id:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {"missing": "taskId"},
                    },
                }
            )

        if not push_config:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {"missing": "pushNotificationConfig"},
                    },
                }
            )

        # Validate URL is HTTPS
        webhook_url = push_config.get("url") or push_config.get("webhookUrl")
        if webhook_url and not webhook_url.startswith("https://"):
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {"error": "pushNotificationConfig.url MUST use HTTPS"},
                    },
                }
            )

        # Store the config (in production, save to database)
        task_push_configs[task_id] = push_config
        logger.info(f"‚úÖ Push notification config stored for task {task_id}")

        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "result": {"success": True, "taskId": task_id},
            }
        )

    except Exception as e:
        logger.error(f"‚ùå tasks/pushNotificationConfig/set error: {e}")
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32603,
                    "message": "Internal error",
                    "data": {"error": str(e)},
                },
            }
        )


async def handle_tasks_push_notification_config_get(
    agent_id: uuid.UUID, params: Dict[str, Any], request_id: str, db: Session
) -> JSONResponse:
    """Handle tasks/pushNotificationConfig/get according to A2A spec section 7.6."""
    logger.info(f"üîç Processing tasks/pushNotificationConfig/get for agent {agent_id}")

    try:
        task_id = params.get("taskId")
        if not task_id:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {"missing": "taskId"},
                    },
                }
            )

        # Retrieve the config (in production, get from database)
        push_config = task_push_configs.get(task_id)

        if push_config:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "result": {
                        "taskId": task_id,
                        "pushNotificationConfig": push_config,
                    },
                }
            )
        else:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32001,
                        "message": "Task not found or no push notification config set",
                        "data": {"taskId": task_id},
                    },
                }
            )

    except Exception as e:
        logger.error(f"‚ùå tasks/pushNotificationConfig/get error: {e}")
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32603,
                    "message": "Internal error",
                    "data": {"error": str(e)},
                },
            }
        )


async def handle_tasks_resubscribe(
    agent_id: uuid.UUID, params: Dict[str, Any], request_id: str, db: Session
) -> JSONResponse:
    """Handle tasks/resubscribe according to A2A spec section 7.7."""
    logger.info(f"üîÑ Processing tasks/resubscribe for agent {agent_id}")

    try:
        task_id = params.get("taskId")
        push_config = params.get("pushNotificationConfig")

        if not task_id:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32602,
                        "message": "Invalid params",
                        "data": {"missing": "taskId"},
                    },
                }
            )

        # Update push notification config if provided
        if push_config:
            task_push_configs[task_id] = push_config
            logger.info(f"‚úÖ Push notification config updated for task {task_id}")

        # In our implementation, tasks complete immediately
        # Return success for A2A compliance
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "result": {
                    "success": True,
                    "taskId": task_id,
                    "message": "Resubscription successful",
                },
            }
        )

    except Exception as e:
        logger.error(f"‚ùå tasks/resubscribe error: {e}")
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32603,
                    "message": "Internal error",
                    "data": {"error": str(e)},
                },
            }
        )


async def handle_agent_authenticated_extended_card(
    agent_id: uuid.UUID, params: Dict[str, Any], request_id: str, db: Session
) -> JSONResponse:
    """Handle agent/authenticatedExtendedCard according to A2A spec section 7.8."""
    logger.info(f"üõ°Ô∏è Processing agent/authenticatedExtendedCard for agent {agent_id}")

    try:
        # Get agent from database
        agent = get_agent(db, agent_id)
        if not agent:
            return JSONResponse(
                content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32001,
                        "message": "Agent not found",
                    },
                }
            )

        # Build authenticated extended agent card (can include additional info after auth)
        extended_card = {
            "name": agent.name,
            "description": agent.description or f"AI Agent {agent.name}",
            "url": f"{settings.API_URL}/api/v1/a2a/{agent_id}",
            "provider": {
                "organization": "Evo AI Platform",
                "url": settings.API_URL,
            },
            "version": "1.0.0",
            "documentationUrl": f"{settings.API_URL}/docs",
            "capabilities": {
                "streaming": True,
                "pushNotifications": True,
                "stateTransitionHistory": False,
                "multiTurnConversations": True,
                "fileProcessing": True,
            },
            "securitySchemes": {
                "apiKey": {
                    "type": "apiKey",
                    "in": "header",
                    "name": "x-api-key",
                }
            },
            "security": [{"apiKey": []}],
            "defaultInputModes": ["text/plain", "application/json"],
            "defaultOutputModes": ["text/plain", "application/json"],
            "skills": [
                {
                    "id": "general-assistance",
                    "name": "General AI Assistant",
                    "description": "Provides general AI assistance and task completion",
                    "tags": ["assistant", "general", "ai", "help"],
                    "examples": ["Help me with a task", "Answer my question"],
                    "inputModes": ["text"],
                    "outputModes": ["text"],
                }
            ],
            # Extended information available after authentication
            "extended": {
                "agent_id": str(agent_id),
                "creation_date": getattr(agent, "created_at", None),
                "available_endpoints": [
                    "message/send",
                    "message/stream",
                    "tasks/get",
                    "tasks/cancel",
                    "tasks/pushNotificationConfig/set",
                    "tasks/pushNotificationConfig/get",
                    "tasks/resubscribe",
                    "agent/authenticatedExtendedCard",
                ],
                "rate_limits": {"requests_per_minute": 100, "concurrent_tasks": 10},
            },
        }

        return JSONResponse(
            content={"jsonrpc": "2.0", "id": request_id, "result": extended_card}
        )

    except Exception as e:
        logger.error(f"‚ùå agent/authenticatedExtendedCard error: {e}")
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32603,
                    "message": "Internal error",
                    "data": {"error": str(e)},
                },
            }
        )


--- src/services/a2a_sdk_adapter.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: a2a_sdk_adapter.py                                                    ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

import logging
import asyncio
from typing import Dict, Any, Optional
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

try:
    from a2a.server.agent_execution import AgentExecutor, RequestContext
    from a2a.server.events import EventQueue
    from a2a.server.tasks import TaskStore, InMemoryTaskStore
    from a2a.server.request_handlers import DefaultRequestHandler
    from a2a.server.apps import A2AStarletteApplication
    from a2a.types import (
        AgentCard,
        AgentCapabilities,
        AgentSkill,
        AgentProvider,
        Task as SDKTask,
        TaskState as SDKTaskState,
        TaskStatus as SDKTaskStatus,
        Message as SDKMessage,
        TaskStatusUpdateEvent,
        TaskArtifactUpdateEvent,
    )
    from a2a.utils import new_agent_text_message, completed_task

    SDK_AVAILABLE = True
except ImportError:
    SDK_AVAILABLE = False
    logging.warning("a2a-sdk not available for adapter")

from src.config.settings import settings
from src.services.agent_service import get_agent
from src.services.mcp_server_service import get_mcp_server
from src.services.a2a_task_manager import A2ATaskManager, A2AService
from src.schemas.a2a_types import (
    SendTaskRequest,
    SendTaskStreamingRequest,
    CancelTaskRequest,
    TaskSendParams,
    TaskState as CustomTaskState,
    TaskStatus as CustomTaskStatus,
)
from src.schemas.a2a_enhanced_types import (
    A2ATypeConverter,
    convert_to_sdk_format,
    convert_from_sdk_format,
)

logger = logging.getLogger(__name__)


class EvoAIAgentExecutor:
    """
    Direct implementation of the Message API for the official SDK.

    Instead of trying to convert to Task API, it implements directly
    the methods expected by the SDK: message/send and message/stream
    """

    def __init__(self, db: Session, agent_id: UUID):
        self.db = db
        self.agent_id = agent_id

    async def execute(
        self, context: "RequestContext", event_queue: "EventQueue"
    ) -> None:
        """
        Direct implementation of message execution using agent_runner.

        Does not use task manager - goes directly to execution logic.
        """
        try:
            logger.info("=" * 80)
            logger.info(f"üöÄ EXECUTOR EXECUTE() CALLED! Agent: {self.agent_id}")
            logger.info(f"Context: {context}")
            logger.info(f"Message: {getattr(context, 'message', 'NO_MESSAGE')}")
            logger.info("=" * 80)

            # Check if there is a message
            if not hasattr(context, "message") or not context.message:
                logger.error("‚ùå No message in context")
                await self._emit_error_event(event_queue, "No message provided")
                return

            # Extract text from message
            message_text = self._extract_text_from_message(context.message)
            if not message_text:
                logger.error("‚ùå No text found in message")
                await self._emit_error_event(event_queue, "No text content found")
                return

            logger.info(f"üìù Extracted message: {message_text}")

            # Generate unique session_id
            session_id = context.context_id or str(uuid4())
            logger.info(f"üìù Using session_id: {session_id}")

            # Import services needed
            from src.services.service_providers import (
                session_service,
                artifacts_service,
                memory_service,
            )

            # Call agent_runner directly (without task manager)
            logger.info("üîÑ Calling agent_runner directly...")

            from src.services.adk.agent_runner import run_agent

            result = await run_agent(
                agent_id=str(self.agent_id),
                external_id=session_id,
                message=message_text,
                session_service=session_service,
                artifacts_service=artifacts_service,
                memory_service=memory_service,
                db=self.db,
                files=None,  # TODO: process files if needed
            )

            logger.info(f"‚úÖ Agent result: {result}")

            # Convert result to SDK event
            final_response = result.get("final_response", "No response")

            # Create response message compatible with SDK
            response_message = new_agent_text_message(final_response)
            event_queue.enqueue_event(response_message)

            logger.info("‚úÖ Response message enqueued successfully")

        except Exception as e:
            logger.error(f"‚ùå ERROR in execute(): {e}")
            import traceback

            logger.error(f"Traceback: {traceback.format_exc()}")
            await self._emit_error_event(event_queue, f"Execution error: {str(e)}")

    def _extract_text_from_message(self, message) -> str:
        """Extract text from SDK message."""
        try:
            logger.info(f"üîç DEBUG MESSAGE STRUCTURE:")
            logger.info(f"Message type: {type(message)}")
            logger.info(f"Message: {message}")
            logger.info(f"Message hasattr parts: {hasattr(message, 'parts')}")

            if hasattr(message, "parts"):
                logger.info(f"Parts: {message.parts}")
                logger.info(f"Parts type: {type(message.parts)}")
                logger.info(
                    f"Parts length: {len(message.parts) if message.parts else 0}"
                )

                if message.parts:
                    for i, part in enumerate(message.parts):
                        logger.info(f"Part {i}: type={type(part)}, content={part}")
                        logger.info(f"Part {i} hasattr text: {hasattr(part, 'text')}")
                        if hasattr(part, "text"):
                            logger.info(f"Part {i} text: {part.text}")
                            return part.text

            # Try other ways to access the text
            if hasattr(message, "text"):
                logger.info(f"Message has direct text: {message.text}")
                return message.text

            # If it's a string directly
            if isinstance(message, str):
                logger.info(f"Message is string: {message}")
                return message

            logger.warning("‚ùå No text found in any format")
            return ""
        except Exception as e:
            logger.error(f"Error extracting text: {e}")
            import traceback

            logger.error(f"Traceback: {traceback.format_exc()}")
            return ""

    async def _emit_error_event(self, event_queue: "EventQueue", error_message: str):
        """Emit error event."""
        try:
            error_msg = new_agent_text_message(f"Error: {error_message}")
            event_queue.enqueue_event(error_msg)
        except Exception as e:
            logger.error(f"Error emitting error event: {e}")

    async def cancel(
        self, context: "RequestContext", event_queue: "EventQueue"
    ) -> None:
        """Implement cancellation (basic for now)."""
        logger.info(f"Cancel called for agent {self.agent_id}")
        # For now, only log - implement real cancellation if needed


class EvoAISDKService:
    """
    Main service that creates and manages A2A servers using the official SDK.
    """

    def __init__(self, db: Session):
        self.db = db
        self.servers: Dict[str, Any] = {}

    def create_a2a_server(self, agent_id: UUID) -> Optional[Any]:
        """
        Create an A2A server using the official SDK but with internal logic.
        """
        if not SDK_AVAILABLE:
            logger.error("‚ùå a2a-sdk not available, cannot create SDK server")
            return None

        try:
            logger.info("=" * 80)
            logger.info(f"üèóÔ∏è CREATING A2A SDK SERVER FOR AGENT {agent_id}")
            logger.info("=" * 80)

            # Search for agent in database
            logger.info("üîç Searching for agent in database...")
            agent = get_agent(self.db, agent_id)
            if not agent:
                logger.error(f"‚ùå Agent {agent_id} not found")
                return None

            logger.info(f"‚úÖ Found agent: {agent.name}")

            # Create agent card using existing logic
            logger.info("üèóÔ∏è Creating agent card...")
            agent_card = self._create_agent_card(agent)
            logger.info(f"‚úÖ Agent card created: {agent_card.name}")

            # Create executor using adapter
            logger.info("üèóÔ∏è Creating agent executor adapter...")
            agent_executor = EvoAIAgentExecutor(self.db, agent_id)
            logger.info("‚úÖ Agent executor created")

            # Create task store
            logger.info("üèóÔ∏è Creating task store...")
            task_store = InMemoryTaskStore()
            logger.info("‚úÖ Task store created")

            # Create request handler
            logger.info("üèóÔ∏è Creating request handler...")
            request_handler = DefaultRequestHandler(
                agent_executor=agent_executor, task_store=task_store
            )
            logger.info("‚úÖ Request handler created")

            # Create Starlette application
            logger.info("üèóÔ∏è Creating Starlette application...")
            server = A2AStarletteApplication(
                agent_card=agent_card, http_handler=request_handler
            )
            logger.info("‚úÖ Starlette application created")

            # Store server
            server_key = str(agent_id)
            self.servers[server_key] = server

            logger.info("=" * 80)
            logger.info(f"üéâ SUCCESSFULLY CREATED A2A SDK SERVER FOR AGENT {agent_id}")
            logger.info("=" * 80)
            return server

        except Exception as e:
            logger.error("=" * 80)
            logger.error(f"‚ùå ERROR CREATING A2A SDK SERVER: {e}")
            import traceback

            logger.error(f"Full traceback: {traceback.format_exc()}")
            logger.error("=" * 80)
            return None

    def get_server(self, agent_id: UUID) -> Optional[Any]:
        """
        Returns existing server or creates a new one.
        """
        server_key = str(agent_id)

        if server_key in self.servers:
            return self.servers[server_key]

        return self.create_a2a_server(agent_id)

    def _create_agent_card(self, agent) -> AgentCard:
        """
        Create AgentCard using existing logic but in SDK format.
        """
        # Reuse existing A2AService logic
        a2a_service = A2AService(self.db, A2ATaskManager(self.db))
        custom_card = a2a_service.get_agent_card(agent.id)

        # Convert to SDK format
        sdk_card = convert_to_sdk_format(custom_card)

        if sdk_card:
            return sdk_card

        # Fallback: create basic card
        return AgentCard(
            name=agent.name,
            description=agent.description or "",
            url=f"{settings.API_URL}/api/v1/a2a-sdk/{agent.id}",
            version=settings.API_VERSION,
            capabilities=AgentCapabilities(
                streaming=True, pushNotifications=True, stateTransitionHistory=True
            ),
            provider=AgentProvider(
                organization=settings.ORGANIZATION_NAME, url=settings.ORGANIZATION_URL
            ),
            defaultInputModes=["text", "file"],
            defaultOutputModes=["text"],
            skills=[],
        )

    def remove_server(self, agent_id: UUID) -> bool:
        """
        Remove server from cache.
        """
        server_key = str(agent_id)
        if server_key in self.servers:
            del self.servers[server_key]
            return True
        return False

    def list_servers(self) -> Dict[str, Dict[str, Any]]:
        """
        List all active servers.
        """
        result = {}
        for agent_id, server in self.servers.items():
            result[agent_id] = {
                "agent_id": agent_id,
                "server_type": "a2a-sdk",
                "active": True,
            }
        return result


# Utility function to create SDK server easily
def create_a2a_sdk_server(db: Session, agent_id: UUID) -> Optional[Any]:
    """
    Utility function to create A2A server using SDK.
    """
    service = EvoAISDKService(db)
    return service.create_a2a_server(agent_id)


# Function to check compatibility
def check_sdk_compatibility() -> Dict[str, Any]:
    """
    Check compatibility and available features of the SDK.
    """
    return {
        "sdk_available": SDK_AVAILABLE,
        "version": (
            getattr(settings, "A2A_SDK_VERSION", "unknown") if SDK_AVAILABLE else None
        ),
        "features": {
            "streaming": SDK_AVAILABLE,
            "task_management": SDK_AVAILABLE,
            "agent_execution": SDK_AVAILABLE,
            "type_validation": SDK_AVAILABLE,
        },
    }


--- src/api/admin_routes.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: admin_routes.py                                                       ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from typing import List
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session
import uuid

from src.config.database import get_db
from src.core.jwt_middleware import get_jwt_token, verify_admin
from src.schemas.audit import AuditLogResponse, AuditLogFilter
from src.services.audit_service import get_audit_logs, create_audit_log
from src.services.user_service import (
    get_admin_users,
    create_admin_user,
    deactivate_user,
)
from src.schemas.user import UserResponse, AdminUserCreate

router = APIRouter(
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(verify_admin)],
    responses={403: {"description": "Permission denied"}},
)


# Audit routes
@router.get("/audit-logs", response_model=List[AuditLogResponse])
async def read_audit_logs(
    filters: AuditLogFilter = Depends(),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """
    Get audit logs with optional filters

    Args:
        filters: Filters for log search
        db: Database session
        payload: JWT token payload

    Returns:
        List[AuditLogResponse]: List of audit logs
    """
    return get_audit_logs(
        db,
        skip=filters.skip,
        limit=filters.limit,
        user_id=filters.user_id,
        action=filters.action,
        resource_type=filters.resource_type,
        resource_id=filters.resource_id,
        start_date=filters.start_date,
        end_date=filters.end_date,
    )


# Admin routes
@router.get("/users", response_model=List[UserResponse])
async def read_admin_users(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """
    List admin users

    Args:
        skip: Number of records to skip
        limit: Maximum number of records to return
        db: Database session
        payload: JWT token payload

    Returns:
        List[UserResponse]: List of admin users
    """
    return get_admin_users(db, skip, limit)


@router.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_new_admin_user(
    user_data: AdminUserCreate,
    request: Request,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """
    Create a new admin user

    Args:
        user_data: User data to be created
        request: FastAPI Request object
        db: Database session
        payload: JWT token payload

    Returns:
        UserResponse: Created user data

    Raises:
        HTTPException: If there is an error in creation
    """
    # Get current user ID
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Unable to identify the logged in user",
        )

    # Create admin user
    user, message = create_admin_user(db, user_data)
    if not user:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    # Register action in audit log
    create_audit_log(
        db,
        user_id=uuid.UUID(user_id),
        action="create",
        resource_type="admin_user",
        resource_id=str(user.id),
        details={"email": user.email},
        request=request,
    )

    return user


@router.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def deactivate_admin_user(
    user_id: uuid.UUID,
    request: Request,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """
    Deactivate an admin user (does not delete, only deactivates)

    Args:
        user_id: ID of the user to be deactivated
        request: FastAPI Request object
        db: Database session
        payload: JWT token payload

    Raises:
        HTTPException: If there is an error in deactivation
    """
    # Get current user ID
    current_user_id = payload.get("user_id")
    if not current_user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Unable to identify the logged in user",
        )

    # Do not allow deactivating yourself
    if str(user_id) == current_user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Unable to deactivate your own user",
        )

    # Deactivate user
    success, message = deactivate_user(db, user_id)
    if not success:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    # Register action in audit log
    create_audit_log(
        db,
        user_id=uuid.UUID(current_user_id),
        action="deactivate",
        resource_type="admin_user",
        resource_id=str(user_id),
        details=None,
        request=request,
    )


--- src/api/agent_routes.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: agent_routes.py                                                       ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
    Header,
    Query,
    File,
    UploadFile,
    Form,
)
from sqlalchemy.orm import Session
from src.config.database import get_db
from typing import List, Dict, Any, Optional, Union
import uuid
from src.core.jwt_middleware import (
    get_jwt_token,
    verify_user_client,
)
from src.schemas.schemas import (
    Agent,
    AgentCreate,
    AgentFolder,
    AgentFolderCreate,
    AgentFolderUpdate,
    ApiKey,
    ApiKeyCreate,
    ApiKeyUpdate,
)
from src.services import agent_service, mcp_server_service, apikey_service
import logging
import json

logger = logging.getLogger(__name__)


async def format_agent_tools(
    mcp_servers: List[Dict[str, Any]], db: Session
) -> List[Dict[str, Any]]:
    """Format MCP server tools for agent card skills"""
    formatted_tools = []

    for server in mcp_servers:
        try:
            # Get the MCP server by ID
            server_id = uuid.UUID(server["id"])
            mcp_server = mcp_server_service.get_mcp_server(db, server_id)

            if not mcp_server:
                logger.warning(f"MCP server not found: {server_id}")
                continue

            # Format each tool
            for tool in mcp_server.tools:
                formatted_tool = {
                    "id": tool["id"],
                    "name": tool["name"],
                    "description": tool["description"],
                    "tags": tool["tags"],
                    "examples": tool["examples"],
                    "inputModes": tool["inputModes"],
                    "outputModes": tool["outputModes"],
                }
                formatted_tools.append(formatted_tool)

        except Exception as e:
            logger.error(
                f"Error formatting tools for MCP server {server.get('id')}: {str(e)}"
            )
            continue

    return formatted_tools


router = APIRouter(
    prefix="/agents",
    tags=["agents"],
    responses={404: {"description": "Not found"}},
)


@router.post("/apikeys", response_model=ApiKey, status_code=status.HTTP_201_CREATED)
async def create_api_key(
    key: ApiKeyCreate,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Create a new API key"""
    await verify_user_client(payload, db, key.client_id)

    db_key = apikey_service.create_api_key(
        db, key.client_id, key.name, key.provider, key.key_value
    )

    return db_key


@router.get("/apikeys", response_model=List[ApiKey])
async def read_api_keys(
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    skip: int = 0,
    limit: int = 100,
    sort_by: str = Query(
        "name", description="Field to sort: name, provider, created_at"
    ),
    sort_direction: str = Query("asc", description="Sort direction: asc, desc"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """List API keys for a client"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    keys = apikey_service.get_api_keys_by_client(
        db, x_client_id, skip, limit, sort_by, sort_direction
    )
    return keys


@router.get("/apikeys/{key_id}", response_model=ApiKey)
async def read_api_key(
    key_id: uuid.UUID,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Get details of a specific API key"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    key = apikey_service.get_api_key(db, key_id)
    if not key:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="API Key not found"
        )

    # Verify if the key belongs to the specified client
    if key.client_id != x_client_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="API Key does not belong to the specified client",
        )

    return key


@router.put("/apikeys/{key_id}", response_model=ApiKey)
async def update_api_key(
    key_id: uuid.UUID,
    key_data: ApiKeyUpdate,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Update an API key"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    # Verify if the key exists
    key = apikey_service.get_api_key(db, key_id)
    if not key:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="API Key not found"
        )

    # Verify if the key belongs to the specified client
    if key.client_id != x_client_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="API Key does not belong to the specified client",
        )

    # Update the key
    updated_key = apikey_service.update_api_key(
        db,
        key_id,
        key_data.name,
        key_data.provider,
        key_data.key_value,
        key_data.is_active,
    )
    return updated_key


@router.delete("/apikeys/{key_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_api_key(
    key_id: uuid.UUID,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Deactivate an API key (soft delete)"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    # Verify if the key exists
    key = apikey_service.get_api_key(db, key_id)
    if not key:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="API Key not found"
        )

    # Verify if the key belongs to the specified client
    if key.client_id != x_client_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="API Key does not belong to the specified client",
        )

    # Deactivate the key
    if not apikey_service.delete_api_key(db, key_id):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="API Key not found"
        )


# Agent folder routes
@router.post(
    "/folders", response_model=AgentFolder, status_code=status.HTTP_201_CREATED
)
async def create_folder(
    folder: AgentFolderCreate,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Create a new folder to organize agents"""
    # Verify if the user has access to the folder's client
    await verify_user_client(payload, db, folder.client_id)

    return agent_service.create_agent_folder(
        db, folder.client_id, folder.name, folder.description
    )


@router.get("/folders", response_model=List[AgentFolder])
async def read_folders(
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """List agent folders for a client"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    return agent_service.get_agent_folders_by_client(db, x_client_id, skip, limit)


@router.get("/folders/{folder_id}", response_model=AgentFolder)
async def read_folder(
    folder_id: uuid.UUID,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Get details of a specific folder"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    folder = agent_service.get_agent_folder(db, folder_id)
    if not folder:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Folder not found"
        )

    # Verify if the folder belongs to the specified client
    if folder.client_id != x_client_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Folder does not belong to the specified client",
        )

    return folder


@router.put("/folders/{folder_id}", response_model=AgentFolder)
async def update_folder(
    folder_id: uuid.UUID,
    folder_data: AgentFolderUpdate,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Update an agent folder"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    # Verify if the folder exists
    folder = agent_service.get_agent_folder(db, folder_id)
    if not folder:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Folder not found"
        )

    # Verify if the folder belongs to the specified client
    if folder.client_id != x_client_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Folder does not belong to the specified client",
        )

    # Update the folder
    updated_folder = agent_service.update_agent_folder(
        db, folder_id, folder_data.name, folder_data.description
    )
    return updated_folder


@router.delete("/folders/{folder_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_folder(
    folder_id: uuid.UUID,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Remove an agent folder"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    # Verify if the folder exists
    folder = agent_service.get_agent_folder(db, folder_id)
    if not folder:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Folder not found"
        )

    # Verify if the folder belongs to the specified client
    if folder.client_id != x_client_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Folder does not belong to the specified client",
        )

    # Delete the folder
    if not agent_service.delete_agent_folder(db, folder_id):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Folder not found"
        )


@router.get("/folders/{folder_id}/agents", response_model=List[Agent])
async def read_folder_agents(
    folder_id: uuid.UUID,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """List agents in a specific folder"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    # Verify if the folder exists
    folder = agent_service.get_agent_folder(db, folder_id)
    if not folder:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Folder not found"
        )

    # Verify if the folder belongs to the specified client
    if folder.client_id != x_client_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Folder does not belong to the specified client",
        )

    # List the agents in the folder
    agents = agent_service.get_agents_by_folder(db, folder_id, skip, limit)

    # Add agent card URL when needed
    for agent in agents:
        if not agent.agent_card_url:
            agent.agent_card_url = agent.agent_card_url_property

    return agents


@router.put("/{agent_id}/folder", response_model=Agent)
async def assign_agent_to_folder(
    agent_id: uuid.UUID,
    folder_id: Optional[uuid.UUID] = None,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Assign an agent to a folder or remove from the current folder (if folder_id=None)"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    # Verify if the agent exists
    agent = agent_service.get_agent(db, agent_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )

    # Verify if the agent belongs to the specified client
    if agent.client_id != x_client_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Agent does not belong to the specified client",
        )

    # If folder_id is provided, verify if the folder exists and belongs to the same client
    if folder_id:
        folder = agent_service.get_agent_folder(db, folder_id)
        if not folder:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="Folder not found"
            )

        if folder.client_id != x_client_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Folder does not belong to the specified client",
            )

    # Assign the agent to the folder or remove from the current folder
    updated_agent = agent_service.assign_agent_to_folder(db, agent_id, folder_id)

    if not updated_agent.agent_card_url:
        updated_agent.agent_card_url = updated_agent.agent_card_url_property

    return updated_agent


# Agent routes (after specific routes)
@router.get("/", response_model=List[Agent])
async def read_agents(
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    skip: int = 0,
    limit: int = 100,
    folder_id: Optional[uuid.UUID] = Query(None, description="Filter by folder"),
    sort_by: str = Query("name", description="Field to sort: name, created_at"),
    sort_direction: str = Query("asc", description="Sort direction: asc, desc"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    # Get agents with optional folder filter and sorting
    agents = agent_service.get_agents_by_client(
        db, x_client_id, skip, limit, True, folder_id, sort_by, sort_direction
    )

    for agent in agents:
        if not agent.agent_card_url:
            agent.agent_card_url = agent.agent_card_url_property

    return agents


@router.post("/", response_model=Agent, status_code=status.HTTP_201_CREATED)
async def create_agent(
    agent: AgentCreate,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    # Verify if the user has access to the agent's client
    await verify_user_client(payload, db, agent.client_id)

    db_agent = await agent_service.create_agent(db, agent)

    if not db_agent.agent_card_url:
        db_agent.agent_card_url = db_agent.agent_card_url_property

    return db_agent


@router.get("/{agent_id}", response_model=Agent)
async def read_agent(
    agent_id: uuid.UUID,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    db_agent = agent_service.get_agent(db, agent_id)
    if db_agent is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )

    # Verify if the user has access to the agent's client
    await verify_user_client(payload, db, x_client_id)

    if not db_agent.agent_card_url:
        db_agent.agent_card_url = db_agent.agent_card_url_property

    return db_agent


@router.put("/{agent_id}", response_model=Agent)
async def update_agent(
    agent_id: uuid.UUID,
    agent_data: Dict[str, Any],
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    # Get the current agent
    db_agent = agent_service.get_agent(db, agent_id)
    if db_agent is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )

    # Verify if the user has access to the agent's client
    await verify_user_client(payload, db, db_agent.client_id)

    # If trying to change the client_id, verify permission for the new client as well
    if "client_id" in agent_data and agent_data["client_id"] != str(db_agent.client_id):
        new_client_id = uuid.UUID(agent_data["client_id"])
        await verify_user_client(payload, db, new_client_id)

    updated_agent = await agent_service.update_agent(db, agent_id, agent_data)

    if not updated_agent.agent_card_url:
        updated_agent.agent_card_url = updated_agent.agent_card_url_property

    return updated_agent


@router.delete("/{agent_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_agent(
    agent_id: uuid.UUID,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    # Get the agent
    db_agent = agent_service.get_agent(db, agent_id)
    if db_agent is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )

    # Verify if the user has access to the agent's client
    await verify_user_client(payload, db, db_agent.client_id)

    if not agent_service.delete_agent(db, agent_id):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )


@router.post("/{agent_id}/share", response_model=Dict[str, str])
async def share_agent(
    agent_id: uuid.UUID,
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Returns the agent's API key for sharing"""
    await verify_user_client(payload, db, x_client_id)

    # Verify if the agent exists
    agent = agent_service.get_agent(db, agent_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )

    # Verify if the agent belongs to the specified client
    if agent.client_id != x_client_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Agent does not belong to the specified client",
        )

    # Verify if API key exists
    if not agent.config or not agent.config.get("api_key"):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="This agent does not have an API key",
        )

    return {"api_key": agent.config["api_key"]}


@router.get("/{agent_id}/shared", response_model=Agent)
async def get_shared_agent(
    agent_id: uuid.UUID,
    api_key: str = Header(..., alias="x-api-key"),
    db: Session = Depends(get_db),
):
    """Get agent details using only API key authentication"""
    # Verify if the agent exists
    agent = agent_service.get_agent(db, agent_id)
    if not agent or not agent.config:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )

    # Verify if the API key matches
    if not agent.config.get("api_key") or agent.config.get("api_key") != api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid API key"
        )

    # Add agent card URL if not present
    if not agent.agent_card_url:
        agent.agent_card_url = agent.agent_card_url_property

    return agent


@router.post("/import", response_model=List[Agent], status_code=status.HTTP_201_CREATED)
async def import_agents(
    file: UploadFile = File(...),
    folder_id: Optional[str] = Form(None),
    x_client_id: uuid.UUID = Header(..., alias="x-client-id"),
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """Import one or more agents from a JSON file"""
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, x_client_id)

    # Convert folder_id to UUID if provided
    folder_uuid = None
    if folder_id:
        try:
            folder_uuid = uuid.UUID(folder_id)
            # Verify the folder exists and belongs to the client
            folder = agent_service.get_agent_folder(db, folder_uuid)
            if not folder:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND, detail="Folder not found"
                )
            if folder.client_id != x_client_id:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Folder does not belong to the specified client",
                )
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid folder ID format",
            )

    try:
        # Check file type
        if not file.filename.endswith(".json"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Only JSON files are supported",
            )

        # Read file content
        file_content = await file.read()

        try:
            # Parse JSON content
            agents_data = json.loads(file_content)
        except json.JSONDecodeError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid JSON format"
            )

        # Call the service function to import agents
        imported_agents = await agent_service.import_agents_from_json(
            db, agents_data, x_client_id, folder_uuid
        )

        return imported_agents

    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Error in agent import: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error importing agents: {str(e)}",
        )


--- frontend/services/api.ts ---
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: /services/api.ts                                                      ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
import axios from "axios";
import { getApiUrl } from "@/lib/env";

const apiUrl = getApiUrl();

const api = axios.create({
  baseURL: apiUrl,
  headers: {
    "Content-Type": "application/json",
  },
});

// Flag to prevent multiple logout attempts
let isLoggingOut = false;

// Function to force logout
const forceLogout = () => {
  if (isLoggingOut) return;
  isLoggingOut = true;

  // Clear localStorage
  localStorage.removeItem("access_token");
  localStorage.removeItem("user");
  localStorage.removeItem("impersonatedClient");
  localStorage.removeItem("isImpersonating");

  // Clear cookies
  document.cookie = "access_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT";
  document.cookie = "user=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT";
  document.cookie = "impersonatedClient=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT";
  document.cookie = "isImpersonating=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT";
  
  // Redirect to login page
  window.location.href = "/login?session_expired=true";
};

// Interceptor to add the token from the cookie to the Authorization header
api.interceptors.request.use((config) => {
  if (typeof window !== "undefined") {
    // Verificar primeiro se estamos em uma rota de agente compartilhado
    const isSharedAgentRequest = config.url && (
      config.url.includes('/agents/shared') || 
      config.url.includes('/chat/ws/')
    );

    const isSharedChatPage = typeof window !== "undefined" && 
      window.location.pathname.startsWith('/shared-chat');

    // Usar API key apenas para requisi√ß√µes espec√≠ficas de agentes compartilhados ou na p√°gina de chat compartilhado
    if ((isSharedAgentRequest || isSharedChatPage) && localStorage.getItem("shared_agent_api_key")) {
      const apiKey = localStorage.getItem("shared_agent_api_key");
      config.headers = config.headers || {};
      config.headers["x-api-key"] = apiKey;
    } else {
      // Caso contr√°rio, usar a autentica√ß√£o normal com JWT
      const match = document.cookie.match(/(?:^|; )access_token=([^;]*)/);
      const token = match ? decodeURIComponent(match[1]) : null;
      if (token) {
        config.headers = config.headers || {};
        config.headers["Authorization"] = `Bearer ${token}`;
      }
    }
  }
  return config;
});

// Interceptor to handle 401 Unauthorized responses
api.interceptors.response.use(
  (response) => response,
  (error) => {
    // Check if we have a 401 Unauthorized error and we're in a browser context
    if (error.response && error.response.status === 401 && typeof window !== "undefined") {
      // Skip logout for login endpoint and other auth endpoints
      const isAuthEndpoint = error.config.url && (
        error.config.url.includes('/auth/login') || 
        error.config.url.includes('/auth/register') ||
        error.config.url.includes('/auth/forgot-password') ||
        error.config.url.includes('/auth/reset-password')
      );

      // Skip logout for shared chat page
      const isSharedChatPage = typeof window !== "undefined" && 
        window.location.pathname.startsWith('/shared-chat');

      if (!isAuthEndpoint && !isSharedChatPage) {
        forceLogout();
      }
    }
    
    return Promise.reject(error);
  }
);

export default api;


--- src/services/apikey_service.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: apikey_service.py                                                     ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from src.models.models import ApiKey
from src.utils.crypto import encrypt_api_key, decrypt_api_key
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from fastapi import HTTPException, status
import uuid
import logging
from typing import List, Optional

logger = logging.getLogger(__name__)


def create_api_key(
    db: Session, client_id: uuid.UUID, name: str, provider: str, key_value: str
) -> ApiKey:
    """Create a new encrypted API key"""
    try:
        # Encrypt the key before saving
        encrypted = encrypt_api_key(key_value)

        # Create the ApiKey object
        api_key = ApiKey(
            client_id=client_id,
            name=name,
            provider=provider,
            encrypted_key=encrypted,
            is_active=True,
        )

        # Save in the database
        db.add(api_key)
        db.commit()
        db.refresh(api_key)
        logger.info(f"API key '{name}' created for client {client_id}")
        return api_key
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error creating API key: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating API key: {str(e)}",
        )


def get_api_key(db: Session, key_id: uuid.UUID) -> Optional[ApiKey]:
    """Get an API key by ID"""
    try:
        return db.query(ApiKey).filter(ApiKey.id == key_id).first()
    except SQLAlchemyError as e:
        logger.error(f"Error getting API key {key_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error getting API key",
        )


def get_api_keys_by_client(
    db: Session,
    client_id: uuid.UUID,
    skip: int = 0,
    limit: int = 100,
    sort_by: str = "name",
    sort_direction: str = "asc",
) -> List[ApiKey]:
    """List the API keys of a client"""
    try:
        query = (
            db.query(ApiKey)
            .filter(ApiKey.client_id == client_id)
            .filter(ApiKey.is_active)
        )

        # Apply sorting
        if sort_by == "name":
            if sort_direction.lower() == "desc":
                query = query.order_by(ApiKey.name.desc())
            else:
                query = query.order_by(ApiKey.name)
        elif sort_by == "provider":
            if sort_direction.lower() == "desc":
                query = query.order_by(ApiKey.provider.desc())
            else:
                query = query.order_by(ApiKey.provider)
        elif sort_by == "created_at":
            if sort_direction.lower() == "desc":
                query = query.order_by(ApiKey.created_at.desc())
            else:
                query = query.order_by(ApiKey.created_at)

        return query.offset(skip).limit(limit).all()
    except SQLAlchemyError as e:
        logger.error(f"Error listing API keys for client {client_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error listing API keys",
        )


def get_decrypted_api_key(db: Session, key_id: uuid.UUID) -> Optional[str]:
    """Get the decrypted value of an API key"""
    try:
        key = get_api_key(db, key_id)
        if not key or not key.is_active:
            logger.warning(f"API key {key_id} not found or inactive")
            return None
        return decrypt_api_key(key.encrypted_key)
    except Exception as e:
        logger.error(f"Error decrypting API key {key_id}: {str(e)}")
        return None


def update_api_key(
    db: Session,
    key_id: uuid.UUID,
    name: Optional[str] = None,
    provider: Optional[str] = None,
    key_value: Optional[str] = None,
    is_active: Optional[bool] = None,
) -> Optional[ApiKey]:
    """Update an API key"""
    try:
        key = get_api_key(db, key_id)
        if not key:
            return None

        if name is not None:
            key.name = name
        if provider is not None:
            key.provider = provider
        if key_value is not None:
            key.encrypted_key = encrypt_api_key(key_value)
        if is_active is not None:
            key.is_active = is_active

        db.commit()
        db.refresh(key)
        logger.info(f"API key {key_id} updated")
        return key
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error updating API key {key_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error updating API key",
        )


def delete_api_key(db: Session, key_id: uuid.UUID) -> bool:
    """Remove an API key (soft delete)"""
    try:
        key = get_api_key(db, key_id)
        if not key:
            return False

        # Soft delete - only marks as inactive
        key.is_active = False
        db.commit()
        logger.info(f"API key {key_id} deactivated")
        return True
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error deleting API key {key_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error deleting API key",
        )


--- src/api/auth_routes.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: auth_routes.py                                                        ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from src.config.database import get_db
from src.models.models import User
from src.schemas.user import (
    UserCreate,
    UserResponse,
    UserLogin,
    TokenResponse,
    ForgotPassword,
    PasswordReset,
    MessageResponse,
    ChangePassword,
)
from src.services.user_service import (
    authenticate_user,
    create_user,
    verify_email,
    resend_verification,
    forgot_password,
    reset_password,
    change_password,
)
from src.services.auth_service import (
    create_access_token,
    get_current_admin_user,
    get_current_user,
)
import logging

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/auth",
    tags=["authentication"],
    responses={404: {"description": "Not found"}},
)


@router.post(
    "/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED
)
async def register_user(user_data: UserCreate, db: Session = Depends(get_db)):
    """
    Register a new user (client) in the system

    Args:
        user_data: User data to be registered
        db: Database session

    Returns:
        UserResponse: Created user data

    Raises:
        HTTPException: If there is an error in registration
    """
    user, message = create_user(db, user_data, is_admin=False, auto_verify=False)
    if not user:
        logger.error(f"Error registering user: {message}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    logger.info(f"User registered successfully: {user.email}")
    return user


@router.post(
    "/register-admin", response_model=UserResponse, status_code=status.HTTP_201_CREATED
)
async def register_admin(
    user_data: UserCreate,
    db: Session = Depends(get_db),
    current_admin: User = Depends(get_current_admin_user),
):
    """
    Register a new admin in the system.
    Only existing admins can create new admins.

    Args:
        user_data: Admin data to be registered
        db: Database session
        current_admin: Current admin (authenticated)

    Returns:
        UserResponse: Created admin data

    Raises:
        HTTPException: If there is an error in registration
    """
    user, message = create_user(db, user_data, is_admin=True)
    if not user:
        logger.error(f"Error registering admin: {message}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    logger.info(
        f"Admin registered successfully: {user.email} (created by {current_admin.email})"
    )
    return user


@router.get("/verify-email/{token}", response_model=MessageResponse)
async def verify_user_email(token: str, db: Session = Depends(get_db)):
    """
    Verify user email using the provided token

    Args:
        token: Verification token
        db: Database session

    Returns:
        MessageResponse: Success message

    Raises:
        HTTPException: If the token is invalid or expired
    """
    success, message = verify_email(db, token)
    if not success:
        logger.warning(f"Failed to verify email: {message}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    logger.info(f"Email verified successfully using token: {token}")
    return {"message": message}


@router.post("/resend-verification", response_model=MessageResponse)
async def resend_verification_email(
    email_data: ForgotPassword, db: Session = Depends(get_db)
):
    """
    Resend verification email to the user

    Args:
        email_data: User email
        db: Database session

    Returns:
        MessageResponse: Success message

    Raises:
        HTTPException: If there is an error in resending
    """
    success, message = resend_verification(db, email_data.email)
    if not success:
        logger.warning(f"Failed to resend verification: {message}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    logger.info(f"Verification email resent successfully to: {email_data.email}")
    return {"message": message}


@router.post("/login", response_model=TokenResponse)
async def login_for_access_token(form_data: UserLogin, db: Session = Depends(get_db)):
    """
    Perform login and return a JWT access token

    Args:
        form_data: Login data (email and password)
        db: Database session

    Returns:
        TokenResponse: Access token and type

    Raises:
        HTTPException: If credentials are invalid
    """
    user, reason = authenticate_user(db, form_data.email, form_data.password)
    if not user:
        if reason == "user_not_found" or reason == "invalid_password":
            logger.warning(f"Login attempt with invalid credentials: {form_data.email}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid email or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        elif reason == "email_not_verified":
            logger.warning(f"Login attempt with unverified email: {form_data.email}")
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Email not verified",
            )
        elif reason == "inactive_user":
            logger.warning(f"Login attempt with inactive user: {form_data.email}")
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User account is inactive",
            )
        else:
            logger.warning(
                f"Login attempt failed for {form_data.email} (reason: {reason})"
            )
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid email or password",
                headers={"WWW-Authenticate": "Bearer"},
            )

    access_token = create_access_token(user)
    logger.info(f"Login successful for user: {user.email}")
    return {"access_token": access_token, "token_type": "bearer"}


@router.post("/forgot-password", response_model=MessageResponse)
async def forgot_user_password(
    email_data: ForgotPassword, db: Session = Depends(get_db)
):
    """
    Initiate the password recovery process

    Args:
        email_data: User email
        db: Database session

    Returns:
        MessageResponse: Success message

    Raises:
        HTTPException: If there is an error in the process
    """
    success, message = forgot_password(db, email_data.email)
    # Always return the same message for security
    return {
        "message": "If the email is registered, you will receive instructions to reset your password."
    }


@router.post("/reset-password", response_model=MessageResponse)
async def reset_user_password(reset_data: PasswordReset, db: Session = Depends(get_db)):
    """
    Reset user password using the provided token

    Args:
        reset_data: Token and new password
        db: Database session

    Returns:
        MessageResponse: Success message

    Raises:
        HTTPException: If the token is invalid or expired
    """
    success, message = reset_password(db, reset_data.token, reset_data.new_password)
    if not success:
        logger.warning(f"Failed to reset password: {message}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    logger.info("Password reset successfully")
    return {"message": message}


@router.post("/me", response_model=UserResponse)
async def get_current_user(
    db: Session = Depends(get_db), current_user: User = Depends(get_current_user)
):
    """
    Get the authenticated user's data

    Args:
        db: Database session
        current_user: Authenticated user

    Returns:
        UserResponse: Authenticated user data

    Raises:
        HTTPException: If the user is not authenticated
    """
    return current_user


@router.post("/change-password", response_model=MessageResponse)
async def change_user_password(
    password_data: ChangePassword,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Change the password of the authenticated user

    Args:
        password_data: Current and new password
        db: Database session
        current_user: Authenticated user

    Returns:
        MessageResponse: Success message

    Raises:
        HTTPException: If the current password is invalid
    """
    success, message = change_password(
        db, current_user.id, password_data.current_password, password_data.new_password
    )

    if not success:
        logger.warning(f"Failed to change password for user: {current_user.email}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    logger.info(f"Password changed successfully for user: {current_user.email}")
    return {"message": message}


--- src/api/chat_routes.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: chat_routes.py                                                        ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

import uuid
import base64
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
    WebSocket,
    WebSocketDisconnect,
    Header,
)
from sqlalchemy.orm import Session
from src.config.settings import settings
from src.config.database import get_db
from src.core.jwt_middleware import (
    get_jwt_token,
    verify_user_client,
    get_jwt_token_ws,
)
from src.services import (
    agent_service,
)
from src.schemas.chat import ChatRequest, ChatResponse, ErrorResponse, FileData
from src.services.adk.agent_runner import run_agent as run_agent_adk, run_agent_stream
from src.services.crewai.agent_runner import run_agent as run_agent_crewai
from src.core.exceptions import AgentNotFoundError
from src.services.service_providers import (
    session_service,
    artifacts_service,
    memory_service,
)

from datetime import datetime
import logging
import json
from typing import Optional, Dict, List, Any

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/chat",
    tags=["chat"],
    responses={404: {"description": "Not found"}},
)


async def get_agent_by_api_key(
    agent_id: str,
    api_key: Optional[str] = Header(None, alias="x-api-key"),
    authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db),
):
    """Flexible authentication for chat routes, allowing JWT or API key"""
    if authorization:
        # Try to authenticate with JWT token first
        try:
            # Extract token from Authorization header if needed
            token = (
                authorization.replace("Bearer ", "")
                if authorization.startswith("Bearer ")
                else authorization
            )
            payload = await get_jwt_token(token)
            agent = agent_service.get_agent(db, agent_id)
            if not agent:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Agent not found",
                )

            # Verify if the user has access to the agent's client
            await verify_user_client(payload, db, agent.client_id)
            return agent
        except Exception as e:
            logger.warning(f"JWT authentication failed: {str(e)}")
            # If JWT fails, continue to try with API key

    # Try to authenticate with API key
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required (JWT or API key)",
        )

    agent = agent_service.get_agent(db, agent_id)
    if not agent or not agent.config:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )

    # Verify if the API key matches
    if not agent.config.get("api_key") or agent.config.get("api_key") != api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid API key"
        )

    return agent


@router.websocket("/ws/{agent_id}/{external_id}")
async def websocket_chat(
    websocket: WebSocket,
    agent_id: str,
    external_id: str,
    db: Session = Depends(get_db),
):
    try:
        # Accept the connection
        await websocket.accept()
        logger.info("WebSocket connection accepted, waiting for authentication")

        # Wait for authentication message
        try:
            auth_data = await websocket.receive_json()
            logger.info(f"Authentication data received: {auth_data}")

            if not (
                auth_data.get("type") == "authorization"
                and (auth_data.get("token") or auth_data.get("api_key"))
            ):
                logger.warning("Invalid authentication message")
                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
                return

            # Verify if the agent exists
            agent = agent_service.get_agent(db, agent_id)
            if not agent:
                logger.warning(f"Agent {agent_id} not found")
                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
                return

            # Verify authentication
            is_authenticated = False

            # Try with JWT token
            if auth_data.get("token"):
                try:
                    payload = await get_jwt_token_ws(auth_data["token"])
                    if payload:
                        # Verify if the user has access to the agent
                        await verify_user_client(payload, db, agent.client_id)
                        is_authenticated = True
                except Exception as e:
                    logger.warning(f"JWT authentication failed: {str(e)}")

            # If JWT fails, try with API key
            if not is_authenticated and auth_data.get("api_key"):
                if agent.config and agent.config.get("api_key") == auth_data.get(
                    "api_key"
                ):
                    is_authenticated = True
                else:
                    logger.warning("Invalid API key")

            if not is_authenticated:
                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
                return

            logger.info(
                f"WebSocket connection established for agent {agent_id} and external_id {external_id}"
            )

            while True:
                try:
                    data = await websocket.receive_json()
                    logger.info(f"Received message: {data}")
                    message = data.get("message")

                    if not message:
                        continue

                    files = None
                    if data.get("files") and isinstance(data.get("files"), list):
                        try:
                            files = []
                            for file_data in data.get("files"):
                                if (
                                    isinstance(file_data, dict)
                                    and file_data.get("filename")
                                    and file_data.get("content_type")
                                    and file_data.get("data")
                                ):
                                    files.append(
                                        FileData(
                                            filename=file_data.get("filename"),
                                            content_type=file_data.get("content_type"),
                                            data=file_data.get("data"),
                                        )
                                    )
                            logger.info(f"Processed {len(files)} files via WebSocket")
                        except Exception as e:
                            logger.error(f"Error processing files: {str(e)}")
                            files = None

                    async for chunk in run_agent_stream(
                        agent_id=agent_id,
                        external_id=external_id,
                        message=message,
                        session_service=session_service,
                        artifacts_service=artifacts_service,
                        memory_service=memory_service,
                        db=db,
                        files=files,
                    ):
                        await websocket.send_json(
                            {"message": json.loads(chunk), "turn_complete": False}
                        )

                    # Send signal of complete turn
                    await websocket.send_json({"message": "", "turn_complete": True})

                except WebSocketDisconnect:
                    logger.info("Client disconnected")
                    break
                except json.JSONDecodeError:
                    logger.warning("Invalid JSON message received")
                    continue
                except Exception as e:
                    logger.error(f"Error in WebSocket message handling: {str(e)}")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
                    break

        except WebSocketDisconnect:
            logger.info("Client disconnected during authentication")
        except json.JSONDecodeError:
            logger.warning("Invalid authentication message format")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        except Exception as e:
            logger.error(f"Error during authentication: {str(e)}")
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)

    except Exception as e:
        logger.error(f"WebSocket error: {str(e)}")
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR)


@router.post(
    "/{agent_id}/{external_id}",
    response_model=ChatResponse,
    responses={
        400: {"model": ErrorResponse},
        404: {"model": ErrorResponse},
        500: {"model": ErrorResponse},
    },
)
async def chat(
    request: ChatRequest,
    agent_id: str,
    external_id: str,
    _=Depends(get_agent_by_api_key),
    db: Session = Depends(get_db),
):
    try:
        if settings.AI_ENGINE == "adk":
            final_response = await run_agent_adk(
                agent_id,
                external_id,
                request.message,
                session_service,
                artifacts_service,
                memory_service,
                db,
                files=request.files,
            )
        elif settings.AI_ENGINE == "crewai":
            final_response = await run_agent_crewai(
                agent_id,
                external_id,
                request.message,
                session_service,
                db,
                files=request.files,
            )

        return {
            "response": final_response["final_response"],
            "message_history": final_response["message_history"],
            "status": "success",
            "timestamp": datetime.now().isoformat(),
        }

    except AgentNotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e)) from e
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)
        ) from e


--- src/api/client_routes.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: client_routes.py                                                      ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, EmailStr
from sqlalchemy.orm import Session
from src.config.database import get_db
from typing import List
import uuid
from src.core.jwt_middleware import (
    get_jwt_token,
    verify_user_client,
    verify_admin,
    get_current_user_client_id,
)
from src.schemas.schemas import (
    Client,
    ClientCreate,
)
from src.schemas.user import UserCreate, TokenResponse
from src.services import (
    client_service,
)
from src.services.auth_service import create_access_token
import logging

logger = logging.getLogger(__name__)


class ClientRegistration(BaseModel):
    name: str
    email: EmailStr
    password: str


router = APIRouter(
    prefix="/clients",
    tags=["clients"],
    responses={404: {"description": "Not found"}},
)


@router.post("", response_model=Client, status_code=status.HTTP_201_CREATED)
async def create_user(
    registration: ClientRegistration,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """
    Create a client and a user associated with it

    Args:
        registration: Client and user data to be created
        db: Database session
        payload: JWT token payload

    Returns:
        Client: Created client
    """
    # Only administrators can create clients
    await verify_admin(payload)

    # Create ClientCreate and UserCreate objects from ClientRegistration
    client = ClientCreate(name=registration.name, email=registration.email)
    user = UserCreate(
        email=registration.email, password=registration.password, name=registration.name
    )

    # Create client with user
    client_obj, message = client_service.create_client_with_user(db, client, user)
    if not client_obj:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    return client_obj


@router.get("/", response_model=List[Client])
async def read_clients(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    # If admin, can see all clients
    # If regular user, can only see their own client
    client_id = get_current_user_client_id(payload)

    if client_id:
        # Regular user - returns only their own client
        client = client_service.get_client(db, client_id)
        return [client] if client else []
    else:
        # Administrator - returns all clients
        return client_service.get_clients(db, skip, limit)


@router.get("/{client_id}", response_model=Client)
async def read_client(
    client_id: uuid.UUID,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, client_id)

    db_client = client_service.get_client(db, client_id)
    if db_client is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Client not found"
        )
    return db_client


@router.put("/{client_id}", response_model=Client)
async def update_client(
    client_id: uuid.UUID,
    client: ClientCreate,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    # Verify if the user has access to this client's data
    await verify_user_client(payload, db, client_id)

    db_client = client_service.update_client(db, client_id, client)
    if db_client is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Client not found"
        )
    return db_client


@router.delete("/{client_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_client(
    client_id: uuid.UUID,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    # Only administrators can delete clients
    await verify_admin(payload)

    if not client_service.delete_client(db, client_id):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Client not found"
        )


@router.post("/{client_id}/impersonate", response_model=TokenResponse)
async def impersonate_client(
    client_id: uuid.UUID,
    db: Session = Depends(get_db),
    payload: dict = Depends(get_jwt_token),
):
    """
    Allows an administrator to obtain a token to impersonate a client

    Args:
        client_id: ID of the client to impersonate
        db: Database session
        payload: JWT payload of the administrator

    Returns:
        TokenResponse: Access token for the client

    Raises:
        HTTPException: If the user is not an administrator or the client does not exist
    """
    # Verify if the user is an administrator
    await verify_admin(payload)

    # Search for the client
    client = client_service.get_client(db, client_id)
    if not client:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Client not found"
        )

    user = client_service.get_client_user(db, client_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User associated with the client not found",
        )

    access_token = create_access_token(user)

    logger.info(
        f"Administrator {payload.get('sub')} impersonated client {client.name} (ID: {client_id})"
    )

    return {"access_token": access_token, "token_type": "bearer"}


--- src/api/__init__.py ---


--- CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [0.1.0] - 2025-05-24

### Added

- Export and Import Agents

### Changed

- A2A implementation updated to version 0.2.1 (https://google.github.io/A2A/specification/#agent2agent-a2a-protocol-specification)
- Frontend redesign
- Fixed message order

## [0.0.11] - 2025-05-16

### Changed

- Fixes in email service and client service

## [0.0.10] - 2025-05-15

### Added

- Add Task Agent for structured single-task execution
- Improve context management in agent execution
- Add file support for A2A protocol (Agent-to-Agent) endpoints
- Implement multimodal content processing in A2A messages
- Add SMTP email provider support as alternative to SendGrid

## [0.0.9] - 2025-05-13

### Added

- Add API key sharing and flexible authentication for chat routes

### Changed

- Enhance user authentication with detailed error handling

## [0.0.8] - 2025-05-13

### Changed

- Update author information in multiple files

## [0.0.7] - 2025-05-13

### Added

- Docker image CI workflow for automated builds and pushes
- GitHub Container Registry (GHCR) integration
- Automated image tagging based on branch and commit
- Docker Buildx setup for multi-platform builds
- Cache optimization for faster builds
- Automated image publishing on push to main and develop branches

## [0.0.6] - 2025-05-13

### Added

- Initial public release of Evo AI platform
- FastAPI-based backend API
- JWT authentication with email verification
- Agent management (LLM, A2A, Sequential, Parallel, Loop, Workflow)
- Agent 2 Agent (A2A) protocol support (Google A2A spec)
- MCP server integration and management
- Custom tools management for agents
- Folder-based agent organization
- Secure API key management with encryption
- PostgreSQL and Redis integration
- Email notifications (SendGrid) with Jinja2 templates
- Audit log system for administrative actions
- LangGraph integration for workflow agents
- OpenTelemetry tracing and Langfuse integration
- Docker and Docker Compose support
- English documentation and codebase

### Changed

- N/A

### Fixed

- N/A

### Security

- JWT tokens with expiration and resource-based access control
- Secure password hashing (bcrypt)
- Account lockout after multiple failed login attempts
- Email verification and password reset flows

---

Older versions and future releases will be listed here.


## Links discovered
- [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
- [Semantic Versioning](https://semver.org/spec/v2.0.0.html)

--- frontend/CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [0.0.7] - 2025-05-15

### Added

- Add Task agents
- Add file support for A2A protocol (Agent-to-Agent) endpoints
- Add entrypoint script for dynamic environment variable handling
- Add agent card URL input and copy functionality

## [0.0.6] - 2025-05-13

### Added

- Agent sharing functionality with third parties via API keys
- Dedicated shared-chat page for accessing shared agents
- Local storage mechanism to save recently used shared agents
- Public access to shared agents without full authentication

### Changed

- Add example environment file and update .gitignore
- Add clientId prop to agent-related components and improve agent data processing
- Refactor middleware to handle shared agent routes as public paths
- Update API interceptors to prevent forced logout on shared chat pages

### security

- Implement force logout functionality on 401 Unauthorized responses

## [0.0.5] - 2025-05-13

### Changed

- Update author information in multiple files

## [0.0.4] - 2025-05-13

### Added
- Initial public release
- User-friendly interface for creating and managing AI agents
- Integration with multiple language models (e.g., GPT-4, Claude)
- Client management interface
- Visual configuration for MCP servers
- Custom tools management
- JWT authentication with email verification
- Agent 2 Agent (A2A) protocol support (Google's A2A spec)
- Workflow Agent with ReactFlow for visual workflow creation
- Secure API key management (encrypted storage)
- Agent organization with folders and categories
- Dashboard with agent overview, usage stats, and recent activities
- Agent editor for creating, editing, and configuring agents
- Workflow editor for building and visualizing agent flows
- API key manager for adding, encrypting, and rotating keys
- RESTful API and WebSocket backend integration
- Docker support for containerized deployment
- Complete documentation and contribution guidelines

---

Older versions and future releases will be listed here.


## Links discovered
- [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
- [Semantic Versioning](https://semver.org/spec/v2.0.0.html)

--- src/utils/security.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: security.py                                                           ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from passlib.context import CryptContext
from datetime import datetime, timedelta
import secrets
import string
from jose import jwt
from src.config.settings import settings
import logging
import bcrypt
from dataclasses import dataclass

logger = logging.getLogger(__name__)

# Fix bcrypt error with passlib
if not hasattr(bcrypt, "__about__"):

    @dataclass
    class BcryptAbout:
        __version__: str = getattr(bcrypt, "__version__")

    setattr(bcrypt, "__about__", BcryptAbout())

# Context for password hashing using bcrypt
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def get_password_hash(password: str) -> str:
    """Creates a password hash"""
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies if the provided password matches the stored hash"""
    return pwd_context.verify(plain_password, hashed_password)


def create_jwt_token(data: dict, expires_delta: timedelta = None) -> str:
    """Creates a JWT token"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.JWT_EXPIRATION_TIME)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(
        to_encode, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM
    )
    return encoded_jwt


def generate_token(length: int = 32) -> str:
    """Generates a secure token for email verification or password reset"""
    alphabet = string.ascii_letters + string.digits
    token = "".join(secrets.choice(alphabet) for _ in range(length))
    return token


--- README.md ---
<h1 align="center">Evo AI - AI Agents Platform</h1>

<div align="center">

[![Whatsapp Group](https://img.shields.io/badge/Group-WhatsApp-%2322BC18)](https://evolution-api.com/whatsapp)
[![Discord Community](https://img.shields.io/badge/Discord-Community-blue)](https://evolution-api.com/discord)
[![Postman Collection](https://img.shields.io/badge/Postman-Collection-orange)](https://evolution-api.com/postman)
[![Documentation](https://img.shields.io/badge/Documentation-Official-green)](https://doc.evolution-api.com)
[![License](https://img.shields.io/badge/license-Apache--2.0-blue)](./LICENSE)
[![Support](https://img.shields.io/badge/Donation-picpay-green)](https://app.picpay.com/user/davidsongomes1998)
[![Sponsors](https://img.shields.io/badge/Github-sponsor-orange)](https://github.com/sponsors/EvolutionAPI)

</div>

## Evo AI - AI Agents Platform

Evo AI is an open-source platform for creating and managing AI agents, enabling integration with different AI models and services.

## üöÄ Overview

The Evo AI platform allows:

- Creation and management of AI agents
- Integration with different language models
- Client management and MCP server configuration
- Custom tools management
- **[Google Agent Development Kit (ADK)](https://google.github.io/adk-docs/)**: Base framework for agent development
- **[CrewAI Support](https://github.com/crewAI/crewAI)**: Alternative framework for agent development (in development)
- JWT authentication with email verification
- **[Agent 2 Agent (A2A) Protocol Support](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/)**: Interoperability between AI agents
- **[Workflow Agent with LangGraph](https://www.langchain.com/langgraph)**: Building complex agent workflows
- **Secure API Key Management**: Encrypted storage of API keys
- **Agent Organization**: Folder structure for organizing agents by categories

## ü§ñ Agent Types

Evo AI supports different types of agents that can be flexibly combined:

### 1. LLM Agent (Language Model)

Agent based on language models like GPT-4, Claude, etc. Can be configured with tools, MCP servers, and sub-agents.

### 2. A2A Agent (Agent-to-Agent)

Agent that implements Google's A2A protocol for agent interoperability.

### 3. Sequential Agent

Executes a sequence of sub-agents in a specific order.

### 4. Parallel Agent

Executes multiple sub-agents simultaneously.

### 5. Loop Agent

Executes sub-agents in a loop with a defined maximum number of iterations.

### 6. Workflow Agent

Executes sub-agents in a custom workflow defined by a graph structure using LangGraph.

### 7. Task Agent

Executes a specific task using a target agent with structured task instructions.

## üõ†Ô∏è Technologies

### Backend
- **FastAPI**: Web framework for building the API
- **SQLAlchemy**: ORM for database interaction
- **PostgreSQL**: Main database
- **Alembic**: Migration system
- **Pydantic**: Data validation and serialization
- **Uvicorn**: ASGI server
- **Redis**: Cache and session management
- **JWT**: Secure token authentication
- **SendGrid/SMTP**: Email service for notifications (configurable)
- **Jinja2**: Template engine for email rendering
- **Bcrypt**: Password hashing and security
- **LangGraph**: Framework for building stateful, multi-agent workflows

### Frontend
- **Next.js 15**: React framework with App Router
- **React 18**: User interface library
- **TypeScript**: Type-safe JavaScript
- **Tailwind CSS**: Utility-first CSS framework
- **shadcn/ui**: Modern component library
- **React Hook Form**: Form management
- **Zod**: Schema validation
- **ReactFlow**: Node-based visual workflows
- **React Query**: Server state management

## üìä Langfuse Integration (Tracing & Observability)

Evo AI platform natively supports integration with [Langfuse](https://langfuse.com/) for detailed tracing of agent executions, prompts, model responses, and tool calls, using the OpenTelemetry (OTel) standard.

### How to configure

1. **Set environment variables in your `.env`:**

   ```env
   LANGFUSE_PUBLIC_KEY="pk-lf-..."
   LANGFUSE_SECRET_KEY="sk-lf-..."
   OTEL_EXPORTER_OTLP_ENDPOINT="https://cloud.langfuse.com/api/public/otel"
   ```

2. **View in the Langfuse dashboard**
   - Access your Langfuse dashboard to see real-time traces.

## ü§ñ Agent 2 Agent (A2A) Protocol Support

Evo AI implements the Google's Agent 2 Agent (A2A) protocol, enabling seamless communication and interoperability between AI agents.

For more information about the A2A protocol, visit [Google's A2A Protocol Documentation](https://google.github.io/A2A/).

## üìã Prerequisites

### Backend
- **Python**: 3.10 or higher
- **PostgreSQL**: 13.0 or higher
- **Redis**: 6.0 or higher
- **Git**: For version control
- **Make**: For running Makefile commands

### Frontend
- **Node.js**: 18.0 or higher
- **pnpm**: Package manager (recommended) or npm/yarn

## üîß Installation

### 1. Clone the Repository

```bash
git clone https://github.com/EvolutionAPI/evo-ai.git
cd evo-ai
```

### 2. Backend Setup

#### Virtual Environment and Dependencies

```bash
# Create and activate virtual environment
make venv
source venv/bin/activate  # Linux/Mac
# or on Windows: venv\Scripts\activate

# Install development dependencies
make install-dev
```

#### Environment Configuration

```bash
# Copy and configure backend environment
cp .env.example .env
# Edit the .env file with your database, Redis, and other settings
```

#### Database Setup

```bash
# Initialize database and apply migrations
make alembic-upgrade

# Seed initial data (admin user, sample clients, etc.)
make seed-all
```

### 3. Frontend Setup

#### Install Dependencies

```bash
# Navigate to frontend directory
cd frontend

# Install dependencies using pnpm (recommended)
pnpm install

# Or using npm
# npm install

# Or using yarn
# yarn install
```

#### Frontend Environment Configuration

```bash
# Copy and configure frontend environment
cp .env.example .env
# Edit .env with your API URL (default: http://localhost:8000)
```

The frontend `.env` should contain:

```env
NEXT_PUBLIC_API_URL=http://localhost:8000
```

## üöÄ Running the Application

### Development Mode

#### Start Backend (Terminal 1)
```bash
# From project root
make run
# Backend will be available at http://localhost:8000
```

#### Start Frontend (Terminal 2)
```bash
# From frontend directory
cd frontend
pnpm dev

# Or using npm/yarn
# npm run dev
# yarn dev

# Frontend will be available at http://localhost:3000
```

### Production Mode

#### Backend
```bash
make run-prod    # Production with multiple workers
```

#### Frontend
```bash
cd frontend
pnpm build && pnpm start

# Or using npm/yarn
# npm run build && npm start
# yarn build && yarn start
```

## üê≥ Docker Installation

### Full Stack with Docker Compose

```bash
# Build and start all services (backend + database + redis)
make docker-build
make docker-up

# Initialize database with seed data
make docker-seed
```

### Frontend with Docker

```bash
# From frontend directory
cd frontend

# Build frontend image
docker build -t evo-ai-frontend .

# Run frontend container
docker run -p 3000:3000 -e NEXT_PUBLIC_API_URL=http://localhost:8000 evo-ai-frontend
```

Or using the provided docker-compose:

```bash
# From frontend directory
cd frontend
docker-compose up -d
```

## üéØ Getting Started

After installation, follow these steps:

1. **Access the Frontend**: Open `http://localhost:3000`
2. **Create Admin Account**: Use the seeded admin credentials or register a new account
3. **Configure MCP Server**: Set up your first MCP server connection
4. **Create Client**: Add a client to organize your agents
5. **Build Your First Agent**: Create and configure your AI agent
6. **Test Agent**: Use the chat interface to interact with your agent

### Default Admin Credentials

After running the seeders, you can login with:
- **Email**: Check the seeder output for the generated admin email
- **Password**: Check the seeder output for the generated password

## üñ•Ô∏è API Documentation

The interactive API documentation is available at:

- Swagger UI: `http://localhost:8000/docs`
- ReDoc: `http://localhost:8000/redoc`

## üë®‚Äçüíª Development Commands

### Backend Commands
```bash
# Database migrations
make alembic-upgrade            # Update database to latest version
make alembic-revision message="description"  # Create new migration

# Seeders
make seed-all                   # Run all seeders

# Code verification
make lint                       # Verify code with flake8
make format                     # Format code with black
```

### Frontend Commands
```bash
# From frontend directory
cd frontend

# Development
pnpm dev                        # Start development server
pnpm build                      # Build for production
pnpm start                      # Start production server
pnpm lint                       # Run ESLint
```

## üöÄ Configuration

### Backend Configuration (.env file)

Key settings include:

```bash
# Database settings
POSTGRES_CONNECTION_STRING="postgresql://postgres:root@localhost:5432/evo_ai"

# Redis settings
REDIS_HOST="localhost"
REDIS_PORT=6379

# AI Engine configuration
AI_ENGINE="adk"  # Options: "adk" (Google Agent Development Kit) or "crewai" (CrewAI framework)

# JWT settings
JWT_SECRET_KEY="your-jwt-secret-key"

# Email provider configuration
EMAIL_PROVIDER="sendgrid"  # Options: "sendgrid" or "smtp"

# Encryption for API keys
ENCRYPTION_KEY="your-encryption-key"
```

### Frontend Configuration (.env file)

```bash
# API Configuration
NEXT_PUBLIC_API_URL="http://localhost:8000"  # Backend API URL
```

> **Note**: While Google ADK is fully supported, the CrewAI engine option is still under active development. For production environments, it's recommended to use the default "adk" engine.

## üîê Authentication

The API uses JWT (JSON Web Token) authentication with:

- User registration and email verification
- Login to obtain JWT tokens
- Password recovery flow
- Account lockout after multiple failed login attempts

## üöÄ Star Us on GitHub

If you find EvoAI useful, please consider giving us a star! Your support helps us grow our community and continue improving the product.

[![Star History Chart](https://api.star-history.com/svg?repos=EvolutionAPI/evo-ai&type=Date)](https://www.star-history.com/#EvolutionAPI/evo-ai&Date)

## ü§ù Contributing

We welcome contributions from the community! Please read our [Contributing Guidelines](CONTRIBUTING.md) for more details.

## üìÑ License

This project is licensed under the [Apache License 2.0](./LICENSE).


## Links discovered
- [![Whatsapp Group](https://img.shields.io/badge/Group-WhatsApp-%2322BC18)
- [![Discord Community](https://img.shields.io/badge/Discord-Community-blue)
- [![Postman Collection](https://img.shields.io/badge/Postman-Collection-orange)
- [![Documentation](https://img.shields.io/badge/Documentation-Official-green)
- [![License](https://img.shields.io/badge/license-Apache--2.0-blue)
- [![Support](https://img.shields.io/badge/Donation-picpay-green)
- [![Sponsors](https://img.shields.io/badge/Github-sponsor-orange)
- [Google Agent Development Kit (ADK)](https://google.github.io/adk-docs/)
- [CrewAI Support](https://github.com/crewAI/crewAI)
- [Agent 2 Agent (A2A) Protocol Support](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/)
- [Workflow Agent with LangGraph](https://www.langchain.com/langgraph)
- [Langfuse](https://langfuse.com/)
- [Google's A2A Protocol Documentation](https://google.github.io/A2A/)
- [![Star History Chart](https://api.star-history.com/svg?repos=EvolutionAPI/evo-ai&type=Date)
- [Contributing Guidelines](https://github.com/EvolutionAPI/evo-ai/blob/main/CONTRIBUTING.md)
- [Apache License 2.0](https://github.com/EvolutionAPI/evo-ai/blob/main/LICENSE.md)

--- conftest.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: conftest.py                                                           ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

from src.config.database import Base, get_db
from src.main import app

# Use in-memory SQLite for tests
SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


@pytest.fixture(scope="function")
def db_session():
    """Creates a fresh database session for each test."""
    Base.metadata.create_all(bind=engine)  # Create tables

    connection = engine.connect()
    transaction = connection.begin()
    session = TestingSessionLocal(bind=connection)

    # Use our test database instead of the standard one
    def override_get_db():
        try:
            yield session
            session.commit()
        finally:
            session.close()

    app.dependency_overrides[get_db] = override_get_db

    yield session  # The test will run here

    # Teardown
    transaction.rollback()
    connection.close()
    Base.metadata.drop_all(bind=engine)
    app.dependency_overrides.clear()


@pytest.fixture(scope="function")
def client(db_session):
    """Creates a FastAPI TestClient with database session fixture."""
    with TestClient(app) as test_client:
        yield test_client


--- setup.py ---
"""Setup script for the package."""

from setuptools import setup

if __name__ == "__main__":
    setup() 

--- frontend/README.md ---
# Evo AI - AI Agents Platform (Frontend)

Evo AI is an open-source platform for creating and managing AI agents, enabling integration with different AI models and services.

## üöÄ Overview

The Evo AI frontend platform enables:

- User-friendly interface for creating and managing AI agents
- Integration with different language models
- Client management
- Visual configuration of MCP servers
- Custom tools management
- JWT authentication with email verification
- **Agent 2 Agent (A2A) Protocol Support**: Interface for interoperability between AI agents following Google's A2A specification
- **Workflow Agent with ReactFlow**: Visual interface for building complex agent workflows
- **Secure API Key Management**: Interface for encrypted storage of API keys
- **Agent Organization**: Folder structure for organizing agents by categories

## üß© Agent Creation Interface

The frontend offers intuitive interfaces for creating different types of agents:

### 1. LLM Agent (Language Model)

Interface for configuring agents based on models like GPT-4, Claude, etc. with tools, MCP servers, and sub-agents.

### 2. A2A Agent (Agent-to-Agent)

Interface for implementing Google's A2A protocol for agent interoperability.

### 3. Sequential Agent

Interface for executing sub-agents in a specific order.

### 4. Parallel Agent

Interface for executing multiple sub-agents simultaneously.

### 5. Loop Agent

Interface for executing sub-agents in a loop with a defined number of iterations.

### 6. Workflow Agent

Visual interface based on ReactFlow for creating complex workflows between agents.

## üõ†Ô∏è Technologies

- [Next.js](https://nextjs.org/) - React framework for production
- [React](https://reactjs.org/) - JavaScript library for building user interfaces
- [Tailwind CSS](https://tailwindcss.com/) - Utility-first CSS framework
- [Shadcn UI](https://ui.shadcn.com/) - UI component library
- [Radix UI](https://www.radix-ui.com/) - Unstyled, accessible components
- [TypeScript](https://www.typescriptlang.org/) - Typed JavaScript
- [React Query](https://tanstack.com/query/latest) - Data fetching and state management
- [Zustand](https://zustand-demo.pmnd.rs/) - Global state management
- [React Flow](https://reactflow.dev/) - Library for building node-based visual workflows
- [Axios](https://axios-http.com/) - HTTP client for API communication

## üìã Requirements

- Node.js 18+ (LTS recommended)
- npm, yarn, or pnpm package manager
- Evo AI backend running

## üîß Installation

1. Clone the repository:

```bash
git clone https://github.com/EvolutionAPI/evo-ai-frontend.git
cd evo-ai-frontend
```

2. Install dependencies:

```bash
npm install
# or
yarn install
# or
pnpm install
```

3. Configure environment variables:

```bash
cp .env.example .env
# Edit the .env file with your settings
```

## üöÄ Running the Project

```bash
# Development mode
npm run dev
# or
yarn dev
# or
pnpm dev

# Production build
npm run build
# or
yarn build
# or
pnpm build

# Start production server
npm run start
# or
yarn start
# or
pnpm start
```

The project will be available at [http://localhost:3000](http://localhost:3000)

## üîê Authentication

The frontend implements JWT authentication integrated with the backend:

- **User Registration**: Form for creating new accounts
- **Email Verification**: Process for verifying via email
- **Login**: Authentication of existing users
- **Password Recovery**: Complete password recovery flow
- **Secure Storage**: Tokens stored in HttpOnly cookies

## üñ•Ô∏è Main Interface Features

### Dashboard

Main dashboard showing:
- Agent overview
- Usage statistics
- Recent activities
- Quick links for agent creation

### Agent Editor

Complete interface for:
- Creating new agents
- Editing existing agents
- Configuring instructions
- Selecting models
- Setting up API keys

### Workflow Editor

Visual editor based on ReactFlow for:
- Creating complex workflows
- Connecting different agents
- Defining conditionals and decision flows
- Visualizing data flow

### API Key Manager

Interface for:
- Adding new API keys
- Securely encrypting keys
- Managing existing keys
- Rotating and updating keys

### Agent Organization

System for:
- Creating folders and categories
- Organizing agents by type or use case
- Searching and filtering agents

## üîÑ Backend Integration

The frontend communicates with the backend through:

- **RESTful API**: Endpoints for resource management
- **WebSockets**: Real-time communication for agent messages
- **Response Streaming**: Support for streaming model responses

## üê≥ Docker Support

The project includes Docker configuration for containerized deployment:

```bash
# Build the Docker image
./docker_build.sh
# or
docker build -t nextjs-frontend .

# Run the container
docker run -p 3000:3000 nextjs-frontend
```

# üê≥ Docker Compose
```bash
# Copy the .env file
cp .env.example .env

# Build and deploy
 docker-compose up -d --build
```

## ü§ù Contributing

We welcome contributions from the community! Here's how you can help:

1. Fork the project
2. Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. Make your changes and add tests if possible
4. Run tests and make sure they pass
5. Commit your changes following conventional commits format (`feat: add amazing feature`)
6. Push to the branch (`git push origin feature/AmazingFeature`)
7. Open a Pull Request

Please read our [Contributing Guidelines](CONTRIBUTING.md) for more details.

## üìÑ License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.

**Trademark Notice:** The name "Evo AI" and related branding are protected trademarks. Unauthorized use is prohibited.

## üë®‚Äçüíª Development Commands

- `npm run dev` - Start the development server
- `npm run build` - Build the application for production
- `npm run start` - Start the production server
- `npm run lint` - Run ESLint to check code quality
- `npm run format` - Format code with Prettier

## üôè Acknowledgments

- [Next.js](https://nextjs.org/)
- [React](https://reactjs.org/)
- [Tailwind CSS](https://tailwindcss.com/)
- [Shadcn UI](https://ui.shadcn.com/)
- [ReactFlow](https://reactflow.dev/) 


## Links discovered
- [Next.js](https://nextjs.org/)
- [React](https://reactjs.org/)
- [Tailwind CSS](https://tailwindcss.com/)
- [Shadcn UI](https://ui.shadcn.com/)
- [Radix UI](https://www.radix-ui.com/)
- [TypeScript](https://www.typescriptlang.org/)
- [React Query](https://tanstack.com/query/latest)
- [Zustand](https://zustand-demo.pmnd.rs/)
- [React Flow](https://reactflow.dev/)
- [Axios](https://axios-http.com/)
- [http://localhost:3000](http://localhost:3000)
- [Contributing Guidelines](https://github.com/EvolutionAPI/evo-ai/blob/main/frontend/CONTRIBUTING.md)
- [LICENSE](https://github.com/EvolutionAPI/evo-ai/blob/main/frontend/LICENSE.md)
- [ReactFlow](https://reactflow.dev/)

--- frontend/middleware.ts ---
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: /middleware.ts                                                        ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
import { NextRequest, NextResponse } from 'next/server'

const PUBLIC_PATHS = ['/login', '/security/verify-email', '/security/reset-password', '/shared-chat']
const ADMIN_PATHS = ['/clients', '/mcp-servers']
const CLIENT_PATHS = ['/agents', '/chat']

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  const isPublic = PUBLIC_PATHS.some((path) => pathname.startsWith(path))
  const isAdminPath = ADMIN_PATHS.some((path) => pathname.startsWith(path))
  const isClientPath = CLIENT_PATHS.some((path) => pathname.startsWith(path))

  const token = request.cookies.get('access_token')?.value
  let isAdmin = false
  let isImpersonating = false
  
  const userCookie = request.cookies.get('user')?.value
  if (userCookie) {
    try {
      const user = JSON.parse(decodeURIComponent(userCookie))
      isAdmin = !!user.is_admin
    } catch {}
  }
  
  isImpersonating = request.cookies.get('isImpersonating')?.value === 'true'
  
  if (!isImpersonating) {
    const headers = request.headers
    isImpersonating = headers.get('x-is-impersonating') === 'true'
  }

  if (isPublic && token) {
    if (pathname.startsWith('/shared-chat')) {
      return NextResponse.next()
    }
    return NextResponse.redirect(new URL('/', request.url))
  }

  if (!isPublic && !token) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  if (isAdminPath && !isAdmin) {
    return NextResponse.redirect(new URL('/', request.url))
  }

  if (isClientPath && isAdmin && !isImpersonating) {
    return NextResponse.redirect(new URL('/mcp-servers', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.svg).*)'],
} 

--- frontend/tailwind.config.ts ---
import type { Config } from "tailwindcss"

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
    "*.{js,ts,jsx,tsx,mdx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config

export default config


--- frontend/types/agent.ts ---
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: /types/agent.ts                                                       ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
export type AgentType =
  | "llm"
  | "a2a"
  | "sequential"
  | "parallel"
  | "loop"
  | "workflow"
  | "task";

export interface ToolConfig {
  id: string;
  envs: Record<string, string>;
}

export interface MCPServerConfig {
  id: string;
  envs: Record<string, string>;
  tools: string[];
  selected_tools?: string[];
}

export interface CustomMCPServer {
  url: string;
  headers?: Record<string, string>;
}

export interface HTTPToolParameter {
  type: string;
  required: boolean;
  description: string;
}

export interface HTTPToolParameters {
  path_params?: Record<string, string>;
  query_params?: Record<string, string | string[]>;
  body_params?: Record<string, HTTPToolParameter>;
}

export interface HTTPToolErrorHandling {
  timeout: number;
  retry_count: number;
  fallback_response: Record<string, string>;
}

export interface HTTPTool {
  name: string;
  method: string;
  values: Record<string, string>;
  headers: Record<string, string>;
  endpoint: string;
  parameters: HTTPToolParameters;
  description: string;
  error_handling: HTTPToolErrorHandling;
}

export interface CustomTools {
  http_tools: HTTPTool[];
}

export interface WorkflowData {
  nodes: any[];
  edges: any[];
}

export interface TaskConfig {
  agent_id: string;
  description: string;
  expected_output: string;
  enabled_tools?: string[];
}

export interface AgentConfig {
  // LLM config
  api_key?: string;
  tools?: ToolConfig[];
  custom_tools?: CustomTools;
  mcp_servers?: MCPServerConfig[];
  custom_mcp_servers?: CustomMCPServer[];

  // Sequential, Parallel e Loop config
  sub_agents?: string[];
  agent_tools?: string[];

  // Loop config
  max_iterations?: number;

  // Workflow config
  workflow?: WorkflowData;

  // Task config
  tasks?: TaskConfig[];
}

export interface Agent {
  id: string;
  client_id: string;
  folder_id?: string;
  name: string;
  description?: string;
  role?: string;
  goal?: string;
  type: AgentType;
  model?: string;
  api_key_id?: string;
  instruction?: string;
  agent_card_url?: string;
  config?: AgentConfig;
  tasks?: TaskConfig[];
  created_at: string;
  updated_at?: string;
}

export interface AgentCreate {
  client_id: string;
  name: string;
  description?: string;
  role?: string;
  goal?: string;
  type: AgentType;
  model?: string;
  api_key_id?: string;
  instruction?: string;
  agent_card_url?: string;
  config?: AgentConfig;
}


--- frontend/services/agentService.ts ---
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: /services/agentService.ts                                             ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
import api from "./api";
import { Agent, AgentCreate } from "../types/agent";
import { escapePromptBraces, sanitizeAgentName } from "@/lib/utils";

const processAgentData = (data: AgentCreate | Partial<AgentCreate>): AgentCreate | Partial<AgentCreate> => {
  const updatedData = {...data};
  
  if (updatedData.instruction) {
    updatedData.instruction = escapePromptBraces(updatedData.instruction);
  }
  
  if (updatedData.name) {
    updatedData.name = sanitizeAgentName(updatedData.name);
  }
  
  return updatedData;
};

export const createAgent = (data: AgentCreate) =>
  api.post<Agent>("/api/v1/agents/", processAgentData(data));

export const listAgents = (
  clientId: string,
  skip = 0,
  limit = 100,
  folderId?: string
) => {
  const queryParams = new URLSearchParams({
    skip: skip.toString(),
    limit: limit.toString(),
  });

  if (folderId) {
    queryParams.append("folder_id", folderId);
  }

  return api.get<Agent[]>(`/api/v1/agents/?${queryParams.toString()}`, {
    headers: { "x-client-id": clientId },
  });
};

export const getAgent = (agentId: string, clientId: string) =>
  api.get<Agent>(`/api/v1/agents/${agentId}`, {
    headers: { "x-client-id": clientId },
  });

export const getSharedAgent = (agentId: string) =>
  api.get<Agent>(`/api/v1/agents/${agentId}/shared`);

export const updateAgent = (agentId: string, data: Partial<AgentCreate>) =>
  api.put<Agent>(`/api/v1/agents/${agentId}`, processAgentData(data));

export const deleteAgent = (agentId: string) =>
  api.delete(`/api/v1/agents/${agentId}`);

// New functions for the folder system

export interface Folder {
  id: string;
  name: string;
  description: string;
  client_id: string;
  created_at: string;
  updated_at: string;
}

export interface FolderCreate {
  name: string;
  description: string;
  client_id: string;
}

export interface FolderUpdate {
  name?: string;
  description?: string;
}

export const createFolder = (data: FolderCreate) =>
  api.post<Folder>("/api/v1/agents/folders", data);

export const listFolders = (clientId: string, skip = 0, limit = 100) =>
  api.get<Folder[]>(`/api/v1/agents/folders?skip=${skip}&limit=${limit}`, {
    headers: { "x-client-id": clientId },
  });

export const getFolder = (folderId: string, clientId: string) =>
  api.get<Folder>(`/api/v1/agents/folders/${folderId}`, {
    headers: { "x-client-id": clientId },
  });

export const updateFolder = (
  folderId: string,
  data: FolderUpdate,
  clientId: string
) =>
  api.put<Folder>(`/api/v1/agents/folders/${folderId}`, data, {
    headers: { "x-client-id": clientId },
  });

export const deleteFolder = (folderId: string, clientId: string) =>
  api.delete(`/api/v1/agents/folders/${folderId}`, {
    headers: { "x-client-id": clientId },
  });

export const listAgentsInFolder = (
  folderId: string,
  clientId: string,
  skip = 0,
  limit = 100
) =>
  api.get<Agent[]>(
    `/api/v1/agents/folders/${folderId}/agents?skip=${skip}&limit=${limit}`,
    {
      headers: { "x-client-id": clientId },
    }
  );

export const assignAgentToFolder = (
  agentId: string,
  folderId: string | null,
  clientId: string
) => {
  const url = folderId
    ? `/api/v1/agents/${agentId}/folder?folder_id=${folderId}`
    : `/api/v1/agents/${agentId}/folder`;

  return api.put<Agent>(
    url,
    {},
    {
      headers: { "x-client-id": clientId },
    }
  );
};

export const shareAgent = (agentId: string, clientId: string) => 
  api.post<{ api_key: string }>(`/api/v1/agents/${agentId}/share`, {}, {
    headers: { "x-client-id": clientId },
  });

// API Key Interfaces and Services

export interface ApiKey {
  id: string;
  name: string;
  provider: string;
  client_id: string;
  created_at: string;
  updated_at: string;
  is_active: boolean;
}

export interface ApiKeyCreate {
  name: string;
  provider: string;
  client_id: string;
  key_value: string;
}

export interface ApiKeyUpdate {
  name?: string;
  provider?: string;
  key_value?: string;
  is_active?: boolean;
}

export const createApiKey = (data: ApiKeyCreate) =>
  api.post<ApiKey>("/api/v1/agents/apikeys", data);

export const listApiKeys = (clientId: string, skip = 0, limit = 100) =>
  api.get<ApiKey[]>(`/api/v1/agents/apikeys?skip=${skip}&limit=${limit}`, {
    headers: { "x-client-id": clientId },
  });

export const getApiKey = (keyId: string, clientId: string) =>
  api.get<ApiKey>(`/api/v1/agents/apikeys/${keyId}`, {
    headers: { "x-client-id": clientId },
  });

export const updateApiKey = (
  keyId: string,
  data: ApiKeyUpdate,
  clientId: string
) =>
  api.put<ApiKey>(`/api/v1/agents/apikeys/${keyId}`, data, {
    headers: { "x-client-id": clientId },
  });

export const deleteApiKey = (keyId: string, clientId: string) =>
  api.delete(`/api/v1/agents/apikeys/${keyId}`, {
    headers: { "x-client-id": clientId },
  });

// Import agent from JSON file
export const importAgentFromJson = (file: File, clientId: string, folderId?: string | null) => {
  const formData = new FormData();
  formData.append('file', file);
  
  // Add folder_id to formData if it exists
  if (folderId) {
    formData.append('folder_id', folderId);
  }
  
  return api.post('/api/v1/agents/import', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
      'x-client-id': clientId
    }
  });
};


--- frontend/types/aiModels.ts ---
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: /types/aiModels.ts                                                    ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
export const availableModels = [
  // GPT-4.1 series
  { value: "openai/gpt-4.1", label: "GPT-4.1", provider: "openai" },
  { value: "openai/gpt-4.1-nano", label: "GPT-4.1 Nano", provider: "openai" },
  { value: "openai/gpt-4.1-mini", label: "GPT-4.1 Mini", provider: "openai" },

  // GPT-4.5 Preview
  {
    value: "openai/gpt-4.5-preview",
    label: "GPT-4.5 Preview",
    provider: "openai",
  },

  // GPT-4 Turbo & GPT-4o
  { value: "openai/gpt-4", label: "GPT-4 Turbo", provider: "openai" },
  { value: "openai/gpt-4o", label: "GPT-4o", provider: "openai" },
  { value: "openai/gpt-4o-mini", label: "GPT-4o Mini", provider: "openai" },

  // GPT-4 Legacy
  { value: "openai/gpt-4-32k", label: "GPT-4 32K", provider: "openai" },

  // GPT-3.5 Turbo series
  {
    value: "openai/gpt-3.5-turbo",
    label: "GPT-3.5 Turbo",
    provider: "openai",
  },
  {
    value: "openai/gpt-3.5-turbo-16k",
    label: "GPT-3.5 Turbo 16K",
    provider: "openai",
  },

  // Gemini Preview models
  {
    value: "gemini/gemini-2.5-pro-preview-05-06",
    label: "Gemini 2.5 Pro (Preview)",
    provider: "gemini",
  },
  {
    value: "gemini/gemini-2.5-flash-preview-04-17",
    label: "Gemini 2.5 Flash (Preview)",
    provider: "gemini",
  },

  // Gemini GA models
  {
    value: "gemini/gemini-2.0-flash",
    label: "Gemini 2.0 Flash",
    provider: "gemini",
  },
  {
    value: "gemini/gemini-2.0-flash-lite",
    label: "Gemini 2.0 Flash-Lite",
    provider: "gemini",
  },
  {
    value: "gemini/gemini-2.0-flash-live-001",
    label: "Gemini 2.0 Flash Live",
    provider: "gemini",
  },

  // Gemini Legacy models
  {
    value: "gemini/gemini-1.5-pro",
    label: "Gemini 1.5 Pro",
    provider: "gemini",
  },
  {
    value: "gemini/gemini-1.5-flash",
    label: "Gemini 1.5 Flash",
    provider: "gemini",
  },
  {
    value: "gemini/gemini-1.5-flash-8b",
    label: "Gemini 1.5 Flash-8B",
    provider: "gemini",
  },

  // Claude 3.7 models
  {
    value: "anthropic/claude-3-7-sonnet-20250219",
    label: "Claude 3.7 Sonnet",
    provider: "anthropic",
  },

  // Claude 3.5 models
  {
    value: "anthropic/claude-3-5-sonnet-20241022",
    label: "Claude 3.5 Sonnet v2",
    provider: "anthropic",
  },
  {
    value: "anthropic/claude-3-5-sonnet-20240620",
    label: "Claude 3.5 Sonnet",
    provider: "anthropic",
  },
  {
    value: "anthropic/claude-3-5-haiku-20241022",
    label: "Claude 3.5 Haiku",
    provider: "anthropic",
  },

  // Claude 3 models
  {
    value: "anthropic/claude-3-opus-20240229",
    label: "Claude 3 Opus",
    provider: "anthropic",
  },
  {
    value: "anthropic/claude-3-sonnet-20240229",
    label: "Claude 3 Sonnet",
    provider: "anthropic",
  },
  {
    value: "anthropic/claude-3-haiku-20240307",
    label: "Claude 3 Haiku",
    provider: "anthropic",
  },

  // Groq Production Models
  {
    value: "groq/gemma2-9b-it",
    label: "Gemma2 9B-IT (Google)",
    provider: "groq",
  },
  {
    value: "groq/llama-3.3-70b-versatile",
    label: "Llama 3.3 70B Versatile (Meta)",
    provider: "groq",
  },
  {
    value: "groq/llama-3.1-8b-instant",
    label: "Llama 3.1 8B Instant (Meta)",
    provider: "groq",
  },
  {
    value: "groq/llama-guard-3-8b",
    label: "Llama Guard 3 8B (Meta)",
    provider: "groq",
  },
  {
    value: "groq/llama3-70b-8192",
    label: "Llama3 70B (Meta)",
    provider: "groq",
  },
  {
    value: "groq/llama3-8b-8192",
    label: "Llama3 8B (Meta)",
    provider: "groq",
  },
  {
    value: "groq/whisper-large-v3",
    label: "Whisper Large v3 (OpenAI)",
    provider: "groq",
  },
  {
    value: "groq/whisper-large-v3-turbo",
    label: "Whisper Large v3 Turbo (OpenAI)",
    provider: "groq",
  },
  {
    value: "groq/distil-whisper-large-v3-en",
    label: "Distil Whisper Large v3-EN (HuggingFace)",
    provider: "groq",
  },

  // Groq Preview Models
  {
    value: "groq/allam-2-7b",
    label: "Allam 2 7B (SDAIA)",
    provider: "groq",
  },
  {
    value: "groq/deepseek-r1-distill-llama-70b",
    label: "DeepSeek R1 Distill Llama 70B",
    provider: "groq",
  },
  {
    value: "groq/meta-llama-llama-4-maverick-17b-128e-instruct",
    label: "Llama 4 Maverick 17B Instruct (Meta)",
    provider: "groq",
  },

  // Groq Preview Systems
  {
    value: "groq/compound-beta",
    label: "Compound Beta",
    provider: "groq",
  },
  {
    value: "groq/compound-beta-mini",
    label: "Compound Beta Mini",
    provider: "groq",
  },

  // Cohere Command Family
  {
    value: "cohere/command-a-03-2025",
    label: "Command A (256K context)",
    provider: "cohere",
  },
  {
    value: "cohere/command-r7b-12-2024",
    label: "Command R7B (128K context)",
    provider: "cohere",
  },
  {
    value: "cohere/command-r-plus-08-2024",
    label: "Command R+ (128K context)",
    provider: "cohere",
  },
  {
    value: "cohere/command-r-08-2024",
    label: "Command R (128K context)",
    provider: "cohere",
  },

  // Cohere Embed Family
  {
    value: "cohere/embed-v4.0",
    label: "Embed v4.0 (Multimodal)",
    provider: "cohere",
  },
  {
    value: "cohere/embed-english-v3.0",
    label: "Embed English v3.0",
    provider: "cohere",
  },
  {
    value: "cohere/embed-english-light-v3.0",
    label: "Embed English Light v3.0",
    provider: "cohere",
  },
  {
    value: "cohere/embed-multilingual-v3.0",
    label: "Embed Multilingual v3.0",
    provider: "cohere",
  },
  {
    value: "cohere/embed-multilingual-light-v3.0",
    label: "Embed Multilingual Light v3.0",
    provider: "cohere",
  },

  // Cohere Rerank Family
  {
    value: "cohere/rerank-v3.5",
    label: "Rerank v3.5 (Multilingual)",
    provider: "cohere",
  },
  {
    value: "cohere/rerank-english-v3.0",
    label: "Rerank English v3.0",
    provider: "cohere",
  },
  {
    value: "cohere/rerank-multilingual-v3.0",
    label: "Rerank Multilingual v3.0",
    provider: "cohere",
  },

  // Cohere Aya Family
  {
    value: "cohere/c4ai-aya-expanse-8b",
    label: "Aya Expanse 8B (23 languages)",
    provider: "cohere",
  },
  {
    value: "cohere/c4ai-aya-expanse-32b",
    label: "Aya Expanse 32B (128K context)",
    provider: "cohere",
  },
  {
    value: "cohere/c4ai-aya-vision-8b",
    label: "Aya Vision 8B (Multimodal)",
    provider: "cohere",
  },
  {
    value: "cohere/c4ai-aya-vision-32b",
    label: "Aya Vision 32B (Multimodal)",
    provider: "cohere",
  },

  // Mistral Premier Models
  {
    value: "mistral/mistral-large-2-v24.11",
    label: "Mistral Large 2 (123B, 128K context)",
    provider: "mistral",
  },
  {
    value: "mistral/pixtral-large-v24.11",
    label: "Pixtral Large (Multimodal, 128K context)",
    provider: "mistral",
  },
  {
    value: "mistral/mistral-medium-3-v07.05",
    label: "Mistral Medium 3 (128K context)",
    provider: "mistral",
  },
  {
    value: "mistral/mistral-saba-v25.02",
    label: "Mistral Saba (Middle East & South Asia, 32K context)",
    provider: "mistral",
  },
  {
    value: "mistral/ministral-8b-v24.10",
    label: "Ministral 8B (128K context)",
    provider: "mistral",
  },
  {
    value: "mistral/ministral-3b-v24.10",
    label: "Ministral 3B (128K context)",
    provider: "mistral",
  },
  {
    value: "mistral/mistral-small-3.1-v25.03",
    label: "Mistral Small 3.1 (24B, Multimodal)",
    provider: "mistral",
  },

  // Mistral Open-Source Models
  {
    value: "mistral/mistral-7b",
    label: "Mistral 7B (128K context)",
    provider: "mistral",
  },
  {
    value: "mistral/mixtral-8x7b",
    label: "Mixtral 8√ó7B (MoE, 128K context)",
    provider: "mistral",
  },
  {
    value: "mistral/mixtral-8x22b",
    label: "Mixtral 8√ó22B (MoE, 128K context)",
    provider: "mistral",
  },
  {
    value: "mistral/codestral-mamba-7b",
    label: "Codestral Mamba 7B (Code, 128K context)",
    provider: "mistral",
  },
  {
    value: "mistral/codestral-22b",
    label: "Codestral 22B (Code, non-commercial)",
    provider: "mistral",
  },
  {
    value: "mistral/mathstral-7b",
    label: "Mathstral 7B (STEM, 32K context)",
    provider: "mistral",
  },
  {
    value: "mistral/mistral-nemo",
    label: "Mistral Nemo (Code focus)",
    provider: "mistral",
  },
  {
    value: "mistral/pixtral-12b",
    label: "Pixtral 12B (Multimodal, 128K context)",
    provider: "mistral",
  },
];

export const availableModelProviders = [
  {
    value: "openai",
    label: "OpenAI",
  },
  {
    value: "gemini",
    label: "Gemini",
  },
  {
    value: "anthropic",
    label: "Anthropic",
  },
  {
    value: "groq",
    label: "Groq",
  },
  {
    value: "cohere",
    label: "Cohere",
  },
];


--- frontend/types/auth.ts ---
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: /types/auth.ts                                                        ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
export interface RegisterRequest {
  email: string;
  password: string;
  name: string;
}

export interface RegisterResponse {
  id: string;
  email: string;
  name: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  access_token: string;
  token_type: string;
}

export interface ResendVerificationRequest {
  email: string;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ResetPasswordRequest {
  token: string;
  new_password: string;
}

export interface ChangePasswordRequest {
  current_password: string;
  new_password: string;
}

export interface MeResponse {
  email: string;
  id: string;
  client_id: string | null;
  is_active: boolean;
  email_verified: boolean;
  is_admin: boolean;
  created_at: string;
}


--- frontend/services/authService.ts ---
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: /services/authService.ts                                              ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
import api from "./api";
import {
  RegisterRequest,
  RegisterResponse,
  LoginRequest,
  LoginResponse,
  ResendVerificationRequest,
  ForgotPasswordRequest,
  ResetPasswordRequest,
  MeResponse,
  ChangePasswordRequest,
} from "../types/auth";

export const register = (data: RegisterRequest) =>
  api.post<RegisterResponse>("/api/v1/auth/register", data);
export const login = (data: LoginRequest) =>
  api.post<LoginResponse>("/api/v1/auth/login", data);
export const verifyEmail = (code: string) =>
  api.get(`/api/v1/auth/verify-email/${code}`);
export const resendVerification = (data: ResendVerificationRequest) =>
  api.post("/api/v1/auth/resend-verification", data);
export const forgotPassword = (data: ForgotPasswordRequest) =>
  api.post("/api/v1/auth/forgot-password", data);
export const resetPassword = (data: ResetPasswordRequest) =>
  api.post("/api/v1/auth/reset-password", data);
export const getMe = () => api.post<MeResponse>("/api/v1/auth/me");
export const changePassword = (data: ChangePasswordRequest) =>
  api.post("/api/v1/auth/change-password", data);


--- frontend/services/clientService.ts ---
/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: /services/clientService.ts                                            ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/
import api from "./api";

export interface Client {
  id: string;
  name: string;
  email: string;
  created_at: string;
  users_count?: number;
  agents_count?: number;
}

export interface CreateClientRequest {
  name: string;
  email: string;
  password: string;
}

export interface UpdateClientRequest {
  name: string;
  email: string;
}

export interface ListClientsResponse {
  items: Client[];
  total: number;
}

export const createClient = async (client: any) => {
  try {
    const response = await api.post("/api/v1/clients", client);
    return response.data;
  } catch (error) {
    throw error;
  }
};

export const listClients = (skip = 0, limit = 10) =>
  api.get<Client[]>(`/api/v1/clients/?skip=${skip}&limit=${limit}`);
export const getClient = (clientId: string) =>
  api.get<Client>(`/api/v1/clients/${clientId}`);
export const updateClient = (clientId: string, data: UpdateClientRequest) =>
  api.put<Client>(`/api/v1/clients/${clientId}`, data);
export const deleteClient = async (id: string) => {
  try {
    const response = await api.delete(`/api/v1/clients/${id}`);
    return response.data;
  } catch (error) {
    throw error;
  }
};

export const impersonateClient = async (id: string) => {
  try {
    const response = await api.post(`/api/v1/clients/${id}/impersonate`);
    return response.data;
  } catch (error) {
    throw error;
  }
};


--- frontend/lib/env.ts ---
import { env } from 'next-runtime-env';

export const getEnv = (key: string, defaultValue?: string): string => {
  try {
    const value = env(key);
    return value || defaultValue || '';
  } catch (error) {
    console.error(`Error getting environment variable ${key}:`, error);
    return defaultValue || '';
  }
};

export const getApiUrl = (): string => {
  return getEnv('NEXT_PUBLIC_API_URL', 'https://api-evoai.evoapicloud.com');
}; 

--- migrations/env.py ---
import asyncio
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import create_async_engine

from sqlalchemy.ext.asyncio import AsyncEngine

from alembic import context

from src.models.models import Base
from src.config.settings import settings

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Sobrescreve a URL do banco de dados com a definida nas configura√ß√µes
config.set_main_option("sqlalchemy.url", settings.POSTGRES_CONNECTION_STRING)

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = [Base.metadata]

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.

# Lista de tabelas a serem ignoradas na gera√ß√£o autom√°tica de migra√ß√µes
exclude_tables = ["sessions", "events", "app_states", "user_states"]


def include_object(object, name, type_, reflected, compare_to):
    """
    Fun√ß√£o de filtro para excluir determinadas tabelas da gera√ß√£o autom√°tica de migra√ß√µes
    """
    if type_ == "table" and name in exclude_tables:
        return False
    return True


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        include_object=include_object,
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = context.config.attributes.get("connection", None)
    if connectable is None:
        connectable = create_async_engine(
            context.config.get_main_option("sqlalchemy.url").replace(
                "postgresql://", "postgresql+asyncpg://"
            ),
            poolclass=pool.NullPool,
            future=True,
        )

    if isinstance(connectable, AsyncEngine):
        asyncio.run(run_async_migrations(connectable))
    else:
        do_run_migrations(connectable)


async def run_async_migrations(connectable):
    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)
    await connectable.dispose()


def do_run_migrations(connection):
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,
        include_object=include_object,
    )
    with context.begin_transaction():
        context.run_migrations()


run_migrations_online()


--- migrations/versions/2df073c7b564_add_task_agent_type_agents_table.py ---
"""add_task_agent_type_agents_table

Revision ID: 2df073c7b564
Revises: 611d84e70bb2
Create Date: 2025-05-14 11:46:39.573247

"""

from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = "2df073c7b564"
down_revision: Union[str, None] = "611d84e70bb2"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint("check_agent_type", "agents", type_="check")
    op.create_check_constraint(
        "check_agent_type",
        "agents",
        "type IN ('llm', 'sequential', 'parallel', 'loop', 'a2a', 'workflow', 'crew_ai', 'task')",
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint("check_agent_type", "agents", type_="check")
    op.create_check_constraint(
        "check_agent_type",
        "agents",
        "type IN ('llm', 'sequential', 'parallel', 'loop', 'a2a', 'workflow', 'crew_ai')",
    )
    # ### end Alembic commands ###


--- migrations/versions/611d84e70bb2_add_crew_ai_coluns_agents_table.py ---
"""add_crew_ai_coluns_agents_table

Revision ID: 611d84e70bb2
Revises: bdc5d363e2e1
Create Date: 2025-05-14 07:31:08.741620

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '611d84e70bb2'
down_revision: Union[str, None] = 'bdc5d363e2e1'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('agents', sa.Column('role', sa.String(), nullable=True))
    op.add_column('agents', sa.Column('goal', sa.Text(), nullable=True))
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('agents', 'goal')
    op.drop_column('agents', 'role')
    # ### end Alembic commands ###


--- migrations/versions/6db4a526335b_init_migrations.py ---
"""init migrations

Revision ID: 6db4a526335b
Revises: 
Create Date: 2025-05-07 13:30:04.971294

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '6db4a526335b'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('clients',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_clients_email'), 'clients', ['email'], unique=True)
    op.create_table('mcp_servers',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('config_type', sa.String(), nullable=False),
    sa.Column('config_json', sa.JSON(), nullable=False),
    sa.Column('environments', sa.JSON(), nullable=False),
    sa.Column('tools', sa.JSON(), nullable=False),
    sa.Column('type', sa.String(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.CheckConstraint("config_type IN ('studio', 'sse')", name='check_mcp_server_config_type'),
    sa.CheckConstraint("type IN ('official', 'community')", name='check_mcp_server_type'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('tools',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('config_json', sa.JSON(), nullable=False),
    sa.Column('environments', sa.JSON(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('agent_folders',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('client_id', sa.UUID(), nullable=True),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['client_id'], ['clients.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('api_keys',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('client_id', sa.UUID(), nullable=True),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('provider', sa.String(), nullable=False),
    sa.Column('encrypted_key', sa.String(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.ForeignKeyConstraint(['client_id'], ['clients.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('users',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('password_hash', sa.String(), nullable=False),
    sa.Column('client_id', sa.UUID(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('is_admin', sa.Boolean(), nullable=True),
    sa.Column('email_verified', sa.Boolean(), nullable=True),
    sa.Column('verification_token', sa.String(), nullable=True),
    sa.Column('verification_token_expiry', sa.DateTime(timezone=True), nullable=True),
    sa.Column('password_reset_token', sa.String(), nullable=True),
    sa.Column('password_reset_expiry', sa.DateTime(timezone=True), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['client_id'], ['clients.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_table('agents',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('client_id', sa.UUID(), nullable=True),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('type', sa.String(), nullable=False),
    sa.Column('model', sa.String(), nullable=True),
    sa.Column('api_key_id', sa.UUID(), nullable=True),
    sa.Column('instruction', sa.Text(), nullable=True),
    sa.Column('agent_card_url', sa.String(), nullable=True),
    sa.Column('folder_id', sa.UUID(), nullable=True),
    sa.Column('config', sa.JSON(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.CheckConstraint("type IN ('llm', 'sequential', 'parallel', 'loop', 'a2a', 'workflow')", name='check_agent_type'),
    sa.ForeignKeyConstraint(['api_key_id'], ['api_keys.id'], ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['client_id'], ['clients.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['folder_id'], ['agent_folders.id'], ondelete='SET NULL'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('audit_logs',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=True),
    sa.Column('action', sa.String(), nullable=False),
    sa.Column('resource_type', sa.String(), nullable=False),
    sa.Column('resource_id', sa.String(), nullable=True),
    sa.Column('details', sa.JSON(), nullable=True),
    sa.Column('ip_address', sa.String(), nullable=True),
    sa.Column('user_agent', sa.String(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='SET NULL'),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('audit_logs')
    op.drop_table('agents')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
    op.drop_table('api_keys')
    op.drop_table('agent_folders')
    op.drop_table('tools')
    op.drop_table('mcp_servers')
    op.drop_index(op.f('ix_clients_email'), table_name='clients')
    op.drop_table('clients')
    # ### end Alembic commands ###


--- migrations/versions/bdc5d363e2e1_add_crew_ai_agent_type_agents_table.py ---
"""add_crew_ai_agent_type_agents_table

Revision ID: bdc5d363e2e1
Revises: 6db4a526335b
Create Date: 2025-05-14 06:23:14.701878

"""

from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = "bdc5d363e2e1"
down_revision: Union[str, None] = "6db4a526335b"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint("check_agent_type", "agents", type_="check")
    op.create_check_constraint(
        "check_agent_type",
        "agents",
        "type IN ('llm', 'sequential', 'parallel', 'loop', 'a2a', 'workflow', 'crew_ai')",
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint("check_agent_type", "agents", type_="check")
    op.create_check_constraint(
        "check_agent_type",
        "agents",
        "type IN ('llm', 'sequential', 'parallel', 'loop', 'a2a', 'workflow')",
    )
    # ### end Alembic commands ###


--- scripts/run_seeders.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: run_seeders.py                                                        ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

"""
Main script to run all seeders in sequence.
Checks dependencies between seeders and runs them in the correct order.
"""

import os
import sys
import logging
import argparse
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Import seeders
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from scripts.seeders.admin_seeder import create_admin_user
from scripts.seeders.client_seeder import create_demo_client_and_user
from scripts.seeders.mcp_server_seeder import create_mcp_servers
from scripts.seeders.tool_seeder import create_tools


def setup_environment():
    """Configure the environment for seeders"""
    load_dotenv()

    # Check if essential environment variables are defined
    required_vars = ["POSTGRES_CONNECTION_STRING"]
    missing_vars = [var for var in required_vars if not os.getenv(var)]

    if missing_vars:
        logger.error(
            f"Required environment variables not defined: {', '.join(missing_vars)}"
        )
        return False

    return True


def run_seeders(seeders):
    """
    Run the specified seeders

    Args:
        seeders (list): List of seeders to run

    Returns:
        bool: True if all seeders were executed successfully, False otherwise
    """
    all_seeders = {
        "admin": create_admin_user,
        "client": create_demo_client_and_user,
        "mcp_servers": create_mcp_servers,
        "tools": create_tools,
    }

    # Define the correct execution order (dependencies)
    seeder_order = ["admin", "client", "mcp_servers", "tools"]

    # If no seeder is specified, run all
    if not seeders:
        seeders = seeder_order
    else:
        # Check if all specified seeders exist
        invalid_seeders = [s for s in seeders if s not in all_seeders]
        if invalid_seeders:
            logger.error(f"Invalid seeders: {', '.join(invalid_seeders)}")
            logger.info(f"Available seeders: {', '.join(all_seeders.keys())}")
            return False

        # Ensure seeders are executed in the correct order
        seeders = [s for s in seeder_order if s in seeders]

    # Run seeders
    success = True
    for seeder_name in seeders:
        logger.info(f"Running seeder: {seeder_name}")

        try:
            seeder_func = all_seeders[seeder_name]
            if not seeder_func():
                logger.error(f"Failed to run seeder: {seeder_name}")
                success = False
        except Exception as e:
            logger.error(f"Error running seeder {seeder_name}: {str(e)}")
            success = False

    return success


def main():
    """Main function"""
    parser = argparse.ArgumentParser(description="Run seeders to populate the database")
    parser.add_argument(
        "--seeders",
        nargs="+",
        help="Seeders to run (admin, client, mcp_servers, tools)",
    )
    args = parser.parse_args()

    # Configure environment
    if not setup_environment():
        sys.exit(1)

    # Run seeders
    success = run_seeders(args.seeders)

    # Output
    if success:
        logger.info("All seeders were executed successfully")
        sys.exit(0)
    else:
        logger.error("There were errors running the seeders")
        sys.exit(1)


if __name__ == "__main__":
    main()


--- scripts/seeders/admin_seeder.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: admin_seeder.py                                                       ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

"""
Script to create an initial admin user:
- Email: admin@evoai.com
- Password: defined in the ADMIN_INITIAL_PASSWORD environment variable
- is_admin: True
- is_active: True
- email_verified: True
"""

import os
import sys
import logging
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
from src.models.models import User
from src.utils.security import get_password_hash

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def create_admin_user():
    """Create an initial admin user in the system"""
    try:
        # Load environment variables
        load_dotenv()

        # Get database settings
        db_url = os.getenv("POSTGRES_CONNECTION_STRING")
        if not db_url:
            logger.error("Environment variable POSTGRES_CONNECTION_STRING not defined")
            return False

        # Get admin password
        admin_password = os.getenv("ADMIN_INITIAL_PASSWORD")
        if not admin_password:
            logger.error("Environment variable ADMIN_INITIAL_PASSWORD not defined")
            return False

        # Admin email configuration
        admin_email = os.getenv("ADMIN_EMAIL", "admin@evoai.com")

        # Connect to the database
        engine = create_engine(db_url)
        Session = sessionmaker(bind=engine)
        session = Session()

        # Verify if the admin already exists
        existing_admin = session.query(User).filter(User.email == admin_email).first()
        if existing_admin:
            logger.info(f"Admin with email {admin_email} already exists")
            return True

        # Create admin
        admin_user = User(
            email=admin_email,
            password_hash=get_password_hash(admin_password),
            is_admin=True,
            is_active=True,
            email_verified=True,
        )

        # Add and commit
        session.add(admin_user)
        session.commit()

        logger.info(f"Admin created successfully: {admin_email}")
        return True

    except Exception as e:
        logger.error(f"Error creating admin: {str(e)}")
        return False
    finally:
        session.close()


if __name__ == "__main__":
    success = create_admin_user()
    sys.exit(0 if success else 1)


--- scripts/seeders/client_seeder.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: client_seeder.py                                                      ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

"""
Script to create a demo client:
- Name: Demo Client
- With associated user:
  - Email: demo@example.com
  - Password: demo123 (or defined in environment variable)
  - is_admin: False
  - is_active: True
  - email_verified: True
"""

import os
import sys
import logging
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
from dotenv import load_dotenv
from src.models.models import User, Client
from src.utils.security import get_password_hash

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def create_demo_client_and_user():
    """Create a demo client and user in the system"""
    try:
        # Load environment variables
        load_dotenv()

        # Get database settings
        db_url = os.getenv("POSTGRES_CONNECTION_STRING")
        if not db_url:
            logger.error("Environment variable POSTGRES_CONNECTION_STRING not defined")
            return False

        # Get demo user password (or use default)
        demo_password = os.getenv("DEMO_PASSWORD", "demo123")

        # Demo client and user settings
        demo_client_name = os.getenv("DEMO_CLIENT_NAME", "Demo Client")
        demo_email = os.getenv("DEMO_EMAIL", "demo@example.com")

        # Connect to the database
        engine = create_engine(db_url)
        Session = sessionmaker(bind=engine)
        session = Session()

        try:
            # Check if the user already exists
            existing_user = session.query(User).filter(User.email == demo_email).first()
            if existing_user:
                logger.info(f"Demo user with email {demo_email} already exists")
                return True

            # Create demo client
            demo_client = Client(name=demo_client_name, email=demo_email)
            session.add(demo_client)
            session.flush()  # Get the client ID

            # Create demo user associated with the client
            demo_user = User(
                email=demo_email,
                password_hash=get_password_hash(demo_password),
                client_id=demo_client.id,
                is_admin=False,
                is_active=True,
                email_verified=True,
            )

            # Add and commit
            session.add(demo_user)
            session.commit()

            logger.info(f"Demo client '{demo_client_name}' created successfully")
            logger.info(f"Demo user created successfully: {demo_email}")
            return True

        except SQLAlchemyError as e:
            session.rollback()
            logger.error(f"Database error when creating demo client/user: {str(e)}")
            return False

    except Exception as e:
        logger.error(f"Error when creating demo client/user: {str(e)}")
        return False
    finally:
        session.close()


if __name__ == "__main__":
    success = create_demo_client_and_user()
    sys.exit(0 if success else 1)


--- scripts/seeders/mcp_server_seeder.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: mcp_server_seeder.py                                                  ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

"""
Script to create default MCP servers:
- Brave Search
- Github
- Sequential Thinking
- Gitlab
- Airbnb
- Serper
- Firecrawl
Each with specific configurations
"""

import os
import sys
import json
import logging
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
from dotenv import load_dotenv
from src.models.models import MCPServer
import uuid

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def create_mcp_servers():
    """Create default MCP servers in the system"""
    try:
        # Load environment variables
        load_dotenv()

        # Get database settings
        db_url = os.getenv("POSTGRES_CONNECTION_STRING")
        if not db_url:
            logger.error("Environment variable POSTGRES_CONNECTION_STRING not defined")
            return False

        # Connect to the database
        engine = create_engine(db_url)
        Session = sessionmaker(bind=engine)
        session = Session()

        try:
            # Check if there are already MCP servers
            existing_servers = session.query(MCPServer).all()
            if existing_servers:
                logger.info(
                    f"There are already {len(existing_servers)} MCP servers registered"
                )
                return True

            # MCP servers definitions
            mcp_servers = [
                {
                    "id": "b73dc2e8-9d91-4167-a8f1-1102c42af3d2",
                    "name": "Brave Search",
                    "description": "Brave Search allows you to seamlessly integrate Brave Search functionality into AI assistants like Claude. By implementing a Model Context Protocol (MCP) server, it enables the AI to leverage Brave Search's web search and local business search capabilities. It provides tools for both general web searches and specific local searches, enhancing the AI assistant's ability to provide relevant and up-to-date information.",
                    "config_type": "studio",
                    "config_json": {
                        "command": "npx",
                        "args": ["-y", "@modelcontextprotocol/server-brave-search"],
                        "env": {"BRAVE_API_KEY": "env@@BRAVE_API_KEY"},
                    },
                    "environments": {"BRAVE_API_KEY": "env@@BRAVE_API_KEY"},
                    "tools": [
                        {
                            "id": "brave_web_search",
                            "name": "Web Search",
                            "description": "Perform web searches using Brave Search",
                            "tags": ["search", "web"],
                            "examples": [
                                "Search for Python documentation",
                                "Find information about AI",
                            ],
                            "inputModes": ["text"],
                            "outputModes": ["application/json"],
                        },
                        {
                            "id": "brave_local_search",
                            "name": "Local Search",
                            "description": "Search for local businesses and places",
                            "tags": ["search", "local"],
                            "examples": [
                                "Find restaurants near me",
                                "Search for hotels in New York",
                            ],
                            "inputModes": ["text"],
                            "outputModes": ["application/json"],
                        },
                    ],
                    "type": "official",
                },
                {
                    "id": "49c7b182-b341-4cc4-864c-7ae623ba41a7",
                    "name": "Github",
                    "description": "The GitHub MCP Server is a Model Context Protocol (MCP) server that provides seamless integration with GitHub APIs, enabling advanced automation and interaction capabilities for developers and tools.",
                    "config_type": "studio",
                    "config_json": {
                        "command": "docker",
                        "args": [
                            "run",
                            "-i",
                            "--rm",
                            "-e",
                            "GITHUB_PERSONAL_ACCESS_TOKEN",
                            "ghcr.io/github/github-mcp-server",
                        ],
                        "env": {
                            "GITHUB_PERSONAL_ACCESS_TOKEN": "env@@GITHUB_PERSONAL_ACCESS_TOKEN"
                        },
                    },
                    "environments": {
                        "GITHUB_PERSONAL_ACCESS_TOKEN": "env@@GITHUB_PERSONAL_ACCESS_TOKEN"
                    },
                    "tools": [
                        {
                            "id": "get_me",
                            "name": "get_me",
                            "description": "Get details of the authenticated user",
                            "tags": ["users,authentication,github"],
                            "examples": ["get me"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_issue",
                            "name": "get_issue",
                            "description": "Gets the contents of an issue within a repository",
                            "tags": ["issues,repository,read,github"],
                            "examples": ["get issue"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_issue_comments",
                            "name": "get_issue_comments",
                            "description": "Get comments for a GitHub issue",
                            "tags": ["issues,comments,read,github"],
                            "examples": ["get issue comments"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_issue",
                            "name": "create_issue",
                            "description": "Create a new issue in a GitHub repository",
                            "tags": ["issues,create,github"],
                            "examples": ["create issue"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "add_issue_comment",
                            "name": "add_issue_comment",
                            "description": "Add a comment to an issue",
                            "tags": ["issues,comments,create,github"],
                            "examples": ["add issue comment"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "list_issues",
                            "name": "list_issues",
                            "description": "List and filter repository issues",
                            "tags": ["issues,list,filter,github"],
                            "examples": ["list issues"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "update_issue",
                            "name": "update_issue",
                            "description": "Update an existing issue in a GitHub repository",
                            "tags": ["issues,update,github"],
                            "examples": ["update issue"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "search_issues",
                            "name": "search_issues",
                            "description": "Search for issues and pull requests",
                            "tags": ["issues,search,github"],
                            "examples": ["search issues"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_pull_request",
                            "name": "get_pull_request",
                            "description": "Get details of a specific pull request",
                            "tags": ["pull_requests,read"],
                            "examples": ["get pull request"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "list_pull_requests",
                            "name": "list_pull_requests",
                            "description": "List and filter repository pull requests",
                            "tags": ["pull_requests,list,filter,github"],
                            "examples": ["list pull requests"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "merge_pull_request",
                            "name": "merge_pull_request",
                            "description": "Merge a pull request",
                            "tags": ["pull_requests,merge,github"],
                            "examples": ["merge pull request"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_pull_request_files",
                            "name": "get_pull_request_files",
                            "description": "Get the list of files changed in a pull request",
                            "tags": ["pull_requests,files,read,github"],
                            "examples": ["get pull request files"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_pull_request_status",
                            "name": "get_pull_request_status",
                            "description": "Get the combined status of all status checks for a pull request",
                            "tags": ["pull_requests,status,read,github"],
                            "examples": ["get pull request status"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "update_pull_request_branch",
                            "name": "update_pull_request_branch",
                            "description": "Update a pull request branch with the latest changes from the base branch",
                            "tags": ["pull_requests,branch,update,github"],
                            "examples": ["update pull request branch"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_pull_request_comments",
                            "name": "get_pull_request_comments",
                            "description": "Get the review comments on a pull request",
                            "tags": ["pull_requests,comments,read,github"],
                            "examples": ["get pull request comments"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_pull_request_reviews",
                            "name": "get_pull_request_reviews",
                            "description": "Get the reviews on a pull request",
                            "tags": ["pull_requests,reviews,read,github"],
                            "examples": ["get pull request reviews"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_pull_request_review",
                            "name": "create_pull_request_review",
                            "description": "Create a review on a pull request review",
                            "tags": ["pull_requests,reviews,create,github"],
                            "examples": ["create pull request review"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_pull_request",
                            "name": "create_pull_request",
                            "description": "Create a new pull request",
                            "tags": ["pull_requests,create,github"],
                            "examples": ["create pull request"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "add_pull_request_review_comment",
                            "name": "add_pull_request_review_comment",
                            "description": "Add a review comment to a pull request or reply to an existing comment",
                            "tags": ["pull_requests,reviews,comments,create,github"],
                            "examples": ["add pull request review comment"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "update_pull_request",
                            "name": "update_pull_request",
                            "description": "Update an existing pull request in a GitHub repository",
                            "tags": ["pull_requests,update,github"],
                            "examples": ["update pull request"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_or_update_file",
                            "name": "create_or_update_file",
                            "description": "Create or update a single file in a repository",
                            "tags": ["repos,file,create,update,github"],
                            "examples": ["create or update file"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "list_branches",
                            "name": "list_branches",
                            "description": "List branches in a GitHub repository",
                            "tags": ["repos,branches,list,github"],
                            "examples": ["list branches"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "push_files",
                            "name": "push_files",
                            "description": "Push multiple files in a single commit",
                            "tags": ["repos,files,push,github"],
                            "examples": ["push files"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "search_repositories",
                            "name": "search_repositories",
                            "description": "Search for GitHub repositories",
                            "tags": ["repos,search,github"],
                            "examples": ["search repositories"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_repository",
                            "name": "create_repository",
                            "description": "Create a new GitHub repository",
                            "tags": ["repos,create,github"],
                            "examples": ["create repository"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_file_contents",
                            "name": "get_file_contents",
                            "description": "Get contents of a file or directory",
                            "tags": ["repos,file,read,github"],
                            "examples": ["get file contents"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "fork_repository",
                            "name": "fork_repository",
                            "description": "Fork a repository",
                            "tags": ["repos,fork,github"],
                            "examples": ["fork repository"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_branch",
                            "name": "create_branch",
                            "description": "Create a new branch",
                            "tags": ["repos,branch,create,github"],
                            "examples": ["create branch"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "list_commits",
                            "name": "list_commits",
                            "description": "Get a list of commits of a branch in a repository",
                            "tags": ["repos,commits,list,github"],
                            "examples": ["list commits"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_commit",
                            "name": "get_commit",
                            "description": "Get details for a commit from a repository",
                            "tags": ["repos,commit,read,github"],
                            "examples": ["get commit"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "search_code",
                            "name": "search_code",
                            "description": "Search for code across GitHub repositories",
                            "tags": ["repos,code,search,github"],
                            "examples": ["search code"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "search_users",
                            "name": "search_users",
                            "description": "Search for GitHub users",
                            "tags": ["users,search,github"],
                            "examples": ["search users"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_code_scanning_alert",
                            "name": "get_code_scanning_alert",
                            "description": "Get a code scanning alert",
                            "tags": ["code_security,alert,github"],
                            "examples": ["get code scanning alert"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "list_code_scanning_alerts",
                            "name": "list_code_scanning_alerts",
                            "description": "List code scanning alerts for a repository",
                            "tags": ["code_security,alerts,github"],
                            "examples": ["list code scanning alerts"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "get_secret_scanning_alert",
                            "name": "get_secret_scanning_alert",
                            "description": "Get a secret scanning alert",
                            "tags": ["code_security,alert,secret,github"],
                            "examples": ["get secret scanning alert"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "list_secret_scanning_alerts",
                            "name": "list_secret_scanning_alerts",
                            "description": "List secret scanning alerts for a repository",
                            "tags": ["code_security,alerts,secret,github"],
                            "examples": ["list secret scanning alerts"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                    ],
                    "type": "official",
                },
                {
                    "id": "6e878520-4a49-45f8-b42c-621bffcf70bf",
                    "name": "Sequential Thinking",
                    "description": "Sequential Thinking helps users organize their thoughts and break down complex problems through a structured workflow. By guiding users through defined cognitive stages like Problem Definition, Research, Analysis, Synthesis, and Conclusion, it provides a framework for progressive thinking. The server tracks the progression of your thinking process, identifies connections between similar thoughts, monitors progress, and generates summaries, making it easier to approach challenges methodically and reach well-reasoned conclusions.",
                    "config_type": "studio",
                    "config_json": {
                        "command": "npx",
                        "args": [
                            "-y",
                            "@modelcontextprotocol/server-sequential-thinking",
                        ],
                        "env": {},
                    },
                    "environments": {},
                    "tools": [
                        {
                            "id": "sequentialthinking",
                            "name": "Sequential Thinking",
                            "description": "Helps organize thoughts and break down complex problems through a structured workflow",
                            "tags": ["thinking", "analysis", "problem-solving"],
                            "examples": [
                                "Help me analyze this problem",
                                "Guide me through this decision making process",
                            ],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        }
                    ],
                    "type": "official",
                },
                {
                    "id": "b626b528-13ac-4d63-aa74-c4acecde9e29",
                    "name": "Gitlab",
                    "description": "MCP Server for the GitLab API, enabling project management, file operations, and more.",
                    "config_type": "studio",
                    "config_json": {
                        "command": "npx",
                        "args": ["-y", "@modelcontextprotocol/server-gitlab"],
                        "env": {
                            "GITLAB_PERSONAL_ACCESS_TOKEN": "env@@GITLAB_PERSONAL_ACCESS_TOKEN",
                            "GITLAB_API_URL": "env@@GITLAB_API_URL",
                        },
                    },
                    "environments": {
                        "GITLAB_PERSONAL_ACCESS_TOKEN": "env@@GITLAB_PERSONAL_ACCESS_TOKEN",
                        "GITLAB_API_URL": "env@@GITLAB_API_URL",
                    },
                    "tools": [
                        {
                            "id": "create_or_update_file",
                            "name": "create_or_update_file",
                            "description": "Create or update a single file in a project",
                            "tags": ["repos", "files", "create", "update", "gitlab"],
                            "examples": ["create or update file"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "push_files",
                            "name": "push_files",
                            "description": "Push multiple files in a single commit",
                            "tags": ["repos", "files", "push", "gitlab"],
                            "examples": ["push files"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "search_repositories",
                            "name": "search_repositories",
                            "description": "Search for GitLab projects",
                            "tags": ["repos", "search", "gitlab"],
                            "examples": ["search repositories"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_repository",
                            "name": "create_repository",
                            "description": "Create a new GitLab project",
                            "tags": ["repos", "create", "gitlab"],
                            "examples": ["create repository"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_issue",
                            "name": "create_issue",
                            "description": "Create a new issue",
                            "tags": ["issues", "create", "gitlab"],
                            "examples": ["create issue"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_merge_request",
                            "name": "create_merge_request",
                            "description": "Create a new merge request",
                            "tags": ["merge_requests", "create", "gitlab"],
                            "examples": ["create merge request"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "fork_repository",
                            "name": "fork_repository",
                            "description": "Fork a project",
                            "tags": ["repos", "fork", "gitlab"],
                            "examples": ["fork repository"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "create_branch",
                            "name": "create_branch",
                            "description": "Create a new branch",
                            "tags": ["branches", "create", "gitlab"],
                            "examples": ["create branch"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                    ],
                    "type": "official",
                },
                {
                    "id": "7bb73ef1-22da-4c05-a05d-d31db4243560",
                    "name": "Airbnb",
                    "description": "MCP Server for searching Airbnb and get listing details.",
                    "config_type": "studio",
                    "config_json": {
                        "command": "npx",
                        "args": ["-y", "@openbnb/mcp-server-airbnb"],
                        "env": {},
                    },
                    "environments": {},
                    "tools": [
                        {
                            "id": "airbnb_search",
                            "name": "airbnb_search",
                            "description": "Search for Airbnb listings.",
                            "tags": ["airbnb", "search", "listings", "travel"],
                            "examples": ["search airbnb listings"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "airbnb_listing_details",
                            "name": "airbnb_listing_details",
                            "description": "Get detailed information about a specific Airbnb listing.",
                            "tags": ["airbnb", "listings", "details", "travel"],
                            "examples": ["get airbnb listing details"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                    ],
                    "type": "official",
                },
                {
                    "id": "ae214cb1-92f0-473c-93a3-e2075884bf4d",
                    "name": "Serper",
                    "description": "A TypeScript-based MCP server that provides web search and webpage scraping capabilities using the Serper API. This server integrates with Claude Desktop to enable powerful web search and content extraction features.",
                    "config_type": "studio",
                    "config_json": {
                        "command": "npx",
                        "args": ["-y", "serper-search-scrape-mcp-server"],
                        "env": {"SERPER_API_KEY": "env@@SERPER_API_KEY"},
                    },
                    "environments": {"SERPER_API_KEY": "env@@SERPER_API_KEY"},
                    "tools": [
                        {
                            "id": "google_search",
                            "name": "google_search",
                            "description": 'Perform web searches via the Serper API, returning rich results such as organic hits, knowledge graph data, "people also ask", related searches, and supporting region/language targeting, pagination, autocorrection and advanced search operators.',
                            "tags": [
                                "search",
                                "web",
                                "information_retrieval",
                                "serper_api",
                            ],
                            "examples": ["search web for Rust programming tutorials"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "scrape",
                            "name": "scrape",
                            "description": "Extract content from web pages, returning plain text or optional markdown, including JSON-LD and head metadata, while preserving document structure.",
                            "tags": [
                                "web_scraping",
                                "content_extraction",
                                "text_processing",
                                "api",
                            ],
                            "examples": ["scrape https://example.com/article"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                    ],
                    "type": "official",
                },
                {
                    "id": "01bcc7ef-a6a5-4264-9e47-9f565499eaaa",
                    "name": "Firecrawl",
                    "description": "A Model Context Protocol (MCP) server implementation that integrates with Firecrawl for web scraping capabilities.",
                    "config_type": "studio",
                    "config_json": {
                        "command": "npx",
                        "args": ["-y", "firecrawl-mcp"],
                        "env": {"FIRECRAWL_API_KEY": "env@@FIRECRAWL_API_KEY"},
                    },
                    "environments": {"FIRECRAWL_API_KEY": "env@@FIRECRAWL_API_KEY"},
                    "tools": [
                        {
                            "id": "firecrawl_scrape",
                            "name": "firecrawl_scrape",
                            "description": "Scrape content from a single URL with advanced options (formats, main-content only, JS rendering, etc.).",
                            "tags": [
                                "scraping",
                                "web",
                                "content_extraction",
                                "firecrawl",
                            ],
                            "examples": ["firecrawl_scrape https://example.com"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "firecrawl_batch_scrape",
                            "name": "firecrawl_batch_scrape",
                            "description": "Scrape multiple URLs efficiently using built-in rate limiting and parallel processing. ",
                            "tags": ["scraping", "batch_processing", "parallel"],
                            "examples": [
                                "firecrawl_batch_scrape https://site1.com",
                                "https://site2.com",
                            ],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "firecrawl_check_batch_status",
                            "name": "firecrawl_check_batch_status",
                            "description": "Check the status of a previously queued batch scrape operation.",
                            "tags": ["scraping", "batch_processing", "monitoring"],
                            "examples": ["firecrawl_check_batch_status batch_1"],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "firecrawl_search",
                            "name": "firecrawl_search",
                            "description": "Perform a web search and optionally scrape content from the top results.",
                            "tags": ["search", "web", "scraping"],
                            "examples": [
                                "firecrawl_search how does carbon capture technology work"
                            ],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "firecrawl_crawl",
                            "name": "firecrawl_crawl",
                            "description": "Start an asynchronous crawl from a seed URL with options for depth, link limits, deduplication, etc.",
                            "tags": ["crawling", "web", "link_discovery"],
                            "examples": [
                                "firecrawl_crawl https://example.com --maxDepth 2 --limit 100"
                            ],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "firecrawl_extract",
                            "name": "firecrawl_extract",
                            "description": "Extract structured data from one or more pages using LLM-guided prompts and a JSON schema.",
                            "tags": ["extraction", "llm", "structured_data"],
                            "examples": [
                                "firecrawl_extract https://site.com/page1",
                                "https://site.com/page2",
                            ],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "firecrawl_deep_research",
                            "name": "firecrawl_deep_research",
                            "description": "Conduct deep web research on a topic by combining crawling, search, and LLM analysis into a single workflow.",
                            "tags": ["research", "web", "llm_analysis"],
                            "examples": [
                                "firecrawl_deep_research impact of renewable energy subsidies"
                            ],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                        {
                            "id": "firecrawl_generate_llmstxt",
                            "name": "firecrawl_generate_llmstxt",
                            "description": "Generate a standardized llms.txt (and optionally llms-full.txt) file for a domain, guiding how LLMs should interact with that site.",
                            "tags": ["site_policy", "metadata", "llms"],
                            "examples": [
                                "firecrawl_generate_llmstxt https://example.com"
                            ],
                            "inputModes": ["text"],
                            "outputModes": ["text"],
                        },
                    ],
                    "type": "official",
                },
            ]

            # Create the MCP servers
            for server_data in mcp_servers:
                server = MCPServer(
                    id=uuid.UUID(server_data["id"]),
                    name=server_data["name"],
                    description=server_data["description"],
                    config_type=server_data["config_type"],
                    config_json=server_data["config_json"],
                    environments=server_data["environments"],
                    tools=server_data["tools"],
                    type=server_data["type"],
                )

                session.add(server)
                logger.info(f"MCP server '{server_data['name']}' created successfully")

            session.commit()
            logger.info("All MCP servers were created successfully")
            return True

        except SQLAlchemyError as e:
            session.rollback()
            logger.error(f"Database error when creating MCP servers: {str(e)}")
            return False
        finally:
            session.close()

    except Exception as e:
        logger.error(f"Error when creating MCP servers: {str(e)}")
        return False


if __name__ == "__main__":
    success = create_mcp_servers()
    sys.exit(0 if success else 1)


--- scripts/seeders/tool_seeder.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: tool_seeder.py                                                        ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

"""
Script to create default tools:
-
Each with basic configurations for demonstration
"""

import os
import sys
import logging
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
from dotenv import load_dotenv
from src.models.models import Tool

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def create_tools():
    """Create default tools in the system"""
    try:
        # Load environment variables
        load_dotenv()

        # Get database settings
        db_url = os.getenv("POSTGRES_CONNECTION_STRING")
        if not db_url:
            logger.error("Environment variable POSTGRES_CONNECTION_STRING not defined")
            return False

        # Connect to the database
        engine = create_engine(db_url)
        Session = sessionmaker(bind=engine)
        session = Session()

        try:
            # Check if there are already tools
            existing_tools = session.query(Tool).all()
            if existing_tools:
                logger.info(f"There are already {len(existing_tools)} tools registered")
                return True

            # Tools definitions
            tools = []

            # Create the tools
            for tool_data in tools:

                tool = Tool(
                    name=tool_data["name"],
                    description=tool_data["description"],
                    config_json=tool_data["config_json"],
                    environments=tool_data["environments"],
                )

                session.add(tool)
                logger.info(f"Tool '{tool_data['name']}' created successfully")

            session.commit()
            logger.info("All tools were created successfully")
            return True

        except SQLAlchemyError as e:
            session.rollback()
            logger.error(f"Database error when creating tools: {str(e)}")
            return False

    except Exception as e:
        logger.error(f"Error when creating tools: {str(e)}")
        return False
    finally:
        session.close()


if __name__ == "__main__":
    success = create_tools()
    sys.exit(0 if success else 1)


--- src/__init__.py ---
"""
Main package of the application
"""


--- src/main.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: main.py                                                               ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

import os
import sys
from pathlib import Path
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from src.config.database import engine, Base
from src.config.settings import settings
from src.utils.logger import setup_logger
from src.utils.otel import init_otel

# Necessary for other modules
from src.services.service_providers import session_service  # noqa: F401
from src.services.service_providers import artifacts_service  # noqa: F401
from src.services.service_providers import memory_service  # noqa: F401

import src.api.auth_routes
import src.api.admin_routes
import src.api.chat_routes
import src.api.session_routes
import src.api.agent_routes
import src.api.mcp_server_routes
import src.api.tool_routes
import src.api.client_routes
import src.api.a2a_routes

# Add the root directory to PYTHONPATH
root_dir = Path(__file__).parent.parent
sys.path.append(str(root_dir))

# Configure logger
logger = setup_logger(__name__)

# FastAPI initialization
app = FastAPI(
    title=settings.API_TITLE,
    description=settings.API_DESCRIPTION,
    version=settings.API_VERSION,
    redirect_slashes=False,
)

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins in development
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Static files configuration
static_dir = Path("static")
if not static_dir.exists():
    static_dir.mkdir(parents=True)
app.mount("/static", StaticFiles(directory=static_dir), name="static")

# PostgreSQL configuration
POSTGRES_CONNECTION_STRING = os.getenv(
    "POSTGRES_CONNECTION_STRING", "postgresql://postgres:root@localhost:5432/evo_ai"
)

# Create database tables
Base.metadata.create_all(bind=engine)

API_PREFIX = "/api/v1"

# Define router references
auth_router = src.api.auth_routes.router
admin_router = src.api.admin_routes.router
chat_router = src.api.chat_routes.router
session_router = src.api.session_routes.router
agent_router = src.api.agent_routes.router
mcp_server_router = src.api.mcp_server_routes.router
tool_router = src.api.tool_routes.router
client_router = src.api.client_routes.router
a2a_router = src.api.a2a_routes.router

# Include routes
app.include_router(auth_router, prefix=API_PREFIX)
app.include_router(admin_router, prefix=API_PREFIX)
app.include_router(mcp_server_router, prefix=API_PREFIX)
app.include_router(tool_router, prefix=API_PREFIX)
app.include_router(client_router, prefix=API_PREFIX)
app.include_router(chat_router, prefix=API_PREFIX)
app.include_router(session_router, prefix=API_PREFIX)
app.include_router(agent_router, prefix=API_PREFIX)
app.include_router(a2a_router, prefix=API_PREFIX)

# Inicializa o OpenTelemetry para Langfuse
init_otel()


@app.get("/")
def read_root():
    return {
        "message": "Welcome to Evo AI API",
        "documentation": "/docs",
        "version": settings.API_VERSION,
        "auth": "To access the API, use JWT authentication via '/api/v1/auth/login'",
    }


--- src/utils/a2a_enhanced_client.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: a2a_enhanced_client.py                                                ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

"""
Enhanced A2A Client that supports both custom implementation and official SDK.

This client provides a unified interface to communicate with A2A agents,
automatically detecting and using the best available implementation.
"""

import logging
import asyncio
import json
from typing import Dict, Any, Optional, AsyncIterator, Union, List
from uuid import uuid4, UUID
from dataclasses import dataclass
from enum import Enum

import httpx

try:
    from a2a.client import A2AClient as SDKClient
    from a2a.types import (
        SendMessageRequest,
        MessageSendParams,
        SendStreamingMessageRequest,
        Message as SDKMessage,
        TextPart as SDKTextPart,
        FilePart as SDKFilePart,
    )

    SDK_AVAILABLE = True
except ImportError:
    SDK_AVAILABLE = False
    logging.warning("a2a-sdk not available for enhanced client")

from src.schemas.a2a_types import (
    Message as CustomMessage,
    Task as CustomTask,
    TaskSendParams as CustomTaskSendParams,
    SendTaskRequest as CustomSendTaskRequest,
    SendTaskStreamingRequest as CustomSendTaskStreamingRequest,
)
from src.schemas.a2a_enhanced_types import (
    A2ATypeValidator,
    convert_to_sdk_format,
    convert_from_sdk_format,
)

logger = logging.getLogger(__name__)


class A2AImplementation(Enum):
    """A2A implementation type."""

    CUSTOM = "custom"
    SDK = "sdk"
    AUTO = "auto"


@dataclass
class A2AClientConfig:
    """A2A client configuration."""

    base_url: str
    api_key: str
    implementation: A2AImplementation = A2AImplementation.AUTO
    timeout: int = 30
    custom_headers: Optional[Dict[str, str]] = None


@dataclass
class A2AResponse:
    """A2A unified response."""

    success: bool
    data: Optional[Any] = None
    error: Optional[str] = None
    implementation_used: Optional[A2AImplementation] = None
    raw_response: Optional[Any] = None


class EnhancedA2AClient:
    """
    Enhanced A2A client that supports both custom implementation and official SDK.

    Automatically detects and uses the best available implementation
    and provides a unified interface for communication with A2A agents.
    """

    def __init__(self, config: A2AClientConfig):
        self.config = config
        self.httpx_client = None
        self.sdk_client = None
        self.available_implementations = []
        self._agent_cards_cache = {}

    async def __aenter__(self):
        """Context manager entry."""
        await self.initialize()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        await self.close()

    async def initialize(self):
        """Initialize the client and detect available implementations."""
        # Initialize HTTP client
        headers = {"x-api-key": self.config.api_key, "Content-Type": "application/json"}
        if self.config.custom_headers:
            headers.update(self.config.custom_headers)

        self.httpx_client = httpx.AsyncClient(
            timeout=self.config.timeout, headers=headers
        )

        # Detect available implementations
        await self._detect_available_implementations()

        # Initialize SDK client if available
        if A2AImplementation.SDK in self.available_implementations and SDK_AVAILABLE:
            await self._initialize_sdk_client()

    async def close(self):
        """Close client resources."""
        if self.httpx_client:
            await self.httpx_client.aclose()

        if self.sdk_client:
            # SDK client cleanup if needed
            pass

    async def _detect_available_implementations(self):
        """Detect which implementations are available on the server."""
        implementations = []

        # Test custom implementation
        try:
            custom_health_url = f"{self.config.base_url}/api/v1/a2a/health"
            response = await self.httpx_client.get(custom_health_url)
            if response.status_code == 200:
                implementations.append(A2AImplementation.CUSTOM)
                logger.info("Custom A2A implementation detected")
        except Exception as e:
            logger.debug(f"Custom implementation not available: {e}")

        # Test SDK implementation
        try:
            sdk_health_url = f"{self.config.base_url}/api/v1/a2a-sdk/health"
            response = await self.httpx_client.get(sdk_health_url)
            if response.status_code == 200:
                implementations.append(A2AImplementation.SDK)
                logger.info("SDK A2A implementation detected")
        except Exception as e:
            logger.debug(f"SDK implementation not available: {e}")

        self.available_implementations = implementations
        logger.info(
            f"Available A2A implementations: {[impl.value for impl in implementations]}"
        )

    async def _initialize_sdk_client(self):
        """Initialize SDK client if available."""
        if not SDK_AVAILABLE:
            logger.warning("SDK not available for client initialization")
            return

        try:
            # For the SDK client, we need to discover available agents
            # For now, we keep None and initialize as needed
            self.sdk_client = None
            logger.info("SDK client initialization prepared")
        except Exception as e:
            logger.error(f"Failed to initialize SDK client: {e}")

    def _choose_implementation(
        self, preferred: Optional[A2AImplementation] = None
    ) -> A2AImplementation:
        """Choose the best implementation based on preference and availability."""
        if preferred and preferred in self.available_implementations:
            return preferred

        if self.config.implementation != A2AImplementation.AUTO:
            if self.config.implementation in self.available_implementations:
                return self.config.implementation
            else:
                logger.warning(
                    f"Requested implementation {self.config.implementation.value} not available, "
                    f"falling back to auto-selection"
                )

        # Auto-selection: prefer SDK if available, otherwise custom
        if A2AImplementation.SDK in self.available_implementations:
            return A2AImplementation.SDK
        elif A2AImplementation.CUSTOM in self.available_implementations:
            return A2AImplementation.CUSTOM
        else:
            raise ValueError("No A2A implementations available")

    async def get_agent_card(
        self,
        agent_id: Union[str, UUID],
        implementation: Optional[A2AImplementation] = None,
    ) -> A2AResponse:
        """
        Get agent card using the specified implementation or the best available.
        """
        agent_id_str = str(agent_id)

        # Check
        cache_key = f"{agent_id_str}_{implementation}"
        if cache_key in self._agent_cards_cache:
            logger.debug(f"Returning cached agent card for {agent_id_str}")
            return self._agent_cards_cache[cache_key]

        chosen_impl = self._choose_implementation(implementation)

        try:
            if chosen_impl == A2AImplementation.SDK:
                response = await self._get_agent_card_sdk(agent_id_str)
            else:
                response = await self._get_agent_card_custom(agent_id_str)

            response.implementation_used = chosen_impl

            # Cache successful responses
            if response.success:
                self._agent_cards_cache[cache_key] = response

            return response

        except Exception as e:
            logger.error(f"Error getting agent card with {chosen_impl.value}: {e}")
            return A2AResponse(
                success=False,
                error=f"Failed to get agent card: {str(e)}",
                implementation_used=chosen_impl,
            )

    async def _get_agent_card_custom(self, agent_id: str) -> A2AResponse:
        """Get agent card using custom implementation."""
        url = f"{self.config.base_url}/api/v1/a2a/{agent_id}/.well-known/agent.json"

        response = await self.httpx_client.get(url)
        response.raise_for_status()

        data = response.json()
        return A2AResponse(success=True, data=data, raw_response=response)

    async def _get_agent_card_sdk(self, agent_id: str) -> A2AResponse:
        """Get agent card using SDK implementation."""
        url = f"{self.config.base_url}/api/v1/a2a-sdk/{agent_id}/.well-known/agent.json"

        response = await self.httpx_client.get(url)
        response.raise_for_status()

        data = response.json()
        return A2AResponse(success=True, data=data, raw_response=response)

    async def send_message(
        self,
        agent_id: Union[str, UUID],
        message: str,
        session_id: Optional[str] = None,
        implementation: Optional[A2AImplementation] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> A2AResponse:
        """
        Send message to agent using the specified implementation.
        """
        agent_id_str = str(agent_id)
        session_id = session_id or str(uuid4())

        chosen_impl = self._choose_implementation(implementation)

        try:
            if chosen_impl == A2AImplementation.SDK:
                response = await self._send_message_sdk(
                    agent_id_str, message, session_id, metadata
                )
            else:
                response = await self._send_message_custom(
                    agent_id_str, message, session_id, metadata
                )

            response.implementation_used = chosen_impl
            return response

        except Exception as e:
            logger.error(f"Error sending message with {chosen_impl.value}: {e}")
            return A2AResponse(
                success=False,
                error=f"Failed to send message: {str(e)}",
                implementation_used=chosen_impl,
            )

    async def _send_message_custom(
        self,
        agent_id: str,
        message: str,
        session_id: str,
        metadata: Optional[Dict[str, Any]],
    ) -> A2AResponse:
        """Send message using custom implementation."""
        url = f"{self.config.base_url}/api/v1/a2a/{agent_id}"

        # Create message in custom format
        custom_message = CustomMessage(
            role="user", parts=[{"type": "text", "text": message}], metadata=metadata
        )

        # Create request using correct method from A2A specification
        request_data = {
            "jsonrpc": "2.0",
            "id": str(uuid4()),
            "method": "tasks/send",  # Correct method from A2A specification
            "params": {
                "id": str(uuid4()),
                "sessionId": session_id,
                "message": (
                    custom_message.model_dump()
                    if hasattr(custom_message, "model_dump")
                    else custom_message.dict()
                ),
            },
        }

        response = await self.httpx_client.post(url, json=request_data)
        response.raise_for_status()

        data = response.json()
        return A2AResponse(success=True, data=data, raw_response=response)

    async def _send_message_sdk(
        self,
        agent_id: str,
        message: str,
        session_id: str,
        metadata: Optional[Dict[str, Any]],
    ) -> A2AResponse:
        """Send message using SDK implementation - uses Message API according to specification."""
        if not SDK_AVAILABLE:
            raise ValueError("SDK not available")

        # For SDK implementation, we use the SDK endpoint
        url = f"{self.config.base_url}/api/v1/a2a-sdk/{agent_id}"

        # Message API according to official specification - only message in params
        message_id = str(uuid4())

        # Exact format according to official specification
        request_data = {
            "jsonrpc": "2.0",
            "id": str(uuid4()),
            "method": "message/send",
            "params": {
                "message": {
                    "role": "user",
                    "parts": [
                        {
                            "type": "text",  # Specification uses "type" not "kind"
                            "text": message,
                        }
                    ],
                    "messageId": message_id,  # According to specification
                }
            },
        }

        response = await self.httpx_client.post(url, json=request_data)
        response.raise_for_status()

        data = response.json()
        return A2AResponse(success=True, data=data, raw_response=response)

    async def send_message_streaming(
        self,
        agent_id: Union[str, UUID],
        message: str,
        session_id: Optional[str] = None,
        implementation: Optional[A2AImplementation] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> AsyncIterator[A2AResponse]:
        """
        Send message with streaming using the specified implementation.
        """
        agent_id_str = str(agent_id)
        session_id = session_id or str(uuid4())

        chosen_impl = self._choose_implementation(implementation)

        try:
            if chosen_impl == A2AImplementation.SDK:
                async for response in self._send_message_streaming_sdk(
                    agent_id_str, message, session_id, metadata
                ):
                    response.implementation_used = chosen_impl
                    yield response
            else:
                async for response in self._send_message_streaming_custom(
                    agent_id_str, message, session_id, metadata
                ):
                    response.implementation_used = chosen_impl
                    yield response

        except Exception as e:
            logger.error(f"Error in streaming with {chosen_impl.value}: {e}")
            yield A2AResponse(
                success=False,
                error=f"Failed to stream message: {str(e)}",
                implementation_used=chosen_impl,
            )

    async def _send_message_streaming_custom(
        self,
        agent_id: str,
        message: str,
        session_id: str,
        metadata: Optional[Dict[str, Any]],
    ) -> AsyncIterator[A2AResponse]:
        """Send message with streaming using custom implementation - uses Task API."""
        url = f"{self.config.base_url}/api/v1/a2a/{agent_id}/subscribe"

        # Create message in custom format
        custom_message = CustomMessage(
            role="user", parts=[{"type": "text", "text": message}], metadata=metadata
        )

        # Our custom implementation uses Task API (tasks/subscribe)
        request_data = {
            "jsonrpc": "2.0",
            "id": str(uuid4()),
            "method": "tasks/subscribe",  # Task API para streaming custom
            "params": {
                "id": str(uuid4()),
                "sessionId": session_id,
                "message": (
                    custom_message.model_dump()
                    if hasattr(custom_message, "model_dump")
                    else custom_message.dict()
                ),
            },
        }

        async with self.httpx_client.stream(
            "POST", url, json=request_data, headers={"Accept": "text/event-stream"}
        ) as response:
            response.raise_for_status()

            async for line in response.aiter_lines():
                if line.startswith("data: "):
                    try:
                        data = json.loads(line[6:])  # Remove "data: "
                        yield A2AResponse(success=True, data=data, raw_response=line)
                    except json.JSONDecodeError:
                        logger.warning(f"Failed to parse SSE data: {line}")

    async def _send_message_streaming_sdk(
        self,
        agent_id: str,
        message: str,
        session_id: str,
        metadata: Optional[Dict[str, Any]],
    ) -> AsyncIterator[A2AResponse]:
        """Send message with streaming using SDK implementation - uses Message API according to specification."""
        if not SDK_AVAILABLE:
            raise ValueError("SDK not available")

        url = f"{self.config.base_url}/api/v1/a2a-sdk/{agent_id}"

        # Message API according to official specification - only message in params
        message_id = str(uuid4())

        # Exact format according to official specification for streaming
        request_data = {
            "jsonrpc": "2.0",
            "id": str(uuid4()),
            "method": "message/stream",
            "params": {
                "message": {
                    "role": "user",
                    "parts": [
                        {
                            "type": "text",  # Specification uses "type" not "kind"
                            "text": message,
                        }
                    ],
                    "messageId": message_id,  # According to specification
                }
            },
        }

        async with self.httpx_client.stream(
            "POST", url, json=request_data, headers={"Accept": "text/event-stream"}
        ) as response:
            response.raise_for_status()

            async for line in response.aiter_lines():
                if line.startswith("data: "):
                    try:
                        data = json.loads(line[6:])  # Remove "data: "
                        yield A2AResponse(success=True, data=data, raw_response=line)
                    except json.JSONDecodeError:
                        logger.warning(f"Failed to parse SSE data: {line}")

    async def compare_implementations(
        self, agent_id: Union[str, UUID]
    ) -> Dict[str, Any]:
        """
        Compare the two implementations for a specific agent.
        """
        agent_id_str = str(agent_id)
        comparison = {
            "agent_id": agent_id_str,
            "available_implementations": [
                impl.value for impl in self.available_implementations
            ],
            "custom_card": None,
            "sdk_card": None,
            "differences": [],
        }

        # Get cards from both implementations
        if A2AImplementation.CUSTOM in self.available_implementations:
            try:
                custom_response = await self._get_agent_card_custom(agent_id_str)
                if custom_response.success:
                    comparison["custom_card"] = custom_response.data
            except Exception as e:
                comparison["custom_error"] = str(e)

        if A2AImplementation.SDK in self.available_implementations:
            try:
                sdk_response = await self._get_agent_card_sdk(agent_id_str)
                if sdk_response.success:
                    comparison["sdk_card"] = sdk_response.data
            except Exception as e:
                comparison["sdk_error"] = str(e)

        # Compare if both are available
        if comparison["custom_card"] and comparison["sdk_card"]:
            custom = comparison["custom_card"]
            sdk = comparison["sdk_card"]

            # List of fields to compare
            fields_to_compare = ["name", "description", "version", "url"]

            for field in fields_to_compare:
                if custom.get(field) != sdk.get(field):
                    comparison["differences"].append(
                        {
                            "field": field,
                            "custom_value": custom.get(field),
                            "sdk_value": sdk.get(field),
                        }
                    )

        return comparison

    async def health_check(self) -> Dict[str, Any]:
        """
        Check health of all available implementations.
        """
        health = {
            "client_initialized": True,
            "available_implementations": [
                impl.value for impl in self.available_implementations
            ],
            "implementations_health": {},
        }

        # Test custom implementation
        try:
            custom_health_url = f"{self.config.base_url}/api/v1/a2a/health"
            response = await self.httpx_client.get(custom_health_url)
            health["implementations_health"]["custom"] = {
                "available": response.status_code == 200,
                "status": response.status_code,
                "response": response.json() if response.status_code == 200 else None,
            }
        except Exception as e:
            health["implementations_health"]["custom"] = {
                "available": False,
                "error": str(e),
            }

        # Test SDK implementation
        try:
            sdk_health_url = f"{self.config.base_url}/api/v1/a2a-sdk/health"
            response = await self.httpx_client.get(sdk_health_url)
            health["implementations_health"]["sdk"] = {
                "available": response.status_code == 200,
                "status": response.status_code,
                "response": response.json() if response.status_code == 200 else None,
            }
        except Exception as e:
            health["implementations_health"]["sdk"] = {
                "available": False,
                "error": str(e),
            }

        return health

    async def _detect_implementation(self) -> A2AImplementation:
        """Detect automatically the available implementation."""
        logger.info("Auto-detecting A2A implementation...")

        # If we force a specific implementation, use it
        if self.config.implementation != A2AImplementation.AUTO:
            logger.info(
                f"Using forced implementation: {self.config.implementation.value}"
            )
            return self.config.implementation

        # If we have agent_id, check specifically based on health check URL
        agent_id = getattr(self, "_current_agent_id", None)

        implementations_to_try = []

        # If the agent_id was detected as being from a specific SDK URL, prefer SDK
        if (
            agent_id
            and hasattr(self, "_prefer_sdk_from_url")
            and self._prefer_sdk_from_url
        ):
            implementations_to_try = [A2AImplementation.SDK, A2AImplementation.CUSTOM]
        else:
            implementations_to_try = [A2AImplementation.CUSTOM, A2AImplementation.SDK]

        for impl in implementations_to_try:
            logger.info(f"Testing {impl.value} implementation...")

            if impl == A2AImplementation.SDK:
                if not SDK_AVAILABLE:
                    logger.info("SDK not available, skipping")
                    continue

                health_url = f"{self.config.base_url}/api/v1/a2a-sdk/health"
            else:
                health_url = f"{self.config.base_url}/api/v1/a2a/health"

            try:
                response = await self.httpx_client.get(health_url, timeout=5.0)
                if response.status_code == 200:
                    logger.info(f"‚úì {impl.value} implementation is available")
                    return impl
                else:
                    logger.info(
                        f"‚úó {impl.value} implementation returned {response.status_code}"
                    )
            except Exception as e:
                logger.info(f"‚úó {impl.value} implementation failed: {str(e)}")

        # Fallback to custom if nothing works
        logger.warning("No implementation detected, falling back to CUSTOM")
        return A2AImplementation.CUSTOM


# Utility function to create client easily
async def create_enhanced_a2a_client(
    base_url: str,
    api_key: str,
    implementation: A2AImplementation = A2AImplementation.AUTO,
    **kwargs,
) -> EnhancedA2AClient:
    """
    Utility function to create and initialize enhanced A2A client.
    """
    config = A2AClientConfig(
        base_url=base_url, api_key=api_key, implementation=implementation, **kwargs
    )

    client = EnhancedA2AClient(config)
    await client.initialize()
    return client


# Example of usage
async def example_usage():
    """Example of how to use the enhanced client."""
    config = A2AClientConfig(
        base_url="http://localhost:8000",
        api_key="your-api-key",
        implementation=A2AImplementation.AUTO,
    )

    async with EnhancedA2AClient(config) as client:
        # Health check
        health = await client.health_check()
        print("Health:", health)

        # Get agent card
        agent_id = "some-agent-id"
        card_response = await client.get_agent_card(agent_id)
        if card_response.success:
            print(
                f"Agent card obtained using {card_response.implementation_used.value}"
            )
            print("Card:", card_response.data)

        # Send message
        message_response = await client.send_message(
            agent_id=agent_id, message="Hello, how can you help me?"
        )
        if message_response.success:
            print(f"Message sent using {message_response.implementation_used.value}")
            print("Response:", message_response.data)

        # Send streaming message
        print("Streaming response:")
        async for chunk in client.send_message_streaming(
            agent_id=agent_id, message="Tell me a story"
        ):
            if chunk.success:
                print(f"Chunk ({chunk.implementation_used.value}):", chunk.data)

        # Compare implementations
        comparison = await client.compare_implementations(agent_id)
        print("Implementation comparison:", comparison)


--- src/schemas/a2a_enhanced_types.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: a2a_enhanced_types.py                                                 ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

import logging
from typing import Dict, Any, Optional, List
from uuid import uuid4

try:
    from a2a.types import (
        AgentCard as SDKAgentCard,
        AgentCapabilities as SDKAgentCapabilities,
        AgentSkill as SDKAgentSkill,
        AgentProvider as SDKAgentProvider,
        Message as SDKMessage,
        Task as SDKTask,
        TaskStatus as SDKTaskStatus,
        TaskState as SDKTaskState,
        Part as SDKPart,
        TextPart as SDKTextPart,
        FilePart as SDKFilePart,
        Artifact as SDKArtifact,
    )

    SDK_AVAILABLE = True
except ImportError:
    SDK_AVAILABLE = False
    logging.warning("a2a-sdk not available, falling back to custom types")

from src.schemas.a2a_types import (
    Task as CustomTask,
    TaskStatus as CustomTaskStatus,
    TaskState as CustomTaskState,
    Message as CustomMessage,
    AgentCard as CustomAgentCard,
    AgentCapabilities as CustomAgentCapabilities,
    AgentSkill as CustomAgentSkill,
    AgentProvider as CustomAgentProvider,
    Artifact as CustomArtifact,
)

logger = logging.getLogger(__name__)


class A2ATypeValidator:
    """Validate and convert types between custom and official SDK implementations"""

    @staticmethod
    def is_sdk_available() -> bool:
        """Check if SDK is available"""
        return SDK_AVAILABLE

    @staticmethod
    def validate_agent_card(card_data: Dict[str, Any]) -> Optional[Any]:
        """Validate agent card using SDK types if available"""
        if not SDK_AVAILABLE:
            logger.debug("SDK not available, using custom validation")
            return CustomAgentCard(**card_data)

        try:
            return SDKAgentCard(**card_data)
        except Exception as e:
            logger.warning(f"SDK validation failed, falling back to custom: {e}")
            return CustomAgentCard(**card_data)

    @staticmethod
    def validate_message(message_data: Dict[str, Any]) -> Optional[Any]:
        """Validate message using SDK types if available"""
        if not SDK_AVAILABLE:
            return CustomMessage(**message_data)

        try:
            return SDKMessage(**message_data)
        except Exception as e:
            logger.warning(f"SDK message validation failed: {e}")
            return CustomMessage(**message_data)

    @staticmethod
    def validate_task(task_data: Dict[str, Any]) -> Optional[Any]:
        """Validate task using SDK types if available"""
        if not SDK_AVAILABLE:
            return CustomTask(**task_data)

        try:
            return SDKTask(**task_data)
        except Exception as e:
            logger.warning(f"SDK task validation failed: {e}")
            return CustomTask(**task_data)


class A2ATypeConverter:
    """Convert between custom and SDK types"""

    @staticmethod
    def custom_task_to_sdk(custom_task: CustomTask) -> Optional[Any]:
        """Convert CustomTask to SDKTask"""
        if not SDK_AVAILABLE:
            return custom_task

        try:
            # Convert status
            sdk_status = None
            if custom_task.status:
                sdk_status = A2ATypeConverter.custom_task_status_to_sdk(
                    custom_task.status
                )

            # If status is None, create a basic status
            if not sdk_status:
                sdk_status = SDKTaskStatus(
                    state=SDKTaskState.unknown, message=None, timestamp=None
                )

            # Convert artifacts
            sdk_artifacts = []
            if custom_task.artifacts:
                for artifact in custom_task.artifacts:
                    sdk_artifact = A2ATypeConverter.custom_artifact_to_sdk(artifact)
                    if sdk_artifact:
                        sdk_artifacts.append(sdk_artifact)

            # Convert history
            sdk_history = []
            if custom_task.history:
                for message in custom_task.history:
                    sdk_message = A2ATypeConverter.custom_message_to_sdk(message)
                    if sdk_message:
                        sdk_history.append(sdk_message)

            return SDKTask(
                id=custom_task.id,
                contextId=custom_task.sessionId,
                kind="task",  # New field in SDK
                status=sdk_status,
                artifacts=sdk_artifacts if sdk_artifacts else None,
                history=sdk_history if sdk_history else None,
                metadata=custom_task.metadata,
            )
        except Exception as e:
            logger.error(f"Failed to convert custom task to SDK: {e}")
            return None

    @staticmethod
    def sdk_task_to_custom(sdk_task) -> Optional[CustomTask]:
        """Convert SDKTask to CustomTask"""
        if not SDK_AVAILABLE:
            return sdk_task

        try:
            # Convert status
            custom_status = A2ATypeConverter.sdk_task_status_to_custom(sdk_task.status)

            # Convert artifacts
            custom_artifacts = []
            if sdk_task.artifacts:
                for artifact in sdk_task.artifacts:
                    custom_artifact = A2ATypeConverter.sdk_artifact_to_custom(artifact)
                    if custom_artifact:
                        custom_artifacts.append(custom_artifact)

            # Convert history
            custom_history = []
            if sdk_task.history:
                for message in sdk_task.history:
                    custom_message = A2ATypeConverter.sdk_message_to_custom(message)
                    if custom_message:
                        custom_history.append(custom_message)

            return CustomTask(
                id=sdk_task.id,
                sessionId=sdk_task.contextId,
                status=custom_status,
                artifacts=custom_artifacts if custom_artifacts else None,
                history=custom_history if custom_history else None,
                metadata=sdk_task.metadata,
            )
        except Exception as e:
            logger.error(f"Failed to convert SDK task to custom: {e}")
            return None

    @staticmethod
    def custom_task_status_to_sdk(custom_status: CustomTaskStatus) -> Optional[Any]:
        """Convert CustomTaskStatus to SDKTaskStatus"""
        if not SDK_AVAILABLE:
            return custom_status

        try:
            # Map states
            state_mapping = {
                CustomTaskState.SUBMITTED: SDKTaskState.submitted,
                CustomTaskState.WORKING: SDKTaskState.working,
                CustomTaskState.INPUT_REQUIRED: SDKTaskState.input_required,
                CustomTaskState.COMPLETED: SDKTaskState.completed,
                CustomTaskState.CANCELED: SDKTaskState.canceled,
                CustomTaskState.FAILED: SDKTaskState.failed,
                CustomTaskState.UNKNOWN: SDKTaskState.unknown,
            }

            sdk_state = state_mapping.get(custom_status.state, SDKTaskState.unknown)

            # Convert message if exists
            sdk_message = None
            if custom_status.message:
                sdk_message = A2ATypeConverter.custom_message_to_sdk(
                    custom_status.message
                )

            # Convert timestamp to string if it's a datetime
            timestamp_str = custom_status.timestamp
            if hasattr(custom_status.timestamp, "isoformat"):
                timestamp_str = custom_status.timestamp.isoformat()

            return SDKTaskStatus(
                state=sdk_state, message=sdk_message, timestamp=timestamp_str
            )
        except Exception as e:
            logger.error(f"Failed to convert task status: {e}")
            return None

    @staticmethod
    def sdk_task_status_to_custom(sdk_status) -> Optional[CustomTaskStatus]:
        """Convert SDKTaskStatus to CustomTaskStatus"""
        if not SDK_AVAILABLE:
            return sdk_status

        try:
            # Map states back
            state_mapping = {
                SDKTaskState.submitted: CustomTaskState.SUBMITTED,
                SDKTaskState.working: CustomTaskState.WORKING,
                SDKTaskState.input_required: CustomTaskState.INPUT_REQUIRED,
                SDKTaskState.completed: CustomTaskState.COMPLETED,
                SDKTaskState.canceled: CustomTaskState.CANCELED,
                SDKTaskState.failed: CustomTaskState.FAILED,
                SDKTaskState.unknown: CustomTaskState.UNKNOWN,
            }

            custom_state = state_mapping.get(sdk_status.state, CustomTaskState.UNKNOWN)

            # Convert message if exists
            custom_message = None
            if sdk_status.message:
                custom_message = A2ATypeConverter.sdk_message_to_custom(
                    sdk_status.message
                )

            return CustomTaskStatus(
                state=custom_state,
                message=custom_message,
                timestamp=sdk_status.timestamp,
            )
        except Exception as e:
            logger.error(f"Failed to convert SDK task status: {e}")
            return None

    @staticmethod
    def custom_message_to_sdk(custom_message: CustomMessage) -> Optional[Any]:
        """Convert CustomMessage to SDKMessage"""
        if not SDK_AVAILABLE:
            return custom_message

        try:
            # Convert parts
            sdk_parts = []
            for part in custom_message.parts:
                if hasattr(part, "type"):
                    if part.type == "text":
                        sdk_parts.append(
                            SDKTextPart(
                                kind="text",
                                text=part.text,
                                metadata=getattr(part, "metadata", None),
                            )
                        )
                    elif part.type == "file":
                        sdk_parts.append(
                            SDKFilePart(
                                kind="file",
                                file=part.file,
                                metadata=getattr(part, "metadata", None),
                            )
                        )

            return SDKMessage(
                role=custom_message.role,
                parts=sdk_parts,
                messageId=getattr(custom_message, "messageId", str(uuid4())),
                metadata=custom_message.metadata,
            )
        except Exception as e:
            logger.error(f"Failed to convert message: {e}")
            return None

    @staticmethod
    def sdk_message_to_custom(sdk_message) -> Optional[CustomMessage]:
        """Convert SDKMessage to CustomMessage"""
        if not SDK_AVAILABLE:
            logger.info("SDK not available, returning original message")
            return sdk_message

        try:
            logger.info(f"Converting SDK message to custom: {type(sdk_message)}")
            logger.info(f"SDK message role: {getattr(sdk_message, 'role', 'NO_ROLE')}")
            logger.info(
                f"SDK message parts: {getattr(sdk_message, 'parts', 'NO_PARTS')}"
            )
            logger.info(
                f"SDK message parts length: {len(getattr(sdk_message, 'parts', []))}"
            )

            # Convert parts back
            custom_parts = []
            for idx, part in enumerate(sdk_message.parts):
                logger.info(f"Processing part {idx}: {type(part)}")
                logger.info(f"Part repr: {repr(part)}")

                try:
                    # The SDK TextPart does not allow direct access via getattr
                    # We will extract data from the repr string
                    part_repr = repr(part)
                    logger.info(f"Parsing part repr: {part_repr}")

                    # Check if it's a TextPart
                    if "TextPart" in str(type(part)) or "kind='text'" in part_repr:
                        logger.info("Detected TextPart")

                        # Extract text from repr
                        import re

                        text_match = re.search(r"text='([^']*)'", part_repr)
                        text_content = text_match.group(1) if text_match else ""

                        logger.info(f"Extracted text: {text_content}")

                        # Create dictionary instead of SimpleNamespace for Pydantic compatibility
                        text_part = {
                            "type": "text",
                            "text": text_content,
                            "metadata": None,
                        }
                        custom_parts.append(text_part)
                        logger.info(f"Created text part dict: {text_part}")

                    elif "FilePart" in str(type(part)) or "kind='file'" in part_repr:
                        logger.info("Detected FilePart")

                        # For file parts, we would need to extract more data
                        # For now, create a basic structure
                        file_part = {
                            "type": "file",
                            "file": None,  # It would be necessary to extract from SDK
                            "metadata": None,
                        }
                        custom_parts.append(file_part)
                        logger.info(f"Created file part dict: {file_part}")

                    else:
                        logger.warning(f"Unknown part type in repr: {part_repr}")
                        # Fallback: try to extract any available text
                        if "text=" in part_repr:
                            import re

                            text_match = re.search(r"text='([^']*)'", part_repr)
                            if text_match:
                                fallback_text = text_match.group(1)
                                text_part = {
                                    "type": "text",
                                    "text": fallback_text,
                                    "metadata": None,
                                }
                                custom_parts.append(text_part)
                                logger.info(f"Created fallback text part: {text_part}")

                except Exception as part_error:
                    logger.error(f"Error processing part {idx}: {part_error}")
                    import traceback

                    logger.error(f"Part processing traceback: {traceback.format_exc()}")
                    continue

            logger.info(f"Total custom parts created: {len(custom_parts)}")

            # Convert role from enum to string if necessary
            role_str = sdk_message.role
            if hasattr(sdk_message.role, "value"):
                role_str = sdk_message.role.value
                logger.info(f"Converted role from enum: {role_str}")
            elif not isinstance(sdk_message.role, str):
                role_str = str(sdk_message.role)
                logger.info(f"Converted role to string: {role_str}")

            custom_message = CustomMessage(
                role=role_str, parts=custom_parts, metadata=sdk_message.metadata
            )

            logger.info(
                f"Created custom message: role={custom_message.role}, parts_count={len(custom_message.parts)}"
            )
            return custom_message

        except Exception as e:
            logger.error(f"Failed to convert SDK message: {e}")
            import traceback

            logger.error(f"Full traceback: {traceback.format_exc()}")
            return None

    @staticmethod
    def custom_artifact_to_sdk(custom_artifact: CustomArtifact) -> Optional[Any]:
        """Convert CustomArtifact to SDKArtifact"""
        if not SDK_AVAILABLE:
            return custom_artifact

        try:
            # Convert parts to SDK format
            sdk_parts = []
            if custom_artifact.parts:
                for part in custom_artifact.parts:
                    # If part is a dictionary, convert to appropriate SDK object
                    if isinstance(part, dict):
                        if part.get("type") == "text":
                            sdk_parts.append(
                                SDKTextPart(
                                    kind="text",
                                    text=part.get("text", ""),
                                    metadata=part.get("metadata"),
                                )
                            )
                        elif part.get("type") == "file":
                            sdk_parts.append(
                                SDKFilePart(
                                    kind="file",
                                    file=part.get("file"),
                                    metadata=part.get("metadata"),
                                )
                            )
                    # If it's already a SDK object, use it directly
                    elif hasattr(part, "kind"):
                        sdk_parts.append(part)
                    # If it's a custom TextPart, convert it
                    else:
                        # Fallback: assume text part
                        text_content = getattr(part, "text", str(part))
                        sdk_parts.append(
                            SDKTextPart(
                                kind="text",
                                text=text_content,
                                metadata=getattr(part, "metadata", None),
                            )
                        )

            # Generate artifactId if it doesn't exist
            artifact_id = getattr(custom_artifact, "artifactId", None)
            if not artifact_id:
                from uuid import uuid4

                artifact_id = str(uuid4())

            return SDKArtifact(
                artifactId=artifact_id,
                name=custom_artifact.name,
                description=custom_artifact.description,
                parts=sdk_parts,
                metadata=custom_artifact.metadata,
            )
        except Exception as e:
            logger.error(f"Failed to convert artifact: {e}")
            return None

    @staticmethod
    def sdk_artifact_to_custom(sdk_artifact) -> Optional[CustomArtifact]:
        """Convert SDKArtifact to CustomArtifact"""
        if not SDK_AVAILABLE:
            return sdk_artifact

        try:
            return CustomArtifact(
                name=sdk_artifact.name,
                description=sdk_artifact.description,
                parts=sdk_artifact.parts,
                index=getattr(sdk_artifact, "index", 0),
                append=getattr(sdk_artifact, "append", None),
                lastChunk=getattr(sdk_artifact, "lastChunk", None),
                metadata=sdk_artifact.metadata,
            )
        except Exception as e:
            logger.error(f"Failed to convert SDK artifact: {e}")
            return None

    @staticmethod
    def custom_agent_card_to_sdk(custom_card: CustomAgentCard) -> Optional[Any]:
        """Convert CustomAgentCard to SDKAgentCard"""
        if not SDK_AVAILABLE:
            return custom_card

        try:
            # Convert capabilities
            sdk_capabilities = None
            if custom_card.capabilities:
                sdk_capabilities = SDKAgentCapabilities(
                    streaming=custom_card.capabilities.streaming,
                    pushNotifications=custom_card.capabilities.pushNotifications,
                    stateTransitionHistory=custom_card.capabilities.stateTransitionHistory,
                )

            # Convert provider
            sdk_provider = None
            if custom_card.provider:
                sdk_provider = SDKAgentProvider(
                    organization=custom_card.provider.organization,
                    url=custom_card.provider.url,
                )

            # Convert skills
            sdk_skills = []
            if custom_card.skills:
                for skill in custom_card.skills:
                    sdk_skill = SDKAgentSkill(
                        id=skill.id,
                        name=skill.name,
                        description=skill.description,
                        tags=skill.tags,
                        examples=skill.examples,
                        inputModes=skill.inputModes,
                        outputModes=skill.outputModes,
                    )
                    sdk_skills.append(sdk_skill)

            return SDKAgentCard(
                name=custom_card.name,
                description=custom_card.description,
                url=custom_card.url,
                version=custom_card.version,
                documentationUrl=custom_card.documentationUrl,
                provider=sdk_provider,
                capabilities=sdk_capabilities,
                authentication=custom_card.authentication,
                defaultInputModes=custom_card.defaultInputModes,
                defaultOutputModes=custom_card.defaultOutputModes,
                skills=sdk_skills,
            )
        except Exception as e:
            logger.error(f"Failed to convert agent card: {e}")
            return None


# Utility functions to facilitate usage
def validate_with_sdk(data: Dict[str, Any], data_type: str) -> Any:
    """Utility function to validate data with SDK when available"""
    validator = A2ATypeValidator()

    if data_type == "agent_card":
        return validator.validate_agent_card(data)
    elif data_type == "message":
        return validator.validate_message(data)
    elif data_type == "task":
        return validator.validate_task(data)
    else:
        raise ValueError(f"Unsupported data type: {data_type}")


def convert_to_sdk_format(custom_obj: Any) -> Any:
    """Utility function to convert custom object to SDK format"""
    converter = A2ATypeConverter()

    if isinstance(custom_obj, CustomTask):
        return converter.custom_task_to_sdk(custom_obj)
    elif isinstance(custom_obj, CustomMessage):
        return converter.custom_message_to_sdk(custom_obj)
    elif isinstance(custom_obj, CustomAgentCard):
        return converter.custom_agent_card_to_sdk(custom_obj)
    else:
        logger.warning(f"No converter available for type: {type(custom_obj)}")
        return custom_obj


def convert_from_sdk_format(sdk_obj: Any) -> Any:
    """Utility function to convert SDK object to custom format"""
    converter = A2ATypeConverter()

    if SDK_AVAILABLE:
        if isinstance(sdk_obj, SDKTask):
            return converter.sdk_task_to_custom(sdk_obj)
        elif isinstance(sdk_obj, SDKMessage):
            return converter.sdk_message_to_custom(sdk_obj)

    return sdk_obj


--- src/schemas/a2a_types.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: a2a_types.py                                                          ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from datetime import datetime
from enum import Enum
from typing import Annotated, Any, Literal, Union, Dict, List, Optional
from uuid import uuid4
from typing_extensions import Self

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    TypeAdapter,
    field_serializer,
    model_validator,
)


class TaskState(str, Enum):
    SUBMITTED = "submitted"
    WORKING = "working"
    INPUT_REQUIRED = "input-required"
    COMPLETED = "completed"
    CANCELED = "canceled"
    FAILED = "failed"
    UNKNOWN = "unknown"


class TextPart(BaseModel):
    type: Literal["text"] = "text"
    text: str
    metadata: dict[str, Any] | None = None


class FileContent(BaseModel):
    name: str | None = None
    mimeType: str | None = None
    bytes: str | None = None
    uri: str | None = None

    @model_validator(mode="after")
    def check_content(self) -> Self:
        if not (self.bytes or self.uri):
            raise ValueError("Either 'bytes' or 'uri' must be present in the file data")
        if self.bytes and self.uri:
            raise ValueError(
                "Only one of 'bytes' or 'uri' can be present in the file data"
            )
        return self


class FilePart(BaseModel):
    type: Literal["file"] = "file"
    file: FileContent
    metadata: dict[str, Any] | None = None


class DataPart(BaseModel):
    type: Literal["data"] = "data"
    data: dict[str, Any]
    metadata: dict[str, Any] | None = None


Part = Annotated[TextPart | FilePart | DataPart, Field(discriminator="type")]


class Message(BaseModel):
    role: Literal["user", "agent"]
    parts: list[Part]
    metadata: dict[str, Any] | None = None


class TaskStatus(BaseModel):
    state: TaskState
    message: Message | None = None
    timestamp: datetime = Field(default_factory=datetime.now)

    @field_serializer("timestamp")
    def serialize_dt(self, dt: datetime, _info):
        return dt.isoformat()


class Artifact(BaseModel):
    name: str | None = None
    description: str | None = None
    parts: list[Part]
    metadata: dict[str, Any] | None = None
    index: int = 0
    append: bool | None = None
    lastChunk: bool | None = None


class Task(BaseModel):
    id: str
    sessionId: str | None = None
    status: TaskStatus
    artifacts: list[Artifact] | None = None
    history: list[Message] | None = None
    metadata: dict[str, Any] | None = None


class TaskStatusUpdateEvent(BaseModel):
    id: str
    status: TaskStatus
    final: bool = False
    metadata: dict[str, Any] | None = None


class TaskArtifactUpdateEvent(BaseModel):
    id: str
    artifact: Artifact
    metadata: dict[str, Any] | None = None


class AuthenticationInfo(BaseModel):
    model_config = ConfigDict(extra="allow")

    schemes: list[str]
    credentials: str | None = None


class PushNotificationConfig(BaseModel):
    url: str
    token: str | None = None
    authentication: AuthenticationInfo | None = None


class TaskIdParams(BaseModel):
    id: str
    metadata: dict[str, Any] | None = None


class TaskQueryParams(TaskIdParams):
    historyLength: int | None = None


class TaskSendParams(BaseModel):
    id: str
    sessionId: str = Field(default_factory=lambda: uuid4().hex)
    message: Message
    acceptedOutputModes: list[str] | None = None
    pushNotification: PushNotificationConfig | None = None
    historyLength: int | None = None
    metadata: dict[str, Any] | None = None


class TaskPushNotificationConfig(BaseModel):
    id: str
    pushNotificationConfig: PushNotificationConfig


# RPC Messages


class JSONRPCMessage(BaseModel):
    jsonrpc: Literal["2.0"] = "2.0"
    id: int | str | None = Field(default_factory=lambda: uuid4().hex)


class JSONRPCRequest(JSONRPCMessage):
    method: str
    params: dict[str, Any] | None = None


class JSONRPCError(BaseModel):
    code: int
    message: str
    data: Any | None = None


class JSONRPCResponse(JSONRPCMessage):
    result: Any | None = None
    error: JSONRPCError | None = None


class SendTaskRequest(JSONRPCRequest):
    method: Literal["tasks/send"] = "tasks/send"
    params: TaskSendParams


class SendTaskResponse(JSONRPCResponse):
    result: Task | None = None


class SendTaskStreamingRequest(JSONRPCRequest):
    method: Literal["tasks/sendSubscribe"] = "tasks/sendSubscribe"
    params: TaskSendParams


class SendTaskStreamingResponse(JSONRPCResponse):
    result: TaskStatusUpdateEvent | TaskArtifactUpdateEvent | None = None


class GetTaskRequest(JSONRPCRequest):
    method: Literal["tasks/get"] = "tasks/get"
    params: TaskQueryParams


class GetTaskResponse(JSONRPCResponse):
    result: Task | None = None


class CancelTaskRequest(JSONRPCRequest):
    method: Literal["tasks/cancel",] = "tasks/cancel"
    params: TaskIdParams


class CancelTaskResponse(JSONRPCResponse):
    result: Task | None = None


class SetTaskPushNotificationRequest(JSONRPCRequest):
    method: Literal["tasks/pushNotification/set",] = "tasks/pushNotification/set"
    params: TaskPushNotificationConfig


class SetTaskPushNotificationResponse(JSONRPCResponse):
    result: TaskPushNotificationConfig | None = None


class GetTaskPushNotificationRequest(JSONRPCRequest):
    method: Literal["tasks/pushNotification/get",] = "tasks/pushNotification/get"
    params: TaskIdParams


class GetTaskPushNotificationResponse(JSONRPCResponse):
    result: TaskPushNotificationConfig | None = None


class TaskResubscriptionRequest(JSONRPCRequest):
    method: Literal["tasks/resubscribe",] = "tasks/resubscribe"
    params: TaskIdParams


A2ARequest = TypeAdapter(
    Annotated[
        SendTaskRequest
        | GetTaskRequest
        | CancelTaskRequest
        | SetTaskPushNotificationRequest
        | GetTaskPushNotificationRequest
        | TaskResubscriptionRequest
        | SendTaskStreamingRequest,
        Field(discriminator="method"),
    ]
)

# Error types


class JSONParseError(JSONRPCError):
    code: int = -32700
    message: str = "Invalid JSON payload"
    data: Any | None = None


class InvalidRequestError(JSONRPCError):
    code: int = -32600
    message: str = "Request payload validation error"
    data: Any | None = None


class MethodNotFoundError(JSONRPCError):
    code: int = -32601
    message: str = "Method not found"
    data: None = None


class InvalidParamsError(JSONRPCError):
    code: int = -32602
    message: str = "Invalid parameters"
    data: Any | None = None


class InternalError(JSONRPCError):
    code: int = -32603
    message: str = "Internal error"
    data: Any | None = None


class TaskNotFoundError(JSONRPCError):
    code: int = -32001
    message: str = "Task not found"
    data: None = None


class TaskNotCancelableError(JSONRPCError):
    code: int = -32002
    message: str = "Task cannot be canceled"
    data: None = None


class PushNotificationNotSupportedError(JSONRPCError):
    code: int = -32003
    message: str = "Push Notification is not supported"
    data: None = None


class UnsupportedOperationError(JSONRPCError):
    code: int = -32004
    message: str = "This operation is not supported"
    data: None = None


class ContentTypeNotSupportedError(JSONRPCError):
    code: int = -32005
    message: str = "Incompatible content types"
    data: None = None


class AgentProvider(BaseModel):
    organization: str
    url: str | None = None


class AgentCapabilities(BaseModel):
    streaming: bool = False
    pushNotifications: bool = False
    stateTransitionHistory: bool = False


class AgentAuthentication(BaseModel):
    schemes: list[str]
    credentials: str | None = None


class AgentSkill(BaseModel):
    id: str
    name: str
    description: str | None = None
    tags: list[str] | None = None
    examples: list[str] | None = None
    inputModes: list[str] | None = None
    outputModes: list[str] | None = None


class AgentCard(BaseModel):
    name: str
    description: str | None = None
    url: str
    provider: AgentProvider | None = None
    version: str
    documentationUrl: str | None = None
    capabilities: AgentCapabilities
    authentication: AgentAuthentication | None = None
    defaultInputModes: list[str] = ["text"]
    defaultOutputModes: list[str] = ["text"]
    skills: list[AgentSkill]


class A2AClientError(Exception):
    pass


class A2AClientHTTPError(A2AClientError):
    def __init__(self, status_code: int, message: str):
        self.status_code = status_code
        self.message = message
        super().__init__(f"HTTP Error {status_code}: {message}")


class A2AClientJSONError(A2AClientError):
    def __init__(self, message: str):
        self.message = message
        super().__init__(f"JSON Error: {message}")


class MissingAPIKeyError(Exception):
    """Exception for missing API key."""


--- src/utils/a2a_utils.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: a2a_utils.py                                                          ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

import base64
import uuid
from typing import Dict, List, Any, Optional
from google.genai.types import Part, Blob

from src.schemas.a2a_types import (
    ContentTypeNotSupportedError,
    JSONRPCResponse,
    UnsupportedOperationError,
    Message,
)


def are_modalities_compatible(
    server_output_modes: list[str], client_output_modes: list[str]
):
    """Modalities are compatible if they are both non-empty
    and there is at least one common element.
    """
    if client_output_modes is None or len(client_output_modes) == 0:
        return True

    if server_output_modes is None or len(server_output_modes) == 0:
        return True

    return any(x in server_output_modes for x in client_output_modes)


def new_incompatible_types_error(request_id):
    return JSONRPCResponse(id=request_id, error=ContentTypeNotSupportedError())


def new_not_implemented_error(request_id):
    return JSONRPCResponse(id=request_id, error=UnsupportedOperationError())


def extract_files_from_message(message: Message) -> List[Dict[str, Any]]:
    """
    Extract file parts from an A2A message.

    Args:
        message: An A2A Message object

    Returns:
        List of file parts extracted from the message
    """
    if not message or not message.parts:
        return []

    files = []
    for part in message.parts:
        if hasattr(part, "type") and part.type == "file" and hasattr(part, "file"):
            files.append(part)

    return files


def a2a_part_to_adk_part(a2a_part: Dict[str, Any]) -> Optional[Part]:
    """
    Convert an A2A protocol part to an ADK Part object.

    Args:
        a2a_part: An A2A part dictionary

    Returns:
        Converted ADK Part object or None if conversion not possible
    """
    part_type = a2a_part.get("type")
    if part_type == "file" and "file" in a2a_part:
        file_data = a2a_part["file"]
        if "bytes" in file_data:
            try:
                # Convert base64 to bytes
                file_bytes = base64.b64decode(file_data["bytes"])
                mime_type = file_data.get("mimeType", "application/octet-stream")

                # Create ADK Part
                return Part(inline_data=Blob(mime_type=mime_type, data=file_bytes))
            except Exception:
                return None
    elif part_type == "text" and "text" in a2a_part:
        # For text parts, we could create a text blob if needed
        return None

    return None


def adk_part_to_a2a_part(
    adk_part: Part, filename: Optional[str] = None
) -> Optional[Dict[str, Any]]:
    """
    Convert an ADK Part object to an A2A protocol part.

    Args:
        adk_part: An ADK Part object
        filename: Optional filename to use

    Returns:
        Converted A2A Part dictionary or None if conversion not possible
    """
    if hasattr(adk_part, "inline_data") and adk_part.inline_data:
        if adk_part.inline_data.data and adk_part.inline_data.mime_type:
            # Convert binary data to base64
            file_bytes = adk_part.inline_data.data
            mime_type = adk_part.inline_data.mime_type

            # Generate filename if not provided
            if not filename:
                ext = get_extension_from_mime(mime_type)
                filename = f"file_{uuid.uuid4().hex}{ext}"

            # Convert to A2A FilePart dict
            return {
                "type": "file",
                "file": {
                    "name": filename,
                    "mimeType": mime_type,
                    "bytes": (
                        base64.b64encode(file_bytes).decode("utf-8")
                        if isinstance(file_bytes, bytes)
                        else str(file_bytes)
                    ),
                },
            }
        elif hasattr(adk_part, "text") and adk_part.text:
            # Convert text part
            return {"type": "text", "text": adk_part.text}

    return None


def get_extension_from_mime(mime_type: str) -> str:
    """
    Get a file extension from MIME type.

    Args:
        mime_type: MIME type string

    Returns:
        Appropriate file extension with leading dot
    """
    if not mime_type:
        return ""

    mime_map = {
        "image/jpeg": ".jpg",
        "image/png": ".png",
        "image/gif": ".gif",
        "application/pdf": ".pdf",
        "text/plain": ".txt",
        "text/html": ".html",
        "text/csv": ".csv",
        "application/json": ".json",
        "application/xml": ".xml",
        "application/msword": ".doc",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ".docx",
        "application/vnd.ms-excel": ".xls",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ".xlsx",
    }

    return mime_map.get(mime_type, "")


--- src/schemas/agent_config.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: agent_config.py                                                       ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from typing import List, Optional, Dict, Union, Any
from pydantic import BaseModel, Field
from uuid import UUID
import secrets
import string
import uuid
from pydantic import validator


class ToolConfig(BaseModel):
    """Configuration of a tool"""

    id: UUID
    envs: Dict[str, str] = Field(
        default_factory=dict, description="Environment variables of the tool"
    )

    class Config:
        from_attributes = True


class MCPServerConfig(BaseModel):
    """Configuration of an MCP server"""

    id: UUID
    envs: Dict[str, str] = Field(
        default_factory=dict, description="Environment variables of the server"
    )
    tools: List[str] = Field(
        default_factory=list, description="List of tools of the server"
    )

    class Config:
        from_attributes = True


class CustomMCPServerConfig(BaseModel):
    """Configuration of a custom MCP server"""

    url: str = Field(..., description="Server URL of the custom MCP server")
    headers: Dict[str, str] = Field(
        default_factory=dict, description="Headers for requests to the server"
    )

    class Config:
        from_attributes = True


class FlowNodes(BaseModel):
    """Configuration of workflow nodes"""

    nodes: List[Any]
    edges: List[Any]


class HTTPToolParameter(BaseModel):
    """Parameter of an HTTP tool"""

    type: str
    required: bool
    description: str

    class Config:
        from_attributes = True


class HTTPToolParameters(BaseModel):
    """Parameters of an HTTP tool"""

    path_params: Optional[Dict[str, str]] = None
    query_params: Optional[Dict[str, Union[str, List[str]]]] = None
    body_params: Optional[Dict[str, HTTPToolParameter]] = None

    class Config:
        from_attributes = True


class HTTPToolErrorHandling(BaseModel):
    """Configuration of error handling"""

    timeout: int
    retry_count: int
    fallback_response: Dict[str, str]

    class Config:
        from_attributes = True


class HTTPTool(BaseModel):
    """Configuration of an HTTP tool"""

    name: str
    method: str
    values: Dict[str, str]
    headers: Dict[str, str]
    endpoint: str
    parameters: HTTPToolParameters
    description: str
    error_handling: HTTPToolErrorHandling

    class Config:
        from_attributes = True


class CustomTools(BaseModel):
    """Configuration of custom tools"""

    http_tools: List[HTTPTool] = Field(
        default_factory=list, description="List of HTTP tools"
    )

    class Config:
        from_attributes = True


def generate_api_key(length: int = 32) -> str:
    """Generate a secure API key."""
    alphabet = string.ascii_letters + string.digits
    return "".join(secrets.choice(alphabet) for _ in range(length))


class LLMConfig(BaseModel):
    """Configuration for LLM agents"""

    api_key: str = Field(
        default_factory=generate_api_key,
        description="API key for the LLM. If not provided, a secure key will be generated automatically.",
    )

    tools: Optional[List[ToolConfig]] = Field(
        default=None, description="List of available tools"
    )
    custom_tools: Optional[CustomTools] = Field(
        default=None, description="Custom tools"
    )
    mcp_servers: Optional[List[MCPServerConfig]] = Field(
        default=None, description="List of MCP servers"
    )
    custom_mcp_servers: Optional[List[CustomMCPServerConfig]] = Field(
        default=None, description="List of custom MCP servers with URL and headers"
    )
    agent_tools: Optional[List[UUID]] = Field(
        default=None, description="List of IDs of sub-agents"
    )
    sub_agents: Optional[List[UUID]] = Field(
        default=None, description="List of IDs of sub-agents"
    )
    workflow: Optional[FlowNodes] = Field(
        default=None, description="Workflow configuration"
    )

    class Config:
        from_attributes = True


class SequentialConfig(BaseModel):
    """Configuration for sequential agents"""

    sub_agents: List[UUID] = Field(
        ..., description="List of IDs of sub-agents in execution order"
    )

    class Config:
        from_attributes = True


class ParallelConfig(BaseModel):
    """Configuration for parallel agents"""

    sub_agents: List[UUID] = Field(
        ..., description="List of IDs of sub-agents for parallel execution"
    )

    class Config:
        from_attributes = True


class LoopConfig(BaseModel):
    """Configuration for loop agents"""

    sub_agents: List[UUID] = Field(
        ..., description="List of IDs of sub-agents for loop execution"
    )
    max_iterations: Optional[int] = Field(
        default=None, description="Maximum number of iterations"
    )
    condition: Optional[str] = Field(
        default=None, description="Condition to stop the loop"
    )

    class Config:
        from_attributes = True


class WorkflowConfig(BaseModel):
    """Configuration for workflow agents"""

    workflow: Dict[str, Any] = Field(
        ..., description="Workflow configuration with nodes and edges"
    )
    sub_agents: Optional[List[UUID]] = Field(
        default_factory=list, description="List of IDs of sub-agents used in workflow"
    )
    api_key: Optional[str] = Field(
        default_factory=generate_api_key, description="API key for the workflow agent"
    )

    class Config:
        from_attributes = True


class AgentTask(BaseModel):
    """Task configuration for agents"""

    agent_id: Union[UUID, str] = Field(
        ..., description="ID of the agent assigned to this task"
    )
    enabled_tools: Optional[List[str]] = Field(
        default_factory=list, description="List of tool names to be used in the task"
    )
    description: str = Field(..., description="Description of the task to be performed")
    expected_output: str = Field(..., description="Expected output from this task")

    @validator("agent_id")
    def validate_agent_id(cls, v):
        if isinstance(v, str):
            try:
                return uuid.UUID(v)
            except ValueError:
                raise ValueError(f"Invalid UUID format for agent_id: {v}")
        return v

    class Config:
        from_attributes = True


class AgentConfig(BaseModel):
    """Configuration for agents"""

    tasks: List[AgentTask] = Field(
        ..., description="List of tasks to be performed by the agent"
    )
    api_key: Optional[str] = Field(
        default_factory=generate_api_key, description="API key for the agent"
    )
    sub_agents: Optional[List[UUID]] = Field(
        default_factory=list, description="List of IDs of sub-agents used in agent"
    )

    class Config:
        from_attributes = True


--- src/services/agent_service.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: agent_service.py                                                      ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from fastapi import HTTPException, status
from src.models.models import Agent, AgentFolder, ApiKey
from src.schemas.schemas import AgentCreate
from typing import List, Optional, Dict, Any, Union
from src.services.mcp_server_service import get_mcp_server
import uuid
import logging
import httpx

logger = logging.getLogger(__name__)


# Helper function to generate API keys
def generate_api_key() -> str:
    """Generate a secure API key"""
    # Format: sk-proj-{random 64 chars}

    return str(uuid.uuid4())


def _convert_uuid_to_str(obj):
    """
    Recursively convert all UUID objects to strings in a dictionary, list or scalar value.
    This ensures JSON serialize for complex nested objects.
    """
    if isinstance(obj, dict):
        return {key: _convert_uuid_to_str(value) for key, value in obj.items()}
    elif isinstance(obj, list):
        return [_convert_uuid_to_str(item) for item in obj]
    elif isinstance(obj, uuid.UUID):
        return str(obj)
    else:
        return obj


def validate_sub_agents(db: Session, sub_agents: List[Union[uuid.UUID, str]]) -> bool:
    """Validate if all sub-agents exist"""
    logger.info(f"Validating sub-agents: {sub_agents}")

    if not sub_agents:
        logger.warning("Empty sub-agents list")
        return False

    for agent_id in sub_agents:
        # Ensure the ID is in the correct format
        agent_id_str = str(agent_id)
        logger.info(f"Validating sub-agent with ID: {agent_id_str}")

        agent = get_agent(db, agent_id_str)
        if not agent:
            logger.warning(f"Sub-agent not found: {agent_id_str}")
            return False
        logger.info(f"Valid sub-agent: {agent.name} (ID: {agent_id_str})")

    logger.info(f"All {len(sub_agents)} sub-agents are valid")
    return True


def get_agent(db: Session, agent_id: Union[uuid.UUID, str]) -> Optional[Agent]:
    """Search for an agent by ID"""
    try:
        # Convert to UUID if it's a string
        if isinstance(agent_id, str):
            try:
                agent_id = uuid.UUID(agent_id)
            except ValueError:
                logger.warning(f"Invalid agent ID: {agent_id}")
                return None

        agent = db.query(Agent).filter(Agent.id == agent_id).first()
        if not agent:
            logger.warning(f"Agent not found: {agent_id}")
            return None

        # Sanitize agent name if it contains spaces or special characters
        if agent.name and any(c for c in agent.name if not (c.isalnum() or c == "_")):
            agent.name = "".join(
                c if c.isalnum() or c == "_" else "_" for c in agent.name
            )
            # Update in database
            db.commit()

        return agent
    except SQLAlchemyError as e:
        logger.error(f"Error searching for agent {agent_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error searching for agent",
        )


def get_agents_by_client(
    db: Session,
    client_id: uuid.UUID,
    skip: int = 0,
    limit: int = 100,
    active_only: bool = True,
    folder_id: Optional[uuid.UUID] = None,
    sort_by: str = "name",
    sort_direction: str = "asc",
) -> List[Agent]:
    """Search for agents by client with pagination and optional folder filter"""
    try:
        query = db.query(Agent).filter(Agent.client_id == client_id)

        # Filter by folder if specified
        if folder_id is not None:
            query = query.filter(Agent.folder_id == folder_id)

        # Apply sorting
        if sort_by == "name":
            if sort_direction.lower() == "desc":
                query = query.order_by(Agent.name.desc())
            else:
                query = query.order_by(Agent.name)
        elif sort_by == "created_at":
            if sort_direction.lower() == "desc":
                query = query.order_by(Agent.created_at.desc())
            else:
                query = query.order_by(Agent.created_at)

        agents = query.offset(skip).limit(limit).all()

        # Sanitize agent names if they contain spaces or special characters
        for agent in agents:
            if agent.name and any(
                c for c in agent.name if not (c.isalnum() or c == "_")
            ):
                agent.name = "".join(
                    c if c.isalnum() or c == "_" else "_" for c in agent.name
                )
                # Update in database
                db.commit()

        return agents
    except SQLAlchemyError as e:
        logger.error(f"Error searching for client agents {client_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error searching for agents",
        )


async def create_agent(db: Session, agent: AgentCreate) -> Agent:
    """Create a new agent"""
    try:
        # Special handling for a2a type agents
        if agent.type == "a2a":
            if not agent.agent_card_url:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="agent_card_url is required for a2a type agents",
                )

            try:
                # Fetch agent card information
                async with httpx.AsyncClient() as client:
                    response = await client.get(agent.agent_card_url)
                    if response.status_code != 200:
                        raise HTTPException(
                            status_code=status.HTTP_400_BAD_REQUEST,
                            detail=f"Failed to fetch agent card: HTTP {response.status_code}",
                        )
                    agent_card = response.json()

                # Update agent with information from agent card
                # Only update name if not provided or empty, or sanitize it
                if not agent.name or agent.name.strip() == "":
                    # Sanitize name: remove spaces and special characters
                    card_name = agent_card.get("name", "Unknown Agent")
                    sanitized_name = "".join(
                        c if c.isalnum() or c == "_" else "_" for c in card_name
                    )
                    agent.name = sanitized_name

                agent.description = agent_card.get("description", "")

                if agent.config is None:
                    agent.config = {}

                # Store the whole agent card in config
                if isinstance(agent.config, dict):
                    agent.config["agent_card"] = agent_card
                else:
                    agent.config = {"agent_card": agent_card}

            except Exception as e:
                logger.error(f"Error fetching agent card: {str(e)}")
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Failed to process agent card: {str(e)}",
                )

        elif agent.type == "workflow":
            if not isinstance(agent.config, dict):
                agent.config = {}

            if "api_key" not in agent.config or not agent.config["api_key"]:
                agent.config["api_key"] = generate_api_key()

        elif agent.type == "task":
            if not isinstance(agent.config, dict):
                agent.config = {}
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Invalid configuration: must be an object with tasks",
                )

            if "tasks" not in agent.config:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid configuration: tasks is required for {agent.type} agents",
                )

            if not agent.config["tasks"]:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Invalid configuration: tasks cannot be empty",
                )

            for task in agent.config["tasks"]:
                if "agent_id" not in task:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="Each task must have an agent_id",
                    )

                agent_id = task["agent_id"]
                task_agent = get_agent(db, agent_id)
                if not task_agent:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail=f"Agent not found for task: {agent_id}",
                    )

            if "sub_agents" in agent.config and agent.config["sub_agents"]:
                if not validate_sub_agents(db, agent.config["sub_agents"]):
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="One or more sub-agents do not exist",
                    )

            if "api_key" not in agent.config or not agent.config["api_key"]:
                agent.config["api_key"] = generate_api_key()

        # Additional sub-agent validation (for non-llm and non-a2a types)
        elif agent.type != "llm":
            if not isinstance(agent.config, dict):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Invalid configuration: must be an object with sub_agents",
                )

            if "sub_agents" not in agent.config:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Invalid configuration: sub_agents is required for sequential, parallel or loop agents",
                )

            if not agent.config["sub_agents"]:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Invalid configuration: sub_agents cannot be empty",
                )

            if not validate_sub_agents(db, agent.config["sub_agents"]):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="One or more sub-agents do not exist",
                )

        # Process the configuration before creating the agent
        config = agent.config
        if config is None:
            config = {}
            agent.config = config

        # Ensure config is a dictionary
        if not isinstance(config, dict):
            config = {}
            agent.config = config

        # Generate automatic API key if not provided or empty
        if not config.get("api_key") or config.get("api_key") == "":
            logger.info("Generating automatic API key for new agent")
            config["api_key"] = generate_api_key()

        processed_config = {}
        processed_config["api_key"] = config.get("api_key", "")

        if "tools" in config:
            processed_config["tools"] = config["tools"]

        if "custom_tools" in config:
            processed_config["custom_tools"] = config["custom_tools"]

        if "agent_tools" in config:
            processed_config["agent_tools"] = config["agent_tools"]

        if "sub_agents" in config:
            processed_config["sub_agents"] = config["sub_agents"]

        if "custom_mcp_servers" in config:
            processed_config["custom_mcp_servers"] = config["custom_mcp_servers"]

        for key, value in config.items():
            if key not in [
                "api_key",
                "tools",
                "custom_tools",
                "sub_agents",
                "agent_tools",
                "custom_mcp_servers",
                "mcp_servers",
            ]:
                processed_config[key] = value

        # Process MCP servers
        if "mcp_servers" in config and config["mcp_servers"] is not None:
            processed_servers = []
            for server in config["mcp_servers"]:
                # Convert server id to UUID if it's a string
                server_id = server["id"]
                if isinstance(server_id, str):
                    server_id = uuid.UUID(server_id)

                # Search for MCP server in the database
                mcp_server = get_mcp_server(db, server_id)
                if not mcp_server:
                    raise HTTPException(
                        status_code=400,
                        detail=f"MCP server not found: {server['id']}",
                    )

                # Check if all required environment variables are provided
                for env_key, env_value in mcp_server.environments.items():
                    if env_key not in server.get("envs", {}):
                        raise HTTPException(
                            status_code=400,
                            detail=f"Environment variable '{env_key}' not provided for MCP server {mcp_server.name}",
                        )

                # Add the processed server
                processed_servers.append(
                    {
                        "id": str(server["id"]),
                        "envs": server["envs"],
                        "tools": server["tools"],
                    }
                )

            processed_config["mcp_servers"] = processed_servers
        elif "mcp_servers" in config:
            processed_config["mcp_servers"] = config["mcp_servers"]

        # Process custom MCP servers
        if "custom_mcp_servers" in config and config["custom_mcp_servers"] is not None:
            processed_custom_servers = []
            for server in config["custom_mcp_servers"]:
                # Validate URL format
                if not server.get("url"):
                    raise HTTPException(
                        status_code=400,
                        detail="URL is required for custom MCP servers",
                    )

                # Add the custom server
                processed_custom_servers.append(
                    {"url": server["url"], "headers": server.get("headers", {})}
                )

            processed_config["custom_mcp_servers"] = processed_custom_servers

        # Process sub-agents
        if "sub_agents" in config and config["sub_agents"] is not None:
            processed_config["sub_agents"] = [
                str(agent_id) for agent_id in config["sub_agents"]
            ]

        # Process agent tools
        if "agent_tools" in config and config["agent_tools"] is not None:
            processed_config["agent_tools"] = [
                str(agent_id) for agent_id in config["agent_tools"]
            ]

        # Process tools
        if "tools" in config and config["tools"] is not None:
            processed_tools = []
            for tool in config["tools"]:
                # Convert tool id to string
                tool_id = tool["id"]

                envs = tool.get("envs", {})
                if envs is None:
                    envs = {}

                processed_tools.append({"id": str(tool_id), "envs": envs})
            processed_config["tools"] = processed_tools

        agent.config = processed_config

        # Ensure all config objects are serializable (convert UUIDs to strings)
        if agent.config is not None:
            agent.config = _convert_uuid_to_str(agent.config)

        # Convert agent to dict ensuring all UUIDs are converted to strings
        agent_dict = agent.model_dump()
        agent_dict = _convert_uuid_to_str(agent_dict)

        # Create agent from the processed dictionary
        db_agent = Agent(**agent_dict)

        # Make one final check to ensure all nested objects are serializable
        # (especially nested UUIDs in config)
        if db_agent.config is not None:
            db_agent.config = _convert_uuid_to_str(db_agent.config)

        db.add(db_agent)
        db.commit()
        db.refresh(db_agent)
        logger.info(f"Agent created successfully: {db_agent.id}")

        return db_agent
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error creating agent: {str(e)}")

        # Add debugging info
        try:
            import json

            if "agent_dict" in locals():
                agent_json = json.dumps(agent_dict)
                logger.info(f"Agent creation attempt with: {agent_json[:200]}...")
        except Exception as json_err:
            logger.error(f"Could not serialize agent for debugging: {str(json_err)}")

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating agent: {str(e)}",
        )


async def update_agent(
    db: Session, agent_id: uuid.UUID, agent_data: Dict[str, Any]
) -> Agent:
    """Update an existing agent"""
    try:
        agent = db.query(Agent).filter(Agent.id == agent_id).first()
        if not agent:
            raise HTTPException(status_code=404, detail="Agent not found")

        # Check if api_key_id is defined
        if "api_key_id" in agent_data and agent_data["api_key_id"]:
            # Check if the referenced API key exists
            api_key_id = agent_data["api_key_id"]
            if isinstance(api_key_id, str):
                api_key_id = uuid.UUID(api_key_id)

            api_key = db.query(ApiKey).filter(ApiKey.id == api_key_id).first()
            if not api_key:
                raise HTTPException(
                    status_code=400,
                    detail=f"API Key with ID {api_key_id} not found",
                )

            # Check if the key belongs to the agent's client
            if api_key.client_id != agent.client_id:
                raise HTTPException(
                    status_code=403,
                    detail="API Key does not belong to the same client as the agent",
                )

        # Continue with the original code
        if "type" in agent_data and agent_data["type"] == "a2a":
            if "agent_card_url" not in agent_data or not agent_data["agent_card_url"]:
                raise HTTPException(
                    status_code=400,
                    detail="agent_card_url is required for a2a type agents",
                )

            if not agent_data["agent_card_url"].endswith("/.well-known/agent.json"):
                raise HTTPException(
                    status_code=400,
                    detail="agent_card_url must end with /.well-known/agent.json",
                )

            try:
                async with httpx.AsyncClient() as client:
                    response = await client.get(agent_data["agent_card_url"])
                    if response.status_code != 200:
                        raise HTTPException(
                            status_code=400,
                            detail=f"Failed to fetch agent card: HTTP {response.status_code}",
                        )
                    agent_card = response.json()

                # Only update name if the original update doesn't specify a name
                if "name" not in agent_data or not agent_data["name"].strip():
                    # Sanitize name: remove spaces and special characters
                    card_name = agent_card.get("name", "Unknown Agent")
                    sanitized_name = "".join(
                        c if c.isalnum() or c == "_" else "_" for c in card_name
                    )
                    agent_data["name"] = sanitized_name
                agent_data["description"] = agent_card.get("description", "")

                if "config" not in agent_data or agent_data["config"] is None:
                    agent_data["config"] = agent.config if agent.config else {}

                agent_data["config"]["agent_card"] = agent_card

            except Exception as e:
                logger.error(f"Error fetching agent card: {str(e)}")
                raise HTTPException(
                    status_code=400,
                    detail=f"Failed to process agent card: {str(e)}",
                )

        elif "agent_card_url" in agent_data and agent.type == "a2a":
            if not agent_data["agent_card_url"]:
                raise HTTPException(
                    status_code=400,
                    detail="agent_card_url cannot be empty for a2a type agents",
                )

            if not agent_data["agent_card_url"].endswith("/.well-known/agent.json"):
                raise HTTPException(
                    status_code=400,
                    detail="agent_card_url must end with /.well-known/agent.json",
                )

            try:
                async with httpx.AsyncClient() as client:
                    response = await client.get(agent_data["agent_card_url"])
                    if response.status_code != 200:
                        raise HTTPException(
                            status_code=400,
                            detail=f"Failed to fetch agent card: HTTP {response.status_code}",
                        )
                    agent_card = response.json()

                # Only update name if the original update doesn't specify a name
                if "name" not in agent_data or not agent_data["name"].strip():
                    # Sanitize name: remove spaces and special characters
                    card_name = agent_card.get("name", "Unknown Agent")
                    sanitized_name = "".join(
                        c if c.isalnum() or c == "_" else "_" for c in card_name
                    )
                    agent_data["name"] = sanitized_name
                agent_data["description"] = agent_card.get("description", "")

                if "config" not in agent_data or agent_data["config"] is None:
                    agent_data["config"] = agent.config if agent.config else {}

                agent_data["config"]["agent_card"] = agent_card

            except Exception as e:
                logger.error(f"Error fetching agent card: {str(e)}")
                raise HTTPException(
                    status_code=400,
                    detail=f"Failed to process agent card: {str(e)}",
                )

        # Convert UUIDs to strings before saving
        if "config" in agent_data:
            config = agent_data["config"]

            processed_config = {}
            processed_config["api_key"] = config.get("api_key", "")

            if "tools" in config:
                processed_config["tools"] = config["tools"]

            if "custom_tools" in config:
                processed_config["custom_tools"] = config["custom_tools"]

            if "sub_agents" in config:
                processed_config["sub_agents"] = config["sub_agents"]

            if "agent_tools" in config:
                processed_config["agent_tools"] = config["agent_tools"]

            if "custom_mcp_servers" in config:
                processed_config["custom_mcp_servers"] = config["custom_mcp_servers"]

            for key, value in config.items():
                if key not in [
                    "api_key",
                    "tools",
                    "custom_tools",
                    "sub_agents",
                    "agent_tools",
                    "custom_mcp_servers",
                    "mcp_servers",
                ]:
                    processed_config[key] = value

            # Process MCP servers
            if "mcp_servers" in config and config["mcp_servers"] is not None:
                processed_servers = []
                for server in config["mcp_servers"]:
                    # Convert server id to UUID if it's a string
                    server_id = server["id"]
                    if isinstance(server_id, str):
                        server_id = uuid.UUID(server_id)

                    # Search for MCP server in the database
                    mcp_server = get_mcp_server(db, server_id)
                    if not mcp_server:
                        raise HTTPException(
                            status_code=400,
                            detail=f"MCP server not found: {server['id']}",
                        )

                    # Check if all required environment variables are provided
                    for env_key, env_value in mcp_server.environments.items():
                        if env_key not in server.get("envs", {}):
                            raise HTTPException(
                                status_code=400,
                                detail=f"Environment variable '{env_key}' not provided for MCP server {mcp_server.name}",
                            )

                    # Add the processed server
                    processed_servers.append(
                        {
                            "id": str(server["id"]),
                            "envs": server["envs"],
                            "tools": server["tools"],
                        }
                    )

                processed_config["mcp_servers"] = processed_servers
            elif "mcp_servers" in config:
                processed_config["mcp_servers"] = config["mcp_servers"]

            # Process custom MCP servers
            if (
                "custom_mcp_servers" in config
                and config["custom_mcp_servers"] is not None
            ):
                processed_custom_servers = []
                for server in config["custom_mcp_servers"]:
                    # Validate URL format
                    if not server.get("url"):
                        raise HTTPException(
                            status_code=400,
                            detail="URL is required for custom MCP servers",
                        )

                    # Add the custom server
                    processed_custom_servers.append(
                        {"url": server["url"], "headers": server.get("headers", {})}
                    )

                processed_config["custom_mcp_servers"] = processed_custom_servers

            # Process sub-agents
            if "sub_agents" in config and config["sub_agents"] is not None:
                processed_config["sub_agents"] = [
                    str(agent_id) for agent_id in config["sub_agents"]
                ]

            # Process agent tools
            if "agent_tools" in config and config["agent_tools"] is not None:
                processed_config["agent_tools"] = [
                    str(agent_id) for agent_id in config["agent_tools"]
                ]

            # Process tools
            if "tools" in config and config["tools"] is not None:
                processed_tools = []
                for tool in config["tools"]:
                    # Convert tool id to string
                    tool_id = tool["id"]

                    envs = tool.get("envs", {})
                    if envs is None:
                        envs = {}

                    processed_tools.append({"id": str(tool_id), "envs": envs})
                processed_config["tools"] = processed_tools

            agent_data["config"] = processed_config

        # Ensure all config objects are serializable (convert UUIDs to strings)
        if "config" in agent_data and agent_data["config"] is not None:
            agent_data["config"] = _convert_uuid_to_str(agent_data["config"])

        # Check if the agent has API key and generate one if not
        agent_config = agent.config or {}
        if "config" not in agent_data:
            agent_data["config"] = agent_config

        if ("type" in agent_data and agent_data["type"] in ["task"]) or (
            agent.type in ["task"] and "config" in agent_data
        ):
            config = agent_data.get("config", {})
            if "tasks" not in config:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid configuration: tasks is required for {agent_data.get('type', agent.type)} agents",
                )

            if not config["tasks"]:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Invalid configuration: tasks cannot be empty",
                )

            for task in config["tasks"]:
                if "agent_id" not in task:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="Each task must have an agent_id",
                    )

                agent_id = task["agent_id"]
                task_agent = get_agent(db, agent_id)
                if not task_agent:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail=f"Agent not found for task: {agent_id}",
                    )

            # Validar sub_agents se existir
            if "sub_agents" in config and config["sub_agents"]:
                if not validate_sub_agents(db, config["sub_agents"]):
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="One or more sub-agents do not exist",
                    )

        if not agent_config.get("api_key") and (
            "config" not in agent_data or not agent_data["config"].get("api_key")
        ):
            logger.info(f"Generating missing API key for existing agent: {agent_id}")
            if "config" not in agent_data:
                agent_data["config"] = {}
            agent_data["config"]["api_key"] = generate_api_key()

        for key, value in agent_data.items():
            setattr(agent, key, value)

        db.commit()
        db.refresh(agent)
        return agent
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error updating agent: {str(e)}")


def delete_agent(db: Session, agent_id: uuid.UUID) -> bool:
    """Remove an agent from the database"""
    try:
        db_agent = get_agent(db, agent_id)
        if not db_agent:
            return False

        # Actually delete the agent from the database
        db.delete(db_agent)
        db.commit()
        logger.info(f"Agent deleted successfully: {agent_id}")
        return True
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error deleting agent {agent_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error deleting agent",
        )


def activate_agent(db: Session, agent_id: uuid.UUID) -> bool:
    """Reactivate an agent"""
    try:
        db_agent = get_agent(db, agent_id)
        if not db_agent:
            return False

        db.commit()
        logger.info(f"Agent reactivated successfully: {agent_id}")
        return True
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error reactivating agent {agent_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error reactivating agent",
        )


# Functions for agent folders
def create_agent_folder(
    db: Session, client_id: uuid.UUID, name: str, description: Optional[str] = None
) -> AgentFolder:
    """Create a new folder to organize agents"""
    try:
        folder = AgentFolder(client_id=client_id, name=name, description=description)
        db.add(folder)
        db.commit()
        db.refresh(folder)
        logger.info(f"Agent folder created successfully: {folder.id}")
        return folder
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error creating agent folder: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating agent folder: {str(e)}",
        )


def get_agent_folder(db: Session, folder_id: uuid.UUID) -> Optional[AgentFolder]:
    """Search for an agent folder by ID"""
    try:
        return db.query(AgentFolder).filter(AgentFolder.id == folder_id).first()
    except SQLAlchemyError as e:
        logger.error(f"Error searching for agent folder {folder_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error searching for agent folder",
        )


def get_agent_folders_by_client(
    db: Session, client_id: uuid.UUID, skip: int = 0, limit: int = 100
) -> List[AgentFolder]:
    """List the agent folders of a client"""
    try:
        return (
            db.query(AgentFolder)
            .filter(AgentFolder.client_id == client_id)
            .offset(skip)
            .limit(limit)
            .all()
        )
    except SQLAlchemyError as e:
        logger.error(f"Error listing agent folders: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error listing agent folders",
        )


def update_agent_folder(
    db: Session,
    folder_id: uuid.UUID,
    name: Optional[str] = None,
    description: Optional[str] = None,
) -> Optional[AgentFolder]:
    """Update an agent folder"""
    try:
        folder = get_agent_folder(db, folder_id)
        if not folder:
            return None

        if name is not None:
            folder.name = name
        if description is not None:
            folder.description = description

        db.commit()
        db.refresh(folder)
        logger.info(f"Agent folder updated: {folder_id}")
        return folder
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error updating agent folder {folder_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error updating agent folder",
        )


def delete_agent_folder(db: Session, folder_id: uuid.UUID) -> bool:
    """Remove an agent folder and unassign the agents"""
    try:
        folder = get_agent_folder(db, folder_id)
        if not folder:
            return False

        # Unassign the agents from the folder (do not delete the agents)
        agents = db.query(Agent).filter(Agent.folder_id == folder_id).all()
        for agent in agents:
            agent.folder_id = None

        # Delete the folder
        db.delete(folder)
        db.commit()
        logger.info(f"Agent folder removed: {folder_id}")
        return True
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error removing agent folder {folder_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error removing agent folder",
        )


def assign_agent_to_folder(
    db: Session, agent_id: uuid.UUID, folder_id: Optional[uuid.UUID]
) -> Optional[Agent]:
    """Assign an agent to a folder (or remove from folder if folder_id is None)"""
    try:
        agent = get_agent(db, agent_id)
        if not agent:
            return None

        # If folder_id is None, remove the agent from the current folder
        if folder_id is None:
            agent.folder_id = None
            db.commit()
            db.refresh(agent)
            logger.info(f"Agent removed from folder: {agent_id}")
            return agent

        # Verify if the folder exists
        folder = get_agent_folder(db, folder_id)
        if not folder:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Folder not found",
            )

        # Verify if the folder belongs to the same client as the agent
        if folder.client_id != agent.client_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="The folder must belong to the same client as the agent",
            )

        # Assign the agent to the folder
        agent.folder_id = folder_id
        db.commit()
        db.refresh(agent)
        logger.info(f"Agent assigned to folder: {folder_id}")
        return agent
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error assigning agent to folder: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error assigning agent to folder",
        )


def get_agents_by_folder(
    db: Session, folder_id: uuid.UUID, skip: int = 0, limit: int = 100
) -> List[Agent]:
    """List the agents of a specific folder"""
    try:
        return (
            db.query(Agent)
            .filter(Agent.folder_id == folder_id)
            .offset(skip)
            .limit(limit)
            .all()
        )
    except SQLAlchemyError as e:
        logger.error(f"Error listing agents of folder {folder_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error listing agents of folder",
        )


async def import_agents_from_json(
    db: Session,
    agents_data: Dict[str, Any],
    client_id: uuid.UUID,
    folder_id: Optional[uuid.UUID] = None,
) -> List[Agent]:
    """
    Import one or more agents from JSON data

    Args:
        db (Session): Database session
        agents_data (Dict[str, Any]): JSON data containing agent definitions
        client_id (uuid.UUID): Client ID to associate with the imported agents
        folder_id (Optional[uuid.UUID]): Optional folder ID to assign agents to

    Returns:
        List[Agent]: List of imported agents
    """
    # Check if the JSON contains a single agent or multiple agents
    if "agents" in agents_data:
        # Multiple agents import
        agents_list = agents_data["agents"]
        if not isinstance(agents_list, list):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="The 'agents' field must contain a list of agent definitions",
            )
    else:
        # Single agent import
        agents_list = [agents_data]

    imported_agents = []
    errors = []
    id_mapping = {}  # Maps original IDs to newly created agent IDs

    # First pass: Import all non-workflow agents to establish ID mappings
    for agent_data in agents_list:
        # Skip workflow agents in the first pass, we'll handle them in the second pass
        if agent_data.get("type") == "workflow":
            continue

        try:
            # Store original ID if present for reference mapping
            original_id = None
            if "id" in agent_data:
                original_id = agent_data["id"]
                del agent_data["id"]  # Always create a new agent with new ID

            # Set the client ID for this agent if not provided
            if "client_id" not in agent_data:
                agent_data["client_id"] = str(client_id)
            else:
                # Ensure the provided client_id matches the authenticated client
                agent_client_id = uuid.UUID(agent_data["client_id"])
                if agent_client_id != client_id:
                    raise HTTPException(
                        status_code=status.HTTP_403_FORBIDDEN,
                        detail=f"Cannot import agent for client ID {agent_client_id}",
                    )

            # Set folder_id if provided and not already set in the agent data
            if folder_id and "folder_id" not in agent_data:
                agent_data["folder_id"] = str(folder_id)

            # Process config: Keep original configuration intact except for agent references
            if "config" in agent_data and agent_data["config"]:
                config = agent_data["config"]

                # Process sub_agents if present
                if "sub_agents" in config and config["sub_agents"]:
                    processed_sub_agents = []

                    for sub_agent_id in config["sub_agents"]:
                        try:
                            # Check if agent exists in database
                            existing_agent = get_agent(db, sub_agent_id)
                            if existing_agent:
                                processed_sub_agents.append(str(existing_agent.id))
                            else:
                                logger.warning(
                                    f"Referenced sub_agent {sub_agent_id} not found - will be skipped"
                                )
                        except Exception as e:
                            logger.warning(
                                f"Error processing sub_agent {sub_agent_id}: {str(e)}"
                            )

                    config["sub_agents"] = processed_sub_agents

                # Process agent_tools if present
                if "agent_tools" in config and config["agent_tools"]:
                    processed_agent_tools = []

                    for agent_tool_id in config["agent_tools"]:
                        try:
                            # Check if agent exists in database
                            existing_agent = get_agent(db, agent_tool_id)
                            if existing_agent:
                                processed_agent_tools.append(str(existing_agent.id))
                            else:
                                logger.warning(
                                    f"Referenced agent_tool {agent_tool_id} not found - will be skipped"
                                )
                        except Exception as e:
                            logger.warning(
                                f"Error processing agent_tool {agent_tool_id}: {str(e)}"
                            )

                    config["agent_tools"] = processed_agent_tools

            # Convert to AgentCreate schema
            agent_create = AgentCreate(**agent_data)

            # Create the agent using existing create_agent function
            db_agent = await create_agent(db, agent_create)

            # Store mapping from original ID to new ID
            if original_id:
                id_mapping[original_id] = str(db_agent.id)

            # If folder_id is provided but not in agent_data (couldn't be set at creation time)
            # assign the agent to the folder after creation
            if folder_id and not agent_data.get("folder_id"):
                db_agent = assign_agent_to_folder(db, db_agent.id, folder_id)

            # Set agent card URL if needed
            if not db_agent.agent_card_url:
                db_agent.agent_card_url = db_agent.agent_card_url_property

            imported_agents.append(db_agent)

        except Exception as e:
            # Log the error and continue with other agents
            agent_name = agent_data.get("name", "Unknown")
            error_msg = f"Error importing agent '{agent_name}': {str(e)}"
            logger.error(error_msg)
            errors.append(error_msg)

    # Second pass: Process workflow agents
    for agent_data in agents_list:
        # Only process workflow agents in the second pass
        if agent_data.get("type") != "workflow":
            continue

        try:
            # Store original ID if present for reference mapping
            original_id = None
            if "id" in agent_data:
                original_id = agent_data["id"]
                del agent_data["id"]  # Always create a new agent with new ID

            # Set the client ID for this agent if not provided
            if "client_id" not in agent_data:
                agent_data["client_id"] = str(client_id)
            else:
                # Ensure the provided client_id matches the authenticated client
                agent_client_id = uuid.UUID(agent_data["client_id"])
                if agent_client_id != client_id:
                    raise HTTPException(
                        status_code=status.HTTP_403_FORBIDDEN,
                        detail=f"Cannot import agent for client ID {agent_client_id}",
                    )

            # Set folder_id if provided and not already set in the agent data
            if folder_id and "folder_id" not in agent_data:
                agent_data["folder_id"] = str(folder_id)

            # Process workflow nodes
            if "config" in agent_data and agent_data["config"]:
                config = agent_data["config"]

                # Process workflow nodes
                if "workflow" in config and config["workflow"]:
                    workflow = config["workflow"]

                    if "nodes" in workflow and isinstance(workflow["nodes"], list):
                        for node in workflow["nodes"]:
                            if (
                                isinstance(node, dict)
                                and node.get("type") == "agent-node"
                            ):
                                if "data" in node and "agent" in node["data"]:
                                    agent_node = node["data"]["agent"]

                                    # Store the original node ID
                                    node_agent_id = None
                                    if "id" in agent_node:
                                        node_agent_id = agent_node["id"]

                                        # Check if this ID is in our mapping (we created it in this import)
                                        if node_agent_id in id_mapping:
                                            # Use our newly created agent
                                            # Get the agent from database with the mapped ID
                                            mapped_id = uuid.UUID(
                                                id_mapping[node_agent_id]
                                            )
                                            db_agent = get_agent(db, mapped_id)
                                            if db_agent:
                                                # Replace with database agent definition
                                                # Extract agent data as dictionary
                                                agent_dict = {
                                                    "id": str(db_agent.id),
                                                    "name": db_agent.name,
                                                    "description": db_agent.description,
                                                    "role": db_agent.role,
                                                    "goal": db_agent.goal,
                                                    "type": db_agent.type,
                                                    "model": db_agent.model,
                                                    "instruction": db_agent.instruction,
                                                    "config": db_agent.config,
                                                }
                                                node["data"]["agent"] = agent_dict
                                        else:
                                            # Check if this agent exists in database
                                            try:
                                                existing_agent = get_agent(
                                                    db, node_agent_id
                                                )
                                                if existing_agent:
                                                    # Replace with database agent definition
                                                    # Extract agent data as dictionary
                                                    agent_dict = {
                                                        "id": str(existing_agent.id),
                                                        "name": existing_agent.name,
                                                        "description": existing_agent.description,
                                                        "role": existing_agent.role,
                                                        "goal": existing_agent.goal,
                                                        "type": existing_agent.type,
                                                        "model": existing_agent.model,
                                                        "instruction": existing_agent.instruction,
                                                        "config": existing_agent.config,
                                                    }
                                                    node["data"]["agent"] = agent_dict
                                                else:
                                                    # Agent doesn't exist, so we'll create a new one
                                                    # First, remove ID to get a new one
                                                    if "id" in agent_node:
                                                        del agent_node["id"]

                                                    # Set client_id to match parent
                                                    agent_node["client_id"] = str(
                                                        client_id
                                                    )

                                                    # Create agent
                                                    inner_agent_create = AgentCreate(
                                                        **agent_node
                                                    )
                                                    inner_db_agent = await create_agent(
                                                        db, inner_agent_create
                                                    )

                                                    # Replace with the new agent
                                                    # Extract agent data as dictionary
                                                    agent_dict = {
                                                        "id": str(inner_db_agent.id),
                                                        "name": inner_db_agent.name,
                                                        "description": inner_db_agent.description,
                                                        "role": inner_db_agent.role,
                                                        "goal": inner_db_agent.goal,
                                                        "type": inner_db_agent.type,
                                                        "model": inner_db_agent.model,
                                                        "instruction": inner_db_agent.instruction,
                                                        "config": inner_db_agent.config,
                                                    }
                                                    node["data"]["agent"] = agent_dict
                                            except Exception as e:
                                                logger.warning(
                                                    f"Error processing agent node {node_agent_id}: {str(e)}"
                                                )
                                                # Continue using the agent definition as is,
                                                # but without ID to get a new one
                                                if "id" in agent_node:
                                                    del agent_node["id"]
                                                agent_node["client_id"] = str(client_id)

                # Process sub_agents if present
                if "sub_agents" in config and config["sub_agents"]:
                    processed_sub_agents = []

                    for sub_agent_id in config["sub_agents"]:
                        # Check if agent exists in database
                        try:
                            # Check if this is an agent we just created
                            if sub_agent_id in id_mapping:
                                processed_sub_agents.append(id_mapping[sub_agent_id])
                            else:
                                # Check if this agent exists in database
                                existing_agent = get_agent(db, sub_agent_id)
                                if existing_agent:
                                    processed_sub_agents.append(str(existing_agent.id))
                                else:
                                    logger.warning(
                                        f"Referenced sub_agent {sub_agent_id} not found - will be skipped"
                                    )
                        except Exception as e:
                            logger.warning(
                                f"Error processing sub_agent {sub_agent_id}: {str(e)}"
                            )

                    config["sub_agents"] = processed_sub_agents

            # Convert to AgentCreate schema
            agent_create = AgentCreate(**agent_data)

            # Create the agent using existing create_agent function
            db_agent = await create_agent(db, agent_create)

            # Store mapping from original ID to new ID
            if original_id:
                id_mapping[original_id] = str(db_agent.id)

            # If folder_id is provided but not in agent_data (couldn't be set at creation time)
            # assign the agent to the folder after creation
            if folder_id and not agent_data.get("folder_id"):
                db_agent = assign_agent_to_folder(db, db_agent.id, folder_id)

            # Set agent card URL if needed
            if not db_agent.agent_card_url:
                db_agent.agent_card_url = db_agent.agent_card_url_property

            imported_agents.append(db_agent)

        except Exception as e:
            # Log the error and continue with other agents
            agent_name = agent_data.get("name", "Unknown")
            error_msg = f"Error importing agent '{agent_name}': {str(e)}"
            logger.error(error_msg)
            errors.append(error_msg)

    # If no agents were imported successfully, raise an error
    if not imported_agents and errors:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail={"message": "Failed to import any agents", "errors": errors},
        )

    return imported_agents


--- src/schemas/audit.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: audit.py                                                              ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from datetime import datetime
from uuid import UUID


class AuditLogBase(BaseModel):
    """Base schema for audit log"""

    action: str
    resource_type: str
    resource_id: Optional[str] = None
    details: Optional[Dict[str, Any]] = None


class AuditLogCreate(AuditLogBase):
    """Schema for creating audit log"""

    pass


class AuditLogResponse(AuditLogBase):
    """Schema for audit log response"""

    id: UUID
    user_id: Optional[UUID] = None
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    created_at: datetime

    class Config:
        from_attributes = True


class AuditLogFilter(BaseModel):
    """Schema for audit log search filters"""

    user_id: Optional[UUID] = None
    action: Optional[str] = None
    resource_type: Optional[str] = None
    resource_id: Optional[str] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    skip: Optional[int] = Field(0, ge=0)
    limit: Optional[int] = Field(100, ge=1, le=1000)


--- src/services/audit_service.py ---
"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @author: Davidson Gomes                                                      ‚îÇ
‚îÇ @file: audit_service.py                                                      ‚îÇ
‚îÇ Developed by: Davidson Gomes                                                 ‚îÇ
‚îÇ Creation date: May 13, 2025                                                  ‚îÇ
‚îÇ Contact: contato@evolution-api.com                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @copyright ¬© Evolution API 2025. All rights reserved.                        ‚îÇ
‚îÇ Licensed under the Apache License, Version 2.0                               ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ You may not use this file except in compliance with the License.             ‚îÇ
‚îÇ You may obtain a copy of the License at                                      ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ    http://www.apache.org/licenses/LICENSE-2.0                                ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îÇ Unless required by applicable law or agreed to in writing, software          ‚îÇ
‚îÇ distributed under the License is distributed on an "AS IS" BASIS,            ‚îÇ
‚îÇ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     ‚îÇ
‚îÇ See the License for the specific language governing permissions and          ‚îÇ
‚îÇ limitations under the License.                                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ @important                                                                   ‚îÇ
‚îÇ For any future changes to the code in this file, it is recommended to        ‚îÇ
‚îÇ include, together with the modification, the information of the developer    ‚îÇ
‚îÇ who changed it and the date of modification.                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from src.models.models import AuditLog
from datetime import datetime
from fastapi import Request
from typing import Optional, Dict, Any, List
import uuid
import logging

logger = logging.getLogger(__name__)


def create_audit_log(
    db: Session,
    user_id: Optional[uuid.UUID],
    action: str,
    resource_type: str,
    resource_id: Optional[str] = None,
    details: Optional[Dict[str, Any]] = None,
    request: Optional[Request] = None,
) -> Optional[AuditLog]:
    """
    Create a new audit log

    Args:
        db: Database session
        user_id: User ID that performed the action (or None if anonymous)
        action: Action performed (ex: "create", "update", "delete")
        resource_type: Resource type (ex: "client", "agent", "user")
        resource_id: Resource ID (optional)
        details: Additional details of the action (optional)
        request: FastAPI Request object (optional, to get IP and User-Agent)

    Returns:
        Optional[AuditLog]: Created audit log or None in case of error
    """
    try:
        ip_address = None
        user_agent = None

        if request:
            ip_address = request.client.host if hasattr(request, "client") else None
            user_agent = request.headers.get("user-agent")

        # Convert details to serializable format
        if details:
            # Convert UUIDs to strings
            for key, value in details.items():
                if isinstance(value, uuid.UUID):
                    details[key] = str(value)

        audit_log = AuditLog(
            user_id=user_id,
            action=action,
            resource_type=resource_type,
            resource_id=str(resource_id) if resource_id else None,
            details=details,
            ip_address=ip_address,
            user_agent=user_agent,
        )

        db.add(audit_log)
        db.commit()
        db.refresh(audit_log)

        logger.info(
            f"Audit log created: {action} in {resource_type}"
            + (f" (ID: {resource_id})" if resource_id else "")
        )

        return audit_log

    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Error creating audit log: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error creating audit log: {str(e)}")
        return None


def get_audit_logs(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    user_id: Optional[uuid.UUID] = None,
    action: Optional[str] = None,
    resource_type: Optional[str] = None,
    resource_id: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
) -> List[AuditLog]:
    """
    Get audit logs with optional filters

    Args:
        db: Database session
        skip: Number of records to skip
        limit: Maximum number of records to return
        user_id: Filter by user ID
        action: Filter by action
        resource_type: Filter by resource type
        resource_id: Filter by resource ID
        start_date: Start date
        end_date: End date

    Returns:
        List[AuditLog]: List of audit logs
    """
    query = db.query(AuditLog)

    # Apply filters, if provided
    if user_id:
        query = query.filter(AuditLog.user_id == user_id)

    if action:
        query = query.filter(AuditLog.action == action)

    if resource_type:
        query = query.filter(AuditLog.resource_type == resource_type)

    if resource_id:
        query = query.filter(AuditLog.resource_id == resource_id)

    if start_date:
        query = query.filter(AuditLog.created_at >= start_date)

    if end_date:
        query = query.filter(AuditLog.created_at <= end_date)

    # Order by creation date (most recent first)
    query = query.order_by(AuditLog.created_at.desc())

    # Apply pagination
    query = query.offset(skip).limit(limit)

    return query.all()
